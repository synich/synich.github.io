<!DOCTYPE html>
<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="/style.css" rel="stylesheet" type="text/css">
<title>协议工作的感悟</title>
<meta content="width=device-width, initial-scale=1" name="viewport">
</head><body><article><header>协议工作的感悟</header><div class="toc">
<ul>
<li><a href="#at-1704">协议的定义和期望 at 17.04</a><ul>
<li><a href="#_1">协议的层次</a></li>
<li><a href="#_2">协议体系的自洽</a></li>
<li><a href="#_3">如何设计好的协议</a></li>
</ul>
</li>
<li><a href="#_4">两代协议的使用总原则和兼容</a><ul>
<li><a href="#at-1609">设备协议兼容策略说明 at 16.09</a></li>
</ul>
</li>
<li><a href="#_5">对协议工作的反思</a><ul>
<li><a href="#at-1608">协议该如何演进 at 16.08</a></li>
<li><a href="#at-1708">处理权限校验问题的反思 at 17.08</a></li>
<li><a href="#at-1712">修改能力协议的思考 at 17.12</a></li>
</ul>
</li>
<li><a href="#_6">几个具体的协议定义思考</a><ul>
<li><a href="#at-1610">变倍与聚焦 at 16.10</a></li>
<li><a href="#at-1706">礼让行人和车流量协议反思 at 17.06</a></li>
<li><a href="#at-1801">人脸查询协议的理解 at 18.01</a></li>
<li><a href="#at-1802">查询协议与资源回收 at 18.02</a></li>
<li><a href="#at-1803">行人卡口事件的思考 at 18.03</a></li>
</ul>
</li>
<li><a href="#176">一些讨论纪要(17年6月初)</a></li>
</ul>
</div>
<p>在我的职业规划中，完全没想过会做了5年的应用软件协议评审，但还是踏踏实实地做了，并且也非常锻炼我的思维能力。</p>
<h2 id="at-1704">协议的定义和期望 at 17.04</h2>
<p>每一个软件只要不是像HelloWorld那样纯入门性质的软件，它一定承载了某种功能，想让它完成某种功能就要有固定的格式，这种格式便是接口，如果网络化了又可以称之为协议。Unix时代的软件多是单机执行，也存在着格式的要求，比如grep就要求第一个参数是搜索关键词，第二个及以后是要搜索的文件名，缺少或者乱了都不行，到了网络时代因为传输的复杂性，接口的要求也愈加复杂，但本质都是对输入的一种约定。有了输入，则软件会按预设的行为给出结果，同样拿grep为例，它会将文件拆分成以行为单位，并将每行和给定关键词进行匹配，一旦匹配成功则输出这行的内容。至于正则表达式如何被编译，又如果匹配，使用者无需关心。</p>
<p>同样的对于业务层协议，要定义一种业务的输入格式及反应行为的期望结果，至于背后的实现逻辑不需要也不应该在协议定义，当然如果我们对这块业务很熟悉，看到接口大致能推断出背后的逻辑是什么样的，当然这不是必须。</p>
<h3 id="_1">协议的层次</h3>
<p>对于分层OSI给出了七层模型，通常业务协议不需要如此复杂，传输层(TCP/UDP)+标识层+载荷就够了。通常TCP占主流，UDP更多的用在实时的音视频流或NAT中，标识层衔接了传输层和载荷，作用是指示分包、加密、校验和等功能，这一层要考虑不同客户端的便利性。载荷层负责描述业务内容，多为消息封装格式，常见的有XML或JSON，如果觉得文本格式浪费体积也有Protobuff或MsgPack这类Binary的消息封装。对于秒级的消息通信业务而言，消息大小、解析时间并不是瓶颈，我认为简单易懂且普及(JS天生支持使得在Web领域更是加分)的JSON是够用了。像Protobuff则是到了毫秒级的通信场景下才能发挥更大的作用。</p>
<h3 id="_2">协议体系的自洽</h3>
<p>协议要能自圆其说。如果从更哲学的角度来理解，尼采有句描述：这个世界没有事实，只有诠释。即所有的现象都是诠释/解释，解释的方式可以有很多种，但是只有最具有说服力的解释，才能占得主流地位。大华协议也是对监控领域这个小世界的诠释，因此只有具备最好的解释性的协议，才能生存到最后。一个好的解释体系，根基有两件事，定义(或概念)和逻辑推演。没有体系内明确的定义(只要明确，不过度追求“正确”)，逻辑推演就是无本之木容易陷入诡辩和循环认证，没有正确的推演，衍生的结果往往会冲突。</p>
<h3 id="_3">如何设计好的协议</h3>
<ol>
<li>
<p>configManager.deleteFile协议，历史原因它是没有入参的，自然也无法知道到底删除什么文件，相应地就我们需要严格定义它的行为，比如让设备回到出厂状态，只要删除的文件让设备看起来是恢复出厂，这个协议目标就达到了。更进一步最好要规定出厂状态的指标，在做测试时更有依据。</p>
</li>
<li>
<p>要实现抽帧播放需求，可以保留I帧后的若干个P帧，也可以若干个I帧只保留1个。如果只是这样定义，似乎也没有问题。但是考虑到H264规范有一种特殊的P帧，比一般的P帧大且只依赖于I帧，这时按照若干个I帧回放1个的定义，对这种视频就应该是若干个I帧加重定位P帧中抽取一个。随着视频格式的不同，协议竟然要跟着变化，说明这样的定义没有触及更根本的东西。更好的定义就是以最少几秒看到一个视频切面来定义能观察到的行为，这种方式不依赖实现细节，协议才能稳定。</p>
</li>
<li>
<p>登陆和是否支持静态/动态多连接在同一个交互里，现在看来就属于过耦合。因为登陆不意味着要取流，但由于多连接的存在，导致登陆的处理代码非常复杂。比如静态要建立所有的连接，如果是动态则必须把状态内化，以期在真正拉流时能确定设备的调性，可是这就把这个特性的周期延长了，理想的设计特性是用完即丢，从概念上尽量做到stateless为好。比如在真正开始取视频流时，在应答中告知客户端接下来的连接特性，客户端依此做反应，这个状态的周期就被约束在真正的取流过程。</p>
</li>
</ol>
<p>视频流协议的业界标准RTSP就是这样，先发请求信令并根据回复的地址/端口建立子连接，而公司的私有协议是先请求建立连接，再创建子连接，最后再发信令。虽然看起来建立连接必不可少，但发信令比起来显然更重要一些，既然更重要，就应该更放在前面，也许后一个看起来也很重要的操作，就可以省掉了。比如大华的P2P网络，实际的连接只有一个，创建一个子连接反而是一种累赘。所以尽量不要额外地假设一些条件，只要保证更高优先级的操作被更早更完整地处理掉。那些额外的假设条件最好要明确地写出来，以便让以后的人知道当环境改变时，可以毫不犹豫地对协议进行调整。</p>
<h2 id="_4">两代协议的使用总原则和兼容</h2>
<h3 id="at-1609">设备协议兼容策略说明 at 16.09</h3>
<p>设备协议在发展的过程中，产生了二代和三代两套协议。</p>
<p>三代协议使用前期由于缺乏管控，同样功能的三代协议会有不同的表现形式，(比如摄像头属性的配置)。且在不同产品线间使用也不一致。另外同样功能也存在三代协议和二代协议的冗余，曾经试图不再使用二代协议，但从市场接受度和技术角度两方面看，这种作法既不可行，也没有必要。但是存在多套协议的混乱局面，必须要明确协议与业务功能的对应关系，本文档定义两套协议的适用场景、及如何选择的原则。</p>
<ul>
<li>二代协议：所有设备都支持，但协议为二进制，Web无法使用</li>
<li>三代协议：协议扩展性好，支撑业务迅速</li>
</ul>
<p>综上协议总原则：SDK的基础业务使用二代协议，扩展业务则使用三代协议。Web全部使用三代协议。</p>
<p>登陆协议</p>
<ul>
<li>SDK -- 0xA0</li>
<li>Web -- global.login</li>
</ul>
<p>登陆协议作为使用设备的第一步，基础性不言而喻。由于二代和三代协议有各自的登陆协议，但是一台设备显然只需要一种登陆协议就够了，综合考虑设备使用面、协议扩展性，NetSDK使用二代协议作为设备的登陆协议。设备保留三代登陆协议给Web使用。</p>
<p>媒体流协议</p>
<p>作为一个监控厂商，视频是基础功能。音视频部分包含流的获取、音视频参数设置、语音对讲等功能。</p>
<ul>
<li>SDK -- 0xF4</li>
<li>Web -- RTSP(前端)/0xF4(存储)</li>
</ul>
<p>视频流协议有三种，其中二代支持静态多连接和动态多连接两种，同时三代协议也有部分产品线在使用。
从协议使用的覆盖面和演进方向综合评估，NetSDK使用二代的动态多连接协议，即0xF4作为未来的支持重点。使用登陆返回的版本号是否为6，来区分设备是否支持动态多连接。</p>
<p>摄像头属性(SDK/Web使用相同协议)</p>
<ul>
<li>如果产品定义包含CameraAttribute，则使用VideoInXX配置族</li>
<li>如果产品定义不包含，则使用VideoInOptions/VideoInPreviewOptions配置</li>
</ul>
<p>通道标题</p>
<ul>
<li>SDK -- 0xA8</li>
<li>Web -- VideoIn/ChannelTitle</li>
</ul>
<p>存储类协议</p>
<p>设备通常都带有一定的存储介质，比如相机的SD卡或者存储类设备带硬盘，这部分涉及的协议，主要包括管理这些介质，或者查找存储介质上的录像/图片。其中尤其以查找录像/图片最为重要。磁盘管理对于运维平台来说，也有很大的价值。</p>
<p>录像查询</p>
<ul>
<li>SDK -- 0xF6 or 0xA5</li>
<li>Web -- MediaFileFind.xxx</li>
</ul>
<p>SDK通过0xA4查询设备的返回，如果xxx，则支持0xF6，否则使用0xA5。</p>
<p>云台控制</p>
<ul>
<li>SDK -- 0x12(基础)+0xF6/Json(扩展)</li>
<li>Web -- Json Over HTTP</li>
</ul>
<p>事件上报</p>
<ul>
<li>SDK -- 0x68/0x69+0xF6</li>
<li>Web -- 如何保持长连接？</li>
</ul>
<p>网络包括有线、无线网卡的管理</p>
<p>用户管理</p>
<ul>
<li>SDK -- 0xA6</li>
<li>Web -- UserManager.xxx</li>
</ul>
<h2 id="_5">对协议工作的反思</h2>
<h3 id="at-1608">协议该如何演进 at 16.08</h3>
<p>协议岗位作为职能部门，工作本身不容易出彩。出了问题会被追责，做得好无非就是不出问题，但不出问题这个标准在组织内部是没有意义的。</p>
<p>曾经有比较理想化的言论，协议就像法律，但事实上迫于现场的压力或者设备以出货等名义，妥协是难以避免的。除此之外日常工作中的扯皮、认识不对等造成的心力损耗更是难以承受。</p>
<p>首先要尽可能地团结友方的力量，协议分为服务器端和Web及NetSDK两个客户端，Web隶属产品线且经常被界面牵着鼻子走，通常很难想到一起，但服务端和NetSDK作为同在一个楼层的兄弟团队，想法利益往往一致。两种客户端因为服务对象不同，协议风格会产生差异。</p>
<p>目前的想法还是要区分Web协议和NetSDK协议，往往Web先定义一套协议，到NetSDK实现时，视情况做一层桥接，不把Web协议直接暴露给NetSDK，而是由服务端调整成更纯粹的协议，实现上可以迁就Web。因此必须要有一支能调动肯拼搏的服务端实现团队作为支撑，否则难以落地。</p>
<h3 id="at-1708">处理权限校验问题的反思 at 17.08</h3>
<p>公司产品的权限校验问题做了半年，前期我没有参与，最近因为人员调整所以换我来继续处理。说实话对于嵌入式产品却有多达6、70种权限的历史遗留问题，我很不认同。我觉得Onvif的权限模型把用户固定地划分到3个组，同时定义了几个固定的权限等级，语义清晰且一致性也很好。</p>
<p>经过上半年的处理，总算把6、70种权限归约到15种权限，结果产品又开始不停地提增加权限需求，我本来想限制权限种类不允许扩充，想想这样做在理论上站不住脚，还是要思考权限问题真正重要的根本约束(出发点)是什么，以及要达成的归约状态又是什么。</p>
<p>约束点就是每次的请求都需要权限校验。但是仅仅这样，就又会发散成不同产品各自定义权限，导致同一个请求却有五花八门的权限定义。甚至更加粗暴直接的是把权限和Web界面绑定。于是就出现今天开发提交给我的，增加一种日程这个请求的权限甚至包括了存储权限和编码权限，原因就是产品的惯性思维，因为录像和动检界面可以增加日程，所以增加日程的权限也要涵盖存储和编码。这类错误根本不值得讨论。</p>
<p>不同的嵌入式产品最终归约到统一客户端来展现，为了达成操作的最终的一致性，有必要限制权限和请求的关系。权限涉及安全产品线、产品线、协议模块和客户端，各自有各自的诉求，初步设想的处理基调是这样。</p>
<ol>
<li>原则上每种请求都要有权限，但如果是非敏感信息的只读操作，可以不校验权限，需要知会到安全产品线。</li>
<li>协议模块对每种请求默认只提供一种预先定义的权限，且这种权限就是展示在客户端上的权限定义。多种权限增加使用认知难度，在处理上歧义也很多。</li>
<li>如果产品线不认同这种权限，可以定制请求的权限列表，配合产品的Web界面，可以满足产品需求，不过这样的产品在接入统一客户端时还是会显示异常，终究无法做到全面的平衡。</li>
</ol>
<h3 id="at-1712">修改能力协议的思考 at 17.12</h3>
<p>对一个视频通道获取智能能力的协议，原来的协议只有一条能力，这种描述不足在于能力有当前能力和潜在能力，嵌入式设备的能力不是孤立的，会受制于其它资源，因此协议上要有两个能力。如果只到这里为止，协议就结束了，但接下来的实现就相当地狗血。</p>
<p>因为用了RPC方式，每个协议和接口对接，接口中只定义了一个caps参数，无法把协议的full节点映射到头文件。通常这种时候再增加一个接口，用来获取full能力，并在RPCServer中调用两次把能力返回也是可行的。此时第二个坑出现了，所有的接口定义在类当中，而类的接口数量是有上限的！此时这个类的32个接口都用完了。当然这种情况也遇到过，换一个类增加接口就是了。但偏偏这个类不是管理类，协议调用这个方法是通过工厂方法的instance，并传递通道号来获取类实例指针方式，比如当前的智能类名字是DevVideoAnalyse，客户端会先指定通道2获取对应的实例token，接下来通过token去访问getCaps方法，到了getCaps的实现只有token，无法映射到DevVideoAnalyse2这个实例(因为无法直接得到通道号)！变通的作法是建立token和两个类实例的绑定关系，这样一来又要多费很多周折，且为这一个方法也没有必要。</p>
<p>最后的解决办法是在getCaps的请求中增加一个channel，通过channel重新获取DevVideoAnalyse2的类实例并调用方法获取full能力。当然这样做协议就显得很冗余，也是协议被实现绑架的一个例子。</p>
<p>我一直对先获取资源指针并操作这种模式很反感，协议不应该暴露资源，如果不是这种模式，虽然类有32个接口数量限制，实现上并不会很丑陋。</p>
<h2 id="_6">几个具体的协议定义思考</h2>
<h3 id="at-1610">变倍与聚焦 at 16.10</h3>
<p>监控行业的相机有枪式和球式两种，还有种半球但实质上和枪式一样，只是安装方式不同。两种相机因为外形和机械结构的不同，使用场景也有很大差异。比如枪式相机主要安装在室内，而球式相机装在室外的较多。这种场景的不同，导致对图像的调校也不一样，典型如白平衡，两者的侧重点就很不一样。</p>
<p>这里从变倍和聚焦出发，谈谈两者的不同。先说说两者的异同：</p>
<ul>
<li>变倍的主要作用是调节透镜的物距，进而影响成像的大小，变倍主要有光学变倍和电子变倍。</li>
<li>聚焦则是使物体成像于焦点上，能看到清晰锐利的图像。</li>
</ul>
<p>从光学镜片的物理特性来说，单个镜头的曲率固定，焦距也固定，无法实现变倍。要变倍必须有多片镜头组，通过调节互相之间的位置，得到一个整体的等效焦距，这个焦距才能变化，焦距变化后就能达到变倍效果(准确的说是视角的变化)。而调焦是由于焦平面没有落在sensor上，整体移动镜头组，在此过程中焦距不会变。</p>
<p>为什么很多人会说分不清楚两者呢，因为在使用的过程中，变倍和聚焦在直观上都有一个物体由模糊变清晰的过程，所以会觉得两者很相似。但仔细区分的话会发现，变倍会引起物体大小的变化，而聚焦只会变清晰，但并不会改变成像的大小。而且更进一步说，变倍并不会使物体自动地变清晰，往往是镜头实现了自动聚焦这一动作。</p>
<p>变倍尤其是光学变倍，都会调整透镜和CCD或CMOS的距离，因此都需要配备电机，或者更高级的会使用步进电机，这就必然导致成本上升。因而低价位的枪式相机大多不具备变倍功能，因为没有变倍，焦距也能在出厂前就调节完成，所以既没有变倍，也没有调焦功能。</p>
<p>而球式相机由于自带云台，能够各种方向的旋转，在旋转的过程中很自然的有了变倍的需求，因此球式相机在行业里又称为PTZ，P和T是Pan(水平)和Tile(垂直)的意思，指的是云台底座的运动方向，而Z则是Zoom，即相机镜头的变倍。当然带云台的相机也可以没有变倍，两者并不强关联。由于球式相机大都具备变倍功能，在日常使用的过程中也经常要调节倍率进行物体的跟踪，往往要配备比较强大的聚焦算法，否则跟踪物体就会发虚模糊，用户是不能接受的。因此对球式相机来说，变倍是其基本功能点，而自动聚焦则是必备条件，但是又由于球式相机经常处于运动状态，对于聚焦只要能达到人眼可见的清晰程度，就能满足用户的使用了。</p>
<p>枪式相机，如果具备变倍功能，通常也会同时提供聚焦的调节功能。当用户购买了变倍相机，并在安装时根据场景选择好倍率，就会仔细地调节聚焦，力求画面清晰锐利，因为枪式相机的视野比较固定，一旦安装好，变倍就固定下来不会轻易改变，因此对聚焦就会有更多微调节的需求。</p>
<p>因此在枪式相机上，能看到单独的变倍和聚焦页面，而球式相机则往往只有变倍的按钮可以使用。</p>
<p>上文说到聚焦的目的是使物体变清晰，那么这个清晰要如何定义呢？如果是手动聚焦，一切依赖肉眼那就全由人来完成，但是往往相机都能自动地调整好焦距，这又是怎么做到的？这就涉及图像处理的算法了：比如在画面中有一个人，那么这个人的轮廓和画面的背景交界处，一定会出现较大的差距(当然如果你非要穿着黑衣在黑夜里，就没得谈了)。那么我们就可以通过计算图像中这些亮度差距较大的地方，来勾勒出轮廓，并通过调节画面，找出亮度差最大的一个场景，这时从理论上说，就是焦距最准确的位置。这个找最大差的原理则类似数学中的求导，当然具体细节复杂得多，只是一个约略的近似。除了这种自动聚焦的方式，还有一种辅助聚焦，在手动调节焦距时，由相机反馈一个当前聚焦峰值，一边手动调焦一边观察聚焦峰值，当这个峰值达到最大的一刻，就找到了焦点。有种把自动聚焦的内部参数，开放给手动调节的感觉。</p>
<p>所以虽然都是变倍和聚焦，由于相机的使用方式不同，这两个功能的呈现和侧重也会有所差异。概括地说就是</p>
<ul>
<li>枪式相机更注重聚焦，达到更好的画质</li>
<li>球式相机更注重变倍，达到运动过程中更好的观看体验</li>
</ul>
<h3 id="at-1706">礼让行人和车流量协议反思 at 17.06</h3>
<p>礼让行人协议的问题是，在说明时忽略了背景介绍。原文是这样的</p>
<pre><code>Direction : ["Left", "Right"]; Left表示向左，Right表示向右，数组为空表示表示不关心方向，即行人即使不动也表示违规。
</code></pre>
<p>这句注释的后半句还好，但前半句就很可笑了，谁不知道Left表示左呢。因为左右是相对的概念，如果不说明坐标系是没有意义的。我初以为是俯视图，但怎么也想不出来，另外同事认为是面对红绿灯的视角，直到问了做过这块业务的开发才知道是以相机预览画面视角，车为上下行故人为左右行。因此把视角补上才完整，另外方向已经解释，但单方向如左表示违规的情况没有给出示例，需要说明比如左车道只有左行，即和车方向靠近时才表示违规，这样的解释才是个好的说明。</p>
<p>再说车流量协议，原稿描述很简单，分别显示机动车/非机动车流量。初看并没有问题，但车流量有很多分类，除了机/非方式，还有按左转/右转/直行分类，也可以按轿车/卡车分类。所以在显示之前要先定下分类模式，然后展示。另外机和非的定义其实也不够确定，比如按车长定义，以4/6/9/12米长度为界把车分为5类，这样的定义相对更严谨一些。</p>
<h3 id="at-1801">人脸查询协议的理解 at 18.01</h3>
<p>一个人脸查询协议反复看了大半年，每次看都有新的体会，直到现在我也不确信是不是完整理解它。</p>
<p>人脸比对涉及两种对像，历史库和注册库，保存的虽然都是人，但历史库是对人一瞬间的描述，注册库则是对人精确描述，两者差异极大。比如年龄，在历史库是年龄但到了注册库却变成了生日，同一件事要用两个角度去解释。</p>
<p>既然两种不同性质的库，查询条件就应该不一样，合在一个接口已经容易引起误解，偏偏最重要的，从哪个库查询字段却放在中间很不起眼的位置，人的理解思维总是头尾相对容易重视，中间如果太多往往会不耐烦地跳过，偏偏这个协议的协议字段有二十多个。</p>
<p>我的调整是，首先按历史库和注册库拆分成两条协议，并对查询条件分类。比如上面提到的年龄，另外像历史库用到的眼镜和注册库用到的家族住址。</p>
<p>除了指定信息查找外，人脸还有种好玩的查询叫以图搜图。给一张照片，会返回若干张和这个照片最像的候选人像。如果有图片，图片本身就表示了一切属性，此时检索条件又不一样，因此又再细分为信息查询和以图搜图。而以图搜图的条件也多是一些模糊性的条件，比如按人脸哪个区域比对（选眼睛还是鼻子）。</p>
<p>经过这样分解拆分成4条协议，再结合对业务理解，可读性才勉强到可用的程度。</p>
<p>再说说库相似度。有需求要求修改人脸库时可以修改相似度，最初我也觉得可以，但经人提醒意识到，为什么会有相似度，是因为人脸识别算法的不准确性需要阈值，但既然是阈值一定要结合当时的环境一起考虑，不应一概而论。环境就是视频通道，经过讲解让需求方接受了这个用法。看一个概念要理解其背后代表的含义和适用场景，否则就容易用偏。</p>
<h3 id="at-1802">查询协议与资源回收 at 18.02</h3>
<p>遇到一个查询业务资源未回收的问题。查询的返回数量不确定，因此会有同步和异步的方式考虑有两种返回形式。如果是异步，在查询前传入一个回调函数，所有的查询结果逐步回调给调用方。如果同步方式，由查询方每次给出一个偏移量和一次查询的数量，逐步地查完。这次的问题就出在同步方式上。</p>
<p>由于是个连续的过程，第一次查询会返回一个句柄号，接下来的查询每次都从这个句柄获取，查询完成后释放该句柄。暂不考虑客户端恶意查询而不释放的问题，当网络断开时，也会存在句柄未关闭从而导致资源泄露问题。原因在于定义查询接口时，和其它的业务定义在同一个类里，而所有的类要服务化，都以单件的形式存在，当网络断开时即使协议库调用了析构函数，实现侧无法做到查询句柄的回收。</p>
<p>服务化和单件不是错，但对这类存在资源分配的业务，把接口都定义在单件中，就使得单件拥有了两种不同生命周期的业务，增加了维护的复杂度，这种情况要避免。</p>
<h3 id="at-1803">行人卡口事件的思考 at 18.03</h3>
<p>收到智能交通产品线增加行人卡口的需求，此前协议中已经有名为HumanTrait的事件，表示视频画面中出现了人。第一感觉就是行人卡口记录的也是人的出现这一事实，和HumanTrait有没有差异？</p>
<p>思考的角度</p>
<p>能否复用就要仔细地比较两者的异同。先分析HumanTrait事件，当视频画面中出现了多个人，会以每个人为单位，进行一次这个人的事件上报，并尽可能地带上脸部照片和一些分析信息。而行人卡口要求记录一个人不同时间的画面，比如走过斑马线前后的画面。虽然描述的都是人，但是HumanTrait是从同一个时间进行切入，描述在这个特定时间点某个空间内人的状态；而行人卡口描述的是同一个人，在不同时间点构造的一个序列。<em>HumanTrait是多人合照，行人卡口是个人短视频</em>。</p>
<p>反思与推广</p>
<p>做协议经常会遇到到底能不能，要不要复用的问题。如果要复用，要看这个复用协议描述的粒度。但是在定义第一版协议时，因为没有比较，描述往往不精确，会隐含了很多外部信息，直到遇到新需求，才会发现原来还可以从另一个维度看。</p>
<p>像上面提到的过人事件为例，第一次看到这个需求时，的确没想到可以从时间序列去记录一个人。其实第一次分析不完整问题也不大，只要后面遇到新需求时，回过头来比较、细化已经定义好的协议也是来得及的。</p>
<p>另一个悖论是倘若粒度真的太小，非常地场景特化，能被复用的可能性自然就少了。</p>
<h2 id="176">一些讨论纪要(17年6月初)</h2>
<ol>
<li>
<p>协议的本质是什么，好的衡量标准(金线)是什么？</p>
<p>协议是被网络化的接口，接口的本质是契约。即在什么样的规定前提下，通过什么样给定的输入，最终达成怎样的输出。衡量标准就是契约的定义，越详细越无歧义越好。至于扩展性的权重，是第二位甚至更靠后，大不了重新订一份新的契约就好了。</p>
</li>
<li>
<p>公司协议有4千多条，粒度是什么或者说应该依据什么来制定协议？(此处是两个原始问题)</p>
<p>有4千多条，就说明有4千多个应用场景，分别有不同的输入，有不同的期望输出。考虑到公司重OEM属性，光IPC一年软件版本能达到1万多个，4千并不多。至于粒度，对超过90%的定制协议，满足定制客户的使用场景就是好的协议。如果一定要说粒度，两件事，如果以普通消费者能够区分的差异度来区分协议。但也不要把从软件上可以归并的行为硬生生归在一起。我想到微信的例子，把小视频和拍照合并到一起后，我的母亲就再也不会用小视频了。(因为那个按键短按是拍照，长按是视频，母亲不会用长按这种操作方法)</p>
</li>
<li>
<p>协议要包含哪些元素？</p>
<p>同问题1，界定什么场景下用，输入和输出，这些要素是第一性的。至于其它request-ID，session-ID，就好比是合同中的签名，如果再有时间戳，相当于合同的有效期，就更好了。</p>
</li>
<li>
<p>RPC要定义哪些方法，如何让调用者更简单？比如做到RESTful风格。</p>
<p>简单的定义要从理解角度看，如果用户懂业务背景，或者需求就是用户定制的，那么和定制需求完全契合的协议，就是最简单的。说实话RESTful风格未必就是简单，把一切都认为是资源的行为，然后基于资源的操作，这种思想适用于互联网，或者反过来说，正是基于互联网的基础设施，提出了RESTful。但不同的领域，未必都要按RESTful方式设计。让使用者最自然的使用方式，就是简单。这方面有很多理论，最少知识/最少惊奇原则。</p>
</li>
</ol><hr><a href="/">back</a></article></body></html>