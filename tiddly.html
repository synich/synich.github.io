
<!doctype html>
<!-- The following comment is called a MOTW comment and is necessary for the TiddlyIE Internet Explorer extension -->
<!-- saved from url=(0021)https://tiddlywiki.com -->
<html lang="zh-Hans">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<!--~~ Raw markup for the top of the head section ~~-->

<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
<meta name="application-name" content="TiddlyWiki" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.3.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no" />
<meta name="copyright" content="TiddlyWiki created by Jeremy Ruston, (jeremy [at] jermolene [dot] com)

Copyright (c) 2004-2007, Jeremy Ruston
Copyright (c) 2007-2023, UnaMesa Association
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." />
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<title>蛙二的记忆 — 卡片式个人网页笔记</title>
<!--~~ This is a Tiddlywiki file. The points of interest in the file are marked with this pattern ~~-->

<!--~~ Raw markup ~~-->



</head>
<body class="tc-body">
<!--~~ Raw markup for the top of the body section ~~-->

<!--~~ Static styles ~~-->
<div id="styleArea">
<style data-tiddler-title="$:/boot/boot.css" data-tiddler-type="text/css" type="text/css">/*
Basic styles used before we boot up the parsing engine
*/

/*
Error message and password prompt
*/

.tc-error-form {
	font-family: sans-serif;
	color: #fff;
	z-index: 20000;
	position: fixed;
	background-color: rgb(255, 75, 75);
	border: 8px solid rgb(255, 0, 0);
	border-radius: 8px;
	width: 50%;
	margin-left: 25%;
	margin-top: 4em;
	padding: 0 2em 1em 2em;
}

.tc-error-form h1 {
	text-align: center;
}

.tc-error-prompt {
	text-align: center;
	color: #000;
}

.tc-error-message {
	overflow: auto;
	max-height: 40em;
	padding-right: 1em;
	margin: 1em 0;
	white-space: pre-line;
}

.tc-password-wrapper {
    font-family: sans-serif;
	z-index: 20000;
	position: fixed;
	text-align: center;
	width: 200px;
	top: 4em;
	left: 50%;
	margin-left: -144px; /* - width/2 - paddingHorz/2 - border */
	padding: 16px 16px 16px 16px;
	border-radius: 8px;
}

.tc-password-wrapper {
	color: #000;
	text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
	background-color: rgb(197, 235, 183);
	border: 8px solid rgb(164, 197, 152);
}

.tc-password-wrapper form {
	text-align: left;
}

.tc-password-wrapper h1 {
	font-size: 16px;
	line-height: 20px;
	padding-bottom: 16px;
}

.tc-password-wrapper input {
	width: 100%;
}
</style>
</div>
<!--~~ Static content for Google and browsers without JavaScript ~~-->
<noscript>
<div id="splashArea">


<p>This <a class="tc-tiddlylink-external" href="https://tiddlywiki.com" rel="noopener noreferrer" target="_blank">TiddlyWiki</a> contains the following tiddlers:</p><p><ul>

<li>《杀戮与文明》读后感</li>

<li>《天朝的崩溃》读后感</li>

<li>《JS语言精粹》学习记录</li>

<li>【翻译】select的历史和epoll的不足</li>

<li>【译】Eiffel之路</li>

<li>【译】Scheme的面向对象呈现（部分）</li>

<li>【转】对PHP的分析</li>

<li>$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/import</li>

<li>$:/config/RelinkOnRename</li>

<li>$:/config/SaveWikiButton/Template</li>

<li>$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/info</li>

<li>$:/config/ViewToolbarButtons/Visibility/Recipe</li>

<li>$:/core/ui/SideBar/Recent</li>

<li>$:/DefaultTiddlers</li>

<li>$:/Import</li>

<li>$:/isEncrypted</li>

<li>$:/language</li>

<li>$:/languages/zh-CN</li>

<li>$:/languages/zh-Hans</li>

<li>$:/plugins/linonetwo/inverse-link-and-folder</li>

<li>$:/SiteTitle</li>

<li>$:/state/advancedsearch/currentTab</li>

<li>$:/state/http-requests</li>

<li>$:/state/showeditpreview</li>

<li>$:/state/tab--1498284803</li>

<li>$:/state/tab--1963855381</li>

<li>$:/state/tab--2112689675</li>

<li>$:/state/tab--86143343</li>

<li>$:/state/tab-1688658110</li>

<li>$:/state/tab-1749438307</li>

<li>$:/state/tab-256990426</li>

<li>$:/state/tab/sidebar--595412856</li>

<li>$:/state/tabs/controlpanel/toolbars-1345989671</li>

<li>$:/status/RequireReloadDueToPluginChange</li>

<li>$:/StoryList</li>

<li>$:/themes/tiddlywiki/snowwhite</li>

<li>$:/themes/tiddlywiki/vanilla</li>

<li>$:/themes/tiddlywiki/vanilla/options/sidebarlayout</li>

<li>安卓程序的构建与链接</li>

<li>安卓野Rom手动清毒记</li>

<li>安卓APK内容分析</li>

<li>安卓root原理小记</li>

<li>版本管理工具的历程</li>

<li>北京之行</li>

<li>比较词法分析和语法分析</li>

<li>编程语言</li>

<li>编程语言的字符串内部表示</li>

<li>编辑器的扩展机制</li>

<li>变倍与聚焦</li>

<li>变量类型与Lua的local关键字</li>

<li>表单的请求类型</li>

<li>并不神秘的深度优先搜索</li>

<li>并发和并行</li>

<li>博客网站功能扩展记录</li>

<li>不可打印字符与转义序列</li>

<li>布尔代数与三段论</li>

<li>操作系统</li>

<li>操作系统启动器的故事</li>

<li>查询协议与资源回收</li>

<li>程序的被集成性</li>

<li>程序语言的依赖包管理</li>

<li>处理权限校验问题的反思</li>

<li>词法语法之后</li>

<li>从串口功能的封装看如何抽象</li>

<li>从ifconfig接口看网卡</li>

<li>从Javascript函数类型理解计算和对象</li>

<li>搭建最小化的Linux系统</li>

<li>打包软件的故事</li>

<li>大华设备协议兼容策略说明</li>

<li>大华视频云框架</li>

<li>代码写法中的状态与异常</li>

<li>灯光和相机差异的关联和协议需求</li>

<li>电话协议的发展</li>

<li>动态链接库与符号表</li>

<li>对《谈谈架构》的理解</li>

<li>对称加密实践</li>

<li>对公有云上数仓的调研</li>

<li>对昼伏夜出和朝九晚五两个技战法的分析</li>

<li>对Lua中Enviroment的理解</li>

<li>对netcat的探索</li>

<li>多核CPU之间的异同</li>

<li>多进程与进程间通信</li>

<li>多终端打开软件用法</li>

<li>二三层网络和MAC地址</li>

<li>防火墙与iptables</li>

<li>分布式哈希技术摘录</li>

<li>分布式计算在Spark上的实现</li>

<li>冯东的Lua</li>

<li>感悟项目开发和问题分解</li>

<li>给应届生出题看指针的易错点</li>

<li>公安数仓总结</li>

<li>公私钥格式的认识</li>

<li>功能重用与接口设计</li>

<li>函数参数的传值与传引用及语义</li>

<li>函数式和对象式，表达式和语句</li>

<li>环境变量的继承</li>

<li>回看晚清七十年历史</li>

<li>几个安卓ROM的体验报告</li>

<li>几种语言的包加载和管理机制</li>

<li>几种语言作用域的比较</li>

<li>加密与安全</li>

<li>简说CSRF</li>

<li>接口设计的原则与反思</li>

<li>接入协议、账户体系和权限</li>

<li>进程线程和协程的切换开销</li>

<li>经度纬度和GeoHash</li>

<li>精巧的安全和DH算法</li>

<li>跨域和同源策略</li>

<li>类型理论</li>

<li>礼让行人和车流量协议问题反思</li>

<li>理解shell的换行和打印</li>

<li>练习健身纪要</li>

<li>两个嵌入式JS引擎的介绍</li>

<li>两个小微JS库的使用</li>

<li>两个一直理解错误的编译问题</li>

<li>浏览器的网络请求发展史</li>

<li>浏览器对文件的处理</li>

<li>论为什么CSS难学</li>

<li>论RESTFul特性</li>

<li>蒙古帝国</li>

<li>面向对象中的类与应用场景</li>

<li>明朝与文官集团</li>

<li>命令行工具用法探索</li>

<li>模块功能的划分与解耦</li>

<li>目录</li>

<li>目录服务和NetBIOS协议</li>

<li>内存使用的观察和理解</li>

<li>排版和字体的关系</li>

<li>排版软件的故事</li>

<li>批处理的用法</li>

<li>千岛湖公司旅游</li>

<li>嵌套加载的目录查找方式比较</li>

<li>区块链的运行机制</li>

<li>人脸查询协议的理解</li>

<li>如何学习emacs</li>

<li>如何在struct里追加指针</li>

<li>软件工具使用</li>

<li>软件可靠性硬件可靠</li>

<li>软件设计</li>

<li>设计方案的不动点和弱化点</li>

<li>神经网络来源与分类</li>

<li>实战flex和bison注意事项</li>

<li>实战flex和lemon要点</li>

<li>使用CVS管理版本</li>

<li>使用DroidScript开发安卓程序</li>

<li>使用fossil管理版本</li>

<li>使用Lazy-Stream方式实现Fibnacci数列</li>

<li>使用xapian和scws进行全文检索</li>

<li>视频的封装格式</li>

<li>视频取流协议</li>

<li>视频云的域和组织</li>

<li>数据库的执行优化</li>

<li>数据库和数仓的历史</li>

<li>数据库计算理论笔记</li>

<li>数据库技术</li>

<li>数据库SQL优化原理</li>

<li>数据挖掘、机器学习和深度学习</li>

<li>数字的精确与不精确</li>

<li>思考、笔记与记忆</li>

<li>所思所想</li>

<li>通过限制来降低沟通成本</li>

<li>通信协议</li>

<li>网络层的交换与路由</li>

<li>网络代理概念与区别</li>

<li>网络文件系统机制</li>

<li>网络相关头文件所属目录的关系</li>

<li>网络协议与socket</li>

<li>网络原理</li>

<li>网页链接</li>

<li>网站项目教训</li>

<li>网站性能测试</li>

<li>微服务的理解和实践</li>

<li>为什么C语言的long类型长度不确定</li>

<li>我对两种同步异步的认识</li>

<li>我国省份行政编码规则</li>

<li>我理解的面向对象设计原则</li>

<li>我司组件化的优劣</li>

<li>系统性能分析的理解</li>

<li>线程模型与调度</li>

<li>消息队列理解</li>

<li>小鲜4刷机反思</li>

<li>协程剖析</li>

<li>协议工作该如何演进</li>

<li>协议是什么，要定义什么</li>

<li>协议为什么要分包</li>

<li>写文件的一些特性</li>

<li>辛弃疾的青玉案赏析</li>

<li>信息的价值与一篇机器学习文章读后感</li>

<li>行人卡口事件的思考</li>

<li>性能监测工具选项备忘</li>

<li>修复操作系统问题记录</li>

<li>修改能力协议的思考</li>

<li>学Scheme经历的误区</li>

<li>压缩技术浅谈</li>

<li>业务分离和厘清概念</li>

<li>一次安卓刷机失败的修复过程</li>

<li>一次反汇编的崩溃定位</li>

<li>一个加密协议定义不仔细的教训</li>

<li>一个GDB和GCC版本不同引起的定位问题</li>

<li>伊斯兰国家的传承</li>

<li>以太和IP网之外的一些网络</li>

<li>音频与声道的一些基本概念</li>

<li>音视频解码器的特性</li>

<li>英语的谓语、表语和动词</li>

<li>硬盘操作和文件系统散记</li>

<li>用数组实现链表</li>

<li>域名和DNS的事</li>

<li>远程文件传输说明</li>

<li>云升级项目的反思</li>

<li>在CentOS和FreeBSD上安装OpenResty的一些记录</li>

<li>指针的三种面貌</li>

<li>重新认识Makefile</li>

<li>仔细打磨写过的程序</li>

<li>字符编码与字体映射</li>

<li>自制编程语言的历程</li>

<li>子进程执行和信号</li>

<li>组件化与线程模型及缺陷</li>

<li>Andoird上用kbox模拟linux环境</li>

<li>Android安装Linux环境</li>

<li>AndroLua记录</li>

<li>Apache和Nginx配置的理解</li>

<li>ARQ可靠传输协议</li>

<li>Bitcoin中三种哈希的区别与关联</li>

<li>BW博客系统简探</li>

<li>C++类的访问控制符与引用</li>

<li>C++模板引起的一个二进制兼容问题</li>

<li>C与和ua的交互问题记录</li>

<li>C语言的HTTP请求</li>

<li>C语言如何获取Lua中的内容</li>

<li>CDN的来源与应用</li>

<li>CGI与FASTCGI规范的理解</li>

<li>Chomsky的4型文法与BNF</li>

<li>continuation的理解</li>

<li>CSS的一些理解</li>

<li>dmesg和BSD初期版本的故事</li>

<li>docker和OCI规范</li>

<li>erlang和其上的扩展语言</li>

<li>flex和bison的理解</li>

<li>Flink引擎学习</li>

<li>FLTK编译历程</li>

<li>GB28181理解</li>

<li>GCC编译4阶段的一些理解</li>

<li>git的远程访问辨析</li>

<li>git概念理解</li>

<li>GitHub用法记录</li>

<li>Go语言学习笔记</li>

<li>Graphviz使用说明</li>

<li>groff中间格式翻译</li>

<li>hadoop体系理解</li>

<li>HTTP2特性学习</li>

<li>HTTP的认证方式</li>

<li>HTTP协议历史与细节</li>

<li>Java程序的演变</li>

<li>JS的单线程和运行时</li>

<li>JS和AWK语言的new和delete</li>

<li>JS模块化历史</li>

<li>Json中的null和undefined</li>

<li>Kubernetes笔记</li>

<li>libuv代码走读</li>

<li>Linux的权限与sudo辨析</li>

<li>Linux的软件包管理软件说明</li>

<li>Linux内核与PAM模块简记</li>

<li>Linux上的虚拟化</li>

<li>lisp编程与结构化思想</li>

<li>lisp的3个处理阶段</li>

<li>Lisp的宏</li>

<li>Lisp文章读后感</li>

<li>lua_call的机制理解</li>

<li>lua闭包和其他语言比较以及修改upvalue</li>

<li>Lua的编译期和运行期区分</li>

<li>lua的表方法及self参数</li>

<li>Lua的Continuation</li>

<li>Lua的require机制及限制</li>

<li>Lua调试器clidebug使用说明</li>

<li>Lua栈操作记录</li>

<li>Lua中引入对象风格的价值和loop的实现</li>

<li>Lua中元表的理解</li>

<li>Lua中udata设置元表机制和回调</li>

<li>LuaJIT的编译过程和FFI接口</li>

<li>LuaUnit记录</li>

<li>Markdown的渊源与流派</li>

<li>mount和文件路径改写</li>

<li>MySQL和Redis备忘</li>

<li>MyStyle</li>

<li>nginx工作流与模块</li>

<li>OpenBSD学习与使用</li>

<li>Openresty代码初读</li>

<li>Openresty的应用开发</li>

<li>P2P及SIP和xinetd</li>

<li>perf使用</li>

<li>php-fpm记录</li>

<li>PHP的一些语言特性</li>

<li>PHP的SESSION机制</li>

<li>PHP两种模式下的调试功能</li>

<li>PHP模板引擎学习</li>

<li>PHP与Web服务器的集成方式</li>

<li>PNG格式的启发</li>

<li>PostgreSQL备忘</li>

<li>PPT到底做什么</li>

<li>procfs记录</li>

<li>promise和future的区别</li>

<li>putty的配置</li>

<li>PySpark分析</li>

<li>Python的包机制</li>

<li>Python的数据科学相关库介绍</li>

<li>Python进阶学习点滴</li>

<li>Python自学手册</li>

<li>RAII、智能指针和GC</li>

<li>RSA/DSA/EC三种算法记录</li>

<li>SASL、GSSAPI和Kerberos的理解</li>

<li>scheme的几个实现Gambit/Chibi/Chicken/S7</li>

<li>setjmp的机制及lua中的异常</li>

<li>SHA家族的哈希算法</li>

<li>Shell编程说明</li>

<li>shell的历史和流派</li>

<li>shell的模式与选项</li>

<li>spark性能调优记录</li>

<li>Spark学习手记</li>

<li>SQL的行转列与列转行</li>

<li>SQL的JOIN种类与选择</li>

<li>SQL语言梳理</li>

<li>SQLite的扩展机制</li>

<li>SQLite分析</li>

<li>SSH点滴</li>

<li>SSL和SSH比较</li>

<li>SSL杂记</li>

<li>stackless和stackfull概念在VM上的一些理解</li>

<li>SU的执行过程与用户登陆机制</li>

<li>tags的说明和比较</li>

<li>TCP的状态与nc的理解</li>

<li>TeX学习笔记</li>

<li>TinyScheme的运行过程</li>

<li>traceroute原理和ICMP</li>

<li>UDP广播多播和IPv6记要</li>

<li>UDP和相关操作</li>

<li>Unicode的若干概念</li>

<li>Url Rewrite和PHP路由的初步认识</li>

<li>UTF8编码规范小记</li>

<li>vim的概念和配置</li>

<li>vim的扩展与插件</li>

<li>vim的自动补全</li>

<li>VPN概念解释</li>

<li>Web单页和跳转</li>

<li>Web开发</li>

<li>Widnows的编译库的理解</li>

<li>Word的标题样式和多级列表关系</li>

<li>wren语言记录</li>

<li>X509证书与GPG验证</li>

<li>YXcms和CanPHP的结合</li>

</ul>
</p>



<style>
.tc-remove-when-wiki-loaded {display: none;}
</style>

</div>
</noscript>
<!--~~ Ordinary tiddlers ~~-->
<script class="tiddlywiki-tiddler-store" type="application/json">[
{"created":"20171230121530000","title":"《杀戮与文明》读后感","text":"\n这是一本相当西方自豪主义的书，写得很啰嗦很冗长，但揭示的理由还是值得看看。整本书为三大部分，创造、延续和控制。\n\n创造部分讲了三个希腊罗马时代的战争故事。萨拉米斯海战，希腊把自己的三艘战舰都以自由命名，将士用命，地米斯托克利也在战争的第一线，反观波斯的薛西斯却在遥远岸上看着自己的战士们死去。这一段有句话让我印象深刻，**城邦，以法律为准绳而运作，虽然规模有限，立于贫瘠的山地之上，却远胜于繁华而缺乏理性的的尼尼微都城**。正是引以为傲的希腊城邦制度催生的法制、自由使每个人都能为自己而战。\n\n马其顿国王亚历山大在高加米拉大败波斯帝国，依赖创造性的步骑配合，亚历山大利用长枪阵的优势，自己率领右翼军集中地如铁锤般打击在敌人战阵中，左翼则是稳如山的步兵方阵负责屠戮，这种配合下的杀人堪称高效。作者对亚历山大的评价，和希特勒的闪电战一样，都是战争上的天才。当然作为反衬，可怜的波斯人再一次因为没有信仰，只知道捡钱而缺乏持久的战斗力，最终败给了不杀光不罢休的马其顿军队。\n\n坎尼会战评价更绝，这是汉尼拔以新月战诱敌深入并歼灭的的经典之作，但作者并没有花重笔墨地赞美汉尼拔，而是用罗马军队在此战后一年迅速恢复元气为依据，再次强调公民兵组织的动员性，最终汉尼拔因为缺少支援只能返回腓尼基并最终以失败结束了布匿战争。\n\n延续的三场战役来到了中世纪，普瓦捷战役是查理马特率领的法兰克士兵抵挡了阿拉伯人的北进，终止了穆斯林对欧洲文明的入侵。这场战争是重装步兵对骑兵的胜利，步兵、骑兵或是弓箭兵没有谁完胜谁的说法，步兵最好的兵源来自农庄，因此要有一支强大的步兵，必须有健康的农庄经济，再一次作者强调了公民社会传统的影响，而骑兵显然是游牧民族的强项，而游牧民族是很难孕育公民社会的，但是从当时的浮雕看，马仅仅是运输工具，真正的战斗是下马的（个人理解是没有马鞍）。另外要给一支步兵提供给养，必须后方有强大的协调组织的资源支撑能力，非公民社会不具备这样的基础。另外中世纪的欧洲十字弓被称为穷人的武器，只要很低的成本就能打击需要巨大成本养成的骑兵，教会甚至限制了十字弓的使用。\n\n勒班陀海战中，欧洲军队拆掉了帆船的撞角换成火炮，虽然帆船数量少于奥斯曼舰队，但火炮数量却多很多，不仅数量，质量也精良得多。奥斯曼的火炮却只能用来作为原材料。除了火炮，欧洲舰队也广泛使用火枪，而奥斯曼却因担心民众不稳定，只敢训练弓箭手（甚至不敢印刷书籍），训练周期长不说，战时还容易疲劳，经此一战更折扣大量训练有素的弓箭手。另外分工的精细化，使当时威尼斯最快能在1小时内下水一条帆船。由于缺乏银行系统，奥斯曼的将帅们不得不在船上放着大量金币。\n\n罗克渡口是一场先败胜的战役，在大部队输掉之后，一股不足百人（投入战斗约80人）的分队顶住了4000祖鲁人进攻，原因就在于坚强的纪律性。作为反例的祖鲁人虽然早就从欧洲得到享受了火器，却始终无法有效地运用(前填充燧发枪没有好的战术素养确实起不到什么作用)，因此祖鲁人仍然习惯了使用短矛。英国人在战争中携带大量的辎重，一个150磅的士兵会携带10磅的武器和60磅的补给，而当地糟糕的交通环境导致在天气好的时候一天也只能行进5英里。而祖鲁人的轻装上阵也导致无法使用火器，在罗克渡口的士兵甚至两天没有吃饭，战场上检视尸体发现祖鲁人嘴里都还塞着食物。","modified":"20171230121530000","tags":"think"},
{"created":"20171130121530000","title":"《天朝的崩溃》读后感","text":"\n草草地看完茅海建先生的天朝的崩溃一书，这本书有500多页，因为时间的关系，只看到其中的一大半的章节，现在留下来的都是一些情绪上的一些记忆。\n\n我对这段历史的细节并不太了解，包括这本书第一章节的绪论提到琦善卖国而想到的，我甚至都不知道琦善是一个什么样的人。我们的教科书往往只是列举这个关键时点的一些人物，比如林则徐，关天培，但是其实还有非常非常多的官员，像琦善，伊里布，这些人物在当时的官职并不比林则徐低，但是因为可能民族的关系，在教科书中并没有过多的涉及。\n\n鸦片战争是清朝在军事力量上和英国的不对等，坚船利炮不是文学上的描述，而事实上的差距，清国因为长期的产品，武器火炮弹药年久失修。比如清军之中最长的火枪，竟然有166年的历史之久，是康熙时代真法俄国留下来的战争器物。各种火炮的配方，因为不懂化学的关系，没有像英国制作的，如此复合化学原是，另外在烘干等各种工艺上的不成熟，导致火药的性能也非常的差。由于缺乏严谨细密的科学理念，所以在各种器物上的差异简直不可以道理计。铁器的铸造工艺也落后很多，所以炮管枪管内壁非常不均匀，射出的弹道也无法保证是预期的吻合，更会导致后管炸裂，未伤敌先伤已。\n\n一方面是科学技术和器物上的落后，另一方面，长达2000多年天朝上国的自尊，在面对英国是一种无法平等的外交状态。英国人提出以封锁海上贸易作为惩罚条件，在吾国看来根本就不是什么问题，甚至英国人不提出封锁海口，我们自己也会封关禁海。所以可以想象，当时要把吾国纳入世界贸易体系，在我们当时人看来是多么的难以理解。林则徐作为当时最积极的士子，提出的方略也没有作战的实用性，他提出的海上操舟作战之法，显然没有在水战之中得到过印证。\n\n因为前方战事情况，到朝廷的失真，道光皇帝在这个过程之中，也由勦到抚最终又到勦的思想转变。整个过程并没有发生实质性的改变。当然，在第一线的官员看来，其实这场仗已经完全没有胜算，也包括像伊里布这样的封疆大臣，虽然在云南有极其丰富的对少数民族的经验，但是面对强大的英国，其实心知肚明，不能硬扛。\n\n所谓的英勇抗战，顽强抵抗，不过是螳臂挡车的送死而已，道德上的正义不代表政治上的正确，明明知道落后，还要以血肉之躯去做抵抗，不是正确的反抗方式，但也是那个时代落后的我们最无奈的选择。\n\n战事结束，从道光到咸丰的十年之间，参加这场战事的12名官员，其思想也没有发生特别大的变化，包括像林则徐官复原职之后，也没有特别积极的改变。但反观日本人，佩里的黑船来袭之后，15年就促成了明治维新。并且一发不可收拾，成为东亚乃至世界强国，而我们却在百年后仍无力抵抗日寇的入侵。我们这样一个老大帝国的转变，比起日本人实在是慢得太多。\n\n当然幸运的是，比起印度人，至少已经发生了转变，并且迎头赶上。所以最后我还是想说，感谢英国人用坚船利炮，使我们融入了这个国际贸易体系。虽然疼痛，而且用了一百多年的时间，走了很多的弯路，流了很多的鲜血，但是今天我们能够享受这样的发展红利，其兆始就在于一百多年前的这场战争吧。","modified":"20171130121530000","tags":"think"},
{"created":"20180401121530000","title":"《JS语言精粹》学习记录","text":"\n知乎上看的，融合了自己的理解。\n\n!! 第一章 精华\n\nJavaScript有很多优秀的想法也有糟粕；\n优秀的想法在于：弱类型，函数，动态对象和富有想象的对象字面量表示法。\n糟粕在于：基于全局变量的编程模型。\n\nJavaScript的函数是主要基于词法作用域（lexical scoping）的顶级对象.\n\n原型继承是JavaScript一个有争议的特性。JavaScript有一个无类型的对象系统。在这个系统中，对象直接从其他对象继承属性。\n始终用一个method方法定义新方法：\n\n```\nFunction.prototype.method = function ( name , func){\nthis.prototype[ name] = func ;\nReturn this;\n}\n```\n\n!! 第二章 语法\n\nNaN表示一个数值，是一个不能产生正常结果的运算结果。不等于任何值，包括他自己。Infinity可以表示无穷大。数字拥有方法，有一个对象Math，包含一套用于数字的方法。\n\n字符串：可以在” ” , ’ ‘里面。\\ 是转义字符。有一个length属性，表示长度。可以用 + 连接字符串，字符串也有一些方法。\n\n语句：每个`\u003Cscript>`提供一个被编译且立即执行的编译单元。JavaScript把他们添加到一个全局的名字空间里面去。\n\nVar在函数内部，定义的是私有变量。代码块在{ } 中，不会创建新的作用域。\n\nSwitch，while，do，for允许有一个可选的标签。可以配合break;\n\n被判断为 假 的值：False ; null ; undifined ;空字符串 ； 数字0 ； 数字NaN\n\nFor in 语句枚举对象里的所有属性\n\n如果throw在一个try代码块中，那么控制流会跳转到catch从句中。如果throw语句在函数中，则该函数调用被放弃，控制流跳转到调用该函数的catch中。\n\nThrow语句的表达式通常是一个对象字面量。通常包含一个message和name。异常捕获器可以利用这些信息知道做什么。\n\n表达式：最简单的表达式是字面量值，变量，内置的值，new开头的表达式，delete开头提取属性，（...）,前置运算符，三元，函数调用，属性提取....\n\ntypeof判断类型。\n\n字面量：对象字面量是一种可以方便的按照指定的规格创建新对象的方法。\n\n函数：函数字面量定义了函数值。\n\n!! 第三章 对象\n\nJavaScript简单的数据类型包括：数字，字符串，布尔类型，null，undifined。除此以外的所有类型都是对象。数字，字符串，布尔值也类似对象，他们有方法，但是他们不可变。\n\n对象是可变的键值对的组合。数组，函数，正则表达式都是对象。对象是属性的容器，属性都有名字和值。值不可是undifined。对象是无类型的，对象中可以包含对象。\n\n对象字面量：方便的创建对象。语法有点特殊，只有在等号或圆括号内的花括号才认为是创建对象。\n\n“||” 可以填充默认值，\n\n“&&”可以避免typeerror错误，由于在不存在的属性取值产生的。\n\n更新： 赋值语句，存在则更新；不存在则扩充。\n\n引用：对象通过引用传递，永远不会被复制。\n\n比较JS和Lua对象，两种语言的实现都有GC和union的值类型，JS会多出两个特殊的字段，properties和prototype。\n\n先说原型（prototype）：每个新建对象都连接到一个原型对象，并且可以从其中继承属性。所有通过字面量创建的对象都连接到Object.prototype,他是js中的标配对象。看MuJS的实现，所有的类型像Object/Array/Function/Date有prototype。七种错误Error/EvalError/RangeError/ReferenceError/SyntaxError/TypeError/URIError也有各自的prototype。\n\n每次构造新对象，都会把新创建的类型的prototype指向预设的原型。原型连接在更新时候不起作用，对对象改变不触及原型。\n\n原型链的任何属性都会产生值 typeof fight .toString // ‘ function’\n\n有两种方法丢掉不需要属性：\n\n# 程序检查并丢掉值为函数的属性。\n\n# 使用hasOwnProperty 方法，如果对象有独立属性，返回true。它不会检查原型链。\n\n再说property，比Lua要丰富一些，具备一些内在属性，READONLY/DONTENUM/DONTCONF。三者可以任意组合。\n普通的属性可以枚举：for in 遍历一个对象中非ENUM的属性名包括原型中的属性。属性出现无序，可以使用数组避免这种情况。\n\nCONF和Frozen相关(ES5特性)。\n\n删除：删除对象的属性可能会让原型链中的属性透露出来。\n\n减少全局变量污染：只创建一个全局变量作为容器这样都在一个名称空间下，减少与其他程序的冲突。\n\n!! 第四章 函数\n\n函数对象：函数是对象。创建时连接到Function.ptototype。每个函数对象在创建的时候配一个prototype属性。其有一个constructor属性且值为函数。\n\n函数字面量：函数通过函数字面量来创建。\n\n```\nVar add = function ( a , b ){\nreturn a + b ;\n}\n```\n\n函数没有名字，如上就叫匿名函数。\n\n函数字面量可以在任何表达式可以出现的地方。也可以在函数中，就是嵌套函数。里层的函数可以调用他上一层的函数的变量。通过函数字面量创建的函数可以连接到他的外部上下文这叫，闭包。\n\n调用：除了函数定义的形式参数以外函数还有两个自带的参数。this 和 argument，this的值取决于调用模式：\n\n函数有4中调用模式：\n\n# 方法调用模式：\n\n函数在对象中保存为属性的时候，为方法。此时this绑定到该对象。通过this可以取值或对对象进行修改。通过this取得对象上下文的方法称为公共方法。\n\n# 函数调用模式：\n\n当函数不是属性的时候，此时当做一个函数来调用。此时this指向了全局变量。这使得函数中的内部函数不能为外部函数服务。解决的办法：在外部函数里让this赋值给一个变量。\n\n# 构造器调用模式：\n\nJs提供一套和基于类的语言类似的对象构建语法。如果在函数前面添加new来调用，那么会在背地里创建一个连接到这个函数的prototype的新对象，this会绑定到这个新对象。一个函数，构建的目的是希望结合new来用，就是构造器函数。\n\n# Apply调用模式\n\n函数可以拥有很多方法。Apply方法允许我们传递一个数组参数给函数。其接受两个参数，第一个为this的值，第二个就为参数数组。\n\n参数：参数有一个附加的对象，argument对象，类似数组，没有数组的属性。函数可以通过这个对象，访问传过来的参数列表。\n\n返回：return\n\n异常：throw语句判断函数的执行。会抛出一个exception对象，其中包含异常类型name，以及异常的描述message。一个try语句只会跟随一个捕获所有异常的catch。\n\n函数的闭包使得具备静态词法作用域，但this的存在又允许动态地打开作用域，兼有动态作用域的效果，很灵活很强大。","modified":"20180401121530000","tags":"think"},
{"created":"20170822121530000","title":"【翻译】select的历史和epoll的不足","text":"\n!! 5种IO模型\n\n# 阻塞IO\n# 非阻塞IO\n# 多路复用\n# 信号驱动\n# 异步IO\n\n阻塞IO不提，非阻塞IO只是减少了从请求发出到真正开始读的时间，但把数据从内核读到应用层，仍然会阻塞进程，只有异步IO才是完完全全的，从请求发出到得到数据的过程，应用侧完全感知不到，最典型的就是windows的IOCP了。据说Java的模型只用到了多路复用模型，IOCP无用武之地，所以为了跨平台考虑，还是Linux的epoll更好，如果到windows平台只能降级到select模型。但是不明白.Net怎么在Linux下实现异步IO模型？\n\n要谈多路复用，就要对Unix进行一次考古。\n\n诞生于1960年代中期的分时复用理念，相对于当时的批处理模式(batch-processing)，可谓是巨大的革新。而Unix是1970年才有的，因此它也要面对并试图解决批处理模式的问题。\n此时Unix面临的阻塞有3种，CPU、磁盘IO、用户输入。\n\n接着谈谈pipe，此时并没有通用的进程间消息机制，也没有semaphore，pipe足以解决当时的问题。因为在3BSD的时候，每个进行只允许最多20个FD，每个用户最多只有20个进程，这种限定下确实不需要IPC和IO复用。同时正是这个限制，也导致了为什么select的接口参数`fd_set`会设计成一个长数组(在当时却并不长)。\n\n!! TCP/IP诞生\n\n1983年诞生的4.2BSD引入了早期版本的TCP/IP协议栈和BSD socket API，虽然在今天看来似乎是理所当然的，其实当时还有一套System V Revision 3的STREAMS接口作为竞争者(现在已经没有人用了)。BSD socket API同时带来了select。\n\n同样的1983年，Rob Pike为Unix 8th Edition开发了Blit，一个图形化的终端。由于当时的BSD并没有类似System V的IPC机制，要实现Blit需要select来实现console的多路复用。\n此处作者向Kirk McKusick求证了select的历史，非阻塞IO和select是同一时间出现的，但非阻塞并不好用，因此select成了最自然的选择。\n\n早期的Unix没有select，是因为当时只能做文件操作，而网络的出现也必然导致select的诞生。\n\n有4种避免阻塞的方式\n\n# 非阻塞IO模式\n# 使用signal，即SIGIO，Linux上用`fcntl(F_SETSIG)`\n# 由系统提供接口，告知哪个FD可读写，select/epoll\n# 进程告诉系统，对哪些FD感兴趣，并注册回调，kqueue/IOCP\n\n三大平台IO复用的时间，依次是windows在1994年加入了IOCP，FreeBSD在2000年6月引入kqueue，Linux最晚，2002年引入epoll。\n\nBryan Cantrill(Joyent)曾猛烈地抨击epoll，提到两个缺陷，在Solaris系统的/dev/poll模型下存在惊群问题，而epoll的语义和/dev/poll很接近，因此也同样存在惊群问题。但是IOCP和kqueue的接口语义和epoll很不一样，似乎这样不容易引起惊群问题。\n另一个问题则是epoll在应用层的语义是整形的fd，但内部实现却是内核对象，两者不一致导致在一些边缘场景下会出现奇怪的问题。\n\n惊群问题直到内核4.5版本，epoll加入了EPOLLEXCLUSIVE才得以解决，这就限制了epoll在多线程环境的运用。其实如果一开始就设计得好，是不会出现上述两个问题的。这也是要批评epoll的原因。\n\n先说惊群的问题，多线程使用epoll的典型场景是HTTP 1.0的短连接模型，很自然的会希望利用多CPU来均衡负载，但却做不到。\n\n!! 电平触发 - 不必要的唤醒\n\n这种模式epoll和select的语义都会引发惊群问题\n\n# 内核收到新的连接\n# 唤醒线程A和B\n# 线程A和B都结束`epoll_wait`\n# 线程A能成功的accept，但B会EAGAIN失败(或者反过来，总之只有一个成功)\n\n!! 边沿触发 - 不必要的唤醒且饿死\n\n第一种没看懂\n\n第二种，达不到负载均衡效果\n\n# 内核收到两个连接，同时有两个线程A和B，由于是边沿触发，只有一个线程被唤醒，假定A\n# 线程A结束`epoll_wait`且accept成功\n# 内核收到第三个连接，但是socket状态从readable到readable，因为是边沿触发，所以内核不会发起调度！\n# 线程A必须accept，期望EAGAIN，但是又得到一个socket\n# 内核收到第四个连接，线程A必须accept，期望EAGAIN，但又得到一个socket\n\n以上过程中socket只发生了一次从non-readable到readable的切换，因此内核只唤醒一次，导致永远在线程A。\n\n正确的解决办法\n\n有两种，最好的方式是用电平触发并加上EPOLLEXCLUSIVE标志(必须4.5内核后)，或者用边沿模式配合EPOLLONESHOT\n\n# 内核收到两个连接，线程A和B在等待，由于边沿模式只触发一次，假定线程A被唤醒\n# 结束`epoll_wait`并调用accept，成功\n# 线程A执行`epoll_ctl(EPOLL_CTL_MOD)`，由于会重置EPOLLONESHOT标志，得以re-arm这个socket\n\n结论就是你必须理解EPOLLONESHOT和EPOLLEXCLUSIVE(还得内核足够新)。\n\n说下kqueue的接口语义和epoll的差异：\n\nepoll和kqueue都会创建一个监听句柄，但是epoll是直接把多个FD放入这个epoll句柄中，但是kqueue却多引入了一个kevent结构，FD通过kevent接口(是的，同名的)和kevent实例以及读写、添加删除等动作先关联，再将这样的一个或多个kevent放入kqueue中。FD和监听句柄中隔了一层。","modified":"20170822121530000","tags":"net"},
{"created":"20180618121530000","title":"【译】Eiffel之路","text":"\n这是一篇开放式地讨论SP和OO的文章(a free ranging discussion, the reader should view it as a promenade on the border road between SP and OO)。\n\n作者赞成Bottom up甚于Top down设计。不该忘记程序构造的基石，对变化的适应，对复用的追求。(The main flaw of Top down,however,is that they neglect fundamental aspects of software: the need for change, and the need for reuse )。自顶向下设计得到的是对应需求的产品，而这些无法适应未来。类似的观点在On lisp的开篇也做了浓墨重彩的描述。重点是向上。与其实现一个最好的解决办法，不如实现一个好的，但适应未来的物件。\n\nThe particular choice of  set facilities and of their sequencing is the least committing decision of system design; because it is bound to be the first to change, it should be made last. 反映在Eiffel上就是缺少main程序概念，只是一堆class的组合，其中一个被指定为root或执行的种子。变更root则是最简单的事。\n\nnot to find fault with their authors, this excise is as easy as it is vain. This discussion aims to generate light than heat.\n\n!! OO的原则和技巧\n\n显式重定义类\n\n作者认为这是OO之所以优雅的关键。a key factor behind the elegance of OO.\n\n多态是种开放的机制，相比起Pascal/Ada用record来固化选择which freezes the list of choices.我倒觉得两者适用场景不同，无高下之分。\n\n静态类型和动态绑定相结合，静态绑定保证了至少有一种选择，而动态绑定则在有多种选择时，有机会选择最好的。\n\n重命名机制使得多继承的接口冲突得到了解决。\n\nGeneralization，尚不清楚是个什么样的方式，但对于以行来计价的程序而言，泛化的价值并不大，只有长期维护的软件才值得这么做。\n\nlifecycle，定义cluster model，对应的就是一个目录。把整个系统级的度量，缩小到目录级别，因而更具伸缩性。由于cluster粒度更小，呼应了前文的对变化的适应和对复用的追求。\n\n管理者不要人为地在设计和实现中设置屏障，他应该对最关键的部分负责。","modified":"20180618121530000","tags":"think"},
{"created":"20140225121530000","title":"【译】Scheme的面向对象呈现（部分）","text":"\n!! 关于Scheme的OO呈现。\n\n话题因为读者疑议而起，川合先亮出自己的观点，Scheme的OO呈现和别的语言并无太多不同，只是因为规范里没有定义，导致了多种不同的实现。如果采用CLOS的风格（他自己的Gauche就是），形式上就是（动词 名词）。这和很多OO语言采用名词.动词在语法顺序上是反的。但这不是更自然吗？川合先是吐槽，很多人认为名词 动词的方式更合理，只是他们早就习惯了这种方式，并没有真正去思考为什么。\n\n!! 抽象的角度\n\n程序常说要抽象，是以对象还是函数来抽象？川合觉得如果以函数为抽象，将函数互相传递可以带来更丰富的表现力。\n\n以树的遍历为例子，如果是面向类的话，需要事先定义tree, leaf, node这些类。\n\n如果是函数导向，则将对树操作的函数是这个样子：\n\n```\n(define (tree-walk tree proc leaf? walker)\n    (define (rec node)\n      (walker (lambda (n) (if (leaf? n) (proc n) (rec n))) node))\n    (if (leaf? tree) (proc tree) (rec tree)))\n```\n\nleaf?取树的节点，返回是不是叶子，walker是取得树节点的函数，对node所有子节点进行高阶函数调用的方法。如果树是用列表来表现，leaf?就是(lambda (x) (not (pair? x)))，walker就是for-each。树如果具现化为文件系统，leaf?就替换为file-is-directory?，walker就是(lambda (proc x) (for-each proc (list-directory x)))\n\n类指向的好处是，看到数据定义，可以知道要如何操作，但操作就必须要从具体的类或树开始继承（如果支持接口继承，会好一点）\n\n函数指向的好处是，在呈现概念时比较纯粹，对树可能的操作并不作限制，如果要让tree-walk运行起来，只要传入适当的leaf?和walker函数就可以。但是也存在可能需要传入的函数不止2、3个，可能会是5个甚至10个，如果看这10个函数，就很难发现tree-walk的本来用意了。\n\n!! 实例解读\n\n看了翻译的文章，看个实际的Gauche-Scheme对象系统，它上承STklos，是从最早的TinyCLOS继承下来的概念，有三个最重要的概念\n\n* Class\n* Generic Function\n* Method\n\nCLOS系统中，Method并不属于特定的Class。通过define-method宏定义出来的变量，\n是Generic Function的实例。\n\nGauche的write/display函数，面对一个复杂对象，会调用和这个对象有关的\nwrite-object函数，通过它来呈现。类似Lua的`__tostring`或JavaScript的toString方法。","modified":"20140225121530000","tags":"lang"},
{"created":"20181021121530000","title":"【转】对PHP的分析","text":"\n我不考虑可以用封装库解决的问题，比如不考虑 JSON api，in_array 默认 == 等等\n我不考虑各种 VM 实现的问题，比如 C 扩展常驻内存\n\n我不考虑 PHP 文档的问题，不考虑 PHP 历史上的问题，比如 5.3 中不能 parse $cb()()\n我不考虑 parser 的报错信息难读问题\n\n文章内容目录：\n\n* FP：set! 和 defun 是不一样的，但是 PHP 连 set! 都不如\n* MP: MP 不是 toString 或者 any -> String， 而是 Expr -> Expr 和 Expr -> Q\n* OO: The big idea is messaging.\n\neechen 说我们可以使用 $func来在 PHP 中实现 FP，但是这是不可行的。让我们考虑最简单的 fib\n```\n$fib = function ($x) use ($fib) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($fib, [$x-1]);\n};\nvar_dump($fibs(10));\n或者\n\n$fib = function ($x) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($fib, [$x-1]);\n};\nvar_dump($fibs(10));\n```\n二者皆会报错，第一个说找不到 $fib，第二个说 $fib 是没有定义的 NULL。\n\n继而我们猜测这只是 PHP 解释器的一个小 bug，我们只需要把 closure 的位置在 AST 往下压一层之后 use 就能找到了，比如\n```\nfunction id($x) {return $x;)\n$fib = id(function ($x) use ($fib) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($fib, [$x-1]);\n});\nvar_dump($fibs(10));\n```\n依然是找不到 $fib。\n\n\n可能这时候我们只是认为 use 之前需要声明，只是一个 php 解释器上实现的一个小 bug，比如\n```\n$fib = NULL;\n$fib = function ($x) use ($fib) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($fib, [$x-1]);\n};\nvar_dump($fibs(10));\n```\n结果是 $fib 在 closure 中对应的值 NULL，无法被访问。\n\n这就是我们说 PHP 既不支持函数作为第一成员又没有 scope 的原因。scope 是作用域内 symbol 和 value 的绑定。PHP 并不存在一个正常的讲上层 scope 的某个 symbol 映射放到 closure 中的方法，PHP 的所谓的 use 只是即时地在 closure 中插入一个 $fib = NULL ，而并非是将对 $fib 的访问转移到上层 scope 的访问中。\n\n简单来讲，**PHP 所谓的 scope 不是 scope，而只是一个解释求值的 barrier，你不可能访问上层 scope 的 symbol。而 php 的 closure 也不是 closure，php 的 closure 只能绑定 value 而不能绑定 symbol。**\n\n如果说要强行 $func 来实现自指递归或者互指递归也不是不可以，那么你需要这么写\n```\n$scope = [];\n$scope['fib'] = function ($x) use ($scope) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($scope['fib'], [$x-1]);\n};\n$fib = $scope['fib'];\n\n或者更加规范的，默认使用的 scope 入口和 defun\n\nfunction createDefun($scope) {\n   return function($fname, $definition) use ($scope) {\n       $scope[$fname] = function () use ($scope, $fname, $definition) {\n          $args = func_get_args();\n          $scope[$fname] = call_user_func_array($definition, array_merge([$scope], $args));\n       };\n   };\n};\n\n$sp = [];\n$defun = createDefun($sp);\n$defun('fib', function($scope, $x) {\n  if ($x == 0) {\n    return 1;\n  }\n  return $x* call_user_func_array($scope['fib'], [$x-1]);\n});\n$fib = $sp['fib'];\n```\n我只是觉得，「一个语言支持 FP 范式」和「一个语言需要自行实现 scope 然后就可以通过手动注入 scope 然后就可以 FP 了」应该是完全不同的两个意思吧？\n\n这也是我们说 「PHP 不是一门支持 FP 的语言」时和说「JS，Py 等等可以写 FP，但是毕竟不是一门 FP 语言」的不同。如果我们有其他语言的经验，（无论这语言是 Py2/Py3，JS，Perl5，还是利用 operation() 当作 function 的旧 CPP，甚至是他喵的 MatLab），我们可以看到他们访问上层 scope 中的 symbol 是自然而然的；而 PHP 我们要么自己实现一个 scope 和 defun，要么就是使用 array(__NAMESPACE__ . '\\' . $className, $funcName) 和 static 这种并非设计为 FP 的 ugly hack。所以我们可以安全地宣称，PHP 是不支持 FP 的。\n\nPS：在本节末尾指出来一下， eechen 原文误以为「PHP 变量可以绑定类」，实际上 PHP 变量只能被赋值为类的实例而不能绑定类。这种不能绑定类特性的缺乏导致了没法实现 immutable-js BaseRecord = Record({...}) 之类的基于函数的类派生，也对实现利用 cache 来加速 immutable 变量的生成增添了很多不必要的 boilerplate code\n\nMP: MP 不是 toString 或者 any -> String， 而是 Expr -> Expr 和 Expr -> Q\n\n一个语言是否具有 MP 的能力并不是其是否有一个叫做 XXXRefection 的方法，实际上 PHP 的 reflection 只是一系列拿到源码的 toString；这类方法在其他语言中也是常见，比如 ES3 时代就有了 Function.prototype.toString这样的方法\n```\nfunction hasContent() {/*\n    Line 1\n    Line 2\n    Line 3\n  */}\nvar content = hasContent.toString.split('\\n').slice(1, -1).join('\\n')\n```\n如果我说 ES3 时代就实现了 MP，我觉得我会被 JSer 打死。甚至 ES5 时代 styled-component 通过了 Tagged templates 实现了 JS 中解析运行 CSS，JSers 也没有吹什么 「JS 是一个支持了 MP」的语言（虽然我明年准备看看能不能借用 tagged template 可以访问 js obj 的特性来实现一些简单的可访问 JS 变量的 DSL，当然这只能说能有一点 MP 技巧；和真正利用 MP 做 code gen 离得很远）\n\n\nMP 是利用已知代码进行 code generaation 的手段。比如 Julia 如果不想多次写 dimension 可以（免责声明：自转行后大概有一年没写 Julia 了，所以下面可能会有简单的语法错误或者漏写 global 或者 quote）\n\nconst c = @cmm( squeeze(sum(mean(a,3),2))) ## cmm stands for common math macros\n\n扩展成如下代码以避免写两次 dimension\n\nconst c = squeeze(sum(mean(a,3),2)), (2,3))\n\n同样我们可以轻松地在处理 NaN 的时候利用 macro 来做替换\n\nconst c = @cmm( periodic(mean(x,2, isNaN=false)))\n\n替换成这样的形式，也就是我们在没有提供 isNaN 接口的时候，一定程度上可以类似用写 R 的方式处理数据\n\nconst c =  periodic(nonNaNMean(x,2))\n\n甚至可以模拟一下 typeclass，下面是利用 MP 将 svd, eof, 等等方法从 Array{Float, 2} 扩展到 Array{Float64, n} 的一种 macro 示例\n\n```\nconst (eofs, pcs) = fuck2D(\n  quote\n    global SST // SST is a 3D array of lat * lon * time\n    describe(SST, 3) // 3 is the timal dimension;\n    return svd(SST)\n  end\n)\n这将扩展成现将 SST 转成 2D array， 然后将 分析后的 1D array 转回 2D 的方法\n\nconst (eofs, pcs) = do\n   global SST\n   SST_config_#1 = create_Dconfig({timal_dims: 3})\n   (SST2D_#1, from_1D_to_sp, from_1D_to_timal) = decompose(SST, SST_config_#1);\n   (eofs1D_#1,pc1D_#1) = svd(SST2D_#1)\n   eofs_#1 = intercept_1D(eofs1D_#1, from_1D_to_sp)\n   pcs_#1  = intercept_1D(pcs1D_#1, from_1D_to_timal)\n   return (eofs_#1, pcs_#1)\nend\n```\n\n这类宏生成代码节省了大量手动写 adapter 的时间，实现了类似 type class 的效果。另外一类常用的 MP 做法是将任何一个需要埋点的函数\n```\nfunction func(a,b,c) {\n     return func(a', b', c')\n}\n这类代码转换成类似\n\nfunction func_effect(f, a, b, c) {\n      call_effect(f, a', b', c')\n}\n```\n这样我们可以在 call_effect 中使用统一的 effect 处理和上下文传递等等。\n\n首先PHPer 看不懂 MP 但是又说 PHP 支持 MP 难道是我的错么？\n这里只是展现一下为什么 MP 的实践需要 AST；在这类需求中，文本替换然后 eval 显然是不安全而且不够灵活的。不在 AST 上 walk 一下还能怎么办呢，难道拿头锤 regex 做替换？\n\n一个 PHPer 可能会争论说其实这类 MP 实践在 PHP 中是可以做到的；然后他可能会举出类似于 Roave/BetterReflection这样的库；显然，在看过这种库之后，即使不懂 MP 也能发现很明显的风险：\n\n其 parser 库并非是 php 解释器自己的 parser，而是另一种 PHP 实现的 https://github.com/nikic/PHP-Parser ；也就是任何 PHP-Parser 和 php 解释器 parser 的不一致都会影响到结果 （而且难以 debug）\nPHP 并没有 eval(Expr) 的手段，对于变换后的 AST，需要使用 PHP-Parser 来 write string，然后执行转写的 string。这不仅仅依赖于 PHP-parser 的正确性，而且任何 php 的报错都会在 eval 这一行，eval（string） 永远是危险的呀\n\n而且不可避免的，这样的 parser 实践还会导致所有含有副作用的语言中 MP 共同要面对的问题：副作用跟踪。考虑到我们在某个文件中元编程两次\n\neval(AST2String(expr1))\n\neval(AST2String(expr2))\n\n如果在 expr1 中含有了\n\nfunction foo {...}\nbar_effect = ...；\n然后 expr2 含有了\n\nfunction foo {...}\nbar_effect = ...;\n然后 expr1 的部分结果就有被 expr2 覆盖的风险。\n\n在 Julia 中，macroexpand 直接会分析上下文并且在变量后面加上 `_#number` 这样的后缀防止覆写变量；而且很多 lisp 系语言中，eval 本身是 lexical scope 下在一个新的 scope 进行的。\n\nOOP：三原则或者四圣谛只是 90 年代类似 Java 语言对于 OOP 的一种实现手段而已\n\n本来我以为我这里不需要解释一下 extends 的问题，可以直接讨论层次复杂度和静态检查的关系。我发现我还是必须引用一下 Alan Kay 的名言 [The big idea is \"messaging\"](http://wiki.c2.com/?AlanKayOnMessaging)\n\n只要我们能够实现层次划分和父子 components 之间的 messaging 传递，那么 OOP 所需要的 divide and conquer 是自然而然的，而且会便利实现 testable module （类似于为了测试方便， database 仅仅被实现为获得值和更新值的一种特例，而非必要的 backend）。\n\n而旧时代的 java 以及其所代码的三原则，实际上很容易出现两个很讨厌的事情，一者是子类对父类的副作用污染，另外一种是只要一个香蕉但是拿到了香蕉加猴子加森林。\n\n当然 data class 和 sub typing 本身就是很讨厌的强行 binding 数据和方法的手段，但是如果不得不这么做了，实际上我们更常委托的方式而非 extends 的方式处理父类和子类的关系。当然，把大部分所需要的方法重新写一遍是很讨厌的 repeat yourself 行为。所以对于动态语言，我们常常依赖约定自动推导 b -> f a -> f b 或者 (a-> b) -> f a -> f b 来压缩类的层次。Java 等等静态语言虽然不能使用这种方法，但是静态分析可以保证在使用工厂或者其他委托方法时候代码的正确性。\n\n然后 PHP 学 Java 了，但是问题是 PHP 能够用静态分析保证委托足够复杂时的正确性，PHP 行么？没有静态分析学 java 就像猪学鸟跳出飞机一样。\n\n尾声\n\n如果你不会 FP，不懂 FP，也没写过 FP，那么就不要说别人「无脑黑 PHP 不支持 FP」\n如果你不会 MP，不懂 MP，也没写过 MP，那么就不要说别人「无脑黑 PHP 不支持 MP」\n如果你对 OO 的理解只停留在三原则上....算了，对于这种 ill-defined 的东西你开心就好\n如果你只会 PHP，或者只会用 PHP 的方式写很多副作用满天飞的语言... 就不要讲什么「好的程序只和程序员有关，和程序语言无关」；这类编程经验不能教人「什么是好的程序」\n\n其实说句实话，作者还真不是了解 php，起码一些基础不行，简单的问题复杂化了，或者是 JavaScript 给你了一些固定的思维方式。明显就是作用域问题，至于为什么 use 继承不了，考虑考虑操作符优先级。\n\n```\n$fib = function ($x) { \n  global $fib;\n if ($x == 0) { return 1; }\n return $x * $fib($x-1);\n};\n```\nvar_dump($fib(10))","modified":"20181021121530000","tags":"web"},
{"created":"20231021162551433","text":"hide","title":"$:/config/PageControlButtons/Visibility/$:/core/ui/Buttons/import","modified":"20231021162552081"},
{"created":"20231026060117172","text":"yes","title":"$:/config/RelinkOnRename","modified":"20231026060117172"},
{"title":"$:/config/SaveWikiButton/Template","text":"$:/core/save/offline-external-js"},
{"created":"20231021152215403","text":"show","title":"$:/config/ViewToolbarButtons/Visibility/$:/core/ui/Buttons/info","modified":"20231021152215403"},
{"created":"20231021152107459","text":"","title":"$:/config/ViewToolbarButtons/Visibility/Recipe","modified":"20231021152153762"},
{"created":"20231026135452984","text":"\u003C$macrocall $name=\"timeline\" limit=20 format={{$:/language/RecentChanges/DateFormat}}/>\n","title":"$:/core/ui/SideBar/Recent","tags":"$:/tags/SideBar","caption":"{{$:/language/SideBar/Recent/Caption}}","modified":"20231026135507269"},
{"created":"20231028055804691","title":"$:/DefaultTiddlers","text":"目录\n","modified":"20231028055805452"},
{"title":"$:/Import","text":"下列条目已被导入：\n\n# [[MyStyle]]","status":"complete"},
{"title":"$:/isEncrypted","text":"no"},
{"created":"20231017154614452","title":"$:/language","text":"$:/languages/zh-Hans","modified":"20231017154614452"},
{"title":"$:/languages/zh-CN","name":"zh-CN","plugin-type":"language","description":"Chinese (China)","author":"BramChen","core-version":">=5.0.8","dependents":"$:/languages/zh-Hans","plugin-priority":"110","version":"5.3.1","type":"application/json","text":"{\"tiddlers\":{\"$:/languages/zh-CN/icon\":{\"title\":\"$:/languages/zh-CN/icon\",\"type\":\"image/svg+xml\",\"text\":\"\u003C?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\u003C!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\u003Csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"1500\\\" height=\\\"1000\\\" viewBox=\\\"-5 -5 30 20\\\">\\n\u003Ctitle>Flag of the People's Republic of China\u003C/title>\\n\u003Crect fill=\\\"#de2910\\\" x=\\\"-5\\\" y=\\\"-5\\\" width=\\\"30\\\" height=\\\"20\\\"/>\\n\u003Cdefs>\\n\u003Cpolygon id=\\\"s\\\" points=\\\"0,-513674 301930,415571 -488533,-158734 488533,-158734 -301930,415571\\\"\\nfill=\\\"#ffde00\\\" transform=\\\"scale(0.0000019467600073)\\\"/>\\n\u003C/defs>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"scale(3)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(5,-3) rotate(-120.963756)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(7,-1) rotate(-98.130102)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(7,2) rotate(-74.054604)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(5,4) rotate(-51.3401917)\\\"/>\\n\u003C/svg>\\n\"}}}"},
{"title":"$:/languages/zh-Hans","name":"zh-Hans","plugin-type":"language","description":"Chinese (Simplified)","author":"BramChen","core-version":">=5.0.8","plugin-priority":"100","version":"5.3.1","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/language/Buttons/AdvancedSearch/Caption\":{\"title\":\"$:/language/Buttons/AdvancedSearch/Caption\",\"text\":\"高级搜索\"},\"$:/language/Buttons/AdvancedSearch/Hint\":{\"title\":\"$:/language/Buttons/AdvancedSearch/Hint\",\"text\":\"高级搜索\"},\"$:/language/Buttons/Cancel/Caption\":{\"title\":\"$:/language/Buttons/Cancel/Caption\",\"text\":\"取消\"},\"$:/language/Buttons/Cancel/Hint\":{\"title\":\"$:/language/Buttons/Cancel/Hint\",\"text\":\"取消对此条目的修改\"},\"$:/language/Buttons/Clone/Caption\":{\"title\":\"$:/language/Buttons/Clone/Caption\",\"text\":\"复制\"},\"$:/language/Buttons/Clone/Hint\":{\"title\":\"$:/language/Buttons/Clone/Hint\",\"text\":\"复制此条目\"},\"$:/language/Buttons/Close/Caption\":{\"title\":\"$:/language/Buttons/Close/Caption\",\"text\":\"关闭\"},\"$:/language/Buttons/Close/Hint\":{\"title\":\"$:/language/Buttons/Close/Hint\",\"text\":\"关闭此条目\"},\"$:/language/Buttons/CloseAll/Caption\":{\"title\":\"$:/language/Buttons/CloseAll/Caption\",\"text\":\"全部关闭\"},\"$:/language/Buttons/CloseAll/Hint\":{\"title\":\"$:/language/Buttons/CloseAll/Hint\",\"text\":\"关闭所有条目\"},\"$:/language/Buttons/CloseOthers/Caption\":{\"title\":\"$:/language/Buttons/CloseOthers/Caption\",\"text\":\"关闭其他\"},\"$:/language/Buttons/CloseOthers/Hint\":{\"title\":\"$:/language/Buttons/CloseOthers/Hint\",\"text\":\"关闭其他条目\"},\"$:/language/Buttons/ControlPanel/Caption\":{\"title\":\"$:/language/Buttons/ControlPanel/Caption\",\"text\":\"控制台\"},\"$:/language/Buttons/ControlPanel/Hint\":{\"title\":\"$:/language/Buttons/ControlPanel/Hint\",\"text\":\"开启控制台\"},\"$:/language/Buttons/CopyToClipboard/Caption\":{\"title\":\"$:/language/Buttons/CopyToClipboard/Caption\",\"text\":\"复制到剪贴板\"},\"$:/language/Buttons/CopyToClipboard/Hint\":{\"title\":\"$:/language/Buttons/CopyToClipboard/Hint\",\"text\":\"将此文本复制到剪贴板\"},\"$:/language/Buttons/Delete/Caption\":{\"title\":\"$:/language/Buttons/Delete/Caption\",\"text\":\"删除\"},\"$:/language/Buttons/Delete/Hint\":{\"title\":\"$:/language/Buttons/Delete/Hint\",\"text\":\"删除此条目\"},\"$:/language/Buttons/DeleteTiddlers/Caption\":{\"title\":\"$:/language/Buttons/DeleteTiddlers/Caption\",\"text\":\"删除条目\"},\"$:/language/Buttons/DeleteTiddlers/Hint\":{\"title\":\"$:/language/Buttons/DeleteTiddlers/Hint\",\"text\":\"删除条目\"},\"$:/language/Buttons/Edit/Caption\":{\"title\":\"$:/language/Buttons/Edit/Caption\",\"text\":\"编辑\"},\"$:/language/Buttons/Edit/Hint\":{\"title\":\"$:/language/Buttons/Edit/Hint\",\"text\":\"编辑此条目\"},\"$:/language/Buttons/Encryption/Caption\":{\"title\":\"$:/language/Buttons/Encryption/Caption\",\"text\":\"加密\"},\"$:/language/Buttons/Encryption/Hint\":{\"title\":\"$:/language/Buttons/Encryption/Hint\",\"text\":\"设置或清除保存此维基的密码\"},\"$:/language/Buttons/Encryption/ClearPassword/Caption\":{\"title\":\"$:/language/Buttons/Encryption/ClearPassword/Caption\",\"text\":\"清除密码\"},\"$:/language/Buttons/Encryption/ClearPassword/Hint\":{\"title\":\"$:/language/Buttons/Encryption/ClearPassword/Hint\",\"text\":\"清除密码且不加密保存此维基\"},\"$:/language/Buttons/Encryption/SetPassword/Caption\":{\"title\":\"$:/language/Buttons/Encryption/SetPassword/Caption\",\"text\":\"设置密码\"},\"$:/language/Buttons/Encryption/SetPassword/Hint\":{\"title\":\"$:/language/Buttons/Encryption/SetPassword/Hint\",\"text\":\"设置加密保存此维基的密码\"},\"$:/language/Buttons/ExportPage/Caption\":{\"title\":\"$:/language/Buttons/ExportPage/Caption\",\"text\":\"导出所有条目\"},\"$:/language/Buttons/ExportPage/Hint\":{\"title\":\"$:/language/Buttons/ExportPage/Hint\",\"text\":\"导出所有条目\"},\"$:/language/Buttons/ExportTiddler/Caption\":{\"title\":\"$:/language/Buttons/ExportTiddler/Caption\",\"text\":\"导出此条目\"},\"$:/language/Buttons/ExportTiddler/Hint\":{\"title\":\"$:/language/Buttons/ExportTiddler/Hint\",\"text\":\"导出此条目\"},\"$:/language/Buttons/ExportTiddlers/Caption\":{\"title\":\"$:/language/Buttons/ExportTiddlers/Caption\",\"text\":\"导出条目\"},\"$:/language/Buttons/ExportTiddlers/Hint\":{\"title\":\"$:/language/Buttons/ExportTiddlers/Hint\",\"text\":\"导出条目\"},\"$:/language/Buttons/SidebarSearch/Hint\":{\"title\":\"$:/language/Buttons/SidebarSearch/Hint\",\"text\":\"选择侧边栏的搜索字段\"},\"$:/language/Buttons/Fold/Caption\":{\"title\":\"$:/language/Buttons/Fold/Caption\",\"text\":\"折叠条目\"},\"$:/language/Buttons/Fold/Hint\":{\"title\":\"$:/language/Buttons/Fold/Hint\",\"text\":\"折叠此条目的内容\"},\"$:/language/Buttons/Unfold/Caption\":{\"title\":\"$:/language/Buttons/Unfold/Caption\",\"text\":\"展开条目\"},\"$:/language/Buttons/Unfold/Hint\":{\"title\":\"$:/language/Buttons/Unfold/Hint\",\"text\":\"展开此条目的内容\"},\"$:/language/Buttons/FoldOthers/Caption\":{\"title\":\"$:/language/Buttons/FoldOthers/Caption\",\"text\":\"折叠其他条目\"},\"$:/language/Buttons/FoldOthers/Hint\":{\"title\":\"$:/language/Buttons/FoldOthers/Hint\",\"text\":\"折叠其他已开启条目的内容\"},\"$:/language/Buttons/FoldAll/Caption\":{\"title\":\"$:/language/Buttons/FoldAll/Caption\",\"text\":\"折叠所有条目\"},\"$:/language/Buttons/FoldAll/Hint\":{\"title\":\"$:/language/Buttons/FoldAll/Hint\",\"text\":\"折叠所有已开启条目的内容\"},\"$:/language/Buttons/Fold/FoldBar/Caption\":{\"title\":\"$:/language/Buttons/Fold/FoldBar/Caption\",\"text\":\"折叠栏\"},\"$:/language/Buttons/Fold/FoldBar/Hint\":{\"title\":\"$:/language/Buttons/Fold/FoldBar/Hint\",\"text\":\"可选的折叠与展开条目的长条按钮\"},\"$:/language/Buttons/UnfoldAll/Caption\":{\"title\":\"$:/language/Buttons/UnfoldAll/Caption\",\"text\":\"展开所有条目\"},\"$:/language/Buttons/UnfoldAll/Hint\":{\"title\":\"$:/language/Buttons/UnfoldAll/Hint\",\"text\":\"展开所有已开启条目的内容\"},\"$:/language/Buttons/FullScreen/Caption\":{\"title\":\"$:/language/Buttons/FullScreen/Caption\",\"text\":\"全屏\"},\"$:/language/Buttons/FullScreen/Hint\":{\"title\":\"$:/language/Buttons/FullScreen/Hint\",\"text\":\"进入或退出全屏模式\"},\"$:/language/Buttons/Help/Caption\":{\"title\":\"$:/language/Buttons/Help/Caption\",\"text\":\"帮助\"},\"$:/language/Buttons/Help/Hint\":{\"title\":\"$:/language/Buttons/Help/Hint\",\"text\":\"显示帮助面板\"},\"$:/language/Buttons/Home/Caption\":{\"title\":\"$:/language/Buttons/Home/Caption\",\"text\":\"首页\"},\"$:/language/Buttons/Home/Hint\":{\"title\":\"$:/language/Buttons/Home/Hint\",\"text\":\"开启首页条目\"},\"$:/language/Buttons/Import/Caption\":{\"title\":\"$:/language/Buttons/Import/Caption\",\"text\":\"导入\"},\"$:/language/Buttons/Import/Hint\":{\"title\":\"$:/language/Buttons/Import/Hint\",\"text\":\"导入许多类型的文件包括文本、图像、~TiddlyWiki 或 JSON\"},\"$:/language/Buttons/Info/Caption\":{\"title\":\"$:/language/Buttons/Info/Caption\",\"text\":\"信息\"},\"$:/language/Buttons/Info/Hint\":{\"title\":\"$:/language/Buttons/Info/Hint\",\"text\":\"显示此条目的信息\"},\"$:/language/Buttons/Language/Caption\":{\"title\":\"$:/language/Buttons/Language/Caption\",\"text\":\"语言\"},\"$:/language/Buttons/Language/Hint\":{\"title\":\"$:/language/Buttons/Language/Hint\",\"text\":\"选择用户界面语言\"},\"$:/language/Buttons/LayoutSwitcher/Hint\":{\"title\":\"$:/language/Buttons/LayoutSwitcher/Hint\",\"text\":\"开启布局切换器\"},\"$:/language/Buttons/LayoutSwitcher/Caption\":{\"title\":\"$:/language/Buttons/LayoutSwitcher/Caption\",\"text\":\"布局\"},\"$:/language/Buttons/Manager/Caption\":{\"title\":\"$:/language/Buttons/Manager/Caption\",\"text\":\"条目管理器\"},\"$:/language/Buttons/Manager/Hint\":{\"title\":\"$:/language/Buttons/Manager/Hint\",\"text\":\"开启条目管理器\"},\"$:/language/Buttons/More/Caption\":{\"title\":\"$:/language/Buttons/More/Caption\",\"text\":\"更多\"},\"$:/language/Buttons/More/Hint\":{\"title\":\"$:/language/Buttons/More/Hint\",\"text\":\"更多操作\"},\"$:/language/Buttons/NewHere/Caption\":{\"title\":\"$:/language/Buttons/NewHere/Caption\",\"text\":\"添加子条目\"},\"$:/language/Buttons/NewHere/Hint\":{\"title\":\"$:/language/Buttons/NewHere/Hint\",\"text\":\"创建一个标签为此条目名称的新条目\"},\"$:/language/Buttons/NetworkActivity/Caption\":{\"title\":\"$:/language/Buttons/NetworkActivity/Caption\",\"text\":\"网络活动\"},\"$:/language/Buttons/NetworkActivity/Hint\":{\"title\":\"$:/language/Buttons/NetworkActivity/Hint\",\"text\":\"取消所有网络活动\"},\"$:/language/Buttons/NewJournal/Caption\":{\"title\":\"$:/language/Buttons/NewJournal/Caption\",\"text\":\"添加日志\"},\"$:/language/Buttons/NewJournal/Hint\":{\"title\":\"$:/language/Buttons/NewJournal/Hint\",\"text\":\"创建一个新的日志条目\"},\"$:/language/Buttons/NewJournalHere/Caption\":{\"title\":\"$:/language/Buttons/NewJournalHere/Caption\",\"text\":\"添加子日志\"},\"$:/language/Buttons/NewJournalHere/Hint\":{\"title\":\"$:/language/Buttons/NewJournalHere/Hint\",\"text\":\"创建一个标签含此条目名称的新日志条目\"},\"$:/language/Buttons/NewImage/Caption\":{\"title\":\"$:/language/Buttons/NewImage/Caption\",\"text\":\"添加图像\"},\"$:/language/Buttons/NewImage/Hint\":{\"title\":\"$:/language/Buttons/NewImage/Hint\",\"text\":\"创建一个新的图像条目\"},\"$:/language/Buttons/NewMarkdown/Caption\":{\"title\":\"$:/language/Buttons/NewMarkdown/Caption\",\"text\":\"添加 Markdown 条目\"},\"$:/language/Buttons/NewMarkdown/Hint\":{\"title\":\"$:/language/Buttons/NewMarkdown/Hint\",\"text\":\"创建一个新的 Markdown 条目\"},\"$:/language/Buttons/NewTiddler/Caption\":{\"title\":\"$:/language/Buttons/NewTiddler/Caption\",\"text\":\"添加条目\"},\"$:/language/Buttons/NewTiddler/Hint\":{\"title\":\"$:/language/Buttons/NewTiddler/Hint\",\"text\":\"创建一个新的条目\"},\"$:/language/Buttons/OpenWindow/Caption\":{\"title\":\"$:/language/Buttons/OpenWindow/Caption\",\"text\":\"开启于新窗口\"},\"$:/language/Buttons/OpenWindow/Hint\":{\"title\":\"$:/language/Buttons/OpenWindow/Hint\",\"text\":\"在新窗口中开启条目\"},\"$:/language/Buttons/Palette/Caption\":{\"title\":\"$:/language/Buttons/Palette/Caption\",\"text\":\"调色板\"},\"$:/language/Buttons/Palette/Hint\":{\"title\":\"$:/language/Buttons/Palette/Hint\",\"text\":\"选择调色板\"},\"$:/language/Buttons/Permalink/Caption\":{\"title\":\"$:/language/Buttons/Permalink/Caption\",\"text\":\"引用链接\"},\"$:/language/Buttons/Permalink/Hint\":{\"title\":\"$:/language/Buttons/Permalink/Hint\",\"text\":\"设置浏览器网址栏为直接链接到此条目\"},\"$:/language/Buttons/Permaview/Caption\":{\"title\":\"$:/language/Buttons/Permaview/Caption\",\"text\":\"永久链接\"},\"$:/language/Buttons/Permaview/Hint\":{\"title\":\"$:/language/Buttons/Permaview/Hint\",\"text\":\"设置浏览器网址栏为直接链接到当前所有已开启条目\"},\"$:/language/Buttons/Print/Caption\":{\"title\":\"$:/language/Buttons/Print/Caption\",\"text\":\"打印页面\"},\"$:/language/Buttons/Print/Hint\":{\"title\":\"$:/language/Buttons/Print/Hint\",\"text\":\"打印当前页面\"},\"$:/language/Buttons/Refresh/Caption\":{\"title\":\"$:/language/Buttons/Refresh/Caption\",\"text\":\"刷新\"},\"$:/language/Buttons/Refresh/Hint\":{\"title\":\"$:/language/Buttons/Refresh/Hint\",\"text\":\"执行维基的完全刷新\"},\"$:/language/Buttons/Save/Caption\":{\"title\":\"$:/language/Buttons/Save/Caption\",\"text\":\"确定\"},\"$:/language/Buttons/Save/Hint\":{\"title\":\"$:/language/Buttons/Save/Hint\",\"text\":\"确定对此条目的更改\"},\"$:/language/Buttons/SaveWiki/Caption\":{\"title\":\"$:/language/Buttons/SaveWiki/Caption\",\"text\":\"保存变更\"},\"$:/language/Buttons/SaveWiki/Hint\":{\"title\":\"$:/language/Buttons/SaveWiki/Hint\",\"text\":\"保存变更\"},\"$:/language/Buttons/StoryView/Caption\":{\"title\":\"$:/language/Buttons/StoryView/Caption\",\"text\":\"视图模式\"},\"$:/language/Buttons/StoryView/Hint\":{\"title\":\"$:/language/Buttons/StoryView/Hint\",\"text\":\"选择查看条目的视觉效果\"},\"$:/language/Buttons/HideSideBar/Caption\":{\"title\":\"$:/language/Buttons/HideSideBar/Caption\",\"text\":\"隐藏侧边栏\"},\"$:/language/Buttons/HideSideBar/Hint\":{\"title\":\"$:/language/Buttons/HideSideBar/Hint\",\"text\":\"隐藏侧边栏\"},\"$:/language/Buttons/ShowSideBar/Caption\":{\"title\":\"$:/language/Buttons/ShowSideBar/Caption\",\"text\":\"显示侧边栏\"},\"$:/language/Buttons/ShowSideBar/Hint\":{\"title\":\"$:/language/Buttons/ShowSideBar/Hint\",\"text\":\"显示侧边栏\"},\"$:/language/Buttons/TagManager/Caption\":{\"title\":\"$:/language/Buttons/TagManager/Caption\",\"text\":\"标签管理\"},\"$:/language/Buttons/TagManager/Hint\":{\"title\":\"$:/language/Buttons/TagManager/Hint\",\"text\":\"标签管理\"},\"$:/language/Buttons/Timestamp/Caption\":{\"title\":\"$:/language/Buttons/Timestamp/Caption\",\"text\":\"时间戳\"},\"$:/language/Buttons/Timestamp/Hint\":{\"title\":\"$:/language/Buttons/Timestamp/Hint\",\"text\":\"选择修改是否更新时间戳\"},\"$:/language/Buttons/Timestamp/On/Caption\":{\"title\":\"$:/language/Buttons/Timestamp/On/Caption\",\"text\":\"时间戳开启\"},\"$:/language/Buttons/Timestamp/On/Hint\":{\"title\":\"$:/language/Buttons/Timestamp/On/Hint\",\"text\":\"条目被修改时，更新时间戳\"},\"$:/language/Buttons/Timestamp/Off/Caption\":{\"title\":\"$:/language/Buttons/Timestamp/Off/Caption\",\"text\":\"时间戳关闭\"},\"$:/language/Buttons/Timestamp/Off/Hint\":{\"title\":\"$:/language/Buttons/Timestamp/Off/Hint\",\"text\":\"条目被修改时，不更新时间戳\"},\"$:/language/Buttons/Theme/Caption\":{\"title\":\"$:/language/Buttons/Theme/Caption\",\"text\":\"布局主题\"},\"$:/language/Buttons/Theme/Hint\":{\"title\":\"$:/language/Buttons/Theme/Hint\",\"text\":\"选择布局主题\"},\"$:/language/Buttons/Bold/Caption\":{\"title\":\"$:/language/Buttons/Bold/Caption\",\"text\":\"粗体\"},\"$:/language/Buttons/Bold/Hint\":{\"title\":\"$:/language/Buttons/Bold/Hint\",\"text\":\"套用粗体格式于所选文本\"},\"$:/language/Buttons/Clear/Caption\":{\"title\":\"$:/language/Buttons/Clear/Caption\",\"text\":\"清除\"},\"$:/language/Buttons/Clear/Hint\":{\"title\":\"$:/language/Buttons/Clear/Hint\",\"text\":\"清除图像为纯色\"},\"$:/language/Buttons/EditorHeight/Caption\":{\"title\":\"$:/language/Buttons/EditorHeight/Caption\",\"text\":\"编辑器高度\"},\"$:/language/Buttons/EditorHeight/Caption/Auto\":{\"title\":\"$:/language/Buttons/EditorHeight/Caption/Auto\",\"text\":\"自动调整高度以适应内容\"},\"$:/language/Buttons/EditorHeight/Caption/Fixed\":{\"title\":\"$:/language/Buttons/EditorHeight/Caption/Fixed\",\"text\":\"固定高度︰\"},\"$:/language/Buttons/EditorHeight/Hint\":{\"title\":\"$:/language/Buttons/EditorHeight/Hint\",\"text\":\"选择文本编辑器的高度\"},\"$:/language/Buttons/Excise/Caption\":{\"title\":\"$:/language/Buttons/Excise/Caption\",\"text\":\"剪切\"},\"$:/language/Buttons/Excise/Caption/Excise\":{\"title\":\"$:/language/Buttons/Excise/Caption/Excise\",\"text\":\"执行剪切\"},\"$:/language/Buttons/Excise/Caption/MacroName\":{\"title\":\"$:/language/Buttons/Excise/Caption/MacroName\",\"text\":\"宏的名称︰\"},\"$:/language/Buttons/Excise/Caption/NewTitle\":{\"title\":\"$:/language/Buttons/Excise/Caption/NewTitle\",\"text\":\"新条目的名称︰\"},\"$:/language/Buttons/Excise/Caption/Replace\":{\"title\":\"$:/language/Buttons/Excise/Caption/Replace\",\"text\":\"替换剪切的文本为：\"},\"$:/language/Buttons/Excise/Caption/Replace/Macro\":{\"title\":\"$:/language/Buttons/Excise/Caption/Replace/Macro\",\"text\":\"宏\"},\"$:/language/Buttons/Excise/Caption/Replace/Link\":{\"title\":\"$:/language/Buttons/Excise/Caption/Replace/Link\",\"text\":\"链接\"},\"$:/language/Buttons/Excise/Caption/Replace/Transclusion\":{\"title\":\"$:/language/Buttons/Excise/Caption/Replace/Transclusion\",\"text\":\"嵌入\"},\"$:/language/Buttons/Excise/Caption/Tag\":{\"title\":\"$:/language/Buttons/Excise/Caption/Tag\",\"text\":\"将新条目的标签设为此条目的名称\"},\"$:/language/Buttons/Excise/Caption/TiddlerExists\":{\"title\":\"$:/language/Buttons/Excise/Caption/TiddlerExists\",\"text\":\"提醒：条目已经存在\"},\"$:/language/Buttons/Excise/Hint\":{\"title\":\"$:/language/Buttons/Excise/Hint\",\"text\":\"剪切所选文本到一个新条目\"},\"$:/language/Buttons/Heading1/Caption\":{\"title\":\"$:/language/Buttons/Heading1/Caption\",\"text\":\"标题 1\"},\"$:/language/Buttons/Heading1/Hint\":{\"title\":\"$:/language/Buttons/Heading1/Hint\",\"text\":\"套用标题级别 1 的格式于包含所选文本的列\"},\"$:/language/Buttons/Heading2/Caption\":{\"title\":\"$:/language/Buttons/Heading2/Caption\",\"text\":\"标题 2\"},\"$:/language/Buttons/Heading2/Hint\":{\"title\":\"$:/language/Buttons/Heading2/Hint\",\"text\":\"套用标题级别 2 的格式于包含所选文本的列\"},\"$:/language/Buttons/Heading3/Caption\":{\"title\":\"$:/language/Buttons/Heading3/Caption\",\"text\":\"标题 3\"},\"$:/language/Buttons/Heading3/Hint\":{\"title\":\"$:/language/Buttons/Heading3/Hint\",\"text\":\"套用标题级别 3 的格式于包含所选文本的列\"},\"$:/language/Buttons/Heading4/Caption\":{\"title\":\"$:/language/Buttons/Heading4/Caption\",\"text\":\"标题 4\"},\"$:/language/Buttons/Heading4/Hint\":{\"title\":\"$:/language/Buttons/Heading4/Hint\",\"text\":\"套用标题级别 4 的格式于包含所选文本的列\"},\"$:/language/Buttons/Heading5/Caption\":{\"title\":\"$:/language/Buttons/Heading5/Caption\",\"text\":\"标题 5\"},\"$:/language/Buttons/Heading5/Hint\":{\"title\":\"$:/language/Buttons/Heading5/Hint\",\"text\":\"套用标题级别 5 的格式于包含所选文本的列\"},\"$:/language/Buttons/Heading6/Caption\":{\"title\":\"$:/language/Buttons/Heading6/Caption\",\"text\":\"标题 6\"},\"$:/language/Buttons/Heading6/Hint\":{\"title\":\"$:/language/Buttons/Heading6/Hint\",\"text\":\"套用标题级别 6 的格式于包含所选文本的列\"},\"$:/language/Buttons/Italic/Caption\":{\"title\":\"$:/language/Buttons/Italic/Caption\",\"text\":\"斜体\"},\"$:/language/Buttons/Italic/Hint\":{\"title\":\"$:/language/Buttons/Italic/Hint\",\"text\":\"套用斜体格式于所选文本\"},\"$:/language/Buttons/LineWidth/Caption\":{\"title\":\"$:/language/Buttons/LineWidth/Caption\",\"text\":\"线宽\"},\"$:/language/Buttons/LineWidth/Hint\":{\"title\":\"$:/language/Buttons/LineWidth/Hint\",\"text\":\"设置绘画的线条宽度\"},\"$:/language/Buttons/Link/Caption\":{\"title\":\"$:/language/Buttons/Link/Caption\",\"text\":\"链接\"},\"$:/language/Buttons/Link/Hint\":{\"title\":\"$:/language/Buttons/Link/Hint\",\"text\":\"创建维基文字链接\"},\"$:/language/Buttons/Linkify/Caption\":{\"title\":\"$:/language/Buttons/Linkify/Caption\",\"text\":\"维基链接\"},\"$:/language/Buttons/Linkify/Hint\":{\"title\":\"$:/language/Buttons/Linkify/Hint\",\"text\":\"套用维基链接于所选文字\"},\"$:/language/Buttons/ListBullet/Caption\":{\"title\":\"$:/language/Buttons/ListBullet/Caption\",\"text\":\"符号清单\"},\"$:/language/Buttons/ListBullet/Hint\":{\"title\":\"$:/language/Buttons/ListBullet/Hint\",\"text\":\"套用符号清单格式于包含所选文本的列\"},\"$:/language/Buttons/ListNumber/Caption\":{\"title\":\"$:/language/Buttons/ListNumber/Caption\",\"text\":\"数字清单\"},\"$:/language/Buttons/ListNumber/Hint\":{\"title\":\"$:/language/Buttons/ListNumber/Hint\",\"text\":\"套用数字清单格式于包含所选文本的列\"},\"$:/language/Buttons/MonoBlock/Caption\":{\"title\":\"$:/language/Buttons/MonoBlock/Caption\",\"text\":\"等宽区块\"},\"$:/language/Buttons/MonoBlock/Hint\":{\"title\":\"$:/language/Buttons/MonoBlock/Hint\",\"text\":\"套用等宽区块格式于包含所选文本的列\"},\"$:/language/Buttons/MonoLine/Caption\":{\"title\":\"$:/language/Buttons/MonoLine/Caption\",\"text\":\"等宽\"},\"$:/language/Buttons/MonoLine/Hint\":{\"title\":\"$:/language/Buttons/MonoLine/Hint\",\"text\":\"套用等宽字符格式于所选文本\"},\"$:/language/Buttons/Opacity/Caption\":{\"title\":\"$:/language/Buttons/Opacity/Caption\",\"text\":\"不透明度\"},\"$:/language/Buttons/Opacity/Hint\":{\"title\":\"$:/language/Buttons/Opacity/Hint\",\"text\":\"设置绘画的不透明度\"},\"$:/language/Buttons/Paint/Caption\":{\"title\":\"$:/language/Buttons/Paint/Caption\",\"text\":\"绘画颜色\"},\"$:/language/Buttons/Paint/Hint\":{\"title\":\"$:/language/Buttons/Paint/Hint\",\"text\":\"设置绘画的颜色\"},\"$:/language/Buttons/Picture/Caption\":{\"title\":\"$:/language/Buttons/Picture/Caption\",\"text\":\"图片\"},\"$:/language/Buttons/Picture/Hint\":{\"title\":\"$:/language/Buttons/Picture/Hint\",\"text\":\"插入图片\"},\"$:/language/Buttons/Preview/Caption\":{\"title\":\"$:/language/Buttons/Preview/Caption\",\"text\":\"预览\"},\"$:/language/Buttons/Preview/Hint\":{\"title\":\"$:/language/Buttons/Preview/Hint\",\"text\":\"显示预览窗格\"},\"$:/language/Buttons/PreviewType/Caption\":{\"title\":\"$:/language/Buttons/PreviewType/Caption\",\"text\":\"预览类型\"},\"$:/language/Buttons/PreviewType/Hint\":{\"title\":\"$:/language/Buttons/PreviewType/Hint\",\"text\":\"选择预览类型\"},\"$:/language/Buttons/Quote/Caption\":{\"title\":\"$:/language/Buttons/Quote/Caption\",\"text\":\"引用\"},\"$:/language/Buttons/Quote/Hint\":{\"title\":\"$:/language/Buttons/Quote/Hint\",\"text\":\"套用引用文本格式于包含所选文本的列\"},\"$:/language/Buttons/RotateLeft/Caption\":{\"title\":\"$:/language/Buttons/RotateLeft/Caption\",\"text\":\"向左旋转\"},\"$:/language/Buttons/RotateLeft/Hint\":{\"title\":\"$:/language/Buttons/RotateLeft/Hint\",\"text\":\"图像向左旋转 90 度\"},\"$:/language/Buttons/Size/Caption\":{\"title\":\"$:/language/Buttons/Size/Caption\",\"text\":\"图像大小\"},\"$:/language/Buttons/Size/Caption/Height\":{\"title\":\"$:/language/Buttons/Size/Caption/Height\",\"text\":\"高度︰\"},\"$:/language/Buttons/Size/Caption/Resize\":{\"title\":\"$:/language/Buttons/Size/Caption/Resize\",\"text\":\"调整图像的大小\"},\"$:/language/Buttons/Size/Caption/Width\":{\"title\":\"$:/language/Buttons/Size/Caption/Width\",\"text\":\"宽度：\"},\"$:/language/Buttons/Size/Hint\":{\"title\":\"$:/language/Buttons/Size/Hint\",\"text\":\"设置图像的大小\"},\"$:/language/Buttons/Stamp/Caption\":{\"title\":\"$:/language/Buttons/Stamp/Caption\",\"text\":\"印记\"},\"$:/language/Buttons/Stamp/Caption/New\":{\"title\":\"$:/language/Buttons/Stamp/Caption/New\",\"text\":\"添加您自己的\"},\"$:/language/Buttons/Stamp/Hint\":{\"title\":\"$:/language/Buttons/Stamp/Hint\",\"text\":\"插入一个预配置的文本片段\"},\"$:/language/Buttons/Stamp/New/Title\":{\"title\":\"$:/language/Buttons/Stamp/New/Title\",\"text\":\"在选单中显示的标题\"},\"$:/language/Buttons/Stamp/New/Text\":{\"title\":\"$:/language/Buttons/Stamp/New/Text\",\"text\":\"片段的文本。（记得在 `caption` 字段中添加一个说明性的标题）。\"},\"$:/language/Buttons/Strikethrough/Caption\":{\"title\":\"$:/language/Buttons/Strikethrough/Caption\",\"text\":\"删除线\"},\"$:/language/Buttons/Strikethrough/Hint\":{\"title\":\"$:/language/Buttons/Strikethrough/Hint\",\"text\":\"套用删除线格式于所选文本\"},\"$:/language/Buttons/Subscript/Caption\":{\"title\":\"$:/language/Buttons/Subscript/Caption\",\"text\":\"下标\"},\"$:/language/Buttons/Subscript/Hint\":{\"title\":\"$:/language/Buttons/Subscript/Hint\",\"text\":\"套用下标格式于所选文本\"},\"$:/language/Buttons/Superscript/Caption\":{\"title\":\"$:/language/Buttons/Superscript/Caption\",\"text\":\"上标\"},\"$:/language/Buttons/Superscript/Hint\":{\"title\":\"$:/language/Buttons/Superscript/Hint\",\"text\":\"套用上标格式于所选文本\"},\"$:/language/Buttons/ToggleSidebar/Hint\":{\"title\":\"$:/language/Buttons/ToggleSidebar/Hint\",\"text\":\"切换显示或隐藏侧边栏\"},\"$:/language/Buttons/Transcludify/Caption\":{\"title\":\"$:/language/Buttons/Transcludify/Caption\",\"text\":\"嵌入\"},\"$:/language/Buttons/Transcludify/Hint\":{\"title\":\"$:/language/Buttons/Transcludify/Hint\",\"text\":\"套用嵌入于所选文字\"},\"$:/language/Buttons/Underline/Caption\":{\"title\":\"$:/language/Buttons/Underline/Caption\",\"text\":\"下划线\"},\"$:/language/Buttons/Underline/Hint\":{\"title\":\"$:/language/Buttons/Underline/Hint\",\"text\":\"套用下划线格式于所选文本\"},\"$:/language/ControlPanel/Advanced/Caption\":{\"title\":\"$:/language/ControlPanel/Advanced/Caption\",\"text\":\"高级\"},\"$:/language/ControlPanel/Advanced/Hint\":{\"title\":\"$:/language/ControlPanel/Advanced/Hint\",\"text\":\"关于此 TiddlyWiki 的内部信息\"},\"$:/language/ControlPanel/Appearance/Caption\":{\"title\":\"$:/language/ControlPanel/Appearance/Caption\",\"text\":\"外观\"},\"$:/language/ControlPanel/Appearance/Hint\":{\"title\":\"$:/language/ControlPanel/Appearance/Hint\",\"text\":\"定制您的 TiddlyWiki 外观。\"},\"$:/language/ControlPanel/Basics/AnimDuration/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/AnimDuration/Prompt\",\"text\":\"动画持续时间\"},\"$:/language/ControlPanel/Basics/AutoFocus/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/AutoFocus/Prompt\",\"text\":\"编辑条目时的默认自动停留字段\"},\"$:/language/ControlPanel/Basics/Caption\":{\"title\":\"$:/language/ControlPanel/Basics/Caption\",\"text\":\"基础\"},\"$:/language/ControlPanel/Basics/DefaultTiddlers/BottomHint\":{\"title\":\"$:/language/ControlPanel/Basics/DefaultTiddlers/BottomHint\",\"text\":\"标题含空白时请使用 &#91;&#91;双中括弧&#93;&#93;，或者您可用 {{保留开启中的条目顺序||$:/snippets/retain-story-ordering-button}}\"},\"$:/language/ControlPanel/Basics/DefaultTiddlers/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/DefaultTiddlers/Prompt\",\"text\":\"首页\"},\"$:/language/ControlPanel/Basics/DefaultTiddlers/TopHint\":{\"title\":\"$:/language/ControlPanel/Basics/DefaultTiddlers/TopHint\",\"text\":\"默认开启的条目\"},\"$:/language/ControlPanel/Basics/Language/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Language/Prompt\",\"text\":\"您好！当前的语言：\"},\"$:/language/ControlPanel/Basics/NewJournal/Tags/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/NewJournal/Tags/Prompt\",\"text\":\"新日志条目的标签\"},\"$:/language/ControlPanel/Basics/NewJournal/Text/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/NewJournal/Text/Prompt\",\"text\":\"新日志条目的内容\"},\"$:/language/ControlPanel/Basics/NewJournal/Title/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/NewJournal/Title/Prompt\",\"text\":\"新日志条目的名称\"},\"$:/language/ControlPanel/Basics/NewTiddler/Tags/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/NewTiddler/Tags/Prompt\",\"text\":\"新条目的标签\"},\"$:/language/ControlPanel/Basics/NewTiddler/Title/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/NewTiddler/Title/Prompt\",\"text\":\"新条目的名称\"},\"$:/language/ControlPanel/Basics/OverriddenShadowTiddlers/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/OverriddenShadowTiddlers/Prompt\",\"text\":\"被覆盖的默认条目数量\"},\"$:/language/ControlPanel/Basics/RemoveTags\":{\"title\":\"$:/language/ControlPanel/Basics/RemoveTags\",\"text\":\"更新到当前格式\"},\"$:/language/ControlPanel/Basics/RemoveTags/Hint\":{\"title\":\"$:/language/ControlPanel/Basics/RemoveTags/Hint\",\"text\":\"将标签配置更新为最新格式\"},\"$:/language/ControlPanel/Basics/ShadowTiddlers/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/ShadowTiddlers/Prompt\",\"text\":\"默认条目数量\"},\"$:/language/ControlPanel/Basics/Subtitle/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Subtitle/Prompt\",\"text\":\"副标题\"},\"$:/language/ControlPanel/Basics/SystemTiddlers/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/SystemTiddlers/Prompt\",\"text\":\"系统条目数量\"},\"$:/language/ControlPanel/Basics/Tags/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Tags/Prompt\",\"text\":\"标签数量\"},\"$:/language/ControlPanel/Basics/Tiddlers/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Tiddlers/Prompt\",\"text\":\"一般条目数量\"},\"$:/language/ControlPanel/Basics/Title/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Title/Prompt\",\"text\":\"此 ~TiddlyWiki 的标题\"},\"$:/language/ControlPanel/Basics/Username/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Username/Prompt\",\"text\":\"编辑者署名\"},\"$:/language/ControlPanel/Basics/Version/Prompt\":{\"title\":\"$:/language/ControlPanel/Basics/Version/Prompt\",\"text\":\"~TiddlyWiki 版本\"},\"$:/language/ControlPanel/Cascades/Caption\":{\"title\":\"$:/language/ControlPanel/Cascades/Caption\",\"text\":\"级联\"},\"$:/language/ControlPanel/Cascades/Hint\":{\"title\":\"$:/language/ControlPanel/Cascades/Hint\",\"text\":\"这些全域规则用于动态选择某些模板。级联的结果是返回结果的序列中的第一个筛选的结果\"},\"$:/language/ControlPanel/Cascades/TagPrompt\":{\"title\":\"$:/language/ControlPanel/Cascades/TagPrompt\",\"text\":\"筛选器标签为 \u003C$macrocall $name=\\\"tag\\\" tag=\u003C\u003CcurrentTiddler>>/>\"},\"$:/language/ControlPanel/EditorTypes/Caption\":{\"title\":\"$:/language/ControlPanel/EditorTypes/Caption\",\"text\":\"编辑器类型\"},\"$:/language/ControlPanel/EditorTypes/Editor/Caption\":{\"title\":\"$:/language/ControlPanel/EditorTypes/Editor/Caption\",\"text\":\"编辑器\"},\"$:/language/ControlPanel/EditorTypes/Hint\":{\"title\":\"$:/language/ControlPanel/EditorTypes/Hint\",\"text\":\"这些条目决定使用哪个编辑器来编辑特定条目类型。\"},\"$:/language/ControlPanel/EditorTypes/Type/Caption\":{\"title\":\"$:/language/ControlPanel/EditorTypes/Type/Caption\",\"text\":\"类型\"},\"$:/language/ControlPanel/EditTemplateBody/Caption\":{\"title\":\"$:/language/ControlPanel/EditTemplateBody/Caption\",\"text\":\"编辑模板主体\"},\"$:/language/ControlPanel/EditTemplateBody/Hint\":{\"title\":\"$:/language/ControlPanel/EditTemplateBody/Hint\",\"text\":\"默认的编辑模板使用此规则级联，动态选择模板来编辑条目的主体。\"},\"$:/language/ControlPanel/FieldEditor/Caption\":{\"title\":\"$:/language/ControlPanel/FieldEditor/Caption\",\"text\":\"字段编辑器\"},\"$:/language/ControlPanel/FieldEditor/Hint\":{\"title\":\"$:/language/ControlPanel/FieldEditor/Hint\",\"text\":\"此规则级联用于根据名称，动态选择用于呈现一个条目字段的模板。其用于编辑模板中。\"},\"$:/language/ControlPanel/Info/Caption\":{\"title\":\"$:/language/ControlPanel/Info/Caption\",\"text\":\"信息\"},\"$:/language/ControlPanel/Info/Hint\":{\"title\":\"$:/language/ControlPanel/Info/Hint\",\"text\":\"有关此 TiddlyWiki 的信息\"},\"$:/language/ControlPanel/KeyboardShortcuts/Add/Prompt\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Add/Prompt\",\"text\":\"在此输入快捷键\"},\"$:/language/ControlPanel/KeyboardShortcuts/Add/Caption\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Add/Caption\",\"text\":\"添加快捷键\"},\"$:/language/ControlPanel/KeyboardShortcuts/Caption\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Caption\",\"text\":\"快捷键\"},\"$:/language/ControlPanel/KeyboardShortcuts/Hint\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Hint\",\"text\":\"管理键盘快捷键分配\"},\"$:/language/ControlPanel/KeyboardShortcuts/NoShortcuts/Caption\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/NoShortcuts/Caption\",\"text\":\"尚无指定快捷键\"},\"$:/language/ControlPanel/KeyboardShortcuts/Remove/Hint\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Remove/Hint\",\"text\":\"删除快捷键\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/All\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/All\",\"text\":\"所有平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Mac\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Mac\",\"text\":\"仅 Macintosh 平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonMac\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonMac\",\"text\":\"仅非 Macintosh 平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Linux\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Linux\",\"text\":\"仅 Linux 平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonLinux\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonLinux\",\"text\":\"仅非 Linux 平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Windows\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/Windows\",\"text\":\"仅 Windows 平台\"},\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonWindows\":{\"title\":\"$:/language/ControlPanel/KeyboardShortcuts/Platform/NonWindows\",\"text\":\"仅非 Windows 平台\"},\"$:/language/ControlPanel/LayoutSwitcher/Caption\":{\"title\":\"$:/language/ControlPanel/LayoutSwitcher/Caption\",\"text\":\"布局\"},\"$:/language/ControlPanel/LoadedModules/Caption\":{\"title\":\"$:/language/ControlPanel/LoadedModules/Caption\",\"text\":\"已加载的模块\"},\"$:/language/ControlPanel/LoadedModules/Hint\":{\"title\":\"$:/language/ControlPanel/LoadedModules/Hint\",\"text\":\"这些是当前已加载的模块之源码条目。斜体的模块则无源码条目，通常是因为它们是在引导过程中设置。\"},\"$:/language/ControlPanel/Palette/Caption\":{\"title\":\"$:/language/ControlPanel/Palette/Caption\",\"text\":\"调色板\"},\"$:/language/ControlPanel/Palette/Editor/Clone/Caption\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Clone/Caption\",\"text\":\"复制\"},\"$:/language/ControlPanel/Palette/Editor/Clone/Prompt\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Clone/Prompt\",\"text\":\"建议您修改前先复制此默认调色板\"},\"$:/language/ControlPanel/Palette/Editor/Delete/Hint\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Delete/Hint\",\"text\":\"从当前调色板中删除此项\"},\"$:/language/ControlPanel/Palette/Editor/Names/External/Show\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Names/External/Show\",\"text\":\"显示不属于当前调色板的颜色名称\"},\"$:/language/ControlPanel/Palette/Editor/Prompt/Modified\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Prompt/Modified\",\"text\":\"此默认调色板已被修改过\"},\"$:/language/ControlPanel/Palette/Editor/Prompt\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Prompt\",\"text\":\"编辑\"},\"$:/language/ControlPanel/Palette/Editor/Reset/Caption\":{\"title\":\"$:/language/ControlPanel/Palette/Editor/Reset/Caption\",\"text\":\"重置\"},\"$:/language/ControlPanel/Palette/HideEditor/Caption\":{\"title\":\"$:/language/ControlPanel/Palette/HideEditor/Caption\",\"text\":\"隐藏编辑器\"},\"$:/language/ControlPanel/Palette/Prompt\":{\"title\":\"$:/language/ControlPanel/Palette/Prompt\",\"text\":\"当前的调色板：\"},\"$:/language/ControlPanel/Palette/ShowEditor/Caption\":{\"title\":\"$:/language/ControlPanel/Palette/ShowEditor/Caption\",\"text\":\"显示编辑器\"},\"$:/language/ControlPanel/Plugins/Add/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Add/Hint\",\"text\":\"从官方插件库安装插件\"},\"$:/language/ControlPanel/Plugins/Add/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Add/Caption\",\"text\":\"获取更多插件\"},\"$:/language/ControlPanel/Plugins/AlreadyInstalled/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/AlreadyInstalled/Hint\",\"text\":\"此插件已经安装版本 \u003C$text text=\u003C\u003CinstalledVersion>>/>\"},\"$:/language/ControlPanel/Plugins/AlsoRequires\":{\"title\":\"$:/language/ControlPanel/Plugins/AlsoRequires\",\"text\":\"还需要：\"},\"$:/language/ControlPanel/Plugins/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Caption\",\"text\":\"插件\"},\"$:/language/ControlPanel/Plugins/Disable/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Disable/Caption\",\"text\":\"禁用\"},\"$:/language/ControlPanel/Plugins/Disable/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Disable/Hint\",\"text\":\"重新加载页面时禁用此插件\"},\"$:/language/ControlPanel/Plugins/Disabled/Status\":{\"title\":\"$:/language/ControlPanel/Plugins/Disabled/Status\",\"text\":\"(已禁用)\"},\"$:/language/ControlPanel/Plugins/Downgrade/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Downgrade/Caption\",\"text\":\"降级\"},\"$:/language/ControlPanel/Plugins/Empty/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Empty/Hint\",\"text\":\"无\"},\"$:/language/ControlPanel/Plugins/Enable/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Enable/Caption\",\"text\":\"启用\"},\"$:/language/ControlPanel/Plugins/Enable/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Enable/Hint\",\"text\":\"重新加载页面时启用此插件\"},\"$:/language/ControlPanel/Plugins/Install/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Install/Caption\",\"text\":\"安装\"},\"$:/language/ControlPanel/Plugins/Installed/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Installed/Hint\",\"text\":\"当前已安装的插件：\"},\"$:/language/ControlPanel/Plugins/Languages/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Languages/Caption\",\"text\":\"语言\"},\"$:/language/ControlPanel/Plugins/Languages/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Languages/Hint\",\"text\":\"语言包插件\"},\"$:/language/ControlPanel/Plugins/NoInfoFound/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/NoInfoFound/Hint\",\"text\":\"无 ''\\\"\u003C$text text=\u003C\u003CcurrentTab>>/>\\\"''\"},\"$:/language/ControlPanel/Plugins/NoInformation/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/NoInformation/Hint\",\"text\":\"未提供信息\"},\"$:/language/ControlPanel/Plugins/NotInstalled/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/NotInstalled/Hint\",\"text\":\"尚未安装此插件\"},\"$:/language/ControlPanel/Plugins/OpenPluginLibrary\":{\"title\":\"$:/language/ControlPanel/Plugins/OpenPluginLibrary\",\"text\":\"打开插件库\"},\"$:/language/ControlPanel/Plugins/ClosePluginLibrary\":{\"title\":\"$:/language/ControlPanel/Plugins/ClosePluginLibrary\",\"text\":\"关闭插件库\"},\"$:/language/ControlPanel/Plugins/PluginWillRequireReload\":{\"title\":\"$:/language/ControlPanel/Plugins/PluginWillRequireReload\",\"text\":\"（需要重新加载）\"},\"$:/language/ControlPanel/Plugins/Plugins/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Plugins/Caption\",\"text\":\"插件\"},\"$:/language/ControlPanel/Plugins/Plugins/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Plugins/Hint\",\"text\":\"插件\"},\"$:/language/ControlPanel/Plugins/Reinstall/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Reinstall/Caption\",\"text\":\"重新安装\"},\"$:/language/ControlPanel/Plugins/Themes/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Themes/Caption\",\"text\":\"布局主题\"},\"$:/language/ControlPanel/Plugins/Themes/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Themes/Hint\",\"text\":\"布局主题插件\"},\"$:/language/ControlPanel/Plugins/Update/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Update/Caption\",\"text\":\"更新\"},\"$:/language/ControlPanel/Plugins/Updates/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Updates/Caption\",\"text\":\"更新\"},\"$:/language/ControlPanel/Plugins/Updates/Hint\":{\"title\":\"$:/language/ControlPanel/Plugins/Updates/Hint\",\"text\":\"已安装插件的可用更新\"},\"$:/language/ControlPanel/Plugins/Updates/UpdateAll/Caption\":{\"title\":\"$:/language/ControlPanel/Plugins/Updates/UpdateAll/Caption\",\"text\":\"更新 \u003C\u003Cupdate-count>> 个插件\"},\"$:/language/ControlPanel/Plugins/SubPluginPrompt\":{\"title\":\"$:/language/ControlPanel/Plugins/SubPluginPrompt\",\"text\":\"提供 \u003C\u003Ccount>> 个可用的附加插件\"},\"$:/language/ControlPanel/Parsing/Caption\":{\"title\":\"$:/language/ControlPanel/Parsing/Caption\",\"text\":\"解析\"},\"$:/language/ControlPanel/Parsing/Hint\":{\"title\":\"$:/language/ControlPanel/Parsing/Hint\",\"text\":\"在此您可以全域禁用或启用维基解析规则。要使更改生效，请保存并重新加载您的维基。禁用某些解析规则，会妨碍 \u003C$text text=\\\"TiddlyWiki\\\"/> 正常运作。可使用[[安全模式|https://tiddlywiki.com/#SafeMode]]恢复正常操作。\"},\"$:/language/ControlPanel/Parsing/Block/Caption\":{\"title\":\"$:/language/ControlPanel/Parsing/Block/Caption\",\"text\":\"区块解析规则\"},\"$:/language/ControlPanel/Parsing/Inline/Caption\":{\"title\":\"$:/language/ControlPanel/Parsing/Inline/Caption\",\"text\":\"内联解析规则\"},\"$:/language/ControlPanel/Parsing/Pragma/Caption\":{\"title\":\"$:/language/ControlPanel/Parsing/Pragma/Caption\",\"text\":\"编译指示解析规则\"},\"$:/language/ControlPanel/Saving/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/Caption\",\"text\":\"保存\"},\"$:/language/ControlPanel/Saving/DownloadSaver/AutoSave/Description\":{\"title\":\"$:/language/ControlPanel/Saving/DownloadSaver/AutoSave/Description\",\"text\":\"允许下载保存模块的自动保存\"},\"$:/language/ControlPanel/Saving/DownloadSaver/AutoSave/Hint\":{\"title\":\"$:/language/ControlPanel/Saving/DownloadSaver/AutoSave/Hint\",\"text\":\"启用下载保存模块的自动保存\"},\"$:/language/ControlPanel/Saving/DownloadSaver/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/DownloadSaver/Caption\",\"text\":\"下载保存模块\"},\"$:/language/ControlPanel/Saving/DownloadSaver/Hint\":{\"title\":\"$:/language/ControlPanel/Saving/DownloadSaver/Hint\",\"text\":\"这些设置适用于兼容 HTML5 的下载保存模块\"},\"$:/language/ControlPanel/Saving/General/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/General/Caption\",\"text\":\"通用\"},\"$:/language/ControlPanel/Saving/General/Hint\":{\"title\":\"$:/language/ControlPanel/Saving/General/Hint\",\"text\":\"这些设置适用于所有已载入的保存模块\"},\"$:/language/ControlPanel/Saving/Hint\":{\"title\":\"$:/language/ControlPanel/Saving/Hint\",\"text\":\"用于通过保存模块将整个 TiddlyWiki 保存为单个文件的设置\"},\"$:/language/ControlPanel/Saving/GitService/Branch\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Branch\",\"text\":\"用于保存的目标分支\"},\"$:/language/ControlPanel/Saving/GitService/CommitMessage\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/CommitMessage\",\"text\":\"由 TiddlyWiki 保存\"},\"$:/language/ControlPanel/Saving/GitService/Description\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Description\",\"text\":\"这些设置仅用于保存至 \u003C\u003Cservice-name>>\"},\"$:/language/ControlPanel/Saving/GitService/Filename\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Filename\",\"text\":\"目标文件的文件名称 (例如，`index.html`)\"},\"$:/language/ControlPanel/Saving/GitService/Path\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Path\",\"text\":\"目标文件的路径 (例如，`/wiki/`)\"},\"$:/language/ControlPanel/Saving/GitService/Repo\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Repo\",\"text\":\"目标存储库 (例如，`Jermolene/TiddlyWiki5`)\"},\"$:/language/ControlPanel/Saving/GitService/ServerURL\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/ServerURL\",\"text\":\"服务器 API 网址\"},\"$:/language/ControlPanel/Saving/GitService/UserName\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/UserName\",\"text\":\"用户名称\"},\"$:/language/ControlPanel/Saving/GitService/GitHub/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/GitHub/Caption\",\"text\":\"~GitHub 保存模块\"},\"$:/language/ControlPanel/Saving/GitService/GitHub/Password\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/GitHub/Password\",\"text\":\"密码、OAUTH 令牌，或个人存取令牌 (详见 [[GitHub 帮助页面|https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line]])\"},\"$:/language/ControlPanel/Saving/GitService/GitLab/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/GitLab/Caption\",\"text\":\"~GitLab 保存模块\"},\"$:/language/ControlPanel/Saving/GitService/GitLab/Password\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/GitLab/Password\",\"text\":\"个人存取令牌的 API (详见 [[GitLab 帮助页面|https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html]])\"},\"$:/language/ControlPanel/Saving/GitService/Gitea/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Gitea/Caption\",\"text\":\"Gitea 保存模块\"},\"$:/language/ControlPanel/Saving/GitService/Gitea/Password\":{\"title\":\"$:/language/ControlPanel/Saving/GitService/Gitea/Password\",\"text\":\"个人存取令牌的 API (通过 Gitea 的 Web 界面：`设定 | 应用程序 | 产生新的令牌`)\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Advanced/Heading\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Advanced/Heading\",\"text\":\"高级设置\"},\"$:/language/ControlPanel/Saving/TiddlySpot/BackupDir\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/BackupDir\",\"text\":\"备份文件夹\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Backups\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Backups\",\"text\":\"备份\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Caption\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Caption\",\"text\":\"~TiddlySpot 保存模块\"},\"$:/language/ControlPanel/Saving/TiddlySpot/ControlPanel\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/ControlPanel\",\"text\":\"~TiddlySpot 控制台\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Description\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Description\",\"text\":\"这些设置只适用于保存到 [[TiddlySpot|http://tiddlyspot.com]]、[[TiddlyHost|https://tiddlyhost.com]]，或兼容的远程服务器。有关 ~TiddlySpot 和 ~TiddlyHost 的保存设置信息，请参阅[[此处|https://github.com/simonbaird/tiddlyhost/wiki/TiddlySpot-Saver-configuration-for-Tiddlyhost-and-Tiddlyspot]]。\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Filename\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Filename\",\"text\":\"上传文件名\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Heading\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Heading\",\"text\":\"~TiddlySpot\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Hint\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Hint\",\"text\":\"//默认之服务器网址 `http://\u003Cwikiname>.tiddlyspot.com/store.cgi`，可改为定制之服务器网址，例如 `http://example.com/store.php`。//\"},\"$:/language/ControlPanel/Saving/TiddlySpot/Password\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/Password\",\"text\":\"密码\"},\"$:/language/ControlPanel/Saving/TiddlySpot/ReadOnly\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/ReadOnly\",\"text\":\"请注意，[[TiddlySpot|http://tiddlyspot.com]] 不再允许创建新网站。对于新网站，您可以使用 [[TiddlyHost|https://tiddlyhost.com]]，一个新的取代 ~TiddlySpot 的讬管服务 。\"},\"$:/language/ControlPanel/Saving/TiddlySpot/ServerURL\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/ServerURL\",\"text\":\"服务器网址\"},\"$:/language/ControlPanel/Saving/TiddlySpot/UploadDir\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/UploadDir\",\"text\":\"上传文件夹\"},\"$:/language/ControlPanel/Saving/TiddlySpot/UserName\":{\"title\":\"$:/language/ControlPanel/Saving/TiddlySpot/UserName\",\"text\":\"用户\"},\"$:/language/ControlPanel/Settings/AutoSave/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/AutoSave/Caption\",\"text\":\"自动保存\"},\"$:/language/ControlPanel/Settings/AutoSave/Disabled/Description\":{\"title\":\"$:/language/ControlPanel/Settings/AutoSave/Disabled/Description\",\"text\":\"不要自动保存变更\"},\"$:/language/ControlPanel/Settings/AutoSave/Enabled/Description\":{\"title\":\"$:/language/ControlPanel/Settings/AutoSave/Enabled/Description\",\"text\":\"自动保存变更\"},\"$:/language/ControlPanel/Settings/AutoSave/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/AutoSave/Hint\",\"text\":\"当使用支持的保存模块时，在编辑期间尝试自动保存变更\"},\"$:/language/ControlPanel/Settings/CamelCase/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/CamelCase/Caption\",\"text\":\"驼峰式维基链接\"},\"$:/language/ControlPanel/Settings/CamelCase/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/CamelCase/Hint\",\"text\":\"您可以全域禁用驼峰式短语自动链接。须保存后重新加载，方才生效。\"},\"$:/language/ControlPanel/Settings/CamelCase/Description\":{\"title\":\"$:/language/ControlPanel/Settings/CamelCase/Description\",\"text\":\"启用自动驼峰式链接\"},\"$:/language/ControlPanel/Settings/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/Caption\",\"text\":\"设置\"},\"$:/language/ControlPanel/Settings/DefaultSidebarTab/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/DefaultSidebarTab/Caption\",\"text\":\"默认侧边栏页签\"},\"$:/language/ControlPanel/Settings/DefaultSidebarTab/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/DefaultSidebarTab/Hint\",\"text\":\"指定默认显示的侧边栏页签\"},\"$:/language/ControlPanel/Settings/DefaultMoreSidebarTab/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/DefaultMoreSidebarTab/Caption\",\"text\":\"更多侧边栏的默认页签\"},\"$:/language/ControlPanel/Settings/DefaultMoreSidebarTab/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/DefaultMoreSidebarTab/Hint\",\"text\":\"指定默认显示的更多侧栏页签\"},\"$:/language/ControlPanel/Settings/EditorToolbar/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/EditorToolbar/Caption\",\"text\":\"编辑器工具栏\"},\"$:/language/ControlPanel/Settings/EditorToolbar/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/EditorToolbar/Hint\",\"text\":\"启用或禁用编辑器工具栏︰\"},\"$:/language/ControlPanel/Settings/EditorToolbar/Description\":{\"title\":\"$:/language/ControlPanel/Settings/EditorToolbar/Description\",\"text\":\"显示编辑器工具栏\"},\"$:/language/ControlPanel/Settings/InfoPanelMode/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/InfoPanelMode/Caption\",\"text\":\"条目信息面板模式\"},\"$:/language/ControlPanel/Settings/InfoPanelMode/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/InfoPanelMode/Hint\",\"text\":\"控制条目信息面板何时关闭︰\"},\"$:/language/ControlPanel/Settings/InfoPanelMode/Popup/Description\":{\"title\":\"$:/language/ControlPanel/Settings/InfoPanelMode/Popup/Description\",\"text\":\"条目信息面板自动关闭\"},\"$:/language/ControlPanel/Settings/InfoPanelMode/Sticky/Description\":{\"title\":\"$:/language/ControlPanel/Settings/InfoPanelMode/Sticky/Description\",\"text\":\"条目信息面板保持打开状态，直到明确关闭\"},\"$:/language/ControlPanel/Settings/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/Hint\",\"text\":\"这些高级设置让您定制 TiddlyWiki 的行为。\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/Caption\",\"text\":\"条目开启行为\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/InsideRiver/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/InsideRiver/Hint\",\"text\":\"从故事河//中//导航\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/OutsideRiver/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/OutsideRiver/Hint\",\"text\":\"从故事河//外//导航\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAbove\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAbove\",\"text\":\"开启于当前条目之上\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenBelow\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenBelow\",\"text\":\"开启于当前条目之下\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAtTop\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAtTop\",\"text\":\"开启于故事河的顶部\"},\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAtBottom\":{\"title\":\"$:/language/ControlPanel/Settings/LinkToBehaviour/OpenAtBottom\",\"text\":\"开启于故事河的底部\"},\"$:/language/ControlPanel/Settings/MissingLinks/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/MissingLinks/Caption\",\"text\":\"维基链接\"},\"$:/language/ControlPanel/Settings/MissingLinks/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/MissingLinks/Hint\",\"text\":\"选择是否要链接到尚未存在的条目\"},\"$:/language/ControlPanel/Settings/MissingLinks/Description\":{\"title\":\"$:/language/ControlPanel/Settings/MissingLinks/Description\",\"text\":\"启用链接到佚失条目\"},\"$:/language/ControlPanel/Settings/NavigationAddressBar/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationAddressBar/Caption\",\"text\":\"网址栏导航\"},\"$:/language/ControlPanel/Settings/NavigationAddressBar/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationAddressBar/Hint\",\"text\":\"在浏览器网址栏导航到条目时的行为：\"},\"$:/language/ControlPanel/Settings/NavigationAddressBar/No/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationAddressBar/No/Description\",\"text\":\"不更新网址栏\"},\"$:/language/ControlPanel/Settings/NavigationAddressBar/Permalink/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationAddressBar/Permalink/Description\",\"text\":\"包含目标条目\"},\"$:/language/ControlPanel/Settings/NavigationAddressBar/Permaview/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationAddressBar/Permaview/Description\",\"text\":\"包括目标条目和当前已开启的条目序列\"},\"$:/language/ControlPanel/Settings/NavigationHistory/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationHistory/Caption\",\"text\":\"历史记录导航\"},\"$:/language/ControlPanel/Settings/NavigationHistory/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationHistory/Hint\",\"text\":\"当导航到条目时，更新浏览器历史记录：\"},\"$:/language/ControlPanel/Settings/NavigationHistory/No/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationHistory/No/Description\",\"text\":\"不更新历史记录\"},\"$:/language/ControlPanel/Settings/NavigationHistory/Yes/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationHistory/Yes/Description\",\"text\":\"更新历史记录\"},\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/Caption\",\"text\":\"引用链接/固定链接 模式\"},\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/Hint\",\"text\":\"选择 引用链接/固定链接 的处理方式：\"},\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/CopyToClipboard/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/CopyToClipboard/Description\",\"text\":\"将 引用链接/固定链接 网址复制到剪贴板\"},\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/UpdateAddressBar/Description\":{\"title\":\"$:/language/ControlPanel/Settings/NavigationPermalinkviewMode/UpdateAddressBar/Description\",\"text\":\"以 引用链接/固定链接 更新网址栏\"},\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Caption\",\"text\":\"性能检测\"},\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Hint\",\"text\":\"在浏览器的开发人员控制台，显示性能统计数据。需要重新加载才能生效。\"},\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Description\":{\"title\":\"$:/language/ControlPanel/Settings/PerformanceInstrumentation/Description\",\"text\":\"启用性能检测\"},\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Caption\",\"text\":\"工具栏按钮样式\"},\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Hint\",\"text\":\"选择工具栏按钮的样式:\"},\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Borderless\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Borderless\",\"text\":\"无边框\"},\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Boxed\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Boxed\",\"text\":\"方框\"},\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Rounded\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtonStyle/Styles/Rounded\",\"text\":\"圆形\"},\"$:/language/ControlPanel/Settings/ToolbarButtons/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtons/Caption\",\"text\":\"工具栏按钮\"},\"$:/language/ControlPanel/Settings/ToolbarButtons/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtons/Hint\",\"text\":\"默认的工具栏按钮外观：\"},\"$:/language/ControlPanel/Settings/ToolbarButtons/Icons/Description\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtons/Icons/Description\",\"text\":\"包含图标\"},\"$:/language/ControlPanel/Settings/ToolbarButtons/Text/Description\":{\"title\":\"$:/language/ControlPanel/Settings/ToolbarButtons/Text/Description\",\"text\":\"包含文本\"},\"$:/language/ControlPanel/Settings/TitleLinks/Caption\":{\"title\":\"$:/language/ControlPanel/Settings/TitleLinks/Caption\",\"text\":\"条目标题\"},\"$:/language/ControlPanel/Settings/TitleLinks/Hint\":{\"title\":\"$:/language/ControlPanel/Settings/TitleLinks/Hint\",\"text\":\"可选地显示条目标题为链接\"},\"$:/language/ControlPanel/Settings/TitleLinks/No/Description\":{\"title\":\"$:/language/ControlPanel/Settings/TitleLinks/No/Description\",\"text\":\"不显示条目标题为链接\"},\"$:/language/ControlPanel/Settings/TitleLinks/Yes/Description\":{\"title\":\"$:/language/ControlPanel/Settings/TitleLinks/Yes/Description\",\"text\":\"显示条目标题为链接\"},\"$:/language/ControlPanel/StoryTiddler/Caption\":{\"title\":\"$:/language/ControlPanel/StoryTiddler/Caption\",\"text\":\"故事条目\"},\"$:/language/ControlPanel/StoryTiddler/Hint\":{\"title\":\"$:/language/ControlPanel/StoryTiddler/Hint\",\"text\":\"此规则级联用于动态选择模板，以便在故事河中显示条目。\"},\"$:/language/ControlPanel/StoryView/Caption\":{\"title\":\"$:/language/ControlPanel/StoryView/Caption\",\"text\":\"视图模式\"},\"$:/language/ControlPanel/StoryView/Prompt\":{\"title\":\"$:/language/ControlPanel/StoryView/Prompt\",\"text\":\"当前的视图模式：\"},\"$:/language/ControlPanel/Stylesheets/Caption\":{\"title\":\"$:/language/ControlPanel/Stylesheets/Caption\",\"text\":\"样式表\"},\"$:/language/ControlPanel/Stylesheets/Expand/Caption\":{\"title\":\"$:/language/ControlPanel/Stylesheets/Expand/Caption\",\"text\":\"全部展开\"},\"$:/language/ControlPanel/Stylesheets/Hint\":{\"title\":\"$:/language/ControlPanel/Stylesheets/Hint\",\"text\":\"这是当前标签为 \u003C\u003Ctag \\\"$:/tags/Stylesheet\\\">> 的样式表条目呈现的 CSS\"},\"$:/language/ControlPanel/Stylesheets/Restore/Caption\":{\"title\":\"$:/language/ControlPanel/Stylesheets/Restore/Caption\",\"text\":\"复原\"},\"$:/language/ControlPanel/Theme/Caption\":{\"title\":\"$:/language/ControlPanel/Theme/Caption\",\"text\":\"布局主题\"},\"$:/language/ControlPanel/Theme/Prompt\":{\"title\":\"$:/language/ControlPanel/Theme/Prompt\",\"text\":\"当前的布局主题：\"},\"$:/language/ControlPanel/TiddlerColour/Caption\":{\"title\":\"$:/language/ControlPanel/TiddlerColour/Caption\",\"text\":\"条目颜色\"},\"$:/language/ControlPanel/TiddlerColour/Hint\":{\"title\":\"$:/language/ControlPanel/TiddlerColour/Hint\",\"text\":\"此规则级联用于动态地为条目选择颜色 (用于图示和关联的标签丸)。\"},\"$:/language/ControlPanel/TiddlerFields/Caption\":{\"title\":\"$:/language/ControlPanel/TiddlerFields/Caption\",\"text\":\"条目字段\"},\"$:/language/ControlPanel/TiddlerFields/Hint\":{\"title\":\"$:/language/ControlPanel/TiddlerFields/Hint\",\"text\":\"这是本维基使用中的所有条目字段（含系统条目的字段，但默认条目的字段除外）。\"},\"$:/language/ControlPanel/TiddlerIcon/Caption\":{\"title\":\"$:/language/ControlPanel/TiddlerIcon/Caption\",\"text\":\"条目图示\"},\"$:/language/ControlPanel/TiddlerIcon/Hint\":{\"title\":\"$:/language/ControlPanel/TiddlerIcon/Hint\",\"text\":\"此规则级联用于动态地为条目选择图示。\"},\"$:/language/ControlPanel/Toolbars/Caption\":{\"title\":\"$:/language/ControlPanel/Toolbars/Caption\",\"text\":\"工具栏\"},\"$:/language/ControlPanel/Toolbars/EditToolbar/Caption\":{\"title\":\"$:/language/ControlPanel/Toolbars/EditToolbar/Caption\",\"text\":\"编辑工具栏\"},\"$:/language/ControlPanel/Toolbars/EditToolbar/Hint\":{\"title\":\"$:/language/ControlPanel/Toolbars/EditToolbar/Hint\",\"text\":\"选择将显示哪些按钮于条目的编辑模式工具栏。拖放可改变顺序。\"},\"$:/language/ControlPanel/Toolbars/Hint\":{\"title\":\"$:/language/ControlPanel/Toolbars/Hint\",\"text\":\"选择将显示哪些工具栏按钮\"},\"$:/language/ControlPanel/Toolbars/PageControls/Caption\":{\"title\":\"$:/language/ControlPanel/Toolbars/PageControls/Caption\",\"text\":\"页面工具栏\"},\"$:/language/ControlPanel/Toolbars/PageControls/Hint\":{\"title\":\"$:/language/ControlPanel/Toolbars/PageControls/Hint\",\"text\":\"选择将显示哪些按钮于主页面的工具栏。拖放可改变顺序。\"},\"$:/language/ControlPanel/Toolbars/EditorToolbar/Caption\":{\"title\":\"$:/language/ControlPanel/Toolbars/EditorToolbar/Caption\",\"text\":\"编辑器工具栏\"},\"$:/language/ControlPanel/Toolbars/EditorToolbar/Hint\":{\"title\":\"$:/language/ControlPanel/Toolbars/EditorToolbar/Hint\",\"text\":\"选择将显示哪些按钮于编辑器工具栏。请注意，某些按钮只会出现在编辑某一类型的条目时。拖放可改变顺序。\"},\"$:/language/ControlPanel/Toolbars/ViewToolbar/Caption\":{\"title\":\"$:/language/ControlPanel/Toolbars/ViewToolbar/Caption\",\"text\":\"查看工具栏\"},\"$:/language/ControlPanel/Toolbars/ViewToolbar/Hint\":{\"title\":\"$:/language/ControlPanel/Toolbars/ViewToolbar/Hint\",\"text\":\"选择将显示哪些按钮于条目的视图模式工具栏。拖放可改变顺序。\"},\"$:/language/ControlPanel/Tools/Download/Full/Caption\":{\"title\":\"$:/language/ControlPanel/Tools/Download/Full/Caption\",\"text\":\"下载完整副本\"},\"$:/language/ControlPanel/ViewTemplateBody/Caption\":{\"title\":\"$:/language/ControlPanel/ViewTemplateBody/Caption\",\"text\":\"查看模板主体\"},\"$:/language/ControlPanel/ViewTemplateBody/Hint\":{\"title\":\"$:/language/ControlPanel/ViewTemplateBody/Hint\",\"text\":\"默认的查看模板使用此规则级联，动态选择模板以显示条目的主体。\"},\"$:/language/ControlPanel/ViewTemplateTitle/Caption\":{\"title\":\"$:/language/ControlPanel/ViewTemplateTitle/Caption\",\"text\":\"查看模板标题\"},\"$:/language/ControlPanel/ViewTemplateTitle/Hint\":{\"title\":\"$:/language/ControlPanel/ViewTemplateTitle/Hint\",\"text\":\"默认的查看模板使用此规则级联，动态选择模板以显示条目的标题。\"},\"$:/core/zh-Hans/readme\":{\"title\":\"$:/core/zh-Hans/readme\",\"text\":\"此插件包含 TiddlyWiki 的核心组件，包括：\\n\\n* JavaScript 代码模块\\n* 图标\\n* 创建 TiddlyWiki 的用户界面所需的模板\\n* 核心所使用的可当地语系化字串的英国英语 (''en-GB'') 翻译\\n\"},\"$:/language/Date/Long/Day/0\":{\"title\":\"$:/language/Date/Long/Day/0\",\"text\":\"周日\"},\"$:/language/Date/Long/Day/1\":{\"title\":\"$:/language/Date/Long/Day/1\",\"text\":\"周一\"},\"$:/language/Date/Long/Day/2\":{\"title\":\"$:/language/Date/Long/Day/2\",\"text\":\"周二\"},\"$:/language/Date/Long/Day/3\":{\"title\":\"$:/language/Date/Long/Day/3\",\"text\":\"周三\"},\"$:/language/Date/Long/Day/4\":{\"title\":\"$:/language/Date/Long/Day/4\",\"text\":\"周四\"},\"$:/language/Date/Long/Day/5\":{\"title\":\"$:/language/Date/Long/Day/5\",\"text\":\"周五\"},\"$:/language/Date/Long/Day/6\":{\"title\":\"$:/language/Date/Long/Day/6\",\"text\":\"周六\"},\"$:/language/Date/Long/Month/1\":{\"title\":\"$:/language/Date/Long/Month/1\",\"text\":\"一月\"},\"$:/language/Date/Long/Month/2\":{\"title\":\"$:/language/Date/Long/Month/2\",\"text\":\"二月\"},\"$:/language/Date/Long/Month/3\":{\"title\":\"$:/language/Date/Long/Month/3\",\"text\":\"三月\"},\"$:/language/Date/Long/Month/4\":{\"title\":\"$:/language/Date/Long/Month/4\",\"text\":\"四月\"},\"$:/language/Date/Long/Month/5\":{\"title\":\"$:/language/Date/Long/Month/5\",\"text\":\"五月\"},\"$:/language/Date/Long/Month/6\":{\"title\":\"$:/language/Date/Long/Month/6\",\"text\":\"六月\"},\"$:/language/Date/Long/Month/7\":{\"title\":\"$:/language/Date/Long/Month/7\",\"text\":\"七月\"},\"$:/language/Date/Long/Month/8\":{\"title\":\"$:/language/Date/Long/Month/8\",\"text\":\"八月\"},\"$:/language/Date/Long/Month/9\":{\"title\":\"$:/language/Date/Long/Month/9\",\"text\":\"九月\"},\"$:/language/Date/Long/Month/10\":{\"title\":\"$:/language/Date/Long/Month/10\",\"text\":\"十月\"},\"$:/language/Date/Long/Month/11\":{\"title\":\"$:/language/Date/Long/Month/11\",\"text\":\"十一月\"},\"$:/language/Date/Long/Month/12\":{\"title\":\"$:/language/Date/Long/Month/12\",\"text\":\"十二月\"},\"$:/language/Date/Period/am\":{\"title\":\"$:/language/Date/Period/am\",\"text\":\"上午\"},\"$:/language/Date/Period/pm\":{\"title\":\"$:/language/Date/Period/pm\",\"text\":\"下午\"},\"$:/language/Date/Short/Day/0\":{\"title\":\"$:/language/Date/Short/Day/0\",\"text\":\"日\"},\"$:/language/Date/Short/Day/1\":{\"title\":\"$:/language/Date/Short/Day/1\",\"text\":\"一\"},\"$:/language/Date/Short/Day/2\":{\"title\":\"$:/language/Date/Short/Day/2\",\"text\":\"二\"},\"$:/language/Date/Short/Day/3\":{\"title\":\"$:/language/Date/Short/Day/3\",\"text\":\"三\"},\"$:/language/Date/Short/Day/4\":{\"title\":\"$:/language/Date/Short/Day/4\",\"text\":\"四\"},\"$:/language/Date/Short/Day/5\":{\"title\":\"$:/language/Date/Short/Day/5\",\"text\":\"五\"},\"$:/language/Date/Short/Day/6\":{\"title\":\"$:/language/Date/Short/Day/6\",\"text\":\"六\"},\"$:/language/Date/Short/Month/1\":{\"title\":\"$:/language/Date/Short/Month/1\",\"text\":\"01月\"},\"$:/language/Date/Short/Month/2\":{\"title\":\"$:/language/Date/Short/Month/2\",\"text\":\"02月\"},\"$:/language/Date/Short/Month/3\":{\"title\":\"$:/language/Date/Short/Month/3\",\"text\":\"03月\"},\"$:/language/Date/Short/Month/4\":{\"title\":\"$:/language/Date/Short/Month/4\",\"text\":\"04月\"},\"$:/language/Date/Short/Month/5\":{\"title\":\"$:/language/Date/Short/Month/5\",\"text\":\"05月\"},\"$:/language/Date/Short/Month/6\":{\"title\":\"$:/language/Date/Short/Month/6\",\"text\":\"06月\"},\"$:/language/Date/Short/Month/7\":{\"title\":\"$:/language/Date/Short/Month/7\",\"text\":\"07月\"},\"$:/language/Date/Short/Month/8\":{\"title\":\"$:/language/Date/Short/Month/8\",\"text\":\"08月\"},\"$:/language/Date/Short/Month/9\":{\"title\":\"$:/language/Date/Short/Month/9\",\"text\":\"09月\"},\"$:/language/Date/Short/Month/10\":{\"title\":\"$:/language/Date/Short/Month/10\",\"text\":\"10月\"},\"$:/language/Date/Short/Month/11\":{\"title\":\"$:/language/Date/Short/Month/11\",\"text\":\"11月\"},\"$:/language/Date/Short/Month/12\":{\"title\":\"$:/language/Date/Short/Month/12\",\"text\":\"12月\"},\"$:/language/RelativeDate/Future/Days\":{\"title\":\"$:/language/RelativeDate/Future/Days\",\"text\":\"\u003C\u003Cperiod>> 天后\"},\"$:/language/RelativeDate/Future/Hours\":{\"title\":\"$:/language/RelativeDate/Future/Hours\",\"text\":\"\u003C\u003Cperiod>> 小时后\"},\"$:/language/RelativeDate/Future/Minutes\":{\"title\":\"$:/language/RelativeDate/Future/Minutes\",\"text\":\"\u003C\u003Cperiod>> 分钟后\"},\"$:/language/RelativeDate/Future/Months\":{\"title\":\"$:/language/RelativeDate/Future/Months\",\"text\":\"\u003C\u003Cperiod>> 个月后\"},\"$:/language/RelativeDate/Future/Second\":{\"title\":\"$:/language/RelativeDate/Future/Second\",\"text\":\"1 秒后\"},\"$:/language/RelativeDate/Future/Seconds\":{\"title\":\"$:/language/RelativeDate/Future/Seconds\",\"text\":\"\u003C\u003Cperiod>> 秒后\"},\"$:/language/RelativeDate/Future/Years\":{\"title\":\"$:/language/RelativeDate/Future/Years\",\"text\":\"\u003C\u003Cperiod>> 年后\"},\"$:/language/RelativeDate/Past/Days\":{\"title\":\"$:/language/RelativeDate/Past/Days\",\"text\":\"\u003C\u003Cperiod>> 天前\"},\"$:/language/RelativeDate/Past/Hours\":{\"title\":\"$:/language/RelativeDate/Past/Hours\",\"text\":\"\u003C\u003Cperiod>> 小时前\"},\"$:/language/RelativeDate/Past/Minutes\":{\"title\":\"$:/language/RelativeDate/Past/Minutes\",\"text\":\"\u003C\u003Cperiod>> 分钟前\"},\"$:/language/RelativeDate/Past/Months\":{\"title\":\"$:/language/RelativeDate/Past/Months\",\"text\":\"\u003C\u003Cperiod>> 个月前\"},\"$:/language/RelativeDate/Past/Second\":{\"title\":\"$:/language/RelativeDate/Past/Second\",\"text\":\"1 秒前\"},\"$:/language/RelativeDate/Past/Seconds\":{\"title\":\"$:/language/RelativeDate/Past/Seconds\",\"text\":\"\u003C\u003Cperiod>> 秒前\"},\"$:/language/RelativeDate/Past/Years\":{\"title\":\"$:/language/RelativeDate/Past/Years\",\"text\":\"\u003C\u003Cperiod>> 年前\"},\"$:/language/Docs/ModuleTypes/allfilteroperator\":{\"title\":\"$:/language/Docs/ModuleTypes/allfilteroperator\",\"text\":\"''all'' 筛选器算子的子算子。\"},\"$:/language/Docs/ModuleTypes/animation\":{\"title\":\"$:/language/Docs/ModuleTypes/animation\",\"text\":\"动画模块包含可用于 RevealWidget 的动画。\"},\"$:/language/Docs/ModuleTypes/authenticator\":{\"title\":\"$:/language/Docs/ModuleTypes/authenticator\",\"text\":\"定义内置 HTTP 服务器对请求的身份验证方式。\"},\"$:/language/Docs/ModuleTypes/bitmapeditoroperation\":{\"title\":\"$:/language/Docs/ModuleTypes/bitmapeditoroperation\",\"text\":\"一个位图编辑器工具栏操作。\"},\"$:/language/Docs/ModuleTypes/command\":{\"title\":\"$:/language/Docs/ModuleTypes/command\",\"text\":\"可于 Node.js 执行的指令。\"},\"$:/language/Docs/ModuleTypes/config\":{\"title\":\"$:/language/Docs/ModuleTypes/config\",\"text\":\"加入 `$tw.config` 的数据。\"},\"$:/language/Docs/ModuleTypes/filteroperator\":{\"title\":\"$:/language/Docs/ModuleTypes/filteroperator\",\"text\":\"个别筛选器算子方法。\"},\"$:/language/Docs/ModuleTypes/global\":{\"title\":\"$:/language/Docs/ModuleTypes/global\",\"text\":\"加入 `$tw` 的全域数据。\"},\"$:/language/Docs/ModuleTypes/info\":{\"title\":\"$:/language/Docs/ModuleTypes/info\",\"text\":\"透过 [[$:/temp/info-plugin]] 伪插件，发布系统信息。\"},\"$:/language/Docs/ModuleTypes/isfilteroperator\":{\"title\":\"$:/language/Docs/ModuleTypes/isfilteroperator\",\"text\":\"''is'' 筛选器算子的运算符。\"},\"$:/language/Docs/ModuleTypes/library\":{\"title\":\"$:/language/Docs/ModuleTypes/library\",\"text\":\"一般用途的 JavaScript 模块的通用模块类型。\"},\"$:/language/Docs/ModuleTypes/macro\":{\"title\":\"$:/language/Docs/ModuleTypes/macro\",\"text\":\"JavaScript ''宏''定义。\"},\"$:/language/Docs/ModuleTypes/parser\":{\"title\":\"$:/language/Docs/ModuleTypes/parser\",\"text\":\"不同内容类型的解析器。\"},\"$:/language/Docs/ModuleTypes/route\":{\"title\":\"$:/language/Docs/ModuleTypes/route\",\"text\":\"定义内置 HTTP 服务器如何处理各个网址格式。\"},\"$:/language/Docs/ModuleTypes/saver\":{\"title\":\"$:/language/Docs/ModuleTypes/saver\",\"text\":\"于浏览器保存文件的不同的保存处理方法。\"},\"$:/language/Docs/ModuleTypes/startup\":{\"title\":\"$:/language/Docs/ModuleTypes/startup\",\"text\":\"启动时期的功能函数。\"},\"$:/language/Docs/ModuleTypes/storyview\":{\"title\":\"$:/language/Docs/ModuleTypes/storyview\",\"text\":\"视图模式用以自订 list 小部件的动画与行为。\"},\"$:/language/Docs/ModuleTypes/texteditoroperation\":{\"title\":\"$:/language/Docs/ModuleTypes/texteditoroperation\",\"text\":\"一个文本编辑器工具栏操作。\"},\"$:/language/Docs/ModuleTypes/tiddlerdeserializer\":{\"title\":\"$:/language/Docs/ModuleTypes/tiddlerdeserializer\",\"text\":\"转换不同内容类型至条目。\"},\"$:/language/Docs/ModuleTypes/tiddlerfield\":{\"title\":\"$:/language/Docs/ModuleTypes/tiddlerfield\",\"text\":\"定义个别条目字段的行为。\"},\"$:/language/Docs/ModuleTypes/tiddlermethod\":{\"title\":\"$:/language/Docs/ModuleTypes/tiddlermethod\",\"text\":\"添加方法至 `$tw.Tiddler` 原型。\"},\"$:/language/Docs/ModuleTypes/upgrader\":{\"title\":\"$:/language/Docs/ModuleTypes/upgrader\",\"text\":\"于升级/导入过程中，套用升级处理至条目。\"},\"$:/language/Docs/ModuleTypes/utils\":{\"title\":\"$:/language/Docs/ModuleTypes/utils\",\"text\":\"添加方法至 `$tw.utils`。\"},\"$:/language/Docs/ModuleTypes/utils-browser\":{\"title\":\"$:/language/Docs/ModuleTypes/utils-browser\",\"text\":\"将特定于浏览器的方法添加到 `$tw.utils`。\"},\"$:/language/Docs/ModuleTypes/utils-node\":{\"title\":\"$:/language/Docs/ModuleTypes/utils-node\",\"text\":\"将特定于 Node.js 的方法添加到 `$tw.utils`。\"},\"$:/language/Docs/ModuleTypes/widget\":{\"title\":\"$:/language/Docs/ModuleTypes/widget\",\"text\":\"封装 DOM 渲染和刷新的小部件。\"},\"$:/language/Docs/ModuleTypes/wikimethod\":{\"title\":\"$:/language/Docs/ModuleTypes/wikimethod\",\"text\":\"添加方法至 `$tw.Wiki`。\"},\"$:/language/Docs/ModuleTypes/wikirule\":{\"title\":\"$:/language/Docs/ModuleTypes/wikirule\",\"text\":\"WikiText 解析器的个别的语法规则。\"},\"$:/language/Docs/PaletteColours/alert-background\":{\"title\":\"$:/language/Docs/PaletteColours/alert-background\",\"text\":\"提醒背景\"},\"$:/language/Docs/PaletteColours/alert-border\":{\"title\":\"$:/language/Docs/PaletteColours/alert-border\",\"text\":\"提醒边框\"},\"$:/language/Docs/PaletteColours/alert-highlight\":{\"title\":\"$:/language/Docs/PaletteColours/alert-highlight\",\"text\":\"提醒高亮度\"},\"$:/language/Docs/PaletteColours/alert-muted-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/alert-muted-foreground\",\"text\":\"提醒的低调前景\"},\"$:/language/Docs/PaletteColours/background\":{\"title\":\"$:/language/Docs/PaletteColours/background\",\"text\":\"一般背景\"},\"$:/language/Docs/PaletteColours/blockquote-bar\":{\"title\":\"$:/language/Docs/PaletteColours/blockquote-bar\",\"text\":\"引用条\"},\"$:/language/Docs/PaletteColours/button-background\":{\"title\":\"$:/language/Docs/PaletteColours/button-background\",\"text\":\"默认按钮背景\"},\"$:/language/Docs/PaletteColours/button-border\":{\"title\":\"$:/language/Docs/PaletteColours/button-border\",\"text\":\"默认按钮边框\"},\"$:/language/Docs/PaletteColours/button-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/button-foreground\",\"text\":\"默认按钮前景\"},\"$:/language/Docs/PaletteColours/code-background\":{\"title\":\"$:/language/Docs/PaletteColours/code-background\",\"text\":\"代码背景\"},\"$:/language/Docs/PaletteColours/code-border\":{\"title\":\"$:/language/Docs/PaletteColours/code-border\",\"text\":\"代码边框\"},\"$:/language/Docs/PaletteColours/code-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/code-foreground\",\"text\":\"代码前景\"},\"$:/language/Docs/PaletteColours/dirty-indicator\":{\"title\":\"$:/language/Docs/PaletteColours/dirty-indicator\",\"text\":\"未保存变更指示器\"},\"$:/language/Docs/PaletteColours/download-background\":{\"title\":\"$:/language/Docs/PaletteColours/download-background\",\"text\":\"下载按钮背景\"},\"$:/language/Docs/PaletteColours/download-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/download-foreground\",\"text\":\"下载按钮前景\"},\"$:/language/Docs/PaletteColours/dragger-background\":{\"title\":\"$:/language/Docs/PaletteColours/dragger-background\",\"text\":\"拖动区背景\"},\"$:/language/Docs/PaletteColours/dragger-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/dragger-foreground\",\"text\":\"拖动区前景\"},\"$:/language/Docs/PaletteColours/dropdown-background\":{\"title\":\"$:/language/Docs/PaletteColours/dropdown-background\",\"text\":\"下拉背景\"},\"$:/language/Docs/PaletteColours/dropdown-border\":{\"title\":\"$:/language/Docs/PaletteColours/dropdown-border\",\"text\":\"下拉边框\"},\"$:/language/Docs/PaletteColours/dropdown-tab-background-selected\":{\"title\":\"$:/language/Docs/PaletteColours/dropdown-tab-background-selected\",\"text\":\"选定的下拉页签背景\"},\"$:/language/Docs/PaletteColours/dropdown-tab-background\":{\"title\":\"$:/language/Docs/PaletteColours/dropdown-tab-background\",\"text\":\"下拉页签背景\"},\"$:/language/Docs/PaletteColours/dropzone-background\":{\"title\":\"$:/language/Docs/PaletteColours/dropzone-background\",\"text\":\"拖放背景\"},\"$:/language/Docs/PaletteColours/external-link-background-hover\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-background-hover\",\"text\":\"悬停外部链结背景\"},\"$:/language/Docs/PaletteColours/external-link-background-visited\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-background-visited\",\"text\":\"已造访过的外部链结背景\"},\"$:/language/Docs/PaletteColours/external-link-background\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-background\",\"text\":\"外部链结背景\"},\"$:/language/Docs/PaletteColours/external-link-foreground-hover\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-foreground-hover\",\"text\":\"悬停外部链结前景\"},\"$:/language/Docs/PaletteColours/external-link-foreground-visited\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-foreground-visited\",\"text\":\"已造访过的外部链结前景\"},\"$:/language/Docs/PaletteColours/external-link-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/external-link-foreground\",\"text\":\"外部链结前景\"},\"$:/language/Docs/PaletteColours/foreground\":{\"title\":\"$:/language/Docs/PaletteColours/foreground\",\"text\":\"一般前景\"},\"$:/language/Docs/PaletteColours/menubar-background\":{\"title\":\"$:/language/Docs/PaletteColours/menubar-background\",\"text\":\"菜单列背景\"},\"$:/language/Docs/PaletteColours/menubar-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/menubar-foreground\",\"text\":\"菜单列前景\"},\"$:/language/Docs/PaletteColours/message-background\":{\"title\":\"$:/language/Docs/PaletteColours/message-background\",\"text\":\"信息框背景\"},\"$:/language/Docs/PaletteColours/message-border\":{\"title\":\"$:/language/Docs/PaletteColours/message-border\",\"text\":\"信息边框\"},\"$:/language/Docs/PaletteColours/message-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/message-foreground\",\"text\":\"信息框前景\"},\"$:/language/Docs/PaletteColours/modal-backdrop\":{\"title\":\"$:/language/Docs/PaletteColours/modal-backdrop\",\"text\":\"模块背景幕\"},\"$:/language/Docs/PaletteColours/modal-background\":{\"title\":\"$:/language/Docs/PaletteColours/modal-background\",\"text\":\"模块背景\"},\"$:/language/Docs/PaletteColours/modal-border\":{\"title\":\"$:/language/Docs/PaletteColours/modal-border\",\"text\":\"模块边框\"},\"$:/language/Docs/PaletteColours/modal-footer-background\":{\"title\":\"$:/language/Docs/PaletteColours/modal-footer-background\",\"text\":\"模块页脚背景\"},\"$:/language/Docs/PaletteColours/modal-footer-border\":{\"title\":\"$:/language/Docs/PaletteColours/modal-footer-border\",\"text\":\"模块页脚边框\"},\"$:/language/Docs/PaletteColours/modal-header-border\":{\"title\":\"$:/language/Docs/PaletteColours/modal-header-border\",\"text\":\"模块标题边框\"},\"$:/language/Docs/PaletteColours/muted-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/muted-foreground\",\"text\":\"一般低调前景\"},\"$:/language/Docs/PaletteColours/notification-background\":{\"title\":\"$:/language/Docs/PaletteColours/notification-background\",\"text\":\"通知背景\"},\"$:/language/Docs/PaletteColours/notification-border\":{\"title\":\"$:/language/Docs/PaletteColours/notification-border\",\"text\":\"通知边框\"},\"$:/language/Docs/PaletteColours/page-background\":{\"title\":\"$:/language/Docs/PaletteColours/page-background\",\"text\":\"页面背景\"},\"$:/language/Docs/PaletteColours/pre-background\":{\"title\":\"$:/language/Docs/PaletteColours/pre-background\",\"text\":\"pre 背景\"},\"$:/language/Docs/PaletteColours/pre-border\":{\"title\":\"$:/language/Docs/PaletteColours/pre-border\",\"text\":\"pre 边框\"},\"$:/language/Docs/PaletteColours/primary\":{\"title\":\"$:/language/Docs/PaletteColours/primary\",\"text\":\"主颜色\"},\"$:/language/Docs/PaletteColours/select-tag-background\":{\"title\":\"$:/language/Docs/PaletteColours/select-tag-background\",\"text\":\"`\u003Cselect>` 元素背景\"},\"$:/language/Docs/PaletteColours/select-tag-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/select-tag-foreground\",\"text\":\"`\u003Cselect>` 元素文本\"},\"$:/language/Docs/PaletteColours/sidebar-button-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-button-foreground\",\"text\":\"侧边栏按钮前景\"},\"$:/language/Docs/PaletteColours/sidebar-controls-foreground-hover\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-controls-foreground-hover\",\"text\":\"悬停侧边栏控制项前景\"},\"$:/language/Docs/PaletteColours/sidebar-controls-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-controls-foreground\",\"text\":\"侧边栏控制项前景\"},\"$:/language/Docs/PaletteColours/sidebar-foreground-shadow\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-foreground-shadow\",\"text\":\"侧边栏前景阴影\"},\"$:/language/Docs/PaletteColours/sidebar-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-foreground\",\"text\":\"侧边栏前景\"},\"$:/language/Docs/PaletteColours/sidebar-muted-foreground-hover\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-muted-foreground-hover\",\"text\":\"悬停侧边栏低调前景\"},\"$:/language/Docs/PaletteColours/sidebar-muted-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-muted-foreground\",\"text\":\"侧边栏低调前景\"},\"$:/language/Docs/PaletteColours/sidebar-tab-background-selected\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-background-selected\",\"text\":\"侧边栏选定页签背景\"},\"$:/language/Docs/PaletteColours/sidebar-tab-background\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-background\",\"text\":\"侧边栏页签背景\"},\"$:/language/Docs/PaletteColours/sidebar-tab-border-selected\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-border-selected\",\"text\":\"侧边栏选定页签边框\"},\"$:/language/Docs/PaletteColours/sidebar-tab-border\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-border\",\"text\":\"侧边栏页签边框\"},\"$:/language/Docs/PaletteColours/sidebar-tab-divider\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-divider\",\"text\":\"侧边栏页签分隔线\"},\"$:/language/Docs/PaletteColours/sidebar-tab-foreground-selected\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-foreground-selected\",\"text\":\"侧边栏选定页签前景\"},\"$:/language/Docs/PaletteColours/sidebar-tab-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tab-foreground\",\"text\":\"侧边栏页签前景\"},\"$:/language/Docs/PaletteColours/sidebar-tiddler-link-foreground-hover\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tiddler-link-foreground-hover\",\"text\":\"侧边栏悬停条目链结前景\"},\"$:/language/Docs/PaletteColours/sidebar-tiddler-link-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/sidebar-tiddler-link-foreground\",\"text\":\"侧边栏条目链结前景\"},\"$:/language/Docs/PaletteColours/site-title-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/site-title-foreground\",\"text\":\"网站标题前景\"},\"$:/language/Docs/PaletteColours/static-alert-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/static-alert-foreground\",\"text\":\"静态提醒前景\"},\"$:/language/Docs/PaletteColours/tab-background-selected\":{\"title\":\"$:/language/Docs/PaletteColours/tab-background-selected\",\"text\":\"选定的页签背景\"},\"$:/language/Docs/PaletteColours/tab-background\":{\"title\":\"$:/language/Docs/PaletteColours/tab-background\",\"text\":\"页签背景\"},\"$:/language/Docs/PaletteColours/tab-border-selected\":{\"title\":\"$:/language/Docs/PaletteColours/tab-border-selected\",\"text\":\"选定的页签边框\"},\"$:/language/Docs/PaletteColours/tab-border\":{\"title\":\"$:/language/Docs/PaletteColours/tab-border\",\"text\":\"页签边框\"},\"$:/language/Docs/PaletteColours/tab-divider\":{\"title\":\"$:/language/Docs/PaletteColours/tab-divider\",\"text\":\"页签分隔线\"},\"$:/language/Docs/PaletteColours/tab-foreground-selected\":{\"title\":\"$:/language/Docs/PaletteColours/tab-foreground-selected\",\"text\":\"选定的页签前景\"},\"$:/language/Docs/PaletteColours/tab-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tab-foreground\",\"text\":\"页签前景\"},\"$:/language/Docs/PaletteColours/table-border\":{\"title\":\"$:/language/Docs/PaletteColours/table-border\",\"text\":\"表格边框\"},\"$:/language/Docs/PaletteColours/table-footer-background\":{\"title\":\"$:/language/Docs/PaletteColours/table-footer-background\",\"text\":\"表格页脚背景\"},\"$:/language/Docs/PaletteColours/table-header-background\":{\"title\":\"$:/language/Docs/PaletteColours/table-header-background\",\"text\":\"表格标题背景\"},\"$:/language/Docs/PaletteColours/tag-background\":{\"title\":\"$:/language/Docs/PaletteColours/tag-background\",\"text\":\"标签背景\"},\"$:/language/Docs/PaletteColours/tag-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tag-foreground\",\"text\":\"标签前景\"},\"$:/language/Docs/PaletteColours/tiddler-background\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-background\",\"text\":\"条目背景\"},\"$:/language/Docs/PaletteColours/tiddler-border\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-border\",\"text\":\"条目边框\"},\"$:/language/Docs/PaletteColours/tiddler-controls-foreground-hover\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-controls-foreground-hover\",\"text\":\"悬停的条目控制项前景\"},\"$:/language/Docs/PaletteColours/tiddler-controls-foreground-selected\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-controls-foreground-selected\",\"text\":\"选定的条目控制项前景\"},\"$:/language/Docs/PaletteColours/tiddler-controls-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-controls-foreground\",\"text\":\"条目控制项前景\"},\"$:/language/Docs/PaletteColours/tiddler-editor-background\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-editor-background\",\"text\":\"条目编辑器背景\"},\"$:/language/Docs/PaletteColours/tiddler-editor-border-image\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-editor-border-image\",\"text\":\"条目编辑器边框图片\"},\"$:/language/Docs/PaletteColours/tiddler-editor-border\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-editor-border\",\"text\":\"条目编辑器边框\"},\"$:/language/Docs/PaletteColours/tiddler-editor-fields-even\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-editor-fields-even\",\"text\":\"条目编辑器中偶数字段背景\"},\"$:/language/Docs/PaletteColours/tiddler-editor-fields-odd\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-editor-fields-odd\",\"text\":\"条目编辑器中奇数字段背景\"},\"$:/language/Docs/PaletteColours/tiddler-info-background\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-info-background\",\"text\":\"条目信息面板背景\"},\"$:/language/Docs/PaletteColours/tiddler-info-border\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-info-border\",\"text\":\"条目信息面板边框\"},\"$:/language/Docs/PaletteColours/tiddler-info-tab-background\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-info-tab-background\",\"text\":\"条目信息面板页签背景\"},\"$:/language/Docs/PaletteColours/tiddler-link-background\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-link-background\",\"text\":\"条目链结背景\"},\"$:/language/Docs/PaletteColours/tiddler-link-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-link-foreground\",\"text\":\"条目链结前景\"},\"$:/language/Docs/PaletteColours/tiddler-subtitle-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-subtitle-foreground\",\"text\":\"条目副标题前景\"},\"$:/language/Docs/PaletteColours/tiddler-title-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/tiddler-title-foreground\",\"text\":\"条目标题前景\"},\"$:/language/Docs/PaletteColours/toolbar-new-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-new-button\",\"text\":\"工具栏 '添加条目' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-options-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-options-button\",\"text\":\"工具栏 '选项' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-save-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-save-button\",\"text\":\"工具栏 '保存' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-info-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-info-button\",\"text\":\"工具栏 '资讯' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-edit-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-edit-button\",\"text\":\"工具栏 '编辑' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-close-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-close-button\",\"text\":\"工具栏 '关闭' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-delete-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-delete-button\",\"text\":\"工具栏 '删除' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-cancel-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-cancel-button\",\"text\":\"工具栏 '取消' 按钮前景\"},\"$:/language/Docs/PaletteColours/toolbar-done-button\":{\"title\":\"$:/language/Docs/PaletteColours/toolbar-done-button\",\"text\":\"工具栏 '完成  按钮前景\"},\"$:/language/Docs/PaletteColours/untagged-background\":{\"title\":\"$:/language/Docs/PaletteColours/untagged-background\",\"text\":\"未设标签的背景\"},\"$:/language/Docs/PaletteColours/very-muted-foreground\":{\"title\":\"$:/language/Docs/PaletteColours/very-muted-foreground\",\"text\":\"非常低调前景\"},\"$:/language/EditTemplate/Caption\":{\"title\":\"$:/language/EditTemplate/Caption\",\"text\":\"编辑器\"},\"$:/language/EditTemplate/Body/External/Hint\":{\"title\":\"$:/language/EditTemplate/Body/External/Hint\",\"text\":\"此条目显示保存于主要的 TiddlyWiki 文件之外的内容。你可以编辑其标签和字段，但不能直接编辑内容本身\"},\"$:/language/EditTemplate/Body/Placeholder\":{\"title\":\"$:/language/EditTemplate/Body/Placeholder\",\"text\":\"输入此条目的内容\"},\"$:/language/EditTemplate/Body/Preview/Type/Output\":{\"title\":\"$:/language/EditTemplate/Body/Preview/Type/Output\",\"text\":\"输出\"},\"$:/language/EditTemplate/Body/Preview/Type/DiffShadow\":{\"title\":\"$:/language/EditTemplate/Body/Preview/Type/DiffShadow\",\"text\":\"与影子条目的差异（如果有）\"},\"$:/language/EditTemplate/Body/Preview/Type/DiffCurrent\":{\"title\":\"$:/language/EditTemplate/Body/Preview/Type/DiffCurrent\",\"text\":\"与当前条目的差异\"},\"$:/language/EditTemplate/Field/Remove/Caption\":{\"title\":\"$:/language/EditTemplate/Field/Remove/Caption\",\"text\":\"删除字段\"},\"$:/language/EditTemplate/Field/Remove/Hint\":{\"title\":\"$:/language/EditTemplate/Field/Remove/Hint\",\"text\":\"删除字段\"},\"$:/language/EditTemplate/Field/Dropdown/Caption\":{\"title\":\"$:/language/EditTemplate/Field/Dropdown/Caption\",\"text\":\"字段列表\"},\"$:/language/EditTemplate/Field/Dropdown/Hint\":{\"title\":\"$:/language/EditTemplate/Field/Dropdown/Hint\",\"text\":\"显示字段列表\"},\"$:/language/EditTemplate/Fields/Add/Button\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Button\",\"text\":\"添加\"},\"$:/language/EditTemplate/Fields/Add/Button/Hint\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Button/Hint\",\"text\":\"添加字段至条目\"},\"$:/language/EditTemplate/Fields/Add/Dropdown/System\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Dropdown/System\",\"text\":\"系统字段\"},\"$:/language/EditTemplate/Fields/Add/Dropdown/User\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Dropdown/User\",\"text\":\"使用者字段\"},\"$:/language/EditTemplate/Fields/Add/Name/Placeholder\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Name/Placeholder\",\"text\":\"字段名称\"},\"$:/language/EditTemplate/Fields/Add/Prompt\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Prompt\",\"text\":\"添加字段：\"},\"$:/language/EditTemplate/Fields/Add/Value/Placeholder\":{\"title\":\"$:/language/EditTemplate/Fields/Add/Value/Placeholder\",\"text\":\"字段内容\"},\"$:/language/EditTemplate/Shadow/Warning\":{\"title\":\"$:/language/EditTemplate/Shadow/Warning\",\"text\":\"这是一个默认条目。您做的任何更改将会覆盖来自 \u003C\u003CpluginLink>> 插件的默认版本。\"},\"$:/language/EditTemplate/Shadow/OverriddenWarning\":{\"title\":\"$:/language/EditTemplate/Shadow/OverriddenWarning\",\"text\":\"这是一个修改过的默认条目。删除此条目可以还原为 \u003C\u003CpluginLink>> 插件中的默认版本。\"},\"$:/language/EditTemplate/Tags/Add/Button\":{\"title\":\"$:/language/EditTemplate/Tags/Add/Button\",\"text\":\"添加\"},\"$:/language/EditTemplate/Tags/Add/Button/Hint\":{\"title\":\"$:/language/EditTemplate/Tags/Add/Button/Hint\",\"text\":\"添加标签\"},\"$:/language/EditTemplate/Tags/Add/Placeholder\":{\"title\":\"$:/language/EditTemplate/Tags/Add/Placeholder\",\"text\":\"标签名称\"},\"$:/language/EditTemplate/Tags/ClearInput/Caption\":{\"title\":\"$:/language/EditTemplate/Tags/ClearInput/Caption\",\"text\":\"清除输入\"},\"$:/language/EditTemplate/Tags/ClearInput/Hint\":{\"title\":\"$:/language/EditTemplate/Tags/ClearInput/Hint\",\"text\":\"清除标签输入\"},\"$:/language/EditTemplate/Tags/Dropdown/Caption\":{\"title\":\"$:/language/EditTemplate/Tags/Dropdown/Caption\",\"text\":\"标签清单\"},\"$:/language/EditTemplate/Tags/Dropdown/Hint\":{\"title\":\"$:/language/EditTemplate/Tags/Dropdown/Hint\",\"text\":\"显示标签清单\"},\"$:/language/EditTemplate/Title/BadCharacterWarning\":{\"title\":\"$:/language/EditTemplate/Title/BadCharacterWarning\",\"text\":\"请注意，避免在条目名称中使用这些字符：\u003C\u003Cbad-chars>>\"},\"$:/language/EditTemplate/Title/Exists/Prompt\":{\"title\":\"$:/language/EditTemplate/Title/Exists/Prompt\",\"text\":\"目标条目已经存在\"},\"$:/language/EditTemplate/Title/Relink/Prompt\":{\"title\":\"$:/language/EditTemplate/Title/Relink/Prompt\",\"text\":\"将在其他条目的 //tags// 和 //list// 字段中的 ''\u003C$text text=\u003C\u003CfromTitle>>/>'' 改为 ''\u003C$text text=\u003C\u003CtoTitle>>/>''\"},\"$:/language/EditTemplate/Title/References/Prompt\":{\"title\":\"$:/language/EditTemplate/Title/References/Prompt\",\"text\":\"下列对此条目的引用，不会自动更新：\"},\"$:/language/EditTemplate/Type/Dropdown/Caption\":{\"title\":\"$:/language/EditTemplate/Type/Dropdown/Caption\",\"text\":\"内容类型清单\"},\"$:/language/EditTemplate/Type/Dropdown/Hint\":{\"title\":\"$:/language/EditTemplate/Type/Dropdown/Hint\",\"text\":\"显示内容类型清单\"},\"$:/language/EditTemplate/Type/Delete/Caption\":{\"title\":\"$:/language/EditTemplate/Type/Delete/Caption\",\"text\":\"删除内容类型\"},\"$:/language/EditTemplate/Type/Delete/Hint\":{\"title\":\"$:/language/EditTemplate/Type/Delete/Hint\",\"text\":\"删除内容类型\"},\"$:/language/EditTemplate/Type/Placeholder\":{\"title\":\"$:/language/EditTemplate/Type/Placeholder\",\"text\":\"内容类型\"},\"$:/language/EditTemplate/Type/Prompt\":{\"title\":\"$:/language/EditTemplate/Type/Prompt\",\"text\":\"类型：\"},\"$:/language/Exporters/StaticRiver\":{\"title\":\"$:/language/Exporters/StaticRiver\",\"text\":\"静态 HTML\"},\"$:/language/Exporters/JsonFile\":{\"title\":\"$:/language/Exporters/JsonFile\",\"text\":\"JSON 文件\"},\"$:/language/Exporters/CsvFile\":{\"title\":\"$:/language/Exporters/CsvFile\",\"text\":\"CSV 文件\"},\"$:/language/Exporters/TidFile\":{\"title\":\"$:/language/Exporters/TidFile\",\"text\":\"\\\".tid\\\" 文件\"},\"$:/language/Docs/Fields/_canonical_uri\":{\"title\":\"$:/language/Docs/Fields/_canonical_uri\",\"text\":\"外部图像条目的完整的 URI\"},\"$:/language/Docs/Fields/author\":{\"title\":\"$:/language/Docs/Fields/author\",\"text\":\"一个插件作者的姓名\"},\"$:/language/Docs/Fields/bag\":{\"title\":\"$:/language/Docs/Fields/bag\",\"text\":\"条目的来源集的名称\"},\"$:/language/Docs/Fields/caption\":{\"title\":\"$:/language/Docs/Fields/caption\",\"text\":\"显示于页签或按钮上的标题文字\"},\"$:/language/Docs/Fields/code-body\":{\"title\":\"$:/language/Docs/Fields/code-body\",\"text\":\"若设置为 ''yes''，视图模板将以程式码形式显示条目\"},\"$:/language/Docs/Fields/color\":{\"title\":\"$:/language/Docs/Fields/color\",\"text\":\"条目的 CSS 颜色值\"},\"$:/language/Docs/Fields/component\":{\"title\":\"$:/language/Docs/Fields/component\",\"text\":\"负责[[提醒条目|AlertMechanism]]的组件名称\"},\"$:/language/Docs/Fields/core-version\":{\"title\":\"$:/language/Docs/Fields/core-version\",\"text\":\"对于一个插件，表示与其兼容的 TiddlyWiki 版本\"},\"$:/language/Docs/Fields/created\":{\"title\":\"$:/language/Docs/Fields/created\",\"text\":\"条目的创建日期\"},\"$:/language/Docs/Fields/creator\":{\"title\":\"$:/language/Docs/Fields/creator\",\"text\":\"条目的创建者\"},\"$:/language/Docs/Fields/current-tiddler\":{\"title\":\"$:/language/Docs/Fields/current-tiddler\",\"text\":\"用于缓存[[浏览历史列表|HistoryMechanism]]的最上层条目\"},\"$:/language/Docs/Fields/dependents\":{\"title\":\"$:/language/Docs/Fields/dependents\",\"text\":\"插件的依赖插件列表\"},\"$:/language/Docs/Fields/description\":{\"title\":\"$:/language/Docs/Fields/description\",\"text\":\"插件的说明、描述\"},\"$:/language/Docs/Fields/draft.of\":{\"title\":\"$:/language/Docs/Fields/draft.of\",\"text\":\"草稿条目，包含条目的标题、标签、字段 ...\"},\"$:/language/Docs/Fields/draft.title\":{\"title\":\"$:/language/Docs/Fields/draft.title\",\"text\":\"草稿条目的标题\"},\"$:/language/Docs/Fields/footer\":{\"title\":\"$:/language/Docs/Fields/footer\",\"text\":\"互动窗口的注脚\"},\"$:/language/Docs/Fields/hide-body\":{\"title\":\"$:/language/Docs/Fields/hide-body\",\"text\":\"若设置为 ''yes''，视图模板将隐藏条目的主体\"},\"$:/language/Docs/Fields/icon\":{\"title\":\"$:/language/Docs/Fields/icon\",\"text\":\"条目的标题含有与条目关联的图标\"},\"$:/language/Docs/Fields/library\":{\"title\":\"$:/language/Docs/Fields/library\",\"text\":\"若设置为 ''yes''，表示条目应该被保存为一个 JavaScript 程序库\"},\"$:/language/Docs/Fields/list\":{\"title\":\"$:/language/Docs/Fields/list\",\"text\":\"条目的列表，指定一些条目的标题清单\"},\"$:/language/Docs/Fields/list-before\":{\"title\":\"$:/language/Docs/Fields/list-before\",\"text\":\"前条目名称将被添加到条目排序清单中的设置条目名称之前，或若此字段存在但是空的，则被添加于清单的前端\"},\"$:/language/Docs/Fields/list-after\":{\"title\":\"$:/language/Docs/Fields/list-after\",\"text\":\"当前条目名称将被添加到条目排序清单的设置条目名称之后，或若此字段存在但是空的，则被添加于清单的尾端\"},\"$:/language/Docs/Fields/modified\":{\"title\":\"$:/language/Docs/Fields/modified\",\"text\":\"条目的最近修改日期与时间\"},\"$:/language/Docs/Fields/modifier\":{\"title\":\"$:/language/Docs/Fields/modifier\",\"text\":\"条目的最近修改者\"},\"$:/language/Docs/Fields/module-type\":{\"title\":\"$:/language/Docs/Fields/module-type\",\"text\":\"对于 javascript 条目，指定其为何种模组\"},\"$:/language/Docs/Fields/name\":{\"title\":\"$:/language/Docs/Fields/name\",\"text\":\"具可读性的插件条目的名称\"},\"$:/language/Docs/Fields/parent-plugin\":{\"title\":\"$:/language/Docs/Fields/parent-plugin\",\"text\":\"对于一个插件，指定其为哪个插件的子插件\"},\"$:/language/Docs/Fields/plugin-priority\":{\"title\":\"$:/language/Docs/Fields/plugin-priority\",\"text\":\"插件条目的优先级数值\"},\"$:/language/Docs/Fields/plugin-type\":{\"title\":\"$:/language/Docs/Fields/plugin-type\",\"text\":\"插件条目的类型\"},\"$:/language/Docs/Fields/released\":{\"title\":\"$:/language/Docs/Fields/released\",\"text\":\"TiddlyWiki 的发布日期\"},\"$:/language/Docs/Fields/revision\":{\"title\":\"$:/language/Docs/Fields/revision\",\"text\":\"条目存放于服务器中的修订版本\"},\"$:/language/Docs/Fields/source\":{\"title\":\"$:/language/Docs/Fields/source\",\"text\":\"条目的网址\"},\"$:/language/Docs/Fields/subtitle\":{\"title\":\"$:/language/Docs/Fields/subtitle\",\"text\":\"互动窗口的副标题\"},\"$:/language/Docs/Fields/tags\":{\"title\":\"$:/language/Docs/Fields/tags\",\"text\":\"条目的标签清单\"},\"$:/language/Docs/Fields/text\":{\"title\":\"$:/language/Docs/Fields/text\",\"text\":\"条目的内文\"},\"$:/language/Docs/Fields/throttle.refresh\":{\"title\":\"$:/language/Docs/Fields/throttle.refresh\",\"text\":\"如果存在，则限制此条目的刷新\"},\"$:/language/Docs/Fields/title\":{\"title\":\"$:/language/Docs/Fields/title\",\"text\":\"条目的唯一名称\"},\"$:/language/Docs/Fields/toc-link\":{\"title\":\"$:/language/Docs/Fields/toc-link\",\"text\":\"若设置为 ''no''，则抑制目录树中的条目链接。\"},\"$:/language/Docs/Fields/type\":{\"title\":\"$:/language/Docs/Fields/type\",\"text\":\"条目的内容类型\"},\"$:/language/Docs/Fields/version\":{\"title\":\"$:/language/Docs/Fields/version\",\"text\":\"插件的版本信息\"},\"$:/language/Docs/Fields/_is_skinny\":{\"title\":\"$:/language/Docs/Fields/_is_skinny\",\"text\":\"如果存在，则表示必须从服务器加载条目的文本字段\"},\"$:/language/Filters/AllTiddlers\":{\"title\":\"$:/language/Filters/AllTiddlers\",\"text\":\"所有条目，不含系统条目\"},\"$:/language/Filters/RecentSystemTiddlers\":{\"title\":\"$:/language/Filters/RecentSystemTiddlers\",\"text\":\"最近修改的条目，包含系统条目\"},\"$:/language/Filters/RecentTiddlers\":{\"title\":\"$:/language/Filters/RecentTiddlers\",\"text\":\"最近修改的条目\"},\"$:/language/Filters/AllTags\":{\"title\":\"$:/language/Filters/AllTags\",\"text\":\"所有标签，不含系统标签\"},\"$:/language/Filters/Missing\":{\"title\":\"$:/language/Filters/Missing\",\"text\":\"缺失条目\"},\"$:/language/Filters/Drafts\":{\"title\":\"$:/language/Filters/Drafts\",\"text\":\"草稿条目\"},\"$:/language/Filters/Orphans\":{\"title\":\"$:/language/Filters/Orphans\",\"text\":\"孤立条目\"},\"$:/language/Filters/SystemTiddlers\":{\"title\":\"$:/language/Filters/SystemTiddlers\",\"text\":\"系统条目\"},\"$:/language/Filters/ShadowTiddlers\":{\"title\":\"$:/language/Filters/ShadowTiddlers\",\"text\":\"默认条目\"},\"$:/language/Filters/OverriddenShadowTiddlers\":{\"title\":\"$:/language/Filters/OverriddenShadowTiddlers\",\"text\":\"被覆盖的默认条目\"},\"$:/language/Filters/SessionTiddlers\":{\"title\":\"$:/language/Filters/SessionTiddlers\",\"text\":\"自维基加载后修改的条目\"},\"$:/language/Filters/SystemTags\":{\"title\":\"$:/language/Filters/SystemTags\",\"text\":\"系统标签\"},\"$:/language/Filters/StoryList\":{\"title\":\"$:/language/Filters/StoryList\",\"text\":\"故事河中的条目，不含 ~$:/AdvancedSearch\"},\"$:/language/Filters/TypedTiddlers\":{\"title\":\"$:/language/Filters/TypedTiddlers\",\"text\":\"非维基文字条目\"},\"GettingStarted\":{\"title\":\"GettingStarted\",\"text\":\"\\\\define lingo-base() $:/language/ControlPanel/Basics/\\n\\n欢迎来到 ~TiddlyWiki 和 ~TiddlyWiki 社区\\n\\n开始在 ~TiddlyWiki 中存储重要信息之前，确保能够可靠地保存更改很重要。详情见 https://tiddlywiki.com/#GettingStarted\\n\\n!! 设置此 ~TiddlyWiki\\n\\n\u003Cdiv class=\\\"tc-control-panel\\\">\\n\\n|tc-table-no-border tc-first-col-min-width tc-first-link-nowrap|k\\n| \u003C$link to=\\\"$:/SiteTitle\\\">\u003C\u003Clingo Title/Prompt>>\u003C/$link>|\u003C$edit-text tiddler=\\\"$:/SiteTitle\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n| \u003C$link to=\\\"$:/SiteSubtitle\\\">\u003C\u003Clingo Subtitle/Prompt>>\u003C/$link>|\u003C$edit-text tiddler=\\\"$:/SiteSubtitle\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|^ \u003C$link to=\\\"$:/DefaultTiddlers\\\">\u003C\u003Clingo DefaultTiddlers/Prompt>>\u003C/$link>\u003Cbr>\u003C\u003Clingo DefaultTiddlers/TopHint>>|\u003C$edit tag=\\\"textarea\\\" tiddler=\\\"$:/DefaultTiddlers\\\"/>\u003Cbr>//\u003C\u003Clingo DefaultTiddlers/BottomHint>>// |\\n\u003C/div>\\n\\n可在[[控制台|$:/ControlPanel]]查看更多选项。\"},\"$:/language/Help/build\":{\"title\":\"$:/language/Help/build\",\"description\":\"自动执行已配置的命令\",\"text\":\"生成指定的生成目标为当前 wiki。若未指定任何生成目标，则生成所有可用的目标。\\n\\n```\\n--build \u003Ctarget> [\u003Ctarget> ...]\\n```\\n\\n生成目标在 wiki 文件夹的 `tiddlywiki.info` 文件中定义。\\n\"},\"$:/language/Help/clearpassword\":{\"title\":\"$:/language/Help/clearpassword\",\"description\":\"清除用于后续加密的密码\",\"text\":\"清除用于后续加密的密码\\n\\n```\\n--clearpassword\\n```\\n\"},\"$:/language/Help/commands\":{\"title\":\"$:/language/Help/commands\",\"description\":\"运行从筛选器传回的命令\",\"text\":\"按顺序运行从筛选器传回的命令符记\\n\\n```\\n--commands \u003Cfilter>\\n```\\n\\n示例\\n\\n```\\n--commands \\\"[enlist{$:/build-commands-as-text}]\\\"\\n```\\n\\n```\\n--commands \\\"[{$:/build-commands-as-json}jsonindexes[]] :map[{$:/build-commands-as-json}jsonget\u003CcurrentTiddler>]\\\"\\n```\\n\"},\"$:/language/Help/default\":{\"title\":\"$:/language/Help/default\",\"text\":\"\\\\define commandTitle()\\n$:/language/Help/$(command)$\\n\\\\end\\n\\\\whitespace trim\\n```\\n用法: tiddlywiki [\u003Cwikifolder>] [--\u003Ccommand> [\u003Cargs>...]...]\\n```\\n\\n可用的命令：\\n\\n\u003Cul>\\n\u003C$list filter=\\\"[commands[]sort[title]]\\\" variable=\\\"command\\\">\\n\u003Cli>\u003C$link to=\u003C\u003CcommandTitle>>>\u003C$macrocall $name=\\\"command\\\" $type=\\\"text/plain\\\" $output=\\\"text/plain\\\"/>\u003C/$link>:\\n&#32;\\n\u003C$transclude tiddler=\u003C\u003CcommandTitle>> field=\\\"description\\\"/>\u003C/li>\\n\u003C/$list>\\n\u003C/ul>\\n\\n取得关于某个命令的详细帮助：\\n\\n```\\ntiddlywiki --help \u003Ccommand>\\n```\\n\"},\"$:/language/Help/deletetiddlers\":{\"title\":\"$:/language/Help/deletetiddlers\",\"description\":\"删除一组条目\",\"text\":\"\u003C\u003C.from-version \\\"5.1.20\\\">> 删除由筛选器标识的一组条目。\\n\\n```\\n--deletetiddlers \u003Cfilter>\\n```\\n\"},\"$:/language/Help/editions\":{\"title\":\"$:/language/Help/editions\",\"description\":\"列出可用的 TiddlyWiki 版本\",\"text\":\"列出可用版本的名称和描述。您可以用 `--init` 命令创建一个指定版本的新维基。\\n\\n```\\n--editions\\n```\\n\"},\"$:/language/Help/fetch\":{\"title\":\"$:/language/Help/fetch\",\"description\":\"通过网址从维基提取条目\",\"text\":\"通过 HTTP/HTTPS 提取一个或多个文件，并导入匹配筛选器的条目，可选的转换传入的名称。\\n\\n```\\n--fetch file \u003Curl> \u003Cimport-filter> \u003Ctransform-filter>\\n--fetch files \u003Curl-filter> \u003Cimport-filter> \u003Ctransform-filter>\\n--fetch raw-file \u003Curl> \u003Ctransform-filter>\\n--fetch raw-files \u003Curl-filter> \u003Ctransform-filter>\\n```\\n\\n \\\"file\\\" 和 \\\"files\\\" 选项提取指定的文件，并尝试导入其中的条目（与将文件拖动到浏览器视窗中的处理相同）。 \\\"raw-file\\\" 和 \\\"raw-files\\\" 变选项提取指定的文件，并将原始文件资料存储于条目，而不套用导入逻辑。\\n\\n使用 \\\"file\\\" and \\\"raw-file\\\" 选项为仅提取单个文件，且第一个参数为要读取文件的网址。\\n\\n使用 \\\"files\\\" 和 \\\"raw-files\\\" 选项为提取多个文件，且第一个参数是一个产生要读取文件的网址清单的筛选器。例如，给定标签为 \\\"remote-server\\\" 的一组具有字段 \\\"url\\\" 的条目，筛选器 `[tag[remote-server]get[url]]` 将取回所有可用的网址。\\n\\n对于 \\\"file\\\" 和 \\\"files\\\" 选项，the `\u003Cimport-filter>` 参数指定一个筛选器，用于确定要导入哪些条目。如果未提供，则默认为 `[all[tiddlers]]`。\\n\\n对于所有选项，`\u003Ctransform-filter>` 参数指定一个可选的筛选器，用于转换导入条目的名称。例如，`[addprefix[$:/myimports/]]` 会将前缀  `$:/myimports/` 加至每个名称。\\n\\n于 `--fetch` 之前使用 `--verbose` 命令，将在导入期间输出进度信息。\\n\\n请注意，TiddlyWiki 不会提取一个已经加载插件的旧版本。\\n\\n以下示例从 https://tiddlywiki.com 取回所有非系统条目，并将其保存到一个 JSON 文件：\\n\\n```\\ntiddlywiki --verbose --fetch file \\\"https://tiddlywiki.com/\\\" \\\"[!is[system]]\\\" \\\"\\\" --rendertiddler \\\"$:/core/templates/exporters/JsonFile\\\" output.json text/plain \\\"\\\" exportFilter \\\"[!is[system]]\\\"\\n```\\n\\n以下范例从 https://tiddlywiki.com 取回 \\\"favicon\\\" 文件，并将其保存在名为 \\\"output.ico\\\" 的文件中。请注意，在 \\\"--fetch\\\" 命令中引用的中间条目 \\\"Icon Tiddler\\\"，因为它被用作转换筛选器来替换预设的名称，而 \\\"--savetiddler\\\" 命令没有引号，因为它是直接用作标题。\\n\\n```\\ntiddlywiki --verbose --fetch raw-file \\\"https://tiddlywiki.com/favicon.ico\\\" \\\"[[Icon Tiddler]]\\\" --savetiddler \\\"Icon Tiddler\\\" output.ico\\n```\\n\"},\"$:/language/Help/help\":{\"title\":\"$:/language/Help/help\",\"description\":\"显示 TiddlyWiki 命令的说明\",\"text\":\"显示命令的帮助文本:\\n\\n```\\n--help [\u003Ccommand>]\\n```\\n\\n若省略命令名称，则显示可用命令的清单。\\n\"},\"$:/language/Help/import\":{\"title\":\"$:/language/Help/import\",\"description\":\"从文件导入条目\",\"text\":\"从 TiddlyWiki 文件 (`.html`)、`.tiddler`、`.tid`、`.json` 或其他本机文件导入条目。必须明确指定解串器，而不像 load 命令，从文件扩展名推断解串器。\\n\\n```\\n--import \u003Cfilepath> \u003Cdeserializer> [\u003Ctitle>] [\u003Cencoding>]\\n```\\n\\n核心的解串器包括：\\n\\n* application/javascript\\n* application/json\\n* application/x-tiddler\\n* application/x-tiddler-html-div\\n* application/x-tiddlers\\n* text/html\\n* text/plain\\n\\n导入的条目名称，默认为文件名。\\n\\n编码默认为 \\\"utf8\\\"，但用于导入二进制文件可以是 \\\"base64\\\"。\\n\\n请注意，TiddlyWiki 不会导入旧版本的已加载插件。\\n\"},\"$:/language/Help/init\":{\"title\":\"$:/language/Help/init\",\"description\":\"初始化一个新的 wiki 文件夹\",\"text\":\"初始化一个空的 [[WikiFolder|WikiFolders]] 的指定版本的副本。\\n\\n```\\n--init \u003Cedition> [\u003Cedition> ...]\\n```\\n\\n例如：\\n\\n```\\ntiddlywiki ./MyWikiFolder --init empty\\n```\\n\\n注意：\\n\\n* 若有需要，将创建 wiki 文件夹目录\\n* 其中 \\\"edition\\\" 默认为 ''empty''\\n* 若 wiki 文件夹不是空的，则初始化命令将失败\\n* 初始化命令会删除 'tiddlywiki.info' 文件内所有 'includeWikis' 的定义。\\n* 当指定多个版本时，这些版本于初始化后，将覆盖早期版本共用的所有文件 (故此最终的 `tiddlywiki.info` 文件将是从最近的版本复制而得)\\n* `--editions` 传回所有可用版本的清单。\\n\"},\"$:/language/Help/listen\":{\"title\":\"$:/language/Help/listen\",\"description\":\"为 TiddlyWiki 提供一个 HTTP 服务器接口\",\"text\":\"通过 HTTP 提供一个维基服务。\\n\\nlisten 命令使用[[命名的命令参数|NamedCommandParameters]]：\\n\\n```\\n--listen [\u003Cname>=\u003Cvalue>]...\\n```\\n\\n所有参数都是可选的, 具有安全的默认值, 可以按任意顺序指定。认可的参数有:\\n\\n* ''host'' - 可选的主机名称， (默认为 \\\"127.0.0.1\\\" 或名为 \\\"localhost\\\")\\n* ''path-prefix'' - 可选的路径前缀\\n* ''port'' - 侦听的埠号；非数值会被解译为一个系统环境变数，从其中提取埠号 (默认为 \\\"8080\\\")\\n* ''credentials'' - 凭证 CSV 文件的路径名（相对于维基文件夹）\\n* ''anon-username'' - 匿名用户的编辑署名\\n* ''username'' - 可选的基础验证用户名称\\n* ''password'' - 可选的基础验证密码\\n* ''authenticated-user-header'' - 可选的请求标头名称，用于受信任身份验证\\n* ''readers'' - 允许读取此维基，以逗号分隔的用户名称的清单\\n* ''writers'' - 允许写入此维基，以逗号分隔的用户名称的清单\\n* ''csrf-disable'' - 设置为 \\\"yes\\\" 以禁用 CSRF 检查 (默认为 \\\"no\\\")\\n* ''sse-enabled'' - 设置为 \\\"yes\\\" 以启用服务器传送的事件 (默认为 \\\"no\\\")\\n* ''root-tiddler'' - 服务的基础条目 (默认为 \\\"$:/core/save/all\\\")\\n* ''root-render-type'' - 呈现的基础条目的内容类型 (默认为 \\\"text/plain\\\")\\n* ''root-serve-type'' - 服务的基础条目的内容类型 (默认为 \\\"text/html\\\")\\n* ''tls-cert'' - TLS 证书文件的路径名（相对于维基文件夹）\\n* ''tls-key'' - TLS 密钥文件的路径名（相对于维基文件夹）\\n* ''debug-level'' - 可选的调试级别；设置为 \\\"debug\\\" 来查看请求的详细信息；(默认为 \\\"none\\\")\\n* ''gzip'' - 设为 \\\"yes\\\" 以启用某些 http 端点的 gzip 压缩 (默认为 \\\"no\\\")\\n* ''use-browser-cache'' - 设置为 \\\"yes\\\" 允许浏览器缓存响应，以节省带宽（默认为 \\\"no\\\")\\n\\n有关向整个本地网络开启实例的信息，以及可能的安全问题，请参阅 TiddlyWiki.com 的 WebServer 条目。\\n\"},\"$:/language/Help/load\":{\"title\":\"$:/language/Help/load\",\"description\":\"从文件中加载条目\",\"text\":\"从 TiddlyWiki (`.html`), `.tiddler`, `.tid`, `.json` 或其他本机文件加载条目。应用的处理程序取决于导入文件的扩展名。如果您需要明确指定解串器和编码，请改用 `import` 命令。\\n\\n```\\n--load \u003Cfilepath> [noerror]\\n--load \u003Cdirpath> [noerror]\\n```\\n\\n默认情况下, 如果未找到条目，load 命令会引发错误。通过提供可选的 \\\"noerror\\\" 参数可以抑制该错误。\\n\\n从已加密的 TiddlyWiki 文件中加载条目，须使用 PasswordCommand 指定密码，例如：\\n\\n```\\ntiddlywiki ./MyWiki --password pa55w0rd --load my_encrypted_wiki.html\\n```\\n\\n请注意 TiddlyWiki 将不加载旧版本的已挂载的插件。\\n\"},\"$:/language/Help/makelibrary\":{\"title\":\"$:/language/Help/makelibrary\",\"description\":\"构建升级处理所需的程式库插件\",\"text\":\"为升级处理构建 `$:/UpgradeLibrary` 条目。\\n\\n升级程式库被格式化为一个插件类型为 `library` 的一般插件条目。它包含 TiddlyWiki5 存储库中所有可用的插件、布局主题和语言包的副本。\\n\\n此命令仅供内部使用；它只是与使用者构建一个自订的升级程序相关。\\n\\n```\\n--makelibrary \u003Ctitle>\\n```\\n\\n标题参数默认为 `$:/UpgradeLibrary`。\\n\"},\"$:/language/Help/notfound\":{\"title\":\"$:/language/Help/notfound\",\"text\":\"无此帮助项目\"},\"$:/language/Help/output\":{\"title\":\"$:/language/Help/output\",\"description\":\"设置后续命令的基准输出文件夹\",\"text\":\"设置后续命令的基准输出文件夹，默认为该版本文件夹的 `output` 子文件夹。\\n\\n```\\n--output \u003Cpathname>\\n```\\n\\n若指定的路径是相对路径，则它是被解析相对于当前的工作文件夹。例如：`--output .` 將輸出文件夹設置為當前工作文件夹。\"},\"$:/language/Help/password\":{\"title\":\"$:/language/Help/password\",\"description\":\"设置用以加密的密码\",\"text\":\"设置用以加密的密码\\n\\n```\\n--password \u003Cpassword>\\n```\\n\\n''请注意''：这不是用于提供 TiddlyWiki 具有密码保护功能。相反地，请看 [[ServerCommand]] 的密码选项说明。\\n\"},\"$:/language/Help/render\":{\"title\":\"$:/language/Help/render\",\"description\":\"呈现个别条目到文件\",\"text\":\"呈现由筛选器标识的个别条目，并将结果保存到指定的文件。\\n\\n可选择性地指定范本条目名称。在此情况下，不是直接呈现每个条目，而是使用设为正在呈现的条目名称的 \\\"currentTiddler\\\" 变量，来呈现范本条目。\\n\\n也可以选择性地指定附加变量的名称和值。\\n\\n```\\n--render \u003Ctiddler-filter> [\u003Cfilename-filter>] [\u003Crender-type>] [\u003Ctemplate>] [ [\u003Cname>] [\u003Cvalue>] ]*\\n```\\n\\n* ''tiddler-filter'': 标识要呈现的条目的筛选器\\n* ''filename-filter'': 可选的筛选器，转换条目名称至路径名。如果省略，默认为 `[is[tiddler]addsuffix[.html]]`，其使用未改变的条目名称为文件名\\n* ''template'': 可选的范本，用于呈现每个条目\\n* ''render-type'': 可选的呈现类型：`text/html` (默认值) 会传回完整的 HTML 文本，而 `text/plain` 只会传回文本内容 (即其忽略 HTML 标记与其他不可印出的数据)\\n* ''name'': 可选的变量名称\\n* ''value'': 可选的变量值\\n\\n默认情况下，文件名被解析为相对于发行版文件夹的 `output` 子文件夹。`--output` 命令可用于将输出指到一个不同的文件夹。\\n\\n附注：\\n\\n* 输出目录不清除任何现有的文件\\n* 文件名的路径中，任何不存在的文件夹，将自动创建。\\n* 当正呈现的条目名称中带有空格，请注意同时使用命令行接口所要求的引号，与 TiddlyWiki 的双重方括号：`--render \\\"[[Motovun Jack.jpg]]\\\"`\\n* 所选的项目被设置为当前正在呈现的条目名称，以此评估文件名筛选器，允条目名称用作基础计算的文件名。例如，`[encodeuricomponent[]addprefix[static/]]` 为每个条目名称套用 URI 编码，然后增加首码 `static/`\\n* `--render` 命令是已弃用的 `--rendertiddler` 和 `--rendertiddlers` 的一个更灵活的替代命令。\\n\\n例子：\\n\\n* `--render \\\"[!is[system]]\\\" \\\"[encodeuricomponent[]addprefix[tiddlers/]addsuffix[.html]]\\\"` -- 呈现所有非系统条目为 \\\"tiddlers\\\" 子文件夹中的文件，文件名为 URL 编码的条目名称和扩展名 HTML\\n* `--render '.' 'tiddlers.json' 'text/plain' '$:/core/templates/exporters/JsonFile' 'exportFilter' '[tag[HelloThere]]'` -- 将标签为 \\\"HelloThere\\\" 的条目渲染到名为 \\\"tiddlers.json\\\" 的 JSON 文件\"},\"$:/language/Help/rendertiddler\":{\"title\":\"$:/language/Help/rendertiddler\",\"description\":\"呈现个别条目为指定的内容类型\",\"text\":\"(请注意：`--rendertiddler` 命令已被弃用，而支持新的、更灵活的 `--render` 命令)\\n\\n呈现个别条目为指定的[[内容类型|ContentType]]，默认为 `text/html` 且保存为指定的文件名。\\n\\n还可以指定一个模板，在这种情况下，\\\"currentTiddler\\\" 变量设为正在呈现的条目 (第一个参数值) 与模板条目合并呈现。\\n\\n也能可选地指定附加变量的名称与其值。\\n\\n```\\n--rendertiddler \u003Ctitle> \u003Cfilename> [\u003Ctype>] [\u003Ctemplate>]\\n```\\n\\n默认情况下，文件名被解析为相对于版本文件夹的 `output` 子文件夹。 `--output` 命令可以用于将输出指定到一个不同的文件夹。\\n\\n自动创建在文件名称的路径中任何缺少的文件夹。\\n\\n例如，以下命令通过使用核心模板 `$:/core/templates/exporters/JsonFile`，将所有匹配筛选器 `[tag[done]]` 的条目保存到名为 `output.json` 的 JSON 文件。\\n\\n```\\n--rendertiddler \\\"$:/core/templates/exporters/JsonFile\\\" output.json text/plain \\\"\\\" exportFilter \\\"[tag[done]]\\\"\\n```\"},\"$:/language/Help/rendertiddlers\":{\"title\":\"$:/language/Help/rendertiddlers\",\"description\":\"呈现符合筛选条件的条目为指定的内容类型\",\"text\":\"(请注意：`--rendertiddlers` 命令已被弃用，而支持新的、更灵活的 `--render` 命令)\\n\\n呈现符合筛选条的条目为指定的[[内容类型|ContentType]] (默认为 `text/html`) 与扩展名 (默认为 `.html`).\\n\\n```\\n--rendertiddlers '\u003Cfilter>' \u003Ctemplate> \u003Cpathname> [\u003Ctype>] [\u003Cextension>] [\\\"noclean\\\"]\\n```\\n\\n例如：\\n\\n```\\n--rendertiddlers '[!is[system]]' $:/core/templates/static.tiddler.html ./static text/plain\\n```\\n\\n默认情况下，路径名被解析为相对于版本文件夹的 `output` 子文件夹。 `--output` 命令可以用于将输出指定到一个不同的文件。\\n\\n在目标文件夹中的任何文件都会被删除，除非指定 ''noclean'' 旗标。若缺少目标文件夹，则以递归方式创建。\"},\"$:/language/Help/save\":{\"title\":\"$:/language/Help/save\",\"description\":\"将个别原始条目保存到文件\",\"text\":\"将筛选器标识的个别条目，以原始文本或二进位格式，保存到指定的文件。\\n\\n```\\n--save \u003Ctiddler-filter> \u003Cfilename-filter>\\n```\\n\\n* ''tiddler-filter'': 标识要保存的条目的筛选器\\n* ''filename-filter'': 可选的筛选器，转换条目名称至路径名。如果省略，默认为 `[is[tiddler]]`，其使用未改变的条目名称为文件名\\n\\n附注：\\n\\n* 输出文件夹不清除任何现有的文件\\n* 文件名的路径中，任何不存在的文件夹，将自动创建。\\n* 当正保存的条目的名称中带有空格，请注意同时使用命令行接口所要求的引号，与 TiddlyWiki 的双重方括号：`--save \\\"[[Motovun Jack.jpg]]\\\"`\\n* 所选的项目被设置为当前正在保存的条目名称，以此评估文件名筛选器，允条目名称用作基础计算的文件名。例如，`[encodeuricomponent[]addprefix[static/]]` 为每个条目名称套用 URI 编码，然后增加首码 `static/`\\n* `--save` 命令是已被弃用的 `--savetiddler` 和 `--savetiddlers` 的一个更灵活的替代命令。\\n\\n例子：\\n\\n* `--save \\\"[!is[system]is[image]]\\\" \\\"[encodeuricomponent[]addprefix[tiddlers/]]\\\"` -- 保存所有非系统的图像条目为 \\\"tiddlers\\\" 子文件夹中的文件，文件名为 URL 编码的条目名称\"},\"$:/language/Help/savetiddler\":{\"title\":\"$:/language/Help/savetiddler\",\"description\":\"将条目的原始内容保存到一个文件\",\"text\":\"(请注意：`--savetiddler` 命令已被弃用，而支持新的、更灵活的 `--save` 命令)\\n\\n保存个别条目的原始文本或二进制格式到指定的文件名。\\n\\n```\\n--savetiddler \u003Ctitle> \u003Cfilename>\\n```\\n\\n默认情况下，文件名被解析为相对于版本文件夹的 `output` 子文件夹。 `--output` 命令可以用于将输出指定到一个不同的文件。\\n\\n自动创建在文件名称的路径中任何缺少的文件夹。\\n\"},\"$:/language/Help/savetiddlers\":{\"title\":\"$:/language/Help/savetiddlers\",\"description\":\"将一群条目的原始内容保存到一个文件夹\",\"text\":\"(请注意：`--savetiddlers` 命令已被弃用，而支持新的、更灵活的 `--save` 命令)\\n\\n保存一群条目的原始文字或二进制格式到指定的文件夹。\\n\\n```\\n--savetiddlers \u003Cfilter> \u003Cpathname> [noclean]\\n```\\n\\n默认情况下，路径名被解析为相对于版本文件夹的 `output` 子文件夹。 `--output` 命令可以用于将输出指定到一个不同的文件夹。\\n\\n保存指定的文件之前，会先清除输出目录的现有文件。可藉由指定 ''noclean'' 旗标，禁用该删除操作。\\n\\n自动创建在路径中任何缺少的文件夹。\\n\"},\"$:/language/Help/savewikifolder\":{\"title\":\"$:/language/Help/savewikifolder\",\"description\":\"将维基保存到一个新的维基文件夹\",\"text\":\"\u003C\u003C.from-version \\\"5.1.20\\\">> 将当前维基保存为一个维基文件夹，包含条目、插件和配置：\\n\\n```\\n--savewikifolder \u003Cwikifolderpath> [\u003Cfilter>] [ [\u003Cname>=\u003Cvalue>] ]*\\n```\\n\\n* 目标维基文件夹必须为空或不存在\\n* 筛选器指定应包括哪些条目。其为可选，默认为 `[all[tiddlers]]`\\n* 官方插件库中的插件，将替换为 `tiddlywiki.info` 文件中引用到的插件\\n* 自订插件将解压缩到自己的文件夹中\\n\\n支持以下选项：\\n\\n* ''filter''：定义要包含在输出中的条目的筛选器操作符。\\n* ''explodePlugins'': 默认为 \\\"yes\\\"\\n** ''yes'' 将 \\\"分解\\\" 插件为单独的条目文件，并将其保存到维基文件夹内的插件目录中\\n** ''no'' 将抑制分解插件到其组成的条目文件中。它将把插件保存为 tiddlers 文件夹中的单个 JSON 条目\\n\\n请注意，两个 ''explodePlugins'' 选项都会生成构建完全相同的原始维基的维基文件夹。区别在于插件在维基文件夹中的表示方式。\\n\\n常见的用法是将一个 TiddlyWiki HTML 文件转换成维基文件夹:\\n\\n```\\ntiddlywiki --load ./mywiki.html --savewikifolder ./mywikifolder\\n```\\n\\n将插件保存到目标维基文件夹的 tiddlers 目录中：\\n\\n```\\ntiddlywiki --load ./mywiki.html --savewikifolder ./mywikifolder explodePlugins=no\\n``` \"},\"$:/language/Help/server\":{\"title\":\"$:/language/Help/server\",\"description\":\"提供一个 HTTP 服务器界面到 TiddlyWiki (已弃用，支持新的 listen 命令)\",\"text\":\"在服务器中内置 TiddlyWiki5 是非常简单。虽与 TiddlyWeb 兼容，但不支持许多健全互联网面向的使用方式所需的功能。\\n\\n提供呈现一个指定条目，也可将个别条目编码成 JSON，且支持基础的 HTTP 操作 `GET`、`PUT` 及 `DELETE`.\\n\\n```\\n--server \u003Cport> \u003Croot-tiddler> \u003Croot-render-type> \u003Croot-serve-type> \u003Cusername> \u003Cpassword> \u003Chost> \u003Cpath-prefix> \u003Cdebug-level>\\n```\\n\\n参数说明：\\n\\n* ''port'' - 要侦听的埠号；非数值会被解译为一个系统环境变数，从其中提取埠号 (默认为 \\\"8080\\\")\\n* ''root-tiddler'' - 服务的基础条目 (默认为 \\\"$:/core/save/all\\\")\\n* ''root-render-type'' - 呈现的基础条目的内容类型 (默认为 \\\"text/plain\\\")\\n* ''root-serve-type'' - 服务的基础条目的内容类型 (默认为 \\\"text/html\\\")\\n* ''username'' - 默认的编辑者署名\\n* ''password'' - 可选的基础验证密码\\n* ''host'' - 可选的主机名称， (默认为 \\\"127.0.0.1\\\" 或名为 \\\"localhost\\\")\\n* ''path-prefix'' - 可选的路径前缀\\n* ''debug-level'' - 可选的调试级别；设置为 \\\"debug\\\" 来查看请求的详细信息；(默认为 \\\"none\\\")\\n\\n若指定密码参数，浏览器将提示使用者输入用户名与密码。注意，密码系以明码方式传递，应只在受信任的网络或 HTTPS 上使用。\\n\\n例如：\\n\\n```\\n--server 8080 $:/core/save/all text/plain text/html MyUserName passw0rd\\n```\\n\\n若您需要设置主机名称或路径前缀，而不要求输入密码，则可以指定空字符串的使用者名和密码。\\n\\n```\\n--server 8080 $:/core/save/all text/plain text/html \\\"\\\" \\\"\\\" 192.168.0.245\\n```\\n\\n使用这样的位址，会将您的系统暴露给本地网络。有关向整个本地网络开启实例的信息，以及可能的安全问题，请参阅 TiddlyWiki.com 的 WebServer 条目。\\n\\n同时执行多个 TiddlyWiki 服务，须分别指定不同的埠号。使用环境变数，有助于将埠号传递给 Node.js 进程。本示例引用一个名为 \\\"MY_PORT_NUMBER\\\" 的环境变数:\\n\\n```\\n--server MY_PORT_NUMBER $:/core/save/all text/plain text/html MyUserName passw0rd\\n```\"},\"$:/language/Help/setfield\":{\"title\":\"$:/language/Help/setfield\",\"description\":\"准备用于外部条目\",\"text\":\"//请注意此命令是试验性的，且可能会更改或在最终定稿前被替换//\\n\\n设置一群条目的指定字段到 wikifying 范本条目的结果，其中的  `currentTiddler` 变数设置为各该条目。\\n\\n```\\n--setfield \u003Cfilter> \u003Cfieldname> \u003Ctemplatetitle> \u003Crendertype>\\n```\\n\\n参数说明：\\n\\n* ''filter'' - 受影响的辨识条目的筛选条件\\n* ''fieldname'' - 要修改的字段（默认为 \\\"text\\\"）\\n* ''templatetitle'' - 该条目 wikify 到指定字段。若为空白或丢失，则删除指定的字段\\n* ''rendertype'' - 要呈现的文本类型（默认为 \\\"text/plain\\\"; \\\"text/html\\\" 可以用于包含 HTML 标记)）\\n\"},\"$:/language/Help/unpackplugin\":{\"title\":\"$:/language/Help/unpackplugin\",\"description\":\"从插件解开附属的条目\",\"text\":\"提取插件的附属条目，将其建立为一般条目：\\n\\n```\\n--unpackplugin \u003Ctitle>\\n```\\n\"},\"$:/language/Help/verbose\":{\"title\":\"$:/language/Help/verbose\",\"description\":\"触发详细的输出模式\",\"text\":\"触发显示详细的命令执行过程，可用于调试\\n\\n```\\n--verbose\\n```\\n\"},\"$:/language/Help/version\":{\"title\":\"$:/language/Help/version\",\"description\":\"显示 TiddlyWiki 的版本编号\",\"text\":\"显示 TiddlyWiki 的版本编号。\\n\\n```\\n--version\\n```\\n\"},\"$:/language/Import/Editor/Import/Heading\":{\"title\":\"$:/language/Import/Editor/Import/Heading\",\"text\":\"导入图像并将其插入至编辑器。\"},\"$:/language/Import/Imported/Hint\":{\"title\":\"$:/language/Import/Imported/Hint\",\"text\":\"下列条目已被导入：\"},\"$:/language/Import/Listing/Cancel/Caption\":{\"title\":\"$:/language/Import/Listing/Cancel/Caption\",\"text\":\"取消\"},\"$:/language/Import/Listing/Cancel/Warning\":{\"title\":\"$:/language/Import/Listing/Cancel/Warning\",\"text\":\"您要取消导入吗？\"},\"$:/language/Import/Listing/Hint\":{\"title\":\"$:/language/Import/Listing/Hint\",\"text\":\"这些条目已备妥导入：\"},\"$:/language/Import/Listing/Import/Caption\":{\"title\":\"$:/language/Import/Listing/Import/Caption\",\"text\":\"导入\"},\"$:/language/Import/Listing/Select/Caption\":{\"title\":\"$:/language/Import/Listing/Select/Caption\",\"text\":\"选择\"},\"$:/language/Import/Listing/Status/Caption\":{\"title\":\"$:/language/Import/Listing/Status/Caption\",\"text\":\"状态\"},\"$:/language/Import/Listing/Title/Caption\":{\"title\":\"$:/language/Import/Listing/Title/Caption\",\"text\":\"条目\"},\"$:/language/Import/Listing/Preview\":{\"title\":\"$:/language/Import/Listing/Preview\",\"text\":\"预览：\"},\"$:/language/Import/Listing/Preview/Text\":{\"title\":\"$:/language/Import/Listing/Preview/Text\",\"text\":\"文本\"},\"$:/language/Import/Listing/Preview/TextRaw\":{\"title\":\"$:/language/Import/Listing/Preview/TextRaw\",\"text\":\"文本 (原始)\"},\"$:/language/Import/Listing/Preview/Fields\":{\"title\":\"$:/language/Import/Listing/Preview/Fields\",\"text\":\"字段\"},\"$:/language/Import/Listing/Preview/Diff\":{\"title\":\"$:/language/Import/Listing/Preview/Diff\",\"text\":\"差异\"},\"$:/language/Import/Listing/Preview/DiffFields\":{\"title\":\"$:/language/Import/Listing/Preview/DiffFields\",\"text\":\"差异 (字段)\"},\"$:/language/Import/Listing/Rename/Prompt\":{\"title\":\"$:/language/Import/Listing/Rename/Prompt\",\"text\":\"重新命名为：\"},\"$:/language/Import/Listing/Rename/Tooltip\":{\"title\":\"$:/language/Import/Listing/Rename/Tooltip\",\"text\":\"导入前重新命名条目\"},\"$:/language/Import/Listing/Rename/ConfirmRename\":{\"title\":\"$:/language/Import/Listing/Rename/ConfirmRename\",\"text\":\"重新命名条目\"},\"$:/language/Import/Listing/Rename/CancelRename\":{\"title\":\"$:/language/Import/Listing/Rename/CancelRename\",\"text\":\"取消\"},\"$:/language/Import/Listing/Rename/OverwriteWarning\":{\"title\":\"$:/language/Import/Listing/Rename/OverwriteWarning\",\"text\":\"具有此标题的条目已存在。\"},\"$:/language/Import/Upgrader/Plugins/Suppressed/Incompatible\":{\"title\":\"$:/language/Import/Upgrader/Plugins/Suppressed/Incompatible\",\"text\":\"封锁的不兼容或过时插件。\"},\"$:/language/Import/Upgrader/Plugins/Suppressed/Version\":{\"title\":\"$:/language/Import/Upgrader/Plugins/Suppressed/Version\",\"text\":\"封锁的插件 (由于传入的 \u003C\u003Cincoming>> 不比现有版本 \u003C\u003Cexisting>> 新)。\"},\"$:/language/Import/Upgrader/Plugins/Upgraded\":{\"title\":\"$:/language/Import/Upgrader/Plugins/Upgraded\",\"text\":\"升级插件，从 \u003C\u003Cincoming>> 到 \u003C\u003Cupgraded>>。\"},\"$:/language/Import/Upgrader/State/Suppressed\":{\"title\":\"$:/language/Import/Upgrader/State/Suppressed\",\"text\":\"封锁的暂存状态条目。\"},\"$:/language/Import/Upgrader/System/Disabled\":{\"title\":\"$:/language/Import/Upgrader/System/Disabled\",\"text\":\"已禁用系統条目。\"},\"$:/language/Import/Upgrader/System/Suppressed\":{\"title\":\"$:/language/Import/Upgrader/System/Suppressed\",\"text\":\"封锁的系统条目。\"},\"$:/language/Import/Upgrader/System/Warning\":{\"title\":\"$:/language/Import/Upgrader/System/Warning\",\"text\":\"核心模块条目。\"},\"$:/language/Import/Upgrader/System/Alert\":{\"title\":\"$:/language/Import/Upgrader/System/Alert\",\"text\":\"您即将导入一个条目会覆盖一个核心模块条目。不建议这样做，因为可能会使系统不稳定。\"},\"$:/language/Import/Upgrader/ThemeTweaks/Created\":{\"title\":\"$:/language/Import/Upgrader/ThemeTweaks/Created\",\"text\":\"从 \u003C$text text=\u003C\u003Cfrom>>/> 迁移布局主题。\"},\"$:/language/Import/Upgrader/Tiddler/Disabled\":{\"title\":\"$:/language/Import/Upgrader/Tiddler/Disabled\",\"text\":\"已禁用系統条目。\"},\"$:/language/Import/Upgrader/Tiddler/Selected\":{\"title\":\"$:/language/Import/Upgrader/Tiddler/Selected\",\"text\":\"选定的条目。\"},\"$:/language/Import/Upgrader/Tiddler/Unselected\":{\"title\":\"$:/language/Import/Upgrader/Tiddler/Unselected\",\"text\":\"未选定的条目。\"},\"$:/language/AboveStory/ClassicPlugin/Warning\":{\"title\":\"$:/language/AboveStory/ClassicPlugin/Warning\",\"text\":\"您似乎要加载为 ~TiddlyWiki 经典版设计的插件。请注意，[[这些插件无法运行于 TiddlyWiki 5.x.x 版|https://tiddlywiki.com/#TiddlyWikiClassic]]。检测到 ~TiddlyWiki 经典版插件：\"},\"$:/language/BinaryWarning/Prompt\":{\"title\":\"$:/language/BinaryWarning/Prompt\",\"text\":\"此条目包含二进制数据\"},\"$:/language/ClassicWarning/Hint\":{\"title\":\"$:/language/ClassicWarning/Hint\",\"text\":\"此条目以经典版 TiddlyWiki 标记格式撰写，不完全兼容新版 TiddlyWiki 的格式，详细信息请参阅：https://tiddlywiki.com/static/Upgrading。\"},\"$:/language/ClassicWarning/Upgrade/Caption\":{\"title\":\"$:/language/ClassicWarning/Upgrade/Caption\",\"text\":\"升级\"},\"$:/language/CloseAll/Button\":{\"title\":\"$:/language/CloseAll/Button\",\"text\":\"全部关闭\"},\"$:/language/ColourPicker/Recent\":{\"title\":\"$:/language/ColourPicker/Recent\",\"text\":\"最近︰\"},\"$:/language/ConfirmCancelTiddler\":{\"title\":\"$:/language/ConfirmCancelTiddler\",\"text\":\"您确定要取消对条目 \\\"\u003C$text text=\u003C\u003Ctitle>>/>\\\" 的更改？\"},\"$:/language/ConfirmDeleteTiddler\":{\"title\":\"$:/language/ConfirmDeleteTiddler\",\"text\":\"您确定要删除条目 \\\"\u003C$text text=\u003C\u003Ctitle>>/>\\\"？\"},\"$:/language/ConfirmDeleteTiddlers\":{\"title\":\"$:/language/ConfirmDeleteTiddlers\",\"text\":\"您确定要删除 \u003C\u003CresultCount>> 个条目？\"},\"$:/language/ConfirmOverwriteTiddler\":{\"title\":\"$:/language/ConfirmOverwriteTiddler\",\"text\":\"您确定要覆盖条目 \\\"\u003C$text text=\u003C\u003Ctitle>>/>\\\"？\"},\"$:/language/ConfirmEditShadowTiddler\":{\"title\":\"$:/language/ConfirmEditShadowTiddler\",\"text\":\"您即将要编辑默认条目，任何更改将会覆盖默认的系统，使未来的升级不寻常。您确定要编辑 \\\"\u003C$text text=\u003C\u003Ctitle>>/>\\\"?\"},\"$:/language/ConfirmAction\":{\"title\":\"$:/language/ConfirmAction\",\"text\":\"是否要继续？\"},\"$:/language/Count\":{\"title\":\"$:/language/Count\",\"text\":\"计数\"},\"$:/language/DefaultNewTiddlerTitle\":{\"title\":\"$:/language/DefaultNewTiddlerTitle\",\"text\":\"新条目\"},\"$:/language/Diffs/CountMessage\":{\"title\":\"$:/language/Diffs/CountMessage\",\"text\":\"\u003C\u003Cdiff-count>> 个差异\"},\"$:/language/DropMessage\":{\"title\":\"$:/language/DropMessage\",\"text\":\"现在放下（或按 ESC 键取消）\"},\"$:/language/Encryption/Cancel\":{\"title\":\"$:/language/Encryption/Cancel\",\"text\":\"取消\"},\"$:/language/Encryption/ConfirmClearPassword\":{\"title\":\"$:/language/Encryption/ConfirmClearPassword\",\"text\":\"您要清除密码吗？当保存此维基时，这将删除已套用的加密\"},\"$:/language/Encryption/Username\":{\"title\":\"$:/language/Encryption/Username\",\"text\":\"用户名称\"},\"$:/language/Encryption/Password\":{\"title\":\"$:/language/Encryption/Password\",\"text\":\"密码\"},\"$:/language/Encryption/PromptSetPassword\":{\"title\":\"$:/language/Encryption/PromptSetPassword\",\"text\":\"为此 TiddlyWiki 设置一个新密码\"},\"$:/language/Encryption/RepeatPassword\":{\"title\":\"$:/language/Encryption/RepeatPassword\",\"text\":\"重复输入密码\"},\"$:/language/Encryption/PasswordNoMatch\":{\"title\":\"$:/language/Encryption/PasswordNoMatch\",\"text\":\"密码不匹配\"},\"$:/language/Encryption/SetPassword\":{\"title\":\"$:/language/Encryption/SetPassword\",\"text\":\"设定密码\"},\"$:/language/Error/Caption\":{\"title\":\"$:/language/Error/Caption\",\"text\":\"错误\"},\"$:/language/Error/DeserializeOperator/MissingOperand\":{\"title\":\"$:/language/Error/DeserializeOperator/MissingOperand\",\"text\":\"筛选器错误：'deserialize' 运算符缺少运算元\"},\"$:/language/Error/DeserializeOperator/UnknownDeserializer\":{\"title\":\"$:/language/Error/DeserializeOperator/UnknownDeserializer\",\"text\":\"筛选器错误：未知的解串器被提供为 'deserialize' 运算符的操作数\"},\"$:/language/Error/Filter\":{\"title\":\"$:/language/Error/Filter\",\"text\":\"筛选器错误\"},\"$:/language/Error/FilterRunPrefix\":{\"title\":\"$:/language/Error/FilterRunPrefix\",\"text\":\"筛选器错误：筛选器 run 的未知首码\"},\"$:/language/Error/FilterSyntax\":{\"title\":\"$:/language/Error/FilterSyntax\",\"text\":\"筛选器运算式中的语法错误\"},\"$:/language/Error/FormatFilterOperator\":{\"title\":\"$:/language/Error/FormatFilterOperator\",\"text\":\"筛选器错误：`format` 筛选器运算符的未知尾码\"},\"$:/language/Error/IsFilterOperator\":{\"title\":\"$:/language/Error/IsFilterOperator\",\"text\":\"筛选器错误︰'is' 筛选器运算符的未知操作数\"},\"$:/language/Error/LoadingPluginLibrary\":{\"title\":\"$:/language/Error/LoadingPluginLibrary\",\"text\":\"加载插件库时，发生错误\"},\"$:/language/Error/NetworkErrorAlert\":{\"title\":\"$:/language/Error/NetworkErrorAlert\",\"text\":\"`\u003Ch2>''网络错误''\u003C/h2>与服务器的连缐似乎已中断。这可能表示您的网络连缐有问题。请尝试恢复网路连缐才能继续。\u003Cbr>\u003Cbr>''恢复连缐时，所有未保存的更改，将自动同步''。`\"},\"$:/language/Error/PutEditConflict\":{\"title\":\"$:/language/Error/PutEditConflict\",\"text\":\"服务器上的文件已更改\"},\"$:/language/Error/PutForbidden\":{\"title\":\"$:/language/Error/PutForbidden\",\"text\":\"没有权限\"},\"$:/language/Error/PutUnauthorized\":{\"title\":\"$:/language/Error/PutUnauthorized\",\"text\":\"需要身分验证\"},\"$:/language/Error/RecursiveTransclusion\":{\"title\":\"$:/language/Error/RecursiveTransclusion\",\"text\":\"于 transclude 小部件中的递归嵌入错误\"},\"$:/language/Error/RetrievingSkinny\":{\"title\":\"$:/language/Error/RetrievingSkinny\",\"text\":\"简要条目清单提取错误\"},\"$:/language/Error/SavingToTWEdit\":{\"title\":\"$:/language/Error/SavingToTWEdit\",\"text\":\"保存到 TWEdit 时，发生错误\"},\"$:/language/Error/WhileSaving\":{\"title\":\"$:/language/Error/WhileSaving\",\"text\":\"保存时，发生错误\"},\"$:/language/Error/XMLHttpRequest\":{\"title\":\"$:/language/Error/XMLHttpRequest\",\"text\":\"XMLHttpRequest 错误代码\"},\"$:/language/Error/ZoominTextNode\":{\"title\":\"$:/language/Error/ZoominTextNode\",\"text\":\"故事视图错误：您似乎尝试与显示在自定义容器中的条目进行交互。这很可能是由于将 `$:/tags/StoryTiddlerTemplateFilter` 与开头包含文本或空格的模板一起使用引起的。请使用编译指示 `\\\\whitespace trim`，并确保条目的全部内容都包含在单个 HTML 元素中。导致此问题的文本：\"},\"$:/language/InternalJavaScriptError/Title\":{\"title\":\"$:/language/InternalJavaScriptError/Title\",\"text\":\"内部的 JavaScript 错误\"},\"$:/language/InternalJavaScriptError/Hint\":{\"title\":\"$:/language/InternalJavaScriptError/Hint\",\"text\":\"喔，真是令人尴尬。建议刷新您的浏览器，重新启动 TiddlyWiki\"},\"$:/language/LayoutSwitcher/Description\":{\"title\":\"$:/language/LayoutSwitcher/Description\",\"text\":\"打开布局切换器\"},\"$:/language/LazyLoadingWarning\":{\"title\":\"$:/language/LazyLoadingWarning\",\"text\":\"\u003Cp>正在从 ''\u003C$text text={{!!_canonical_uri}}/>'' 加载外部内容 ...\u003C/p>\u003Cp>如果此信息未消失，可能是条目内容类型与外部内容的类型不匹配，或是您可能正在使用的浏览器，不支援单文件式维基的外部内容。请参阅 https://tiddlywiki.com/#ExternalText\u003C/p>\"},\"$:/language/LoginToTiddlySpace\":{\"title\":\"$:/language/LoginToTiddlySpace\",\"text\":\"登录 TiddlySpace\"},\"$:/language/Manager/Controls/FilterByTag/None\":{\"title\":\"$:/language/Manager/Controls/FilterByTag/None\",\"text\":\"(无)\"},\"$:/language/Manager/Controls/FilterByTag/Prompt\":{\"title\":\"$:/language/Manager/Controls/FilterByTag/Prompt\",\"text\":\"按标签筛选︰\"},\"$:/language/Manager/Controls/Order/Prompt\":{\"title\":\"$:/language/Manager/Controls/Order/Prompt\",\"text\":\"反向顺序\"},\"$:/language/Manager/Controls/Search/Placeholder\":{\"title\":\"$:/language/Manager/Controls/Search/Placeholder\",\"text\":\"搜索\"},\"$:/language/Manager/Controls/Search/Prompt\":{\"title\":\"$:/language/Manager/Controls/Search/Prompt\",\"text\":\"搜索︰\"},\"$:/language/Manager/Controls/Show/Option/Tags\":{\"title\":\"$:/language/Manager/Controls/Show/Option/Tags\",\"text\":\"标签\"},\"$:/language/Manager/Controls/Show/Option/Tiddlers\":{\"title\":\"$:/language/Manager/Controls/Show/Option/Tiddlers\",\"text\":\"条目\"},\"$:/language/Manager/Controls/Show/Prompt\":{\"title\":\"$:/language/Manager/Controls/Show/Prompt\",\"text\":\"显示︰\"},\"$:/language/Manager/Controls/Sort/Prompt\":{\"title\":\"$:/language/Manager/Controls/Sort/Prompt\",\"text\":\"排序︰\"},\"$:/language/Manager/Item/Colour\":{\"title\":\"$:/language/Manager/Item/Colour\",\"text\":\"颜色\"},\"$:/language/Manager/Item/Fields\":{\"title\":\"$:/language/Manager/Item/Fields\",\"text\":\"字段\"},\"$:/language/Manager/Item/Icon/None\":{\"title\":\"$:/language/Manager/Item/Icon/None\",\"text\":\"(无)\"},\"$:/language/Manager/Item/Icon\":{\"title\":\"$:/language/Manager/Item/Icon\",\"text\":\"图标\"},\"$:/language/Manager/Item/RawText\":{\"title\":\"$:/language/Manager/Item/RawText\",\"text\":\"原始文字\"},\"$:/language/Manager/Item/Tags\":{\"title\":\"$:/language/Manager/Item/Tags\",\"text\":\"标签\"},\"$:/language/Manager/Item/Tools\":{\"title\":\"$:/language/Manager/Item/Tools\",\"text\":\"工具\"},\"$:/language/Manager/Item/WikifiedText\":{\"title\":\"$:/language/Manager/Item/WikifiedText\",\"text\":\"Wikified 文字\"},\"$:/language/MissingTiddler/Hint\":{\"title\":\"$:/language/MissingTiddler/Hint\",\"text\":\"佚失条目 \\\"\u003C$text text=\u003C\u003CcurrentTiddler>>/>\\\" - 点击 {{||$:/core/ui/Buttons/edit}} 可创建此条目\"},\"$:/language/No\":{\"title\":\"$:/language/No\",\"text\":\"否\"},\"$:/language/OfficialPluginLibrary\":{\"title\":\"$:/language/OfficialPluginLibrary\",\"text\":\"~TiddlyWiki 官方插件库\"},\"$:/language/OfficialPluginLibrary/Hint\":{\"title\":\"$:/language/OfficialPluginLibrary/Hint\",\"text\":\"此为在 tiddlywiki.com 的 ~TiddlyWiki 官方插件库。由核心团队维护的插件、主题和语言包。\"},\"$:/language/PageTemplate/Description\":{\"title\":\"$:/language/PageTemplate/Description\",\"text\":\"默认的 ~Tiddlywiki 布局\"},\"$:/language/PageTemplate/Name\":{\"title\":\"$:/language/PageTemplate/Name\",\"text\":\"默认的 ~PageTemplate\"},\"$:/language/PluginReloadWarning\":{\"title\":\"$:/language/PluginReloadWarning\",\"text\":\"请保存 {{$:/core/ui/Buttons/save-wiki}} 并刷新页面 {{$:/core/ui/Buttons/refresh}} ，使 ~JavaScript 插件的更改生效\"},\"$:/language/RecentChanges/DateFormat\":{\"title\":\"$:/language/RecentChanges/DateFormat\",\"text\":\"YYYY年0MM月0DD日\"},\"$:/language/Shortcuts/Input/Accept/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Accept/Hint\",\"text\":\"接受选取的项目\"},\"$:/language/Shortcuts/Input/AcceptVariant/Hint\":{\"title\":\"$:/language/Shortcuts/Input/AcceptVariant/Hint\",\"text\":\"接受选取项目 (变种)\"},\"$:/language/Shortcuts/Input/AdvancedSearch/Hint\":{\"title\":\"$:/language/Shortcuts/Input/AdvancedSearch/Hint\",\"text\":\"从侧边栏搜索字段内打开[[进阶搜索|$:/AdvancedSearch]]面板\"},\"$:/language/Shortcuts/Input/Cancel/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Cancel/Hint\",\"text\":\"清除输入字段\"},\"$:/language/Shortcuts/Input/Down/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Down/Hint\",\"text\":\"选择下一个项目\"},\"$:/language/Shortcuts/Input/Tab-Left/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Tab-Left/Hint\",\"text\":\"选择上一个页签\"},\"$:/language/Shortcuts/Input/Tab-Right/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Tab-Right/Hint\",\"text\":\"选择下一个页签\"},\"$:/language/Shortcuts/Input/Up/Hint\":{\"title\":\"$:/language/Shortcuts/Input/Up/Hint\",\"text\":\"选择前一个项目\"},\"$:/language/Shortcuts/SidebarLayout/Hint\":{\"title\":\"$:/language/Shortcuts/SidebarLayout/Hint\",\"text\":\"更改侧边栏布局\"},\"$:/language/Switcher/Subtitle/theme\":{\"title\":\"$:/language/Switcher/Subtitle/theme\",\"text\":\"切换布局主题\"},\"$:/language/Switcher/Subtitle/layout\":{\"title\":\"$:/language/Switcher/Subtitle/layout\",\"text\":\"切换布局\"},\"$:/language/Switcher/Subtitle/language\":{\"title\":\"$:/language/Switcher/Subtitle/language\",\"text\":\"切换语言\"},\"$:/language/Switcher/Subtitle/palette\":{\"title\":\"$:/language/Switcher/Subtitle/palette\",\"text\":\"切换调色板\"},\"$:/language/SystemTiddler/Tooltip\":{\"title\":\"$:/language/SystemTiddler/Tooltip\",\"text\":\"此为系统条目\"},\"$:/language/SystemTiddlers/Include/Prompt\":{\"title\":\"$:/language/SystemTiddlers/Include/Prompt\",\"text\":\"包括系统条目\"},\"$:/language/TagManager/Colour/Heading\":{\"title\":\"$:/language/TagManager/Colour/Heading\",\"text\":\"颜色\"},\"$:/language/TagManager/Count/Heading\":{\"title\":\"$:/language/TagManager/Count/Heading\",\"text\":\"计数\"},\"$:/language/TagManager/Icon/Heading\":{\"title\":\"$:/language/TagManager/Icon/Heading\",\"text\":\"图标\"},\"$:/language/TagManager/Icons/None\":{\"title\":\"$:/language/TagManager/Icons/None\",\"text\":\"无\"},\"$:/language/TagManager/Info/Heading\":{\"title\":\"$:/language/TagManager/Info/Heading\",\"text\":\"信息\"},\"$:/language/TagManager/Tag/Heading\":{\"title\":\"$:/language/TagManager/Tag/Heading\",\"text\":\"标签\"},\"$:/language/Tiddler/DateFormat\":{\"title\":\"$:/language/Tiddler/DateFormat\",\"text\":\"YYYY年0MM月0DD日 0hh:0mm\"},\"$:/language/UnsavedChangesWarning\":{\"title\":\"$:/language/UnsavedChangesWarning\",\"text\":\"在此 TiddlyWiki 您有尚未保存的变动\"},\"$:/language/Yes\":{\"title\":\"$:/language/Yes\",\"text\":\"是\"},\"$:/language/Modals/Download\":{\"title\":\"$:/language/Modals/Download\",\"type\":\"text/vnd.tiddlywiki\",\"subtitle\":\"Download changes\",\"footer\":\"\u003C$button message=\\\"tm-close-tiddler\\\">关闭\u003C/$button>\",\"help\":\"https://tiddlywiki.com/\",\"text\":\"您的浏览器只支援手动保存。\\n\\n要保存更动的维基，右键点击下方的下载链结，选择\\\"下载文件\\\"或\\\"保存文件\\\"，然后选择文件夹或文件名。\\n\\n//您可以藉由按一下 Ctrl 键（Windows）或 options/ alt 键（Mac OS X）中的链接，稍微加速操作。您不会被提示文件夹或文件名，您的浏览器可能无法辨认它的文件名 -- 在做其他任何事之前，您可能需要重新命名扩展名为 `.html` 的文件。//\\n\\n在智能型手机上，不允许下载文件，但您可以标记链结，然后从一台可以正常保存维基的台式机的维基同步你的书签。\"},\"$:/config/NewJournal/Title\":{\"title\":\"$:/config/NewJournal/Title\",\"text\":\"YYYY年0MM月0DD日\"},\"$:/config/NewJournal/Text\":{\"title\":\"$:/config/NewJournal/Text\",\"text\":\"\"},\"$:/config/NewJournal/Tags\":{\"title\":\"$:/config/NewJournal/Tags\",\"text\":\"日志\\n\"},\"$:/language/Notifications/Save/Done\":{\"title\":\"$:/language/Notifications/Save/Done\",\"text\":\"已保存 wiki\"},\"$:/language/Notifications/Save/Starting\":{\"title\":\"$:/language/Notifications/Save/Starting\",\"text\":\"开始保存 wiki\"},\"$:/language/Notifications/CopiedToClipboard/Succeeded\":{\"title\":\"$:/language/Notifications/CopiedToClipboard/Succeeded\",\"text\":\"已复制到剪贴板！\"},\"$:/language/Notifications/CopiedToClipboard/Failed\":{\"title\":\"$:/language/Notifications/CopiedToClipboard/Failed\",\"text\":\"无法复制到剪贴板！\"},\"$:/language/Search/DefaultResults/Caption\":{\"title\":\"$:/language/Search/DefaultResults/Caption\",\"text\":\"列表\"},\"$:/language/Search/Filter/Caption\":{\"title\":\"$:/language/Search/Filter/Caption\",\"text\":\"筛选\"},\"$:/language/Search/Filter/Hint\":{\"title\":\"$:/language/Search/Filter/Hint\",\"text\":\"以[[筛选表达式|https://tiddlywiki.com/static/Filters.html]]搜索\"},\"$:/language/Search/Filter/Matches\":{\"title\":\"$:/language/Search/Filter/Matches\",\"text\":\"//\u003Csmall>\u003C\u003CresultCount>> 个条目符合条件\u003C/small>//\"},\"$:/language/Search/Matches\":{\"title\":\"$:/language/Search/Matches\",\"text\":\"//\u003Csmall>\u003C\u003CresultCount>> 个条目符合条件\u003C/small>//\"},\"$:/language/Search/Matches/All\":{\"title\":\"$:/language/Search/Matches/All\",\"text\":\"所有匹配：\"},\"$:/language/Search/Matches/Title\":{\"title\":\"$:/language/Search/Matches/Title\",\"text\":\"条目名称匹配：\"},\"$:/language/Search/Search\":{\"title\":\"$:/language/Search/Search\",\"text\":\"搜索\"},\"$:/language/Search/Search/TooShort\":{\"title\":\"$:/language/Search/Search/TooShort\",\"text\":\"搜索文本太短\"},\"$:/language/Search/Shadows/Caption\":{\"title\":\"$:/language/Search/Shadows/Caption\",\"text\":\"默认\"},\"$:/language/Search/Shadows/Hint\":{\"title\":\"$:/language/Search/Shadows/Hint\",\"text\":\"搜索默认条目\"},\"$:/language/Search/Shadows/Matches\":{\"title\":\"$:/language/Search/Shadows/Matches\",\"text\":\"//\u003Csmall>\u003C\u003CresultCount>> 个条目符合条件\u003C/small>//\"},\"$:/language/Search/Standard/Caption\":{\"title\":\"$:/language/Search/Standard/Caption\",\"text\":\"标准\"},\"$:/language/Search/Standard/Hint\":{\"title\":\"$:/language/Search/Standard/Hint\",\"text\":\"搜索一般条目\"},\"$:/language/Search/Standard/Matches\":{\"title\":\"$:/language/Search/Standard/Matches\",\"text\":\"//\u003Csmall>\u003C\u003CresultCount>> 个条目符合条件\u003C/small>//\"},\"$:/language/Search/System/Caption\":{\"title\":\"$:/language/Search/System/Caption\",\"text\":\"系统\"},\"$:/language/Search/System/Hint\":{\"title\":\"$:/language/Search/System/Hint\",\"text\":\"搜索系统条目\"},\"$:/language/Search/System/Matches\":{\"title\":\"$:/language/Search/System/Matches\",\"text\":\"//\u003Csmall>\u003C\u003CresultCount>> 个条目符合条件\u003C/small>//\"},\"$:/language/SideBar/All/Caption\":{\"title\":\"$:/language/SideBar/All/Caption\",\"text\":\"全部\"},\"$:/language/SideBar/Caption\":{\"title\":\"$:/language/SideBar/Caption\",\"text\":\"侧边栏\"},\"$:/language/SideBar/Contents/Caption\":{\"title\":\"$:/language/SideBar/Contents/Caption\",\"text\":\"目录\"},\"$:/language/SideBar/Drafts/Caption\":{\"title\":\"$:/language/SideBar/Drafts/Caption\",\"text\":\"草稿\"},\"$:/language/SideBar/Explorer/Caption\":{\"title\":\"$:/language/SideBar/Explorer/Caption\",\"text\":\"探索\"},\"$:/language/SideBar/Missing/Caption\":{\"title\":\"$:/language/SideBar/Missing/Caption\",\"text\":\"缺失\"},\"$:/language/SideBar/More/Caption\":{\"title\":\"$:/language/SideBar/More/Caption\",\"text\":\"更多\"},\"$:/language/SideBar/Open/Caption\":{\"title\":\"$:/language/SideBar/Open/Caption\",\"text\":\"开启\"},\"$:/language/SideBar/Orphans/Caption\":{\"title\":\"$:/language/SideBar/Orphans/Caption\",\"text\":\"孤立\"},\"$:/language/SideBar/Recent/Caption\":{\"title\":\"$:/language/SideBar/Recent/Caption\",\"text\":\"最近\"},\"$:/language/SideBar/Shadows/Caption\":{\"title\":\"$:/language/SideBar/Shadows/Caption\",\"text\":\"默认\"},\"$:/language/SideBar/System/Caption\":{\"title\":\"$:/language/SideBar/System/Caption\",\"text\":\"系统\"},\"$:/language/SideBar/Tags/Caption\":{\"title\":\"$:/language/SideBar/Tags/Caption\",\"text\":\"标签\"},\"$:/language/SideBar/Tags/Untagged/Caption\":{\"title\":\"$:/language/SideBar/Tags/Untagged/Caption\",\"text\":\"未设标签\"},\"$:/language/SideBar/Tools/Caption\":{\"title\":\"$:/language/SideBar/Tools/Caption\",\"text\":\"工具\"},\"$:/language/SideBar/Types/Caption\":{\"title\":\"$:/language/SideBar/Types/Caption\",\"text\":\"类型\"},\"$:/SiteSubtitle\":{\"title\":\"$:/SiteSubtitle\",\"text\":\"卡片式个人网页笔记\"},\"$:/SiteTitle\":{\"title\":\"$:/SiteTitle\",\"text\":\"我的 ~TiddlyWiki\"},\"$:/language/Snippets/ListByTag\":{\"title\":\"$:/language/Snippets/ListByTag\",\"tags\":\"$:/tags/TextEditor/Snippet\",\"caption\":\"按标签筛选的条目列表\",\"text\":\"\u003C\u003Clist-links \\\"[tag[task]sort[title]]\\\">>\\n\"},\"$:/language/Snippets/MacroDefinition\":{\"title\":\"$:/language/Snippets/MacroDefinition\",\"tags\":\"$:/tags/TextEditor/Snippet\",\"caption\":\"宏的定义\",\"text\":\"\\\\define macroName(param1:\\\"默认值\\\",param2)\\n宏的内容\\n\\\\end\\n\"},\"$:/language/Snippets/Table4x3\":{\"title\":\"$:/language/Snippets/Table4x3\",\"tags\":\"$:/tags/TextEditor/Snippet\",\"caption\":\"4 x 3 的表格\",\"text\":\"|! | !一 | !二 | !三 | !四 |\\n|! 1| | | | |\\n|! 2| | | | |\\n|! 3 | | | | |\\n\"},\"$:/language/Snippets/TableOfContents\":{\"title\":\"$:/language/Snippets/TableOfContents\",\"tags\":\"$:/tags/TextEditor/Snippet\",\"caption\":\"目录\",\"text\":\"\u003Cdiv class=\\\"tc-table-of-contents\\\">\\n\\n\u003C\u003Ctoc-selective-expandable 'TableOfContents'>>\\n\\n\u003C/div>\"},\"$:/language/ThemeTweaks/ThemeTweaks\":{\"title\":\"$:/language/ThemeTweaks/ThemeTweaks\",\"text\":\"主题调整\"},\"$:/language/ThemeTweaks/ThemeTweaks/Hint\":{\"title\":\"$:/language/ThemeTweaks/ThemeTweaks/Hint\",\"text\":\"您可以调整 ''Vanilla'' 布局主题的某些样貌。\"},\"$:/language/ThemeTweaks/Options\":{\"title\":\"$:/language/ThemeTweaks/Options\",\"text\":\"选项\"},\"$:/language/ThemeTweaks/Options/SidebarLayout\":{\"title\":\"$:/language/ThemeTweaks/Options/SidebarLayout\",\"text\":\"侧边栏布局\"},\"$:/language/ThemeTweaks/Options/SidebarLayout/Fixed-Fluid\":{\"title\":\"$:/language/ThemeTweaks/Options/SidebarLayout/Fixed-Fluid\",\"text\":\"固定故事，浮动侧边栏\"},\"$:/language/ThemeTweaks/Options/SidebarLayout/Fluid-Fixed\":{\"title\":\"$:/language/ThemeTweaks/Options/SidebarLayout/Fluid-Fixed\",\"text\":\"浮动故事，固定侧边栏\"},\"$:/language/ThemeTweaks/Options/StickyTitles\":{\"title\":\"$:/language/ThemeTweaks/Options/StickyTitles\",\"text\":\"置顶标题\"},\"$:/language/ThemeTweaks/Options/StickyTitles/Hint\":{\"title\":\"$:/language/ThemeTweaks/Options/StickyTitles/Hint\",\"text\":\"使条目名称吸顶\"},\"$:/language/ThemeTweaks/Options/CodeWrapping\":{\"title\":\"$:/language/ThemeTweaks/Options/CodeWrapping\",\"text\":\"在代码区块中换行\"},\"$:/language/ThemeTweaks/Settings\":{\"title\":\"$:/language/ThemeTweaks/Settings\",\"text\":\"设置\"},\"$:/language/ThemeTweaks/Settings/FontFamily\":{\"title\":\"$:/language/ThemeTweaks/Settings/FontFamily\",\"text\":\"字型\"},\"$:/language/ThemeTweaks/Settings/CodeFontFamily\":{\"title\":\"$:/language/ThemeTweaks/Settings/CodeFontFamily\",\"text\":\"代码字型\"},\"$:/language/ThemeTweaks/Settings/EditorFontFamily\":{\"title\":\"$:/language/ThemeTweaks/Settings/EditorFontFamily\",\"text\":\"编辑器字型\"},\"$:/language/ThemeTweaks/Settings/BackgroundImage\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImage\",\"text\":\"页面背景图像\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment\",\"text\":\"页面背景图像附属\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment/Scroll\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment/Scroll\",\"text\":\"随条目滚动\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment/Fixed\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageAttachment/Fixed\",\"text\":\"固定于窗口\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageSize\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageSize\",\"text\":\"页面背景图像大小\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Auto\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Auto\",\"text\":\"自动\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Cover\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Cover\",\"text\":\"覆盖\"},\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Contain\":{\"title\":\"$:/language/ThemeTweaks/Settings/BackgroundImageSize/Contain\",\"text\":\"包含\"},\"$:/language/ThemeTweaks/Metrics\":{\"title\":\"$:/language/ThemeTweaks/Metrics\",\"text\":\"大小\"},\"$:/language/ThemeTweaks/Metrics/FontSize\":{\"title\":\"$:/language/ThemeTweaks/Metrics/FontSize\",\"text\":\"字体大小\"},\"$:/language/ThemeTweaks/Metrics/LineHeight\":{\"title\":\"$:/language/ThemeTweaks/Metrics/LineHeight\",\"text\":\"行高\"},\"$:/language/ThemeTweaks/Metrics/BodyFontSize\":{\"title\":\"$:/language/ThemeTweaks/Metrics/BodyFontSize\",\"text\":\"条目本文的字体大小\"},\"$:/language/ThemeTweaks/Metrics/BodyLineHeight\":{\"title\":\"$:/language/ThemeTweaks/Metrics/BodyLineHeight\",\"text\":\"条目本文的行高\"},\"$:/language/ThemeTweaks/Metrics/StoryLeft\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryLeft\",\"text\":\"故事左侧位置\"},\"$:/language/ThemeTweaks/Metrics/StoryLeft/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryLeft/Hint\",\"text\":\"故事河（条目区）的左边缘与页面左端的间距\"},\"$:/language/ThemeTweaks/Metrics/StoryTop\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryTop\",\"text\":\"故事顶部位置\"},\"$:/language/ThemeTweaks/Metrics/StoryTop/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryTop/Hint\",\"text\":\"故事河（条目区）的上边缘与页面顶部的间距\"},\"$:/language/ThemeTweaks/Metrics/StoryRight\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryRight\",\"text\":\"故事右侧位置\"},\"$:/language/ThemeTweaks/Metrics/StoryRight/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryRight/Hint\",\"text\":\"侧边栏的左边缘与页面左端的间距\"},\"$:/language/ThemeTweaks/Metrics/StoryWidth\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryWidth\",\"text\":\"故事的宽度\"},\"$:/language/ThemeTweaks/Metrics/StoryWidth/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/StoryWidth/Hint\",\"text\":\"故事河的整体宽度\"},\"$:/language/ThemeTweaks/Metrics/TiddlerWidth\":{\"title\":\"$:/language/ThemeTweaks/Metrics/TiddlerWidth\",\"text\":\"条目宽度\"},\"$:/language/ThemeTweaks/Metrics/TiddlerWidth/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/TiddlerWidth/Hint\",\"text\":\"在故事河内\"},\"$:/language/ThemeTweaks/Metrics/SidebarBreakpoint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/SidebarBreakpoint\",\"text\":\"侧边栏中断点\"},\"$:/language/ThemeTweaks/Metrics/SidebarBreakpoint/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/SidebarBreakpoint/Hint\",\"text\":\"故事河和侧边栏会并排显示的最小页面宽度\"},\"$:/language/ThemeTweaks/Metrics/SidebarWidth\":{\"title\":\"$:/language/ThemeTweaks/Metrics/SidebarWidth\",\"text\":\"侧边栏宽度\"},\"$:/language/ThemeTweaks/Metrics/SidebarWidth/Hint\":{\"title\":\"$:/language/ThemeTweaks/Metrics/SidebarWidth/Hint\",\"text\":\"在 浮动故事，固定侧边栏 布局中，侧边栏的宽度\"},\"$:/language/TiddlerInfo/Advanced/Caption\":{\"title\":\"$:/language/TiddlerInfo/Advanced/Caption\",\"text\":\"高级\"},\"$:/language/TiddlerInfo/Advanced/PluginInfo/Empty/Hint\":{\"title\":\"$:/language/TiddlerInfo/Advanced/PluginInfo/Empty/Hint\",\"text\":\"无信息\"},\"$:/language/TiddlerInfo/Advanced/PluginInfo/Heading\":{\"title\":\"$:/language/TiddlerInfo/Advanced/PluginInfo/Heading\",\"text\":\"插件明细\"},\"$:/language/TiddlerInfo/Advanced/PluginInfo/Hint\":{\"title\":\"$:/language/TiddlerInfo/Advanced/PluginInfo/Hint\",\"text\":\"此插件包含以下预设条目：\"},\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Heading\":{\"title\":\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Heading\",\"text\":\"默认条目状态\"},\"$:/language/TiddlerInfo/Advanced/ShadowInfo/NotShadow/Hint\":{\"title\":\"$:/language/TiddlerInfo/Advanced/ShadowInfo/NotShadow/Hint\",\"text\":\"\u003C$link to=\u003C\u003CinfoTiddler>>>\u003C$text text=\u003C\u003CinfoTiddler>>/>\u003C/$link> 不是一个默认条目\"},\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Shadow/Hint\":{\"title\":\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Shadow/Hint\",\"text\":\"\u003C$link to=\u003C\u003CinfoTiddler>>>\u003C$text text=\u003C\u003CinfoTiddler>>/>\u003C/$link> 是一个默认条目\"},\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Shadow/Source\":{\"title\":\"$:/language/TiddlerInfo/Advanced/ShadowInfo/Shadow/Source\",\"text\":\"此条目定义于插件 \u003C$link to=\u003C\u003CpluginTiddler>>>\u003C$text text=\u003C\u003CpluginTiddler>>/>\u003C/$link>\"},\"$:/language/TiddlerInfo/Advanced/ShadowInfo/OverriddenShadow/Hint\":{\"title\":\"$:/language/TiddlerInfo/Advanced/ShadowInfo/OverriddenShadow/Hint\",\"text\":\"已被一般条目覆盖\"},\"$:/language/TiddlerInfo/Fields/Caption\":{\"title\":\"$:/language/TiddlerInfo/Fields/Caption\",\"text\":\"字段\"},\"$:/language/TiddlerInfo/List/Caption\":{\"title\":\"$:/language/TiddlerInfo/List/Caption\",\"text\":\"列表\"},\"$:/language/TiddlerInfo/List/Empty\":{\"title\":\"$:/language/TiddlerInfo/List/Empty\",\"text\":\"此条目无指定列表\"},\"$:/language/TiddlerInfo/Listed/Caption\":{\"title\":\"$:/language/TiddlerInfo/Listed/Caption\",\"text\":\"被列于\"},\"$:/language/TiddlerInfo/Listed/Empty\":{\"title\":\"$:/language/TiddlerInfo/Listed/Empty\",\"text\":\"此条目未出现于其他条目的列表中\"},\"$:/language/TiddlerInfo/References/Caption\":{\"title\":\"$:/language/TiddlerInfo/References/Caption\",\"text\":\"反向链接\"},\"$:/language/TiddlerInfo/References/Empty\":{\"title\":\"$:/language/TiddlerInfo/References/Empty\",\"text\":\"无条目链接至此\"},\"$:/language/TiddlerInfo/Tagging/Caption\":{\"title\":\"$:/language/TiddlerInfo/Tagging/Caption\",\"text\":\"子条目\"},\"$:/language/TiddlerInfo/Tagging/Empty\":{\"title\":\"$:/language/TiddlerInfo/Tagging/Empty\",\"text\":\"无任何条目以此条目之标题为标签\"},\"$:/language/TiddlerInfo/Tools/Caption\":{\"title\":\"$:/language/TiddlerInfo/Tools/Caption\",\"text\":\"工具\"},\"$:/language/Docs/Types/application/javascript\":{\"title\":\"$:/language/Docs/Types/application/javascript\",\"description\":\"JavaScript 源码\",\"name\":\"application/javascript\",\"group\":\"开发者\"},\"$:/language/Docs/Types/application/json\":{\"title\":\"$:/language/Docs/Types/application/json\",\"description\":\"JSON 数据\",\"name\":\"application/json\",\"group\":\"开发者\"},\"$:/language/Docs/Types/application/x-tiddler-dictionary\":{\"title\":\"$:/language/Docs/Types/application/x-tiddler-dictionary\",\"description\":\"数据字典\",\"name\":\"application/x-tiddler-dictionary\",\"group\":\"开发者\"},\"$:/language/Docs/Types/image/gif\":{\"title\":\"$:/language/Docs/Types/image/gif\",\"description\":\"GIF 图像\",\"name\":\"image/gif\",\"group\":\"图像\"},\"$:/language/Docs/Types/image/jpeg\":{\"title\":\"$:/language/Docs/Types/image/jpeg\",\"description\":\"JPEG 图像\",\"name\":\"image/jpeg\",\"group\":\"图像\"},\"$:/language/Docs/Types/image/png\":{\"title\":\"$:/language/Docs/Types/image/png\",\"description\":\"PNG 图像\",\"name\":\"image/png\",\"group\":\"图像\"},\"$:/language/Docs/Types/image/svg+xml\":{\"title\":\"$:/language/Docs/Types/image/svg+xml\",\"description\":\"结构式矢量图\",\"name\":\"image/svg+xml\",\"group\":\"图像\"},\"$:/language/Docs/Types/image/x-icon\":{\"title\":\"$:/language/Docs/Types/image/x-icon\",\"description\":\"图标\",\"name\":\"image/x-icon\",\"group\":\"图像\"},\"$:/language/Docs/Types/text/css\":{\"title\":\"$:/language/Docs/Types/text/css\",\"description\":\"静态样式\",\"name\":\"text/css\",\"group\":\"开发者\"},\"$:/language/Docs/Types/text/html\":{\"title\":\"$:/language/Docs/Types/text/html\",\"description\":\"HTML 标记\",\"name\":\"text/html\",\"group\":\"文本\"},\"$:/language/Docs/Types/text/plain\":{\"title\":\"$:/language/Docs/Types/text/plain\",\"description\":\"纯文本\",\"name\":\"text/plain\",\"group\":\"文本\"},\"$:/language/Docs/Types/text/vnd.tiddlywiki\":{\"title\":\"$:/language/Docs/Types/text/vnd.tiddlywiki\",\"description\":\"TiddlyWiki 5\",\"name\":\"text/vnd.tiddlywiki\",\"group\":\"文本\"},\"$:/language/Docs/Types/text/x-tiddlywiki\":{\"title\":\"$:/language/Docs/Types/text/x-tiddlywiki\",\"description\":\"TiddlyWiki 2\",\"name\":\"text/x-tiddlywiki\",\"group\":\"文本\"},\"$:/config/Search/MinLength\":{\"title\":\"$:/config/Search/MinLength\",\"text\":\"1\"},\"$:/languages/zh-Hans/icon\":{\"title\":\"$:/languages/zh-Hans/icon\",\"type\":\"image/svg+xml\",\"text\":\"\u003C?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\u003C!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\u003Csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"1500\\\" height=\\\"1000\\\" viewBox=\\\"-5 -5 30 20\\\">\\n\u003Ctitle>Flag of the People's Republic of China\u003C/title>\\n\u003Crect fill=\\\"#de2910\\\" x=\\\"-5\\\" y=\\\"-5\\\" width=\\\"30\\\" height=\\\"20\\\"/>\\n\u003Cdefs>\\n\u003Cpolygon id=\\\"s\\\" points=\\\"0,-513674 301930,415571 -488533,-158734 488533,-158734 -301930,415571\\\"\\nfill=\\\"#ffde00\\\" transform=\\\"scale(0.0000019467600073)\\\"/>\\n\u003C/defs>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"scale(3)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(5,-3) rotate(-120.963756)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(7,-1) rotate(-98.130102)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(7,2) rotate(-74.054604)\\\"/>\\n\u003Cuse xlink:href=\\\"#s\\\" transform=\\\"translate(5,4) rotate(-51.3401917)\\\"/>\\n\u003C/svg>\\n\"}}}"},
{"text":"{\"tiddlers\":{\"$:/plugins/linonetwo/inverse-link-and-folder/infobar\":{\"title\":\"$:/plugins/linonetwo/inverse-link-and-folder/infobar\",\"created\":\"20200414150455988\",\"creator\":\"LinOnetwo\",\"tags\":\"$:/tags/ViewTemplate\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\u003C$reveal\\n\\tstate=\u003C\u003Cfolded-state>>\\n\\ttype=\\\"nomatch\\\"\\n\\ttext=\\\"hide\\\"\\n\\tanimate=\\\"yes\\\"\\n>\\n\u003C!-- \u003C$list filter=\\\"[all[current]backtranscludes[]first[]sort[title]]\\\">\\n\\t\u003Clabel style=\\\"margin-left:auto;margin-right:auto;width:fit-content;display:block;\\\">嵌出 (other)-{}->(this)\u003C/label>\\n\u003C/$list>\\n\\n\u003C\u003Cinverse-link-and-folder_list-links filter:\\\"[all[current]backtranscludes[]]\\\" class:\\\"horizontal-list-links\\\" >> -->\\n\\n\u003C$list filter=\\\"[all[current]backlinks[]first[]sort[title]]\\\">\\n\\t\u003Clabel style=\\\"margin-left:auto;margin-right:auto;width:fit-content;display:block;\\\">链入\u003C/label>\\n\u003C/$list>\\n\\n\u003C\u003Cinverse-link-and-folder_list-links filter:\\\"[all[current]backlinks[]]\\\" class:\\\"horizontal-list-links\\\" >>\\n\\n\u003C$list filter=\\\"[all[current]tagging[]first[]]\\\">\\n\\t\u003Clabel style=\\\"margin-left:auto;margin-right:auto;width:fit-content;display:block;\\\">此文件夹中的文件\u003C/label>\\n\u003C/$list>\\n\\n\u003C\u003Cinverse-link-and-folder_list-links filter:\\\"[all[current]tagging[]sort[title]]\\\" class:\\\"horizontal-list-links\\\" >>\\n\\n\u003C/$reveal>\"},\"$:/plugins/linonetwo/inverse-link-and-folder/list-link.css\":{\"title\":\"$:/plugins/linonetwo/inverse-link-and-folder/list-link.css\",\"tags\":\"$:/tags/Stylesheet\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\".horizontal-list-links {\\n  display: flex;\\n  flex-direction: row;\\n  flex-wrap: wrap;\\n  max-height: 250px;\\n  overflow-y: auto;\\n  padding: 0;\\n  list-style-type: none;\\n}\\n.horizontal-list-links::-webkit-scrollbar {\\n\\twidth: 0 !important\\n}\\n\\n.horizontal-list-links li a,\\n.horizontal-list-links li a:hover {\\n  line-height: unset;\\n  background-color: unset;\\n  border: none;\\n  padding: 5px;\\n  line-height: 1.8;\\n}\\n\"},\"$:/plugins/linonetwo/inverse-link-and-folder/list-link\":{\"title\":\"$:/plugins/linonetwo/inverse-link-and-folder/list-link\",\"created\":\"20200414150455988\",\"creator\":\"LinOnetwo\",\"tags\":\"$:/tags/Macro\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\define inverse-link-and-folder_list-links(filter,type:\\\"ul\\\",subtype:\\\"li\\\",class:\\\"\\\",emptyMessage)\\n\\\\whitespace trim\\n  \u003C$type$ class=\\\"$class$\\\">\\n    \u003C$list filter=\\\"$filter$\\\" emptyMessage=\u003C\u003C__emptyMessage__>>>\\n      \u003C$subtype$>\\n        \u003C$link to={{!!title}}>\\n          \u003C$macrocall $name=\\\"tag-pill-body\\\" tag=\u003C\u003CcurrentTiddler>> icon={{!!icon}} colour={{!!color}} palette={{$:/palette}} element-tag=\\\"\\\"\\\"$button\\\"\\\"\\\" element-attributes=\\\"\\\"\\\"tag='span'\\\"\\\"\\\"/>\\n        \u003C/$link>\\n      \u003C/$subtype$>\\n    \u003C/$list>\\n  \u003C/$type$>\\n\\\\end\\n\"},\"$:/plugins/linonetwo/inverse-link-and-folder/readme\":{\"title\":\"$:/plugins/linonetwo/inverse-link-and-folder/readme\",\"created\":\"20200602150455988\",\"creator\":\"LinOnetwo\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"!! Features\\n\\nThis plugin provides these additional info on the bottom of every tiddler:\\n\\n# other tiddler linking to this tiddler\\n# tiddlers in this folder (tagged with this tiddler's title, see tw-locator's document for detail about the tag-based folder structure)\\n# folders containing this tiddler (since tag-based folder structure is a Graph, so there may be many)\\n\\nYou can change [[infobar.tid|$:/plugins/linonetwo/inverse-link-and-folder/infobar]] to add more info.\\n\\n[[list-link.tid|$:/plugins/linonetwo/inverse-link-and-folder/list-link]] and [[list-link.css|$:/plugins/linonetwo/inverse-link-and-folder/list-link.css]] are styles of that info bar.\\n\\n!! Credits\\n\\nThis plugin is inspired by RoamResearch. list-link macro and filter in infobar is learnt from  copy&paste-ing of Jeremy's code and tutorials.\\n\"}}}","type":"application/json","author":"LinOnetwo","core-version":">=5.1.22","dependents":"","description":"Add inverse link (bi-directional link) and folder information to the bottom of tiddlers","list":"readme","name":"inverse-link-and-folder","plugin-type":"plugin","title":"$:/plugins/linonetwo/inverse-link-and-folder","version":"0.0.4"},
{"created":"20231022061234684","title":"$:/SiteTitle","text":"蛙二的记忆","modified":"20231022061238692"},
{"created":"20231021150800467","title":"$:/state/advancedsearch/currentTab","text":"$:/core/ui/AdvancedSearch/Filter","modified":"20231027050605669"},
{"title":"$:/state/http-requests","text":"0"},
{"created":"20231021151041891","title":"$:/state/showeditpreview","text":"no","modified":"20231029060132463"},
{"created":"20231021150800467","title":"$:/state/tab--1498284803","text":"$:/core/ui/AdvancedSearch/Filter","modified":"20231027050605670"},
{"created":"20231017154415339","title":"$:/state/tab--1963855381","text":"$:/core/ui/ControlPanel/Toolbars","modified":"20231021152211515"},
{"created":"20231017154623715","title":"$:/state/tab--2112689675","text":"$:/core/ui/ControlPanel/Basics","modified":"20231022061231279"},
{"created":"20231017154552339","title":"$:/state/tab--86143343","text":"$:/core/ui/ControlPanel/Plugins/Installed/Plugins","modified":"20231026143826559"},
{"created":"20231017154556812","title":"$:/state/tab-1688658110","text":"$:/core/ui/ControlPanel/Plugins/Add/Languages","modified":"20231017154556812"},
{"created":"20231017154411811","title":"$:/state/tab-1749438307","text":"$:/core/ui/ControlPanel/Info","modified":"20231028062354710"},
{"created":"20231021152458906","title":"$:/state/tab-256990426","text":"$:/core/ui/TiddlerInfo/Fields","modified":"20231021153713490"},
{"created":"20231017154528980","title":"$:/state/tab/sidebar--595412856","text":"$:/core/ui/SideBar/Recent","modified":"20231030065533641"},
{"created":"20231017154423227","title":"$:/state/tabs/controlpanel/toolbars-1345989671","text":"$:/core/ui/ControlPanel/Toolbars/ViewToolbar","modified":"20231017154425339"},
{"title":"$:/status/RequireReloadDueToPluginChange","text":"no"},
{"title":"$:/StoryList","created":"20231030065538937","text":"","list":"$:/AdvancedSearch 目录","modified":"20231030065538937"},
{"title":"$:/themes/tiddlywiki/snowwhite","name":"Snow White","author":"JeremyRuston","core-version":">=5.0.0","plugin-type":"theme","description":"Emphasises individual tiddlers","dependents":"$:/themes/tiddlywiki/vanilla","plugin-priority":"0","version":"5.3.1","type":"application/json","text":"{\"tiddlers\":{\"$:/themes/tiddlywiki/snowwhite/base\":{\"title\":\"$:/themes/tiddlywiki/snowwhite/base\",\"tags\":\"[[$:/tags/Stylesheet]]\",\"text\":\"\\\\define sidebarbreakpoint-minus-one()\\n\u003C$text text={{{ [{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}removesuffix[px]subtract[1]addsuffix[px]] ~[{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}] }}}/>\\n\\\\end\\n\\n\\\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline\\n\\n.tc-sidebar-header {\\n\\ttext-shadow: 0 1px 0 \u003C\u003Ccolour sidebar-foreground-shadow>>;\\n}\\n\\n.tc-tiddler-info {\\n\\t\u003C\u003Cbox-shadow \\\"inset 1px 2px 3px rgba(0,0,0,0.1)\\\">>\\n}\\n\\n@media screen {\\n\\t.tc-tiddler-frame {\\n\\t\\t\u003C\u003Cbox-shadow \\\"1px 1px 5px rgba(0, 0, 0, 0.3)\\\">>\\n\\t}\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\t.tc-tiddler-frame {\\n\\t\\t\u003C\u003Cbox-shadow none>>\\n\\t}\\n}\\n\\n.tc-page-controls button svg, .tc-tiddler-controls button svg, .tc-topbar button svg {\\n\\t\u003C\u003Ctransition \\\"fill 150ms ease-in-out\\\">>\\n}\\n\\n.tc-tiddler-controls button.tc-selected,\\n.tc-page-controls button.tc-selected {\\n\\t\u003C\u003Cfilter \\\"drop-shadow(0px -1px 2px rgba(0,0,0,0.25))\\\">>\\n}\\n\\n.tc-tiddler-frame input.tc-edit-texteditor,\\n.tc-tiddler-frame select.tc-edit-texteditor {\\n\\t\u003C\u003Cbox-shadow \\\"inset 0 1px 8px rgba(0, 0, 0, 0.15)\\\">>\\n}\\n\\n.tc-edit-tags {\\n\\t\u003C\u003Cbox-shadow \\\"inset 0 1px 8px rgba(0, 0, 0, 0.15)\\\">>\\n}\\n\\n.tc-tiddler-frame .tc-edit-tags input.tc-edit-texteditor {\\n\\t\u003C\u003Cbox-shadow \\\"none\\\">>\\n\\tborder: none;\\n\\toutline: none;\\n}\\n\\ntextarea.tc-edit-texteditor {\\n\\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/editorfontfamily}};\\n}\\n\\ncanvas.tc-edit-bitmapeditor  {\\n\\t\u003C\u003Cbox-shadow \\\"2px 2px 5px rgba(0, 0, 0, 0.5)\\\">>\\n}\\n\\n.tc-drop-down {\\n\\tborder-radius: 4px;\\n\\t\u003C\u003Cbox-shadow \\\"2px 2px 10px rgba(0, 0, 0, 0.5)\\\">>\\n}\\n\\n.tc-block-dropdown {\\n\\tborder-radius: 4px;\\n\\t\u003C\u003Cbox-shadow \\\"2px 2px 10px rgba(0, 0, 0, 0.5)\\\">>\\n}\\n\\n.tc-modal {\\n\\tborder-radius: 6px;\\n\\t\u003C\u003Cbox-shadow \\\"0 3px 7px rgba(0,0,0,0.3)\\\">>\\n}\\n\\n.tc-modal-footer {\\n\\tborder-radius: 0 0 6px 6px;\\n\\t\u003C\u003Cbox-shadow \\\"inset 0 1px 0 #fff\\\">>;\\n}\\n\\n\\n.tc-alert {\\n\\tborder-radius: 6px;\\n\\t\u003C\u003Cbox-shadow \\\"0 3px 7px rgba(0,0,0,0.6)\\\">>\\n}\\n\\n.tc-notification {\\n\\tborder-radius: 6px;\\n\\t\u003C\u003Cbox-shadow \\\"0 3px 7px rgba(0,0,0,0.3)\\\">>\\n\\ttext-shadow: 0 1px 0 rgba(255,255,255, 0.8);\\n}\\n\\n.tc-sidebar-lists .tc-tab-set .tc-tab-divider {\\n\\tborder-top: none;\\n\\theight: 1px;\\n\\t\u003C\u003Cbackground-linear-gradient \\\"left, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.0) 100%\\\">>\\n}\\n\\n.tc-more-sidebar > .tc-tab-set > .tc-tab-buttons > button {\\n\\t\u003C\u003Cbackground-linear-gradient \\\"left, rgba(0,0,0,0.01) 0%, rgba(0,0,0,0.1) 100%\\\">>\\n}\\n\\n.tc-more-sidebar > .tc-tab-set > .tc-tab-buttons > button.tc-tab-selected {\\n\\t\u003C\u003Cbackground-linear-gradient \\\"left, rgba(0,0,0,0.05) 0%, rgba(255,255,255,0.05) 100%\\\">>\\n}\\n\\n.tc-message-box img {\\n\\t\u003C\u003Cbox-shadow \\\"1px 1px 3px rgba(0,0,0,0.5)\\\">>\\n}\\n\\n.tc-plugin-info {\\n\\t\u003C\u003Cbox-shadow \\\"1px 1px 3px rgba(0,0,0,0.5)\\\">>\\n}\\n\"}}}"},
{"title":"$:/themes/tiddlywiki/vanilla","name":"Vanilla","author":"JeremyRuston","core-version":">=5.0.0","plugin-type":"theme","description":"Basic theme","plugin-priority":"0","version":"5.3.1","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/themes/tiddlywiki/vanilla/themetweaks\":{\"title\":\"$:/themes/tiddlywiki/vanilla/themetweaks\",\"tags\":\"$:/tags/ControlPanel/Appearance\",\"caption\":\"{{$:/language/ThemeTweaks/ThemeTweaks}}\",\"text\":\"\\\\define lingo-base() $:/language/ThemeTweaks/\\n\\n\\\\define replacement-text()\\n[img[$(imageTitle)$]]\\n\\\\end\\n\\n\\\\define backgroundimage-dropdown()\\n\u003Cdiv class=\\\"tc-drop-down-wrapper\\\">\\n\u003C$set name=\\\"state\\\" value=\u003C\u003Cqualify \\\"$:/state/popup/themetweaks/backgroundimage\\\">>>\\n\u003C$button popup=\u003C\u003Cstate>> class=\\\"tc-btn-invisible tc-btn-dropdown\\\">{{$:/core/images/down-arrow}}\u003C/$button>\\n\u003C$reveal state=\u003C\u003Cstate>> type=\\\"popup\\\" position=\\\"belowleft\\\" text=\\\"\\\" default=\\\"\\\" class=\\\"tc-popup-keep\\\">\\n\u003Cdiv class=\\\"tc-drop-down\\\" style=\\\"text-align:center;\\\">\\n\u003C$macrocall $name=\\\"image-picker\\\" actions=\\\"\\\"\\\"\\n\\n\u003C$action-setfield\\n\\t$tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimage\\\"\\n\\t$value=\u003C\u003CimageTitle>>\\n/>\\n\\n\u003C$action-deletetiddler $tiddler=\u003C\u003Cstate>>/>\\n\\n\\\"\\\"\\\"/>\\n\u003C/div>\\n\u003C/$reveal>\\n\u003C/$set>\\n\u003C/div>\\n\\\\end\\n\\n\\\\define backgroundimageattachment-dropdown()\\n\u003C$select tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimageattachment\\\" default=\\\"scroll\\\">\\n\u003Coption value=\\\"scroll\\\">\u003C\u003Clingo Settings/BackgroundImageAttachment/Scroll>>\u003C/option>\\n\u003Coption value=\\\"fixed\\\">\u003C\u003Clingo Settings/BackgroundImageAttachment/Fixed>>\u003C/option>\\n\u003C/$select>\\n\\\\end\\n\\n\\\\define backgroundimagesize-dropdown()\\n\u003C$select tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize\\\" default=\\\"scroll\\\">\\n\u003Coption value=\\\"auto\\\">\u003C\u003Clingo Settings/BackgroundImageSize/Auto>>\u003C/option>\\n\u003Coption value=\\\"cover\\\">\u003C\u003Clingo Settings/BackgroundImageSize/Cover>>\u003C/option>\\n\u003Coption value=\\\"contain\\\">\u003C\u003Clingo Settings/BackgroundImageSize/Contain>>\u003C/option>\\n\u003C/$select>\\n\\\\end\\n\\n\u003C\u003Clingo ThemeTweaks/Hint>>\\n\\n! \u003C\u003Clingo Options>>\\n\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/options/sidebarlayout\\\">\u003C\u003Clingo Options/SidebarLayout>>\u003C/$link> |\u003C$select tiddler=\\\"$:/themes/tiddlywiki/vanilla/options/sidebarlayout\\\">\u003Coption value=\\\"fixed-fluid\\\">\u003C\u003Clingo Options/SidebarLayout/Fixed-Fluid>>\u003C/option>\u003Coption value=\\\"fluid-fixed\\\">\u003C\u003Clingo Options/SidebarLayout/Fluid-Fixed>>\u003C/option>\u003C/$select> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/options/stickytitles\\\">\u003C\u003Clingo Options/StickyTitles>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Options/StickyTitles/Hint>>// |\u003C$select tiddler=\\\"$:/themes/tiddlywiki/vanilla/options/stickytitles\\\">\u003Coption value=\\\"no\\\">{{$:/language/No}}\u003C/option>\u003Coption value=\\\"yes\\\">{{$:/language/Yes}}\u003C/option>\u003C/$select> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/options/codewrapping\\\">\u003C\u003Clingo Options/CodeWrapping>>\u003C/$link> |\u003C$select tiddler=\\\"$:/themes/tiddlywiki/vanilla/options/codewrapping\\\">\u003Coption value=\\\"pre\\\">{{$:/language/No}}\u003C/option>\u003Coption value=\\\"pre-wrap\\\">{{$:/language/Yes}}\u003C/option>\u003C/$select> |\\n\\n! \u003C\u003Clingo Settings>>\\n\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\\\">\u003C\u003Clingo Settings/FontFamily>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\\\" default=\\\"\\\" tag=\\\"input\\\"/> | |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/codefontfamily\\\">\u003C\u003Clingo Settings/CodeFontFamily>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/codefontfamily\\\" default=\\\"\\\" tag=\\\"input\\\"/> | |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/editorfontfamily\\\">\u003C\u003Clingo Settings/EditorFontFamily>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/editorfontfamily\\\" default=\\\"\\\" tag=\\\"input\\\"/> | |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimage\\\">\u003C\u003Clingo Settings/BackgroundImage>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimage\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\u003C\u003Cbackgroundimage-dropdown>> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimageattachment\\\">\u003C\u003Clingo Settings/BackgroundImageAttachment>>\u003C/$link> |\u003C\u003Cbackgroundimageattachment-dropdown>> | |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize\\\">\u003C\u003Clingo Settings/BackgroundImageSize>>\u003C/$link> |\u003C\u003Cbackgroundimagesize-dropdown>> | |\\n\\n! \u003C\u003Clingo Metrics>>\\n\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/fontsize\\\">\u003C\u003Clingo Metrics/FontSize>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/fontsize\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/lineheight\\\">\u003C\u003Clingo Metrics/LineHeight>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/lineheight\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/bodyfontsize\\\">\u003C\u003Clingo Metrics/BodyFontSize>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/bodyfontsize\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/bodylineheight\\\">\u003C\u003Clingo Metrics/BodyLineHeight>>\u003C/$link> |\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/bodylineheight\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/storyleft\\\">\u003C\u003Clingo Metrics/StoryLeft>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/StoryLeft/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/storyleft\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/storytop\\\">\u003C\u003Clingo Metrics/StoryTop>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/StoryTop/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/storytop\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/storyright\\\">\u003C\u003Clingo Metrics/StoryRight>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/StoryRight/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/storyright\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/storywidth\\\">\u003C\u003Clingo Metrics/StoryWidth>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/StoryWidth/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/storywidth\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth\\\">\u003C\u003Clingo Metrics/TiddlerWidth>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/TiddlerWidth/Hint>>//\u003Cbr> |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint\\\">\u003C\u003Clingo Metrics/SidebarBreakpoint>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/SidebarBreakpoint/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n|\u003C$link to=\\\"$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth\\\">\u003C\u003Clingo Metrics/SidebarWidth>>\u003C/$link>\u003Cbr>//\u003C\u003Clingo Metrics/SidebarWidth/Hint>>// |^\u003C$edit-text tiddler=\\\"$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth\\\" default=\\\"\\\" tag=\\\"input\\\"/> |\\n\"},\"$:/themes/tiddlywiki/vanilla/base\":{\"title\":\"$:/themes/tiddlywiki/vanilla/base\",\"tags\":\"[[$:/tags/Stylesheet]]\",\"code-body\":\"yes\",\"text\":\"\\\\define custom-background-datauri()\\n\u003C$set name=\\\"background\\\" value={{$:/themes/tiddlywiki/vanilla/settings/backgroundimage}}>\\n\u003C$list filter=\\\"[\u003Cbackground>is[image]]\\\">\\n`background: url(`\\n\u003C$list filter=\\\"[\u003Cbackground>!has[_canonical_uri]]\\\">\\n`\\\"`\u003C$macrocall $name=\\\"datauri\\\" title={{$:/themes/tiddlywiki/vanilla/settings/backgroundimage}}/>`\\\"`\\n\u003C/$list>\\n\u003C$list filter=\\\"[\u003Cbackground>has[_canonical_uri]]\\\">\\n`\\\"`\u003C$view tiddler={{$:/themes/tiddlywiki/vanilla/settings/backgroundimage}} field=\\\"_canonical_uri\\\"/>`\\\"`\\n\u003C/$list>\\n`) center center;`\\n`background-attachment: `{{$:/themes/tiddlywiki/vanilla/settings/backgroundimageattachment}}`;\\n-webkit-background-size:` {{$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize}}`;\\n-moz-background-size:` {{$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize}}`;\\n-o-background-size:` {{$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize}}`;\\nbackground-size:` {{$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize}}`;`\\n\u003C/$list>\\n\u003C/$set>\\n\\\\end\\n\\n\\\\define sidebarbreakpoint()\\n\u003C$text text={{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}/>\\n\\\\end\\n\\n\\\\define sidebarbreakpoint-minus-one()\\n\u003C$text text={{{ [{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}removesuffix[px]subtract[1]addsuffix[px]] ~[{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}] }}}/>\\n\\\\end\\n\\n\\\\define if-fluid-fixed(text,hiddenSidebarText)\\n\u003C$reveal state=\\\"$:/themes/tiddlywiki/vanilla/options/sidebarlayout\\\" type=\\\"match\\\" text=\\\"fluid-fixed\\\">\\n$text$\\n\u003C$reveal state=\\\"$:/state/sidebar\\\" type=\\\"nomatch\\\" text=\\\"yes\\\" default=\\\"yes\\\">\\n$hiddenSidebarText$\\n\u003C/$reveal>\\n\u003C/$reveal>\\n\\\\end\\n\\n\\\\define if-editor-height-fixed(then,else)\\n\u003C$reveal state=\\\"$:/config/TextEditor/EditorHeight/Mode\\\" type=\\\"match\\\" text=\\\"fixed\\\">\\n$then$\\n\u003C/$reveal>\\n\u003C$reveal state=\\\"$:/config/TextEditor/EditorHeight/Mode\\\" type=\\\"match\\\" text=\\\"auto\\\">\\n$else$\\n\u003C/$reveal>\\n\\\\end\\n\\n\\\\define set-type-selector-min-width()\\n\u003C$set name=\\\"typeLength\\\" value={{{ [all[shadows+tiddlers]prefix[$:/language/Docs/Types/]get[name]length[]maxall[]] }}}>\\n\\n\\t.tc-type-selector-dropdown-wrapper {\\n\\t\\tmin-width: calc(\u003C\u003CtypeLength>>ch + 4em);\\n\\t}\\n\\n\\t.tc-type-selector-dropdown-wrapper input.tc-edit-typeeditor {\\n\\t\\tmin-width: \u003C\u003CtypeLength>>ch;\\n\\t}\\n\\n\u003C/$set>\\n\\\\end\\n\\n\\\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline macrocallblock\\n\\n/*\\n** Start with the normalize CSS reset, and then belay some of its effects\\n*/\\n\\n{{$:/themes/tiddlywiki/vanilla/reset}}\\n\\n*, input[type=\\\"search\\\"] {\\n\\tbox-sizing: border-box;\\n\\t-moz-box-sizing: border-box;\\n\\t-webkit-box-sizing: border-box;\\n}\\n\\n/*\\n** Button default styles. Makes them look consistent for all browsers\\n*/\\nhtml button {\\n\\tline-height: 1.2;\\n\\tcolor: \u003C\u003Ccolour button-foreground>>;\\n\\tfill: \u003C\u003Ccolour button-foreground>>;\\n\\tbackground: \u003C\u003Ccolour button-background>>;\\n\\tborder-color: \u003C\u003Ccolour button-border>>;\\n}\\n\\nbutton:disabled svg {\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n/*\\n** Basic element styles\\n*/\\n\\nhtml, body {\\n\\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/fontfamily}};\\n\\ttext-rendering: optimizeLegibility; /* Enables kerning and ligatures etc. */\\n\\t-webkit-font-smoothing: antialiased;\\n\\t-moz-osx-font-smoothing: grayscale;\\n}\\n\\nhtml:-webkit-full-screen {\\n\\tbackground-color: \u003C\u003Ccolour page-background>>;\\n}\\n\\nbody.tc-body {\\n\\tfont-size: {{$:/themes/tiddlywiki/vanilla/metrics/fontsize}};\\n\\tline-height: {{$:/themes/tiddlywiki/vanilla/metrics/lineheight}};\\n\\tword-wrap: break-word;\\n\\t\u003C\u003Ccustom-background-datauri>>\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n\\tbackground-color: \u003C\u003Ccolour page-background>>;\\n\\tfill: \u003C\u003Ccolour foreground>>;\\n}\\n\\n\u003C\u003Cif-background-attachment \\\"\\\"\\\"\\n\\nbody.tc-body {\\n\\tbackground-color: transparent;\\n}\\n\\n\\\"\\\"\\\">>\\n\\n/**\\n * Correct the font size and margin on `h1` elements within `section` and\\n * `article` contexts in Chrome, Firefox, and Safari.\\n */\\n\\nh1 {\\n\\tfont-size: 2em;\\n}\\n\\nh1, h2, h3, h4, h5, h6 {\\n\\tline-height: 1.2;\\n\\tfont-weight: normal;\\n}\\n\\npre {\\n\\tdisplay: block;\\n\\tmargin-top: 1em;\\n\\tmargin-bottom: 1em;\\n\\tword-break: normal;\\n\\tword-wrap: break-word;\\n\\twhite-space: {{$:/themes/tiddlywiki/vanilla/options/codewrapping}};\\n\\tbackground-color: \u003C\u003Ccolour pre-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour pre-border>>;\\n\\tpadding: 0 3px 2px;\\n\\tborder-radius: 3px;\\n\\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/codefontfamily}};\\n}\\n\\ncode {\\n\\tcolor: \u003C\u003Ccolour code-foreground>>;\\n\\tbackground-color: \u003C\u003Ccolour code-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour code-border>>;\\n\\twhite-space: {{$:/themes/tiddlywiki/vanilla/options/codewrapping}};\\n\\tpadding: 0 3px 2px;\\n\\tborder-radius: 3px;\\n\\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/codefontfamily}};\\n}\\n\\nblockquote {\\n\\tborder-left: 5px solid \u003C\u003Ccolour blockquote-bar>>;\\n\\tmargin-left: 25px;\\n\\tpadding-left: 10px;\\n\\tquotes: \\\"\\\\201C\\\"\\\"\\\\201D\\\"\\\"\\\\2018\\\"\\\"\\\\2019\\\";\\n}\\n\\nblockquote > div {\\n\\tmargin-top: 1em;\\n\\tmargin-bottom: 1em;\\n}\\n\\nblockquote.tc-big-quote {\\n\\tfont-family: Georgia, serif;\\n\\tposition: relative;\\n\\tbackground: \u003C\u003Ccolour pre-background>>;\\n\\tborder-left: none;\\n\\tmargin-left: 50px;\\n\\tmargin-right: 50px;\\n\\tpadding: 10px;\\n\\tborder-radius: 8px;\\n}\\n\\nblockquote.tc-big-quote cite:before {\\n\\tcontent: \\\"\\\\2014 \\\\2009\\\";\\n}\\n\\nblockquote.tc-big-quote:before {\\n\\tfont-family: Georgia, serif;\\n\\tcolor: \u003C\u003Ccolour blockquote-bar>>;\\n\\tcontent: open-quote;\\n\\tfont-size: 8em;\\n\\tline-height: 0.1em;\\n\\tmargin-right: 0.25em;\\n\\tvertical-align: -0.4em;\\n\\tposition: absolute;\\n\\tleft: -50px;\\n\\ttop: 42px;\\n}\\n\\nblockquote.tc-big-quote:after {\\n\\tfont-family: Georgia, serif;\\n\\tcolor: \u003C\u003Ccolour blockquote-bar>>;\\n\\tcontent: close-quote;\\n\\tfont-size: 8em;\\n\\tline-height: 0.1em;\\n\\tmargin-right: 0.25em;\\n\\tvertical-align: -0.4em;\\n\\tposition: absolute;\\n\\tright: -80px;\\n\\tbottom: -20px;\\n}\\n\\ndl dt {\\n\\tfont-weight: bold;\\n\\tmargin-top: 6px;\\n}\\n\\ntextarea,\\ninput[type=text],\\ninput[type=search],\\ninput[type=\\\"\\\"],\\ninput:not([type]) {\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n}\\n\\ninput[type=\\\"checkbox\\\"] {\\n\\tvertical-align: middle;\\n}\\n\\ninput[type=\\\"search\\\"]::-webkit-search-decoration,\\ninput[type=\\\"search\\\"]::-webkit-search-cancel-button,\\ninput[type=\\\"search\\\"]::-webkit-search-results-button,\\ninput[type=\\\"search\\\"]::-webkit-search-results-decoration {\\n\\t-webkit-appearance:none;\\n}\\n\\n.tc-muted {\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\nsvg.tc-image-button {\\n\\tpadding: 0px 1px 1px 0px;\\n}\\n\\n.tc-icon-wrapper > svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n}\\n\\nkbd {\\n\\tdisplay: inline-block;\\n\\tpadding: 3px 5px;\\n\\tfont-size: 0.8em;\\n\\tline-height: 1.2;\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n\\tvertical-align: middle;\\n\\tbackground-color: \u003C\u003Ccolour background>>;\\n\\tborder: solid 1px \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-bottom-color: \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-radius: 3px;\\n\\tbox-shadow: inset 0 -1px 0 \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n::selection {\\n\\tbackground-color: Highlight;\\n\\tcolor: HighlightText;\\n\\tbackground-color: \u003C\u003Ccolour selection-background>>;\\n\\tcolor: \u003C\u003Ccolour selection-foreground>>;\\n}\\n\\n.tc-inline-style {\\n\\tbackground: \u003C\u003Ccolour highlight-background>>;\\n\\tcolor: \u003C\u003Ccolour highlight-foreground>>;\\n}\\n\\nform.tc-form-inline {\\n\\tdisplay: inline;\\n}\\n\\n/*\\nMarkdown likes putting code elements inside pre elements\\n*/\\npre > code {\\n\\tpadding: 0;\\n\\tborder: none;\\n\\tbackground-color: inherit;\\n\\tcolor: inherit;\\n}\\n\\n/*\\nTable defaults\\n*/\\n\\ntable {\\n\\tborder: 1px solid \u003C\u003Ccolour table-border>>;\\n\\twidth: auto;\\n\\tmax-width: 100%;\\n\\tcaption-side: bottom;\\n\\tmargin-top: 1em;\\n\\tmargin-bottom: 1em;\\n\\t/* next 2 elements needed, since normalize 8.0.1 */\\n\\tborder-collapse: collapse;\\n\\tborder-spacing: 0;\\n}\\n\\ntable th, table td {\\n\\tpadding: 0 7px 0 7px;\\n\\tborder-top: 1px solid \u003C\u003Ccolour table-border>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour table-border>>;\\n}\\n\\ntable thead tr td, table th {\\n\\tbackground-color: \u003C\u003Ccolour table-header-background>>;\\n\\tfont-weight: bold;\\n}\\n\\ntable tfoot tr td {\\n\\tbackground-color: \u003C\u003Ccolour table-footer-background>>;\\n}\\n\\n/*\\nTable utility classes\\n*/\\n\\n/* Remove borders from table as used in eg: GettingStarted*/\\n.tc-table-no-border,\\n.tc-table-no-border th,\\n.tc-table-no-border td {\\n\\tborder: initial;\\n}\\n\\n/* First column in table width will fit to text.*/\\n/* This rule makes most sense with tc-first-link-nowrap*/\\n.tc-first-col-min-width td:nth-child(1) {\\n\\twidth: 1%;\\n}\\n\\n/*\\n** Utility classes work well with tables but also for other containers\\n*/\\n\\n/* First link A element will not wrap */\\n.tc-first-link-nowrap:first-of-type a {\\n\\twhite-space: nowrap;\\n}\\n\\n/* Move the table to the center of the container */\\n.tc-center {\\n\\tmargin-left: auto;\\n\\tmargin-right: auto;\\n}\\n\\n.tc-max-width {\\n\\twidth: 100%;\\n}\\n\\n.tc-max-width-80 {\\n\\tmax-width: 80%;\\n}\\n\\n/* Allow input and textarea to look like the ControlPanel inputs */\\n.tc-edit-max-width input,\\n.tc-edit-max-width textarea {\\n\\twidth: 100%;\\n\\tpadding: 3px;\\n}\\n\\n/*\\nCSV parser plugin\\n*/\\n\\n.tc-csv-table {\\n\\twhite-space: nowrap;\\n}\\n\\n.tc-csv-table th,\\n.tc-csv-table td {\\n\\twhite-space: pre-line;\\n}\\n\\n/*\\nTiddler frame in story river\\n*/\\n\\n.tc-tiddler-frame img,\\n.tc-tiddler-frame svg,\\n.tc-tiddler-frame canvas,\\n.tc-tiddler-frame embed,\\n.tc-tiddler-frame iframe {\\n\\tmax-width: 100%;\\n}\\n\\n.tc-tiddler-body > embed,\\n.tc-tiddler-body > iframe {\\n\\twidth: 100%;\\n\\theight: 600px;\\n}\\n\\n:root {\\n\\tcolor-scheme: {{{ [{$:/palette}get[color-scheme]] ~light }}};\\n}\\n\\n/*\\n** Links\\n*/\\n\\nbutton.tc-tiddlylink,\\na.tc-tiddlylink {\\n\\ttext-decoration: none;\\n\\tfont-weight: 500;\\n\\tcolor: \u003C\u003Ccolour tiddler-link-foreground>>;\\n\\t-webkit-user-select: inherit; /* Otherwise the draggable attribute makes links impossible to select */\\n\\t-webkit-touch-callout: none; /* Prevents long presses from bringing up a link preview */\\n}\\n\\n.tc-sidebar-lists a.tc-tiddlylink {\\n\\tcolor: \u003C\u003Ccolour sidebar-tiddler-link-foreground>>;\\n}\\n\\n.tc-sidebar-lists a.tc-tiddlylink:hover {\\n\\tcolor: \u003C\u003Ccolour sidebar-tiddler-link-foreground-hover>>;\\n}\\n\\nbutton.tc-tiddlylink:hover,\\na.tc-tiddlylink:hover {\\n\\ttext-decoration: underline;\\n}\\n\\na.tc-tiddlylink-resolves {\\n}\\n\\na.tc-tiddlylink-shadow {\\n\\tfont-weight: bold;\\n}\\n\\na.tc-tiddlylink-shadow.tc-tiddlylink-resolves {\\n\\tfont-weight: normal;\\n}\\n\\na.tc-tiddlylink-missing {\\n\\tfont-style: italic;\\n}\\n\\na.tc-tiddlylink-external {\\n\\ttext-decoration: underline;\\n\\tcolor: \u003C\u003Ccolour external-link-foreground>>;\\n\\tbackground-color: \u003C\u003Ccolour external-link-background>>;\\n}\\n\\na.tc-tiddlylink-external:visited {\\n\\tcolor: \u003C\u003Ccolour external-link-foreground-visited>>;\\n\\tbackground-color: \u003C\u003Ccolour external-link-background-visited>>;\\n}\\n\\na.tc-tiddlylink-external:hover {\\n\\tcolor: \u003C\u003Ccolour external-link-foreground-hover>>;\\n\\tbackground-color: \u003C\u003Ccolour external-link-background-hover>>;\\n}\\n\\n.tc-drop-down a.tc-tiddlylink:hover {\\n\\tcolor: \u003C\u003Ccolour tiddler-link-background>>;\\n}\\n\\n/*\\n** Drag and drop styles\\n*/\\n\\n.tc-tiddler-dragger {\\n\\tposition: relative;\\n\\tz-index: -10000;\\n}\\n\\n.tc-tiddler-dragger-inner {\\n\\tposition: absolute;\\n\\ttop: -1000px;\\n\\tleft: -1000px;\\n\\tdisplay: inline-block;\\n\\tpadding: 8px 20px;\\n\\tfont-size: 16.9px;\\n\\tfont-weight: bold;\\n\\tline-height: 20px;\\n\\tcolor: \u003C\u003Ccolour dragger-foreground>>;\\n\\ttext-shadow: 0 1px 0 rgba(0, 0, 0, 1);\\n\\twhite-space: nowrap;\\n\\tvertical-align: baseline;\\n\\tbackground-color: \u003C\u003Ccolour dragger-background>>;\\n\\tborder-radius: 20px;\\n}\\n\\n.tc-tiddler-dragger-cover {\\n\\tposition: absolute;\\n\\tbackground-color: \u003C\u003Ccolour page-background>>;\\n}\\n\\n.tc-page-container > .tc-dropzone {\\n\\tmin-height: 100vh;\\n}\\n\\n.tc-dropzone {\\n\\tposition: relative;\\n}\\n\\n.tc-dropzone.tc-dragover:before {\\n\\tz-index: 10000;\\n\\tdisplay: block;\\n\\tposition: fixed;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tbackground: \u003C\u003Ccolour dropzone-background>>;\\n\\ttext-align: center;\\n\\tcontent: \\\"\u003C\u003Clingo DropMessage>>\\\";\\n}\\n\\n.tc-droppable > .tc-droppable-placeholder {\\n\\tdisplay: none;\\n}\\n\\n.tc-droppable.tc-dragover > .tc-droppable-placeholder {\\n\\tdisplay: block;\\n\\tborder: 2px dashed \u003C\u003Ccolour dropzone-background>>;\\n}\\n\\n.tc-draggable {\\n\\tcursor: move;\\n}\\n\\n.tc-sidebar-tab-open .tc-droppable-placeholder, .tc-tagged-draggable-list .tc-droppable-placeholder,\\n.tc-links-draggable-list .tc-droppable-placeholder {\\n\\tline-height: 2em;\\n\\theight: 2em;\\n}\\n\\n.tc-sidebar-tab-open-item {\\n\\tposition: relative;\\n}\\n\\n.tc-sidebar-tab-open .tc-btn-invisible.tc-btn-mini svg {\\n\\tfont-size: 0.7em;\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n/*\\n** Plugin reload warning\\n*/\\n\\n.tc-plugin-reload-warning {\\n\\tz-index: 1000;\\n\\tdisplay: block;\\n\\tposition: fixed;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tbackground: \u003C\u003Ccolour alert-background>>;\\n\\ttext-align: center;\\n}\\n\\n/*\\n** Buttons\\n*/\\n\\nbutton svg, button img, label svg, label img {\\n\\tvertical-align: middle;\\n}\\n\\n.tc-btn-invisible {\\n\\tpadding: 0;\\n\\tmargin: 0;\\n\\tbackground: none;\\n\\tborder: none;\\n\\tcursor: pointer;\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n\\tfill: \u003C\u003Ccolour foreground>>;\\n}\\n\\nbutton:disabled.tc-btn-invisible  {\\n\\tcursor: default;\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-btn-boxed {\\n\\tfont-size: 0.6em;\\n\\tpadding: 0.2em;\\n\\tmargin: 1px;\\n\\tbackground: none;\\n\\tborder: 1px solid \u003C\u003Ccolour tiddler-controls-foreground>>;\\n\\tborder-radius: 0.25em;\\n}\\n\\nhtml body.tc-body .tc-btn-boxed svg {\\n\\tfont-size: 1.6666em;\\n}\\n\\n.tc-btn-boxed:hover {\\n\\tbackground: \u003C\u003Ccolour muted-foreground>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n}\\n\\nhtml body.tc-body .tc-btn-boxed:hover svg {\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-btn-rounded {\\n\\tfont-size: 0.5em;\\n\\tline-height: 2;\\n\\tpadding: 0em 0.3em 0.2em 0.4em;\\n\\tmargin: 1px;\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tbackground: \u003C\u003Ccolour muted-foreground>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tborder-radius: 2em;\\n}\\n\\nhtml body.tc-body .tc-btn-rounded svg {\\n\\tfont-size: 1.6666em;\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-btn-rounded:hover {\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\nhtml body.tc-body .tc-btn-rounded:hover svg {\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-btn-icon svg {\\n\\theight: 1em;\\n\\twidth: 1em;\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n\\n.tc-btn-text {\\n\\tmargin-left: 7px;\\n}\\n\\n/* used for documentation \\\"fake\\\" buttons */\\n.tc-btn-standard {\\n\\tline-height: 1.8;\\n\\tcolor: #667;\\n\\tbackground-color: #e0e0e0;\\n\\tborder: 1px solid #888;\\n\\tpadding: 2px 1px 2px 1px;\\n\\tmargin: 1px 4px 1px 4px;\\n}\\n\\n.tc-btn-big-green {\\n\\tdisplay: inline-block;\\n\\tpadding: 8px;\\n\\tmargin: 4px 8px 4px 8px;\\n\\tbackground: \u003C\u003Ccolour download-background>>;\\n\\tcolor: \u003C\u003Ccolour download-foreground>>;\\n\\tfill: \u003C\u003Ccolour download-foreground>>;\\n\\tborder: none;\\n\\tborder-radius: 2px;\\n\\tfont-size: 1.2em;\\n\\tline-height: 1.4em;\\n\\ttext-decoration: none;\\n}\\n\\n.tc-btn-big-green svg,\\n.tc-btn-big-green img {\\n\\theight: 2em;\\n\\twidth: 2em;\\n\\tvertical-align: middle;\\n\\tfill: \u003C\u003Ccolour download-foreground>>;\\n}\\n\\n.tc-primary-btn {\\n\\tbackground: \u003C\u003Ccolour primary>>;\\n}\\n\\n.tc-sidebar-lists input {\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-sidebar-lists button {\\n\\tcolor: \u003C\u003Ccolour sidebar-button-foreground>>;\\n\\tfill: \u003C\u003Ccolour sidebar-button-foreground>>;\\n}\\n\\n.tc-sidebar-lists button.tc-btn-mini {\\n\\tcolor: \u003C\u003Ccolour sidebar-muted-foreground>>;\\n}\\n\\n.tc-sidebar-lists button.tc-btn-mini:hover {\\n\\tcolor: \u003C\u003Ccolour sidebar-muted-foreground-hover>>;\\n}\\n\\n.tc-sidebar-lists button small {\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n}\\n\\nbutton svg.tc-image-button, button .tc-image-button img {\\n\\theight: 1em;\\n\\twidth: 1em;\\n}\\n\\n.tc-unfold-banner {\\n\\tposition: absolute;\\n\\tpadding: 0;\\n\\tmargin: 0;\\n\\tbackground: none;\\n\\tborder: none;\\n\\twidth: 100%;\\n\\twidth: calc(100% + 2px);\\n\\tmargin-left: -43px;\\n\\ttext-align: center;\\n\\tborder-top: 2px solid \u003C\u003Ccolour tiddler-info-background>>;\\n\\tmargin-top: 4px;\\n}\\n\\n.tc-unfold-banner:hover {\\n\\tbackground: \u003C\u003Ccolour tiddler-info-background>>;\\n\\tborder-top: 2px solid \u003C\u003Ccolour tiddler-info-border>>;\\n}\\n\\n.tc-unfold-banner svg, .tc-fold-banner svg {\\n\\theight: 0.75em;\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground>>;\\n}\\n\\n.tc-unfold-banner:hover svg, .tc-fold-banner:hover svg {\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground-hover>>;\\n}\\n\\n.tc-fold-banner {\\n\\tposition: absolute;\\n\\tpadding: 0;\\n\\tmargin: 0;\\n\\tbackground: none;\\n\\tborder: none;\\n\\twidth: 23px;\\n\\ttext-align: center;\\n\\tmargin-left: -35px;\\n\\ttop: 6px;\\n\\tbottom: 6px;\\n}\\n\\n.tc-fold-banner:hover {\\n\\tbackground: \u003C\u003Ccolour tiddler-info-background>>;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\n\\t.tc-unfold-banner {\\n\\t\\tposition: static;\\n\\t\\twidth: calc(100% + 59px);\\n\\t}\\n\\n\\t.tc-fold-banner {\\n\\t\\twidth: 16px;\\n\\t\\tmargin-left: -16px;\\n\\t\\tfont-size: 0.75em;\\n\\t}\\n\\n}\\n\\n/*\\n** Tags and missing tiddlers\\n*/\\n\\n.tc-tag-list-item {\\n\\tposition: relative;\\n\\tdisplay: inline-block;\\n}\\n\\n.tc-tags-wrapper {\\n\\tmargin: 4px 0 14px 0;\\n}\\n\\n.tc-tags-wrapper .tc-tag-list-item {\\n\\tmargin-right: 7px;\\n}\\n\\n.tc-missing-tiddler-label {\\n\\tfont-style: italic;\\n\\tfont-weight: normal;\\n\\tdisplay: inline-block;\\n\\tfont-size: 11.844px;\\n\\tline-height: 14px;\\n\\twhite-space: nowrap;\\n\\tvertical-align: baseline;\\n}\\n\\n.tc-block-tags-dropdown > .tc-btn-invisible:hover {\\n\\tbackground-color: \u003C\u003Ccolour primary>>;\\n}\\n\\nbutton.tc-tag-label, span.tc-tag-label {\\n\\tdisplay: inline-block;\\n\\tpadding: 0.16em 0.7em;\\n\\tfont-size: 0.9em;\\n\\tfont-weight: normal;\\n\\tline-height: 1.2em;\\n\\tcolor: \u003C\u003Ccolour tag-foreground>>;\\n\\twhite-space: break-spaces;\\n\\tvertical-align: baseline;\\n\\tbackground-color: \u003C\u003Ccolour tag-background>>;\\n\\tborder-radius: 1em;\\n}\\n\\n.tc-sidebar-scrollable .tc-tag-label {\\n\\ttext-shadow: none;\\n}\\n\\n.tc-untagged-separator {\\n\\tborder: 0;\\n\\theight: 1px;\\n\\tbackground: \u003C\u003Ccolour tab-divider>>;\\n}\\n\\nbutton.tc-untagged-label {\\n\\tbackground-color: \u003C\u003Ccolour untagged-background>>;\\n}\\n\\n.tc-tag-label svg, .tc-tag-label img {\\n\\theight: 1em;\\n\\twidth: 1em;\\n\\tmargin-right: 3px;\\n\\tmargin-bottom: 1px;\\n\\tvertical-align: bottom;\\n}\\n\\n.tc-edit-tags button.tc-remove-tag-button svg {\\n\\tfont-size: 0.7em;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-tag-manager-table .tc-tag-label {\\n}\\n\\n.tc-tag-manager-tag {\\n\\twidth: 100%;\\n}\\n\\nbutton.tc-btn-invisible.tc-remove-tag-button {\\n\\toutline: none;\\n}\\n\\n.tc-tag-button-selected,\\n.tc-list-item-selected a.tc-tiddlylink, a.tc-list-item-selected {\\n\\tbackground-color: \u003C\u003Ccolour primary>>;\\n\\tcolor: \u003C\u003Ccolour tiddler-background>>;\\n}\\n\\n/*\\n** Page layout\\n*/\\n\\n.tc-topbar {\\n\\tposition: fixed;\\n\\tz-index: 1200;\\n}\\n\\n.tc-topbar-left {\\n\\tleft: 29px;\\n\\ttop: 5px;\\n}\\n\\n.tc-topbar-right {\\n\\ttop: 5px;\\n\\tright: 29px;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\n\\t.tc-topbar-right {\\n\\t\\tright: 10px;\\n\\t}\\n\\n}\\n\\n.tc-topbar button {\\n\\tpadding: 8px;\\n}\\n\\n.tc-topbar svg {\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-topbar button:hover svg {\\n\\tfill: \u003C\u003Ccolour foreground>>;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\n\\t.tc-show-sidebar-btn svg.tc-image-chevron-left, .tc-hide-sidebar-btn svg.tc-image-chevron-right {\\n\\t\\ttransform: rotate(-90deg);\\n\\t}\\n\\n}\\n\\n.tc-sidebar-header {\\n\\tcolor: \u003C\u003Ccolour sidebar-foreground>>;\\n\\tfill: \u003C\u003Ccolour sidebar-foreground>>;\\n}\\n\\n.tc-sidebar-header .tc-title a.tc-tiddlylink-resolves {\\n\\tfont-weight: normal;\\n}\\n\\n.tc-sidebar-header .tc-sidebar-lists p {\\n\\tmargin-top: 3px;\\n\\tmargin-bottom: 3px;\\n}\\n\\n.tc-sidebar-header .tc-missing-tiddler-label {\\n\\tcolor: \u003C\u003Ccolour sidebar-foreground>>;\\n}\\n\\n.tc-advanced-search input {\\n\\twidth: 60%;\\n}\\n\\n.tc-search a svg {\\n\\twidth: 1.2em;\\n\\theight: 1.2em;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-page-controls {\\n\\tmargin-top: 14px;\\n\\tfont-size: 1.5em;\\n}\\n\\n.tc-page-controls .tc-drop-down {\\n\\tfont-size: 1rem;\\n}\\n\\n.tc-page-controls button {\\n\\tmargin-right: 0.5em;\\n}\\n\\n.tc-page-controls a.tc-tiddlylink:hover {\\n\\ttext-decoration: none;\\n}\\n\\n.tc-page-controls img {\\n\\twidth: 1em;\\n}\\n\\n.tc-page-controls svg {\\n\\tfill: \u003C\u003Ccolour sidebar-controls-foreground>>;\\n}\\n\\n.tc-page-controls button:hover svg, .tc-page-controls a:hover svg {\\n\\tfill: \u003C\u003Ccolour sidebar-controls-foreground-hover>>;\\n}\\n\\n.tc-sidebar-lists .tc-menu-list-item {\\n\\twhite-space: nowrap;\\n}\\n\\n.tc-menu-list-count {\\n\\tfont-weight: bold;\\n}\\n\\n.tc-menu-list-subitem {\\n\\tpadding-left: 7px;\\n}\\n\\n.tc-story-river {\\n\\tposition: relative;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\n\\t.tc-sidebar-header {\\n\\t\\tpadding: 14px;\\n\\t\\tmin-height: 32px;\\n\\t\\tmargin-top: {{$:/themes/tiddlywiki/vanilla/metrics/storytop}};\\n\\t\\ttransition:  min-height {{$:/config/AnimationDuration}}ms ease-in-out, padding-top {{$:/config/AnimationDuration}}ms ease-in-out, padding-bottom {{$:/config/AnimationDuration}}ms ease-in-out;\\n\\t}\\n\\t\\n\\t\u003C\u003Cif-no-sidebar \\\"\\\"\\\"\\n\\n\\t\\t.tc-sidebar-header {\\n\\t\\t\\tmin-height: 0;\\n\\t\\t\\tpadding-top: 0;\\n\\t\\t\\tpadding-bottom: 0;\\n\\t\\t}\\n\\n\\t\\\"\\\"\\\">>\\n\\n\\t.tc-story-river {\\n\\t\\tposition: relative;\\n\\t\\tpadding: 0;\\n\\t}\\n}\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\\t.tc-message-box {\\n\\t\\tmargin: 21px -21px 21px -21px;\\n\\t}\\n\\n\\t.tc-sidebar-scrollable {\\n\\t\\tposition: fixed;\\n\\t\\ttop: {{$:/themes/tiddlywiki/vanilla/metrics/storytop}};\\n\\t\\tleft: {{$:/themes/tiddlywiki/vanilla/metrics/storyright}};\\n\\t\\tbottom: 0;\\n\\t\\tright: 0;\\n\\t\\toverflow-y: auto;\\n\\t\\toverflow-x: auto;\\n\\t\\t-webkit-overflow-scrolling: touch;\\n\\t\\tmargin: 0 0 0 -42px;\\n\\t\\tpadding: 71px 0 28px 42px;\\n\\t}\\n\\n\\thtml[dir=\\\"rtl\\\"] .tc-sidebar-scrollable {\\n\\t\\tleft: auto;\\n\\t\\tright: {{$:/themes/tiddlywiki/vanilla/metrics/storyright}};\\n\\t}\\n\\n\\t.tc-story-river {\\n\\t\\tposition: relative;\\n\\t\\tleft: {{$:/themes/tiddlywiki/vanilla/metrics/storyleft}};\\n\\t\\ttop: {{$:/themes/tiddlywiki/vanilla/metrics/storytop}};\\n\\t\\twidth: {{$:/themes/tiddlywiki/vanilla/metrics/storywidth}};\\n\\t\\tpadding: 42px 42px 42px 42px;\\n\\t}\\n\\n\u003C\u003Cif-no-sidebar \\\"\\n\\n\\t.tc-story-river {\\n\\t\\twidth: calc(100% - {{$:/themes/tiddlywiki/vanilla/metrics/storyleft}});\\n\\t}\\n\\n\\\">>\\n\\n\\t.tc-story-river.tc-static-story-river {\\n\\t\\tmargin-right: 0;\\n\\t\\tpadding-right: 42px;\\n\\t}\\n\\n}\\n\\n@media print {\\n\\n\\tbody.tc-body {\\n\\t\\tbackground-color: transparent;\\n\\t}\\n\\n\\t.tc-sidebar-header, .tc-topbar {\\n\\t\\tdisplay: none;\\n\\t}\\n\\n\\t.tc-story-river {\\n\\t\\tmargin: 0;\\n\\t\\tpadding: 0;\\n\\t}\\n\\n\\t.tc-story-river .tc-tiddler-frame {\\n\\t\\tmargin: 0;\\n\\t\\tborder: none;\\n\\t\\tpadding: 0;\\n\\t}\\n}\\n\\n/*\\n** Tiddler styles\\n*/\\n\\n.tc-tiddler-frame {\\n\\tposition: relative;\\n\\tmargin-bottom: 28px;\\n\\tbackground-color: \u003C\u003Ccolour tiddler-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour tiddler-border>>;\\n}\\n\\n{{$:/themes/tiddlywiki/vanilla/sticky}}\\n\\n.tc-tiddler-info {\\n\\toverflow: hidden;\\n\\tpadding: 14px 42px 14px 42px;\\n\\tbackground-color: \u003C\u003Ccolour tiddler-info-background>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour tiddler-info-border>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tiddler-info-border>>;\\n}\\n\\n.tc-tiddler-info p {\\n\\tmargin-top: 3px;\\n\\tmargin-bottom: 3px;\\n}\\n\\n.tc-tiddler-info .tc-tab-buttons button.tc-tab-selected {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-info-tab-background>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tiddler-info-tab-background>>;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\n\\t.tc-tiddler-info {\\n\\t\\tpadding: 14px 14px 14px 14px;\\n\\t}\\n\\n}\\n\\n.tc-view-field-table {\\n\\twidth: 100%;\\n}\\n\\n.tc-view-field-name {\\n\\twidth: 1%; /* Makes this column be as narrow as possible */\\n\\twhite-space: nowrap;\\n\\tvertical-align: top;\\n\\ttext-align: right;\\n\\tfont-style: italic;\\n\\tfont-weight: normal;\\n}\\n\\n.tc-view-field-value {\\n\\tword-break: break-all;\\n}\\n\\n@media (max-width: \u003C\u003Csidebarbreakpoint-minus-one>>) {\\n\\t.tc-tiddler-frame {\\n\\t\\tpadding: 14px 14px 14px 14px;\\n\\t\\tmargin-bottom: .5em;\\n\\t}\\n\\n\\t.tc-tiddler-info {\\n\\t\\tmargin: 0 -14px 0 -14px;\\n\\t}\\n}\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\t.tc-tiddler-frame {\\n\\t\\tpadding: 28px 42px 42px 42px;\\n\\t\\twidth: {{$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth}};\\n\\t\\tborder-radius: 2px;\\n\\t}\\n\\n\u003C\u003Cif-no-sidebar \\\"\\n\\n\\t.tc-tiddler-frame {\\n\\t\\twidth: 100%;\\n\\t}\\n\\n\\\">>\\n\\n\\t.tc-tiddler-info {\\n\\t\\tmargin: 0 -42px 0 -42px;\\n\\t}\\n}\\n\\n.tc-site-title,\\n.tc-titlebar {\\n\\tfont-weight: normal;\\n\\tfont-size: 2.35em;\\n\\tline-height: 1.35em;\\n\\tcolor: \u003C\u003Ccolour tiddler-title-foreground>>;\\n\\tmargin: 0;\\n}\\n\\n.tc-site-title {\\n\\tcolor: \u003C\u003Ccolour site-title-foreground>>;\\n}\\n\\n.tc-tiddler-title-icon {\\n\\tvertical-align: middle;\\n\\tmargin-right: .1em;\\n}\\n\\n.tc-tiddler-title-icon svg {\\n\\twidth: 0.9em;\\n\\theight: 0.9em;\\n}\\n\\n.tc-system-title-prefix {\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-titlebar h2 {\\n\\tfont-size: 1em;\\n\\tdisplay: inline;\\n}\\n\\n.tc-titlebar img {\\n\\theight: 1em;\\n}\\n\\n.tc-subtitle {\\n\\tfont-size: 0.9em;\\n\\tcolor: \u003C\u003Ccolour tiddler-subtitle-foreground>>;\\n\\tfont-weight: normal;\\n}\\n\\n.tc-subtitle .tc-tiddlylink {\\n\\tmargin-right: .3em;\\n}\\n\\n.tc-tiddler-missing .tc-title {\\n\\tfont-style: italic;\\n\\tfont-weight: normal;\\n}\\n\\n.tc-tiddler-frame .tc-tiddler-controls {\\n\\tfloat: right;\\n\\tpadding: 3px; /* make space for outline */\\n}\\n\\n.tc-tiddler-controls .tc-drop-down {\\n\\tfont-size: 0.6em;\\n}\\n\\n.tc-tiddler-controls .tc-drop-down .tc-drop-down {\\n\\tfont-size: 1em;\\n}\\n\\n.tc-tiddler-controls > span > button,\\n.tc-tiddler-controls > span > span > button,\\n.tc-tiddler-controls > span > span > span > button {\\n\\tvertical-align: baseline;\\n\\tmargin-left:5px;\\n}\\n\\n.tc-tiddler-controls button svg, .tc-tiddler-controls button img,\\n.tc-search button svg, .tc-search a svg {\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground>>;\\n}\\n\\n.tc-tiddler-controls button svg, .tc-tiddler-controls button img {\\n\\theight: 0.75em;\\n}\\n\\n.tc-search button svg, .tc-search a svg {\\n\\theight: 1.2em;\\n\\twidth: 1.2em;\\n\\tmargin: 0 0.25em;\\n}\\n\\n.tc-tiddler-controls button.tc-selected svg,\\n.tc-page-controls button.tc-selected svg  {\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground-selected>>;\\n}\\n\\n.tc-tiddler-controls button.tc-btn-invisible:hover svg,\\n.tc-search button:hover svg, .tc-search a:hover svg {\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground-hover>>;\\n}\\n\\n@media print {\\n\\t.tc-tiddler-controls {\\n\\t\\tdisplay: none;\\n\\t}\\n}\\n\\n.tc-tiddler-help { /* Help prompts within tiddler template */\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n\\tmargin-top: 14px;\\n}\\n\\n.tc-tiddler-help a.tc-tiddlylink {\\n\\tcolor: \u003C\u003Ccolour very-muted-foreground>>;\\n}\\n\\n.tc-tiddler-frame .tc-edit-texteditor {\\n\\twidth: 100%;\\n\\tmargin: 4px 0 4px 0;\\n}\\n\\n.tc-tiddler-frame input.tc-edit-texteditor,\\n.tc-tiddler-frame textarea.tc-edit-texteditor,\\n.tc-tiddler-frame iframe.tc-edit-texteditor,\\n.tc-tiddler-frame select.tc-edit-texteditor {\\n\\tpadding: 3px 3px 3px 3px;\\n\\tborder: 1px solid \u003C\u003Ccolour tiddler-editor-border>>;\\n\\tline-height: 1.3em;\\n\\tfont-family: {{$:/themes/tiddlywiki/vanilla/settings/editorfontfamily}};\\n}\\n\\n.tc-tiddler-frame input.tc-edit-texteditor,\\n.tc-tiddler-frame textarea.tc-edit-texteditor,\\n.tc-tiddler-frame iframe.tc-edit-texteditor {\\n\\t-webkit-appearance: none;\\n}\\n\\n.tc-tiddler-frame input.tc-edit-texteditor,\\n.tc-tiddler-frame select.tc-edit-texteditor,\\n.tc-tiddler-frame textarea.tc-edit-texteditor {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-editor-background>>;\\n}\\n\\n.tc-tiddler-frame iframe.tc-edit-texteditor {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-background>>;\\n}\\n\\n.tc-tiddler-frame .tc-edit-fields input.tc-edit-fieldeditor,\\n.tc-tiddler-frame .tc-edit-fields select.tc-edit-fieldeditor,\\n.tc-tiddler-frame .tc-edit-fields textarea.tc-edit-fieldeditor {\\n\\tmargin: 0;\\n\\tpadding: 2px 3px;\\n}\\n\\n.tc-tiddler-frame .tc-binary-warning {\\n\\twidth: 100%;\\n\\theight: 5em;\\n\\ttext-align: center;\\n\\tpadding: 3em 3em 6em 3em;\\n\\tbackground: \u003C\u003Ccolour alert-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour alert-border>>;\\n}\\n\\ncanvas.tc-edit-bitmapeditor  {\\n\\tborder: 6px solid \u003C\u003Ccolour tiddler-editor-border-image>>;\\n\\tcursor: crosshair;\\n\\t-moz-user-select: none;\\n\\t-webkit-user-select: none;\\n\\t-ms-user-select: none;\\n\\tmargin-top: 6px;\\n\\tmargin-bottom: 6px;\\n}\\n\\n.tc-edit-bitmapeditor-width {\\n\\tdisplay: block;\\n}\\n\\n.tc-edit-bitmapeditor-height {\\n\\tdisplay: block;\\n}\\n\\n.tc-tiddler-body {\\n\\tclear: both;\\n}\\n\\n.tc-tiddler-frame .tc-tiddler-body {\\n\\tfont-size: {{$:/themes/tiddlywiki/vanilla/metrics/bodyfontsize}};\\n\\tline-height: {{$:/themes/tiddlywiki/vanilla/metrics/bodylineheight}};\\n}\\n\\n.tc-titlebar, .tc-tiddler-edit-title {\\n\\toverflow: hidden; /* https://github.com/Jermolene/TiddlyWiki5/issues/282 */\\n}\\n\\nhtml body.tc-body.tc-single-tiddler-window {\\n\\tmargin: 1em;\\n\\tbackground: \u003C\u003Ccolour tiddler-background>>;\\n}\\n\\n.tc-single-tiddler-window img,\\n.tc-single-tiddler-window svg,\\n.tc-single-tiddler-window canvas,\\n.tc-single-tiddler-window embed,\\n.tc-single-tiddler-window iframe {\\n\\tmax-width: 100%;\\n}\\n\\n/*\\n** Editor\\n*/\\n\\n.tc-editor-toolbar {\\n\\tmargin-top: 8px;\\n}\\n\\n.tc-editor-toolbar button {\\n\\tvertical-align: middle;\\n\\tbackground-color: \u003C\u003Ccolour tiddler-controls-foreground>>;\\n\\tcolor: \u003C\u003Ccolour tiddler-controls-foreground-selected>>;\\n\\tfill: \u003C\u003Ccolour tiddler-controls-foreground-selected>>;\\n\\tborder-radius: 4px;\\n\\tpadding: 3px;\\n\\tmargin: 2px 0 2px 4px;\\n}\\n\\n.tc-editor-toolbar button.tc-text-editor-toolbar-item-adjunct {\\n\\tmargin-left: 1px;\\n\\twidth: 1em;\\n\\tborder-radius: 8px;\\n}\\n\\n.tc-editor-toolbar button.tc-text-editor-toolbar-item-start-group {\\n\\tmargin-left: 11px;\\n}\\n\\n.tc-editor-toolbar button.tc-selected {\\n\\tbackground-color: \u003C\u003Ccolour primary>>;\\n}\\n\\n.tc-editor-toolbar button svg {\\n\\twidth: 1.6em;\\n\\theight: 1.2em;\\n}\\n\\n.tc-editor-toolbar .tc-drop-down button.tc-btn-mini {\\n\\tpadding: 2px 4px;\\n}\\n\\n.tc-editor-toolbar button:hover {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-controls-foreground-selected>>;\\n\\tfill: \u003C\u003Ccolour background>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-editor-toolbar .tc-text-editor-toolbar-more {\\n\\twhite-space: normal;\\n}\\n\\n.tc-editor-toolbar .tc-text-editor-toolbar-more button {\\n\\tdisplay: inline-block;\\n\\tpadding: 3px;\\n\\twidth: auto;\\n}\\n\\n.tc-editor-toolbar .tc-search-results {\\n\\tpadding: 0;\\n}\\n\\n.tc-editor-toolbar button.tc-editortoolbar-stamp-button + .tc-popup .tc-drop-down > p {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n}\\n\\n.tc-editor-toolbar button.tc-editortoolbar-stamp-button + .tc-popup .tc-drop-down a.tc-tiddlylink {\\n\\tfont-weight: normal;\\n}\\n\\n/*\\n** Adjustments for fluid-fixed mode\\n*/\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\u003C\u003Cif-fluid-fixed text:\\\"\\\"\\\"\\n\\n\\t.tc-story-river {\\n\\t\\tpadding-right: 0;\\n\\t\\tposition: relative;\\n\\t\\twidth: auto;\\n\\t\\tleft: 0;\\n\\t\\tmargin-left: {{$:/themes/tiddlywiki/vanilla/metrics/storyleft}};\\n\\t\\tmargin-right: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth}};\\n\\t}\\n\\n\\t.tc-tiddler-frame {\\n\\t\\twidth: 100%;\\n\\t}\\n\\n\\t.tc-sidebar-scrollable {\\n\\t\\tleft: auto;\\n\\t\\tbottom: 0;\\n\\t\\tright: 0;\\n\\t\\twidth: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth}};\\n\\t}\\n\\n\\tbody.tc-body .tc-page-container.tc-page-view-zoomin .tc-tiddler-frame {\\n\\t\\twidth: 100%;\\n\\t\\twidth: calc(100% - 42px);\\n\\t}\\n\\n\\\"\\\"\\\" hiddenSidebarText:\\\"\\\"\\\"\\n\\n\\t.tc-story-river {\\n\\t\\tpadding-right: 3em;\\n\\t\\tmargin-right: 0;\\n\\t}\\n\\n\\tbody.tc-body .tc-page-container.tc-page-view-zoomin .tc-tiddler-frame {\\n\\t\\twidth: 100%;\\n\\t\\twidth: calc(100% - 84px);\\n\\t}\\n\\n\\\"\\\"\\\">>\\n\\n}\\n\\n/*\\n** Toolbar buttons\\n*/\\n\\n.tc-page-controls svg.tc-image-new-button {\\n\\tfill: \u003C\u003Ccolour toolbar-new-button>>;\\n}\\n\\n.tc-page-controls svg.tc-image-options-button {\\n\\tfill: \u003C\u003Ccolour toolbar-options-button>>;\\n}\\n\\n.tc-page-controls svg.tc-image-save-button {\\n\\tfill: \u003C\u003Ccolour toolbar-save-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-info-button {\\n\\tfill: \u003C\u003Ccolour toolbar-info-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-edit-button {\\n\\tfill: \u003C\u003Ccolour toolbar-edit-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-close-button {\\n\\tfill: \u003C\u003Ccolour toolbar-close-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-delete-button {\\n\\tfill: \u003C\u003Ccolour toolbar-delete-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-cancel-button {\\n\\tfill: \u003C\u003Ccolour toolbar-cancel-button>>;\\n}\\n\\n.tc-tiddler-controls button svg.tc-image-done-button {\\n\\tfill: \u003C\u003Ccolour toolbar-done-button>>;\\n}\\n\\n.tc-page-controls svg.tc-image-layout-button {\\n\\tfill: \u003C\u003Ccolour toolbar-options-button>>;\\n}\\n\\n/*\\n** Tiddler edit mode\\n*/\\n\\n.tc-tiddler-edit-frame em.tc-edit {\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n\\tfont-style: normal;\\n}\\n\\n.tc-edit-type-dropdown a.tc-tiddlylink-missing {\\n\\tfont-style: normal;\\n}\\n\\n.tc-type-selector .tc-edit-typeeditor {\\n\\twidth: auto;\\n}\\n\\n.tc-type-selector-dropdown-wrapper {\\n\\tdisplay: inline-block;\\n}\\n\\n\u003C\u003Cset-type-selector-min-width>>\\n\\n.tc-edit-tags {\\n\\tborder: 1px solid \u003C\u003Ccolour tiddler-editor-border>>;\\n\\tpadding: 4px 8px 4px 8px;\\n}\\n\\n.tc-edit-add-tag {\\n\\tdisplay: inline-block;\\n}\\n\\n.tc-edit-add-tag .tc-add-tag-name input {\\n\\twidth: 50%;\\n}\\n\\n.tc-edit-add-tag .tc-keyboard {\\n\\tdisplay:inline;\\n}\\n\\n.tc-edit-tags .tc-tag-label {\\n\\tdisplay: inline-block;\\n}\\n\\n.tc-edit-tags-list {\\n\\tmargin: 14px 0 14px 0;\\n}\\n\\n.tc-remove-tag-button {\\n\\tpadding-left: 4px;\\n}\\n\\n.tc-tiddler-preview {\\n\\toverflow: auto;\\n}\\n\\n.tc-tiddler-preview-preview {\\n\\tfloat: right;\\n\\twidth: 49%;\\n\\tborder: 1px solid \u003C\u003Ccolour tiddler-editor-border>>;\\n\\tmargin: 4px 0 3px 3px;\\n\\tpadding: 3px 3px 3px 3px;\\n}\\n\\n\u003C\u003Cif-editor-height-fixed then:\\\"\\\"\\\"\\n\\n.tc-tiddler-preview-preview {\\n\\toverflow-y: scroll;\\n\\theight: {{$:/config/TextEditor/EditorHeight/Height}};\\n}\\n\\n\\\"\\\"\\\">>\\n\\n.tc-tiddler-frame .tc-tiddler-preview .tc-edit-texteditor {\\n\\twidth: 49%;\\n}\\n\\n.tc-tiddler-frame .tc-tiddler-preview canvas.tc-edit-bitmapeditor {\\n\\tmax-width: 49%;\\n}\\n\\n.tc-edit-fields {\\n\\twidth: 100%;\\n}\\n\\n.tc-edit-fields.tc-edit-fields-small {\\n\\tmargin-top: 0;\\n\\tmargin-bottom: 0;\\n}\\n\\n.tc-edit-fields table, .tc-edit-fields tr, .tc-edit-fields td {\\n\\tborder: none;\\n\\tpadding: 4px;\\n}\\n\\n.tc-edit-fields > tbody > .tc-edit-field:nth-child(odd) {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-editor-fields-odd>>;\\n}\\n\\n.tc-edit-fields > tbody > .tc-edit-field:nth-child(even) {\\n\\tbackground-color: \u003C\u003Ccolour tiddler-editor-fields-even>>;\\n}\\n\\n.tc-edit-field-name {\\n\\ttext-align: right;\\n}\\n\\n.tc-edit-field-value input {\\n\\twidth: 100%;\\n}\\n\\n.tc-edit-field-remove {\\n}\\n\\n.tc-edit-field-remove svg {\\n\\theight: 1em;\\n\\twidth: 1em;\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-edit-field-add-name-wrapper input.tc-edit-texteditor {\\n\\twidth: auto;\\n}\\n\\n.tc-edit-field-add-name-wrapper {\\n\\tdisplay: inline-block;\\n}\\n\\n.tc-edit-field-add-value {\\n\\tdisplay: inline-block;\\n}\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\\t.tc-edit-field-add-value {\\n\\t\\twidth: 35%;\\n\\t}\\n\\n}\\n\\n.tc-edit-field-add-button {\\n\\tdisplay: inline-block;\\n\\twidth: 10%;\\n}\\n\\n\\n/*\\n** Tiddler editor dropzone\\n*/\\n\\n.tc-dropzone-editor {\\n\\tposition:relative;\\n}\\n\\n.tc-dropzone-editor.tc-dragover .tc-editor-toolbar::after{\\n\\tz-index: 10000;\\n\\ttop:0;\\n\\tleft:0;\\n\\tright:0;\\n\\theight: 100%;\\n\\tbackground: \u003C\u003Ccolour dropzone-background>>;\\n\\tcontent: \\\"\u003C\u003Clingo DropMessage>>\\\";\\n\\tpointer-events: none;\\n\\tposition: absolute;\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\tjustify-content: center;\\n\\tbackground-color: \u003C\u003Ccolor background>>;\\n\\tborder: 4px dashed \u003C\u003Ccolor modal-border>>;\\n\\tfont-weight: bold;\\n\\tfont-size: 150%;\\n\\topacity: 0.8;\\n\\tcolor: \u003C\u003Ccolor foreground>>;\\n}\\n\\n.tc-editor-importpopup {\\n\\twidth: 100%;\\n\\theight: 100%;\\n}\\n\\n.tc-editor-import {\\n\\tposition: absolute;\\n\\ttop: 50%;\\n\\tleft: 50%;\\n\\ttransform: translate(-50%, -50%);\\n\\tbackground: \u003C\u003Ccolor pre-background>>;\\n\\tbox-shadow: 2px 2px 10px \u003C\u003Ccolour foreground>>;\\n\\tpadding: 10px;\\n\\twidth: 96%;\\n\\tborder: 1px solid \u003C\u003Ccolor tiddler-controls-foreground>>;\\n\\ttext-align:center;\\n}\\n\\n.tc-editor-import img {\\n\\tmax-height: 500px;\\n}\\n\\n/*\\n** Storyview Classes\\n*/\\n\\n.tc-viewswitcher .tc-image-button {\\n\\tmargin-right: .3em;\\n}\\n\\n.tc-page-container.tc-page-view-zoomin .tc-tiddler-frame {\\n\\tposition: absolute;\\n\\tdisplay: block;\\n\\twidth: 100%;\\n}\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\\t.tc-page-container.tc-page-view-zoomin .tc-tiddler-frame {\\n\\t\\twidth: calc(100% - 84px);\\n\\t}\\n\\n}\\n\\n/*\\n** Dropdowns\\n*/\\n\\n.tc-btn-dropdown {\\n\\ttext-align: left;\\n}\\n\\n.tc-btn-dropdown svg, .tc-btn-dropdown img {\\n\\theight: 1em;\\n\\twidth: 1em;\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-drop-down-wrapper {\\n\\tposition: relative;\\n}\\n\\n.tc-drop-down {\\n\\tmin-width: 380px;\\n\\tborder: 1px solid \u003C\u003Ccolour dropdown-border>>;\\n\\tbackground-color: \u003C\u003Ccolour dropdown-background>>;\\n\\tpadding: 7px 0 7px 0;\\n\\tmargin: 4px 0 0 0;\\n\\twhite-space: nowrap;\\n\\ttext-shadow: none;\\n\\tline-height: 1.4;\\n}\\n\\n.tc-drop-down .tc-drop-down {\\n\\tmargin-left: 14px;\\n}\\n\\n.tc-drop-down button svg, .tc-drop-down a svg  {\\n\\tfill: \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-drop-down button:disabled svg {\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-drop-down button.tc-btn-invisible:hover svg {\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-drop-down .tc-drop-down-info {\\n\\tpadding-left: 14px;\\n}\\n\\n.tc-drop-down p {\\n\\tpadding: 0 14px 0 14px;\\n}\\n\\n.tc-drop-down svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n}\\n\\n.tc-drop-down img {\\n\\twidth: 1em;\\n}\\n\\n.tc-drop-down a, .tc-drop-down button {\\n\\tdisplay: block;\\n\\tpadding: 0 14px 0 14px;\\n\\twidth: 100%;\\n\\ttext-align: left;\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n\\tline-height: 1.4;\\n}\\n\\n.tc-drop-down .tc-tab-set .tc-tab-buttons button {\\n\\tdisplay: inline-block;\\n\\twidth: auto;\\n\\tmargin-bottom: 0px;\\n\\tborder-bottom-left-radius: 0;\\n\\tborder-bottom-right-radius: 0;\\n}\\n\\n.tc-drop-down .tc-prompt {\\n\\tpadding: 0 14px;\\n}\\n\\n.tc-drop-down .tc-chooser {\\n\\tborder: none;\\n}\\n\\n.tc-drop-down .tc-chooser .tc-swatches-horiz {\\n\\tfont-size: 0.4em;\\n\\tpadding-left: 1.2em;\\n}\\n\\n.tc-drop-down .tc-file-input-wrapper {\\n\\twidth: 100%;\\n}\\n\\n.tc-drop-down .tc-file-input-wrapper button {\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-drop-down a:hover, .tc-drop-down button:hover, .tc-drop-down .tc-file-input-wrapper:hover button {\\n\\tcolor: \u003C\u003Ccolour tiddler-link-background>>;\\n\\tbackground-color: \u003C\u003Ccolour tiddler-link-foreground>>;\\n\\ttext-decoration: none;\\n}\\n\\n.tc-drop-down .tc-tab-buttons button {\\n\\tbackground-color: \u003C\u003Ccolour dropdown-tab-background>>;\\n}\\n\\n.tc-drop-down .tc-tab-buttons button.tc-tab-selected {\\n\\tbackground-color: \u003C\u003Ccolour dropdown-tab-background-selected>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour dropdown-tab-background-selected>>;\\n}\\n\\n.tc-drop-down-bullet {\\n\\tdisplay: inline-block;\\n\\twidth: 0.5em;\\n}\\n\\n.tc-drop-down .tc-tab-contents a {\\n\\tpadding: 0 0.5em 0 0.5em;\\n}\\n\\n.tc-block-dropdown-wrapper {\\n\\tposition: relative;\\n}\\n\\n.tc-block-dropdown {\\n\\tposition: absolute;\\n\\tmin-width: 220px;\\n\\tborder: 1px solid \u003C\u003Ccolour dropdown-border>>;\\n\\tbackground-color: \u003C\u003Ccolour dropdown-background>>;\\n\\tpadding: 7px 0;\\n\\tmargin: 4px 0 0 0;\\n\\twhite-space: nowrap;\\n\\tz-index: 1000;\\n\\ttext-shadow: none;\\n}\\n\\n.tc-block-dropdown.tc-search-drop-down {\\n\\tmargin-left: -12px;\\n}\\n\\n.tc-block-dropdown a {\\n\\tdisplay: block;\\n\\tpadding: 4px 14px 4px 14px;\\n}\\n\\n.tc-block-dropdown.tc-search-drop-down a {\\n\\tdisplay: block;\\n\\tpadding: 0px 10px 0px 10px;\\n}\\n\\n.tc-drop-down .tc-dropdown-item-plain,\\n.tc-block-dropdown .tc-dropdown-item-plain {\\n\\tpadding: 4px 14px 4px 7px;\\n}\\n\\n.tc-drop-down .tc-dropdown-item,\\n.tc-block-dropdown .tc-dropdown-item {\\n\\tpadding: 4px 14px 4px 7px;\\n\\tcolor: \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-block-dropdown a.tc-tiddlylink:hover {\\n\\tcolor: \u003C\u003Ccolour tiddler-link-background>>;\\n\\tbackground-color: \u003C\u003Ccolour tiddler-link-foreground>>;\\n\\ttext-decoration: none;\\n}\\n\\n.tc-search-results {\\n\\tpadding: 0 7px 0 7px;\\n}\\n\\n.tc-image-chooser, .tc-colour-chooser {\\n\\twhite-space: normal;\\n}\\n\\n.tc-image-chooser a,\\n.tc-colour-chooser a {\\n\\tdisplay: inline-block;\\n\\tvertical-align: top;\\n\\ttext-align: center;\\n\\tposition: relative;\\n}\\n\\n.tc-image-chooser a {\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tpadding: 2px;\\n\\tmargin: 2px;\\n\\twidth: 4em;\\n\\theight: 4em;\\n}\\n\\n.tc-colour-chooser a {\\n\\tpadding: 3px;\\n\\twidth: 2em;\\n\\theight: 2em;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-image-chooser a:hover,\\n.tc-colour-chooser a:hover {\\n\\tbackground: \u003C\u003Ccolour primary>>;\\n\\tpadding: 0px;\\n\\tborder: 3px solid \u003C\u003Ccolour primary>>;\\n}\\n\\n.tc-image-chooser a svg,\\n.tc-image-chooser a img {\\n\\tdisplay: inline-block;\\n\\twidth: auto;\\n\\theight: auto;\\n\\tmax-width: 3.5em;\\n\\tmax-height: 3.5em;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tmargin: auto;\\n}\\n\\n/* Make search dropdown visible on small screens. issue #7003 */\\n@media (max-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\\t.tc-sidebar-search .tc-block-dropdown-wrapper {\\n\\t\\tposition: initial;\\n\\t}\\n\\n}\\n\\n/*\\n** Modals\\n*/\\n\\n.tc-modal-wrapper {\\n\\tposition: fixed;\\n\\toverflow: auto;\\n\\toverflow-y: scroll;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tz-index: 900;\\n}\\n\\n.tc-modal-backdrop {\\n\\tposition: fixed;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tz-index: 1000;\\n\\tbackground-color: \u003C\u003Ccolour modal-backdrop>>;\\n}\\n\\n.tc-modal {\\n\\tz-index: 1100;\\n\\tbackground-color: \u003C\u003Ccolour modal-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour modal-border>>;\\n}\\n\\n@media (max-width: 55em) {\\n\\t.tc-modal {\\n\\t\\tposition: fixed;\\n\\t\\ttop: 1em;\\n\\t\\tleft: 1em;\\n\\t\\tright: 1em;\\n\\t}\\n\\n\\t.tc-modal-body {\\n\\t\\toverflow-y: auto;\\n\\t\\tmax-height: 400px;\\n\\t\\tmax-height: 60vh;\\n\\t}\\n}\\n\\n@media (min-width: 55em) {\\n\\t.tc-modal {\\n\\t\\tposition: fixed;\\n\\t\\ttop: 2em;\\n\\t\\tleft: 25%;\\n\\t\\twidth: 50%;\\n\\t}\\n\\n\\t.tc-modal-body {\\n\\t\\toverflow-y: auto;\\n\\t\\tmax-height: 400px;\\n\\t\\tmax-height: 60vh;\\n\\t}\\n}\\n\\n.tc-modal-header {\\n\\tpadding: 9px 15px;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour modal-header-border>>;\\n}\\n\\n.tc-modal-header h3 {\\n\\tmargin: 0;\\n\\tline-height: 30px;\\n}\\n\\n.tc-modal-header img, .tc-modal-header svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n}\\n\\n.tc-modal-body {\\n\\tpadding: 15px;\\n}\\n\\n.tc-modal-footer {\\n\\tpadding: 14px 15px 15px;\\n\\tmargin-bottom: 0;\\n\\ttext-align: right;\\n\\tbackground-color: \u003C\u003Ccolour modal-footer-background>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour modal-footer-border>>;\\n}\\n\\n.tc-modal-prevent-scroll {\\n\\toverflow: hidden;\\n}\\n\\n/*\\n** Centered modals\\n*/\\n.tc-modal-centered .tc-modal {\\n\\twidth: auto;\\n\\ttop: 50%;\\n\\tleft: 50%;\\n\\ttransform: translate(-50%, -50%) !important;\\n}\\n\\n/*\\n** Notifications\\n*/\\n\\n.tc-notification {\\n\\tposition: fixed;\\n\\ttop: 14px;\\n\\tright: 42px;\\n\\tz-index: 1300;\\n\\tmax-width: 280px;\\n\\tpadding: 0 14px 0 14px;\\n\\tbackground-color: \u003C\u003Ccolour notification-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour notification-border>>;\\n}\\n\\n/*\\n** Tabs\\n*/\\n\\n.tc-tab-set.tc-vertical {\\n\\tdisplay: -webkit-flex;\\n\\tdisplay: flex;\\n}\\n\\n.tc-tab-buttons {\\n\\tfont-size: 0.85em;\\n\\tpadding-top: 1em;\\n\\tmargin-bottom: -2px;\\n}\\n\\n.tc-tab-buttons.tc-vertical  {\\n\\tz-index: 100;\\n\\tdisplay: block;\\n\\tpadding-top: 14px;\\n\\tvertical-align: top;\\n\\ttext-align: right;\\n\\tmargin-bottom: inherit;\\n\\tmargin-right: -1px;\\n\\tmax-width: 33%;\\n\\t-webkit-flex: 0 0 auto;\\n\\tflex: 0 0 auto;\\n}\\n\\n.tc-tab-buttons button.tc-tab-selected {\\n\\tcolor: \u003C\u003Ccolour tab-foreground-selected>>;\\n\\tbackground-color: \u003C\u003Ccolour tab-background-selected>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border-selected>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-border-selected>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour tab-border-selected>>;\\n}\\n\\n.tc-tab-buttons button {\\n\\tcolor: \u003C\u003Ccolour tab-foreground>>;\\n\\tpadding: 3px 5px 3px 5px;\\n\\tmargin-right: 0.3em;\\n\\tfont-weight: normal;\\n\\tborder: none;\\n\\tbackground: inherit;\\n\\tbackground-color: \u003C\u003Ccolour tab-background>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-top-left-radius: 2px;\\n\\tborder-top-right-radius: 2px;\\n\\tborder-bottom-left-radius: 0;\\n\\tborder-bottom-right-radius: 0;\\n}\\n\\n.tc-tab-buttons.tc-vertical button {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\tmargin-top: 3px;\\n\\tmargin-right: 0;\\n\\ttext-align: right;\\n\\tbackground-color: \u003C\u003Ccolour tab-background>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-right: none;\\n\\tborder-top-left-radius: 2px;\\n\\tborder-bottom-left-radius: 2px;\\n\\tborder-top-right-radius: 0;\\n\\tborder-bottom-right-radius: 0;\\n}\\n\\n.tc-tab-buttons.tc-vertical button.tc-tab-selected {\\n\\tbackground-color: \u003C\u003Ccolour tab-background-selected>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour tab-background-selected>>;\\n}\\n\\n.tc-tab-divider {\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-divider>>;\\n}\\n\\n.tc-tab-divider.tc-vertical  {\\n\\tdisplay: none;\\n}\\n\\n.tc-tab-content {\\n\\tmargin-top: 14px;\\n}\\n\\n.tc-tab-content.tc-vertical  {\\n\\tdisplay: inline-block;\\n\\tvertical-align: top;\\n\\tpadding-top: 0;\\n\\tpadding-left: 14px;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\t-webkit-flex: 1 0 70%;\\n\\tflex: 1 0 70%;\\n\\toverflow: auto;\\n}\\n\\n.tc-sidebar-lists .tc-tab-buttons {\\n\\tmargin-bottom: -1px;\\n}\\n\\n.tc-sidebar-lists .tc-tab-buttons button.tc-tab-selected {\\n\\tbackground-color: \u003C\u003Ccolour sidebar-tab-background-selected>>;\\n\\tcolor: \u003C\u003Ccolour sidebar-tab-foreground-selected>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour sidebar-tab-border-selected>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour sidebar-tab-border-selected>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour sidebar-tab-border-selected>>;\\n}\\n\\n.tc-sidebar-lists .tc-tab-buttons button {\\n\\tbackground-color: \u003C\u003Ccolour sidebar-tab-background>>;\\n\\tcolor: \u003C\u003Ccolour sidebar-tab-foreground>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour sidebar-tab-border>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour sidebar-tab-border>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour sidebar-tab-border>>;\\n}\\n\\n.tc-sidebar-lists .tc-tab-divider {\\n\\tborder-top: 1px solid \u003C\u003Ccolour sidebar-tab-divider>>;\\n}\\n\\n.tc-more-sidebar > .tc-tab-set > .tc-tab-buttons > button {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\tbackground-color: \u003C\u003Ccolour sidebar-tab-background>>;\\n\\tborder-top: none;\\n\\tborder-left: none;\\n\\tborder-bottom: none;\\n\\tborder-right: 1px solid #ccc;\\n\\tmargin-bottom: inherit;\\n}\\n\\n.tc-more-sidebar > .tc-tab-set > .tc-tab-buttons > button.tc-tab-selected {\\n\\tbackground-color: \u003C\u003Ccolour sidebar-tab-background-selected>>;\\n\\tborder: none;\\n}\\n\\n/*\\n** Manager\\n*/\\n\\n.tc-manager-wrapper {\\n\\t\\n}\\n\\n.tc-manager-controls {\\n\\t\\n}\\n\\n.tc-manager-control {\\n\\tmargin: 0.5em 0;\\n}\\n\\n.tc-manager-control select {\\n\\tmax-width: 100%;\\n}\\n\\n.tc-manager-list {\\n\\twidth: 100%;\\n\\tborder-top: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-right: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-manager-list-item {\\n\\n}\\n\\n.tc-manager-list-item-heading {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\ttext-align: left;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tpadding: 3px;\\n}\\n\\n.tc-manager-list-item-heading-selected {\\n\\tfont-weight: bold;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tfill: \u003C\u003Ccolour background>>;\\n\\tbackground-color: \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-manager-list-item-heading:hover {\\n\\tbackground: \u003C\u003Ccolour primary>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-manager-list-item-content {\\n\\tdisplay: flex;\\n}\\n\\n.tc-manager-list-item-content-sidebar {\\n\\tflex: 1 0;\\n\\tbackground: \u003C\u003Ccolour tiddler-editor-background>>;\\n\\tborder-right: 0.5em solid \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-bottom: 0.5em solid \u003C\u003Ccolour muted-foreground>>;\\n\\twhite-space: nowrap;\\n}\\n\\n.tc-manager-list-item-content-item-heading {\\n\\tdisplay: block;\\n\\twidth: 100%;\\n\\ttext-align: left;\\n\\tbackground: \u003C\u003Ccolour muted-foreground>>;\\n\\ttext-transform: uppercase;\\n\\tfont-size: 0.6em;\\n\\tfont-weight: bold;\\n\\tpadding: 0.5em 0 0.5em 0;\\n}\\n\\n.tc-manager-list-item-content-item-body {\\n\\tpadding: 0 0.5em 0 0.5em;\\n}\\n\\n.tc-manager-list-item-content-item-body > pre {\\n\\tmargin: 0.5em 0 0.5em 0;\\n\\tborder: none;\\n\\tbackground: inherit;\\n}\\n\\n.tc-manager-list-item-content-tiddler {\\n\\tflex: 3 1;\\n\\tborder-left: 0.5em solid \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-right: 0.5em solid \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-bottom: 0.5em solid \u003C\u003Ccolour muted-foreground>>;\\n}\\n\\n.tc-manager-list-item-content-item-body > table {\\n\\tborder: none;\\n\\tpadding: 0;\\n\\tmargin: 0;\\n}\\n\\n.tc-manager-list-item-content-item-body > table td {\\n\\tborder: none;\\n}\\n\\n.tc-manager-icon-editor > button {\\n\\twidth: 100%;\\n}\\n\\n.tc-manager-icon-editor > button > svg,\\n.tc-manager-icon-editor > button > button {\\n\\twidth: 100%;\\n\\theight: auto;\\n}\\n\\n/*\\n** Import table\\n*/\\n\\n.tc-import-table {\\n\\twidth: 100%;\\n}\\n\\n.tc-import-table svg.tc-image-edit-button {\\n\\tmax-width: unset;\\n}\\n\\n.tc-import-table th:first-of-type {\\n\\twidth: 10%;\\n}\\n\\n.tc-import-table th:last-of-type {\\n\\twidth: 30%;\\n}\\n\\n.tc-import-table .tc-row-disabled {\\n\\tbackground: \u003C\u003Ccolour very-muted-foreground>>10;\\n\\topacity: 0.8;\\n}\\n\\n.tc-import-table .tc-row-warning {\\n\\tbackground: \u003C\u003Ccolour diff-delete-background>>50;\\n}\\n\\n/*\\n** Alerts\\n*/\\n\\n.tc-alerts {\\n\\tposition: fixed;\\n\\ttop: 28px;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tmax-width: 50%;\\n\\tz-index: 20000;\\n}\\n\\n.tc-alert {\\n\\tposition: relative;\\n\\tmargin: 14px;\\n\\tpadding: 7px;\\n\\tborder: 1px solid \u003C\u003Ccolour alert-border>>;\\n\\tbackground-color: \u003C\u003Ccolour alert-background>>;\\n}\\n\\n.tc-alert-toolbar {\\n\\tposition: absolute;\\n\\ttop: 7px;\\n\\tright: 7px;\\n\\tline-height: 0;\\n}\\n\\n.tc-alert-toolbar svg {\\n\\tfill: \u003C\u003Ccolour alert-muted-foreground>>;\\n}\\n\\n.tc-alert-subtitle {\\n\\tcolor: \u003C\u003Ccolour alert-muted-foreground>>;\\n\\tfont-weight: bold;\\n\\tfont-size: 0.8em;\\n\\tmargin-bottom: 0.5em;\\n}\\n\\n.tc-alert-body > p {\\n\\tmargin: 0;\\n}\\n\\n.tc-alert-highlight {\\n\\tcolor: \u003C\u003Ccolour alert-highlight>>;\\n}\\n\\n@media (min-width: \u003C\u003Csidebarbreakpoint>>) {\\n\\n\\t.tc-static-alert {\\n\\t\\tposition: relative;\\n\\t}\\n\\n\\t.tc-static-alert-inner {\\n\\t\\tposition: absolute;\\n\\t\\tz-index: 100;\\n\\t}\\n\\n}\\n\\n.tc-static-alert-inner {\\n\\tpadding: 0 2px 2px 42px;\\n\\tcolor: \u003C\u003Ccolour static-alert-foreground>>;\\n}\\n\\n/*\\n** Floating drafts list\\n*/\\n\\n.tc-drafts-list {\\n\\tz-index: 2000;\\n\\tposition: fixed;\\n\\tfont-size: 0.8em;\\n\\tleft: 0;\\n\\tbottom: 0;\\n}\\n\\n.tc-drafts-list a {\\n\\tmargin: 0 0.5em;\\n\\tpadding: 4px 4px;\\n\\tborder-top-left-radius: 4px;\\n\\tborder-top-right-radius: 4px;\\n\\tborder: 1px solid \u003C\u003Ccolour background>>;\\n\\tborder-bottom: none;\\n\\tbackground: \u003C\u003Ccolour dirty-indicator>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-drafts-list a:hover {\\n\\ttext-decoration: none;\\n\\tbackground: \u003C\u003Ccolour foreground>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-drafts-list a svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n\\tvertical-align: text-bottom;\\n}\\n\\n/*\\n** Control panel\\n*/\\n\\n.tc-control-panel td {\\n\\tpadding: 4px;\\n}\\n\\n.tc-control-panel table, .tc-control-panel table input, .tc-control-panel table textarea {\\n\\twidth: 100%;\\n}\\n\\n.tc-plugin-info {\\n\\tdisplay: flex;\\n\\ttext-shadow: none;\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tfill: \u003C\u003Ccolour muted-foreground>>;\\n\\tbackground-color: \u003C\u003Ccolour background>>;\\n\\tmargin: 0.5em 0 0.5em 0;\\n\\tpadding: 4px;\\n\\talign-items: center;\\n}\\n\\n.tc-sidebar-lists a.tc-tiddlylink.tc-plugin-info {\\n\\tcolor: \u003C\u003Ccolour tiddler-link-foreground>>;\\n}\\n\\n\\n.tc-plugin-info-sub-plugins .tc-plugin-info {\\n\\tmargin: 0.5em;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-plugin-info-sub-plugin-indicator {\\n\\tmargin: -16px 1em 0 2em;\\n}\\n\\n.tc-plugin-info-sub-plugin-indicator button {\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tbackground: \u003C\u003Ccolour foreground>>;\\n\\tborder-radius: 8px;\\n\\tpadding: 2px 7px;\\n\\tfont-size: 0.75em;\\n}\\n\\n.tc-plugin-info-sub-plugins .tc-plugin-info-dropdown {\\n\\tmargin-left: 1em;\\n\\tmargin-right: 1em;\\n}\\n\\n.tc-plugin-info-disabled {\\n\\tbackground: -webkit-repeating-linear-gradient(45deg, #ff0, #ff0 10px, #eee 10px, #eee 20px);\\n\\tbackground: repeating-linear-gradient(45deg, #ff0, #ff0 10px, #eee 10px, #eee 20px);\\n}\\n\\n.tc-plugin-info-disabled:hover {\\n\\tbackground: -webkit-repeating-linear-gradient(45deg, #aa0, #aa0 10px, #888 10px, #888 20px);\\n\\tbackground: repeating-linear-gradient(45deg, #aa0, #aa0 10px, #888 10px, #888 20px);\\n}\\n\\na.tc-tiddlylink.tc-plugin-info:hover {\\n\\ttext-decoration: none;\\n\\tbackground-color: \u003C\u003Ccolour primary>>;\\n\\tcolor: \u003C\u003Ccolour background>>;\\n\\tfill: \u003C\u003Ccolour foreground>>;\\n}\\n\\na.tc-tiddlylink.tc-plugin-info:hover > .tc-plugin-info-chunk > svg {\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-plugin-info-chunk {\\n\\tmargin: 2px;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-toggle {\\n\\tflex-grow: 0;\\n\\tflex-shrink: 0;\\n\\tline-height: 1;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-icon {\\n\\tflex-grow: 0;\\n\\tflex-shrink: 0;\\n\\tline-height: 1;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-description {\\n\\tflex-grow: 1;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-buttons {\\n\\tfont-size: 0.8em;\\n\\tline-height: 1.2;\\n\\tflex-grow: 0;\\n\\tflex-shrink: 0;\\n\\ttext-align: right;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-description h1 {\\n\\tfont-size: 1em;\\n\\tline-height: 1.2;\\n\\tmargin: 2px 0 2px 0;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-description h2 {\\n\\tfont-size: 0.8em;\\n\\tline-height: 1.2;\\n\\tmargin: 2px 0 2px 0;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-description div {\\n\\tfont-size: 0.7em;\\n\\tline-height: 1.2;\\n\\tmargin: 2px 0 2px 0;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-toggle img, .tc-plugin-info-chunk.tc-plugin-info-toggle svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n}\\n\\n.tc-plugin-info-chunk.tc-plugin-info-icon img, .tc-plugin-info-chunk.tc-plugin-info-icon svg {\\n\\twidth: 2em;\\n\\theight: 2em;\\n}\\n\\n.tc-plugin-info-dropdown {\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n\\tmargin-top: -8px;\\n}\\n\\n.tc-plugin-info-dropdown-message {\\n\\tbackground: \u003C\u003Ccolour message-background>>;\\n\\tpadding: 0.5em 1em 0.5em 1em;\\n\\tfont-weight: bold;\\n\\tfont-size: 0.8em;\\n}\\n\\n.tc-plugin-info-dropdown-body {\\n\\tpadding: 1em 1em 0 1em;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-plugin-info-sub-plugins {\\n\\tpadding: 0.5em;\\n\\tmargin: 0 1em 1em 1em;\\n\\tbackground: \u003C\u003Ccolour notification-background>>;\\n}\\n\\n.tc-install-plugin {\\n\\tfont-weight: bold;\\n\\tbackground: green;\\n\\tcolor: white;\\n\\tfill: white;\\n\\tborder-radius: 4px;\\n\\tpadding: 3px;\\n}\\n\\n.tc-install-plugin.tc-reinstall-downgrade {\\n\\tbackground: red;\\n}\\n\\n.tc-install-plugin.tc-reinstall {\\n\\tbackground: blue;\\n}\\n\\n.tc-install-plugin.tc-reinstall-upgrade {\\n\\tbackground: orange;\\n}\\n\\n.tc-check-list {\\n\\tline-height: 2em;\\n}\\n\\n.tc-check-list .tc-image-button {\\n\\theight: 1.5em;\\n}\\n\\n/*\\n** Message boxes\\n*/\\n\\n.tc-message-box {\\n\\tborder: 1px solid \u003C\u003Ccolour message-border>>;\\n\\tbackground: \u003C\u003Ccolour message-background>>;\\n\\tpadding: 0px 21px 0px 21px;\\n\\tfont-size: 12px;\\n\\tline-height: 18px;\\n\\tcolor: \u003C\u003Ccolour message-foreground>>;\\n}\\n\\n.tc-message-box svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n\\tvertical-align: text-bottom;\\n}\\n\\n/*\\n** Pictures\\n*/\\n\\n.tc-bordered-image {\\n\\tborder: 1px solid \u003C\u003Ccolour muted-foreground>>;\\n\\tpadding: 5px;\\n\\tmargin: 5px;\\n}\\n\\n/*\\n** Floats\\n*/\\n\\n.tc-float-right {\\n\\tfloat: right;\\n}\\n\\n/*\\n** Chooser\\n*/\\n\\n.tc-chooser {\\n\\tborder-right: 1px solid \u003C\u003Ccolour table-header-background>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour table-header-background>>;\\n}\\n\\n\\n.tc-chooser-item {\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour table-header-background>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour table-header-background>>;\\n\\tpadding: 2px 4px 2px 14px;\\n}\\n\\n.tc-drop-down .tc-chooser-item {\\n\\tpadding: 2px;\\n}\\n\\n.tc-chosen,\\n.tc-chooser-item:hover {\\n\\tbackground-color: \u003C\u003Ccolour table-header-background>>;\\n\\tborder-color: \u003C\u003Ccolour table-footer-background>>;\\n}\\n\\n.tc-chosen .tc-tiddlylink {\\n\\tcursor:default;\\n}\\n\\n.tc-chooser-item .tc-tiddlylink {\\n\\tdisplay: block;\\n\\ttext-decoration: none;\\n\\tbackground-color: transparent;\\n}\\n\\n.tc-chooser-item:hover .tc-tiddlylink:hover {\\n\\ttext-decoration: none;\\n}\\n\\n.tc-drop-down .tc-chosen .tc-tiddlylink,\\n.tc-drop-down .tc-chooser-item .tc-tiddlylink:hover {\\n\\tcolor: \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-chosen > .tc-tiddlylink:before {\\n\\tmargin-left: -10px;\\n\\tposition: relative;\\n\\tcontent: \\\"» \\\";\\n}\\n\\n.tc-chooser-item svg,\\n.tc-chooser-item img{\\n\\twidth: 1em;\\n\\theight: 1em;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-language-chooser .tc-image-button img {\\n\\twidth: 2em;\\n\\tvertical-align: -0.15em;\\n}\\n\\n/*\\n** Palette swatches\\n*/\\n\\n.tc-swatches-horiz {\\n}\\n\\n.tc-swatches-horiz .tc-swatch {\\n\\tdisplay: inline-block;\\n}\\n\\n.tc-swatch {\\n\\twidth: 2em;\\n\\theight: 2em;\\n\\tmargin: 0.4em;\\n\\tborder: 1px solid #888;\\n}\\n\\ninput.tc-palette-manager-colour-input {\\n\\twidth: 100%;\\n\\tpadding: 0;\\n}\\n\\n/*\\n** Table of contents\\n*/\\n\\n.tc-sidebar-lists .tc-table-of-contents {\\n\\twhite-space: nowrap;\\n}\\n\\n.tc-table-of-contents button,\\n.tc-table-of-contents .toc-item-muted {\\n\\tcolor: \u003C\u003Ccolour sidebar-foreground>>;\\n}\\n\\n.tc-table-of-contents svg {\\n\\twidth: 0.7em;\\n\\theight: 0.7em;\\n\\tvertical-align: middle;\\n\\tfill: \u003C\u003Ccolour sidebar-foreground>>;\\n}\\n\\n.tc-table-of-contents ol {\\n\\tlist-style-type: none;\\n\\tpadding-left: 0;\\n}\\n\\n.tc-table-of-contents ol ol {\\n\\tpadding-left: 1em;\\n}\\n\\n.tc-table-of-contents li {\\n\\tfont-size: 1.0em;\\n\\tfont-weight: bold;\\n}\\n\\n.tc-table-of-contents li a {\\n\\tfont-weight: bold;\\n}\\n\\n.tc-table-of-contents li li {\\n\\tfont-size: 0.95em;\\n\\tfont-weight: normal;\\n\\tline-height: 1.4;\\n}\\n\\n.tc-table-of-contents li li a {\\n\\tfont-weight: normal;\\n}\\n\\n.tc-table-of-contents li li li {\\n\\tfont-size: 0.95em;\\n\\tfont-weight: normal;\\n\\tline-height: 1.5;\\n}\\n\\n.tc-table-of-contents li li li li {\\n\\tfont-size: 0.95em;\\n\\tfont-weight: normal;\\n}\\n\\n.tc-tabbed-table-of-contents {\\n\\tdisplay: -webkit-flex;\\n\\tdisplay: flex;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents {\\n\\tz-index: 100;\\n\\tdisplay: inline-block;\\n\\tpadding-left: 1em;\\n\\tmax-width: 50%;\\n\\t-webkit-flex: 0 0 auto;\\n\\tflex: 0 0 auto;\\n\\tbackground: \u003C\u003Ccolour tab-background>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tab-border>>;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item > a,\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item-selected > a {\\n\\tdisplay: block;\\n\\tpadding: 0.12em 1em 0.12em 0.25em;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item > a {\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-background>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-background>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tab-background>>;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item > a:hover {\\n\\ttext-decoration: none;\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tbackground: \u003C\u003Ccolour tab-border>>;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item-selected > a {\\n\\tborder-top: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-left: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n\\tmargin-right: -1px;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-table-of-contents .toc-item-selected > a:hover {\\n\\ttext-decoration: none;\\n}\\n\\n.tc-tabbed-table-of-contents .tc-tabbed-table-of-contents-content {\\n\\tdisplay: inline-block;\\n\\tvertical-align: top;\\n\\tpadding-left: 1.5em;\\n\\tpadding-right: 1.5em;\\n\\tborder: 1px solid \u003C\u003Ccolour tab-border>>;\\n\\t-webkit-flex: 1 0 50%;\\n\\tflex: 1 0 50%;\\n}\\n\\n/*\\n** Dirty indicator\\n*/\\n\\nhtml body svg.tc-image-save-button-dynamic .tc-image-save-button-dynamic-clean {\\n\\tvisibility: visible;\\n}\\n\\nhtml body svg.tc-image-save-button-dynamic .tc-image-save-button-dynamic-dirty {\\n\\tvisibility: hidden;\\n}\\n\\nhtml body.tc-dirty svg.tc-image-save-button-dynamic .tc-image-save-button-dynamic-clean {\\n\\tvisibility: hidden;\\n}\\n\\nhtml body.tc-dirty svg.tc-image-save-button-dynamic .tc-image-save-button-dynamic-dirty {\\n\\tvisibility: visible;\\n}\\n\\nhtml body.tc-dirty span.tc-dirty-indicator, html body.tc-dirty span.tc-dirty-indicator svg {\\n\\tfill: \u003C\u003Ccolour dirty-indicator>>;\\n\\tcolor: \u003C\u003Ccolour dirty-indicator>>;\\n}\\n\\n/*\\n** File inputs\\n*/\\n\\n.tc-file-input-wrapper {\\n\\tposition: relative;\\n\\toverflow: hidden;\\n\\tdisplay: inline-block;\\n\\tvertical-align: middle;\\n}\\n\\n.tc-file-input-wrapper input[type=file] {\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\tfont-size: 999px;\\n\\tmax-width: 100%;\\n\\tmax-height: 100%;\\n\\tfilter: alpha(opacity=0);\\n\\topacity: 0;\\n\\toutline: none;\\n\\tbackground: white;\\n\\tcursor: pointer;\\n\\tdisplay: inline-block;\\n}\\n\\n::-webkit-file-upload-button {\\n\\tcursor:pointer;\\n}\\n\\n/*\\n** Thumbnail macros\\n*/\\n\\n.tc-thumbnail-wrapper {\\n\\tposition: relative;\\n\\tdisplay: inline-block;\\n\\tmargin: 6px;\\n\\tvertical-align: top;\\n}\\n\\n.tc-thumbnail-right-wrapper {\\n\\tfloat:right;\\n\\tmargin: 0.5em 0 0.5em 0.5em;\\n}\\n\\n.tc-thumbnail-image {\\n\\ttext-align: center;\\n\\toverflow: hidden;\\n\\tborder-radius: 3px;\\n}\\n\\n.tc-thumbnail-image svg,\\n.tc-thumbnail-image img {\\n\\tfilter: alpha(opacity=1);\\n\\topacity: 1;\\n\\tmin-width: 100%;\\n\\tmin-height: 100%;\\n\\tmax-width: 100%;\\n}\\n\\n.tc-thumbnail-wrapper:hover .tc-thumbnail-image svg,\\n.tc-thumbnail-wrapper:hover .tc-thumbnail-image img {\\n\\tfilter: alpha(opacity=0.8);\\n\\topacity: 0.8;\\n}\\n\\n.tc-thumbnail-background {\\n\\tposition: absolute;\\n\\tborder-radius: 3px;\\n}\\n\\n.tc-thumbnail-icon svg,\\n.tc-thumbnail-icon img {\\n\\twidth: 3em;\\n\\theight: 3em;\\n\\t\u003C\u003Cfilter \\\"drop-shadow(2px 2px 4px rgba(0,0,0,0.3))\\\">>\\n}\\n\\n.tc-thumbnail-wrapper:hover .tc-thumbnail-icon svg,\\n.tc-thumbnail-wrapper:hover .tc-thumbnail-icon img {\\n\\tfill: #fff;\\n\\t\u003C\u003Cfilter \\\"drop-shadow(3px 3px 4px rgba(0,0,0,0.6))\\\">>\\n}\\n\\n.tc-thumbnail-icon {\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\tdisplay: -webkit-flex;\\n\\t-webkit-align-items: center;\\n\\t-webkit-justify-content: center;\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\tjustify-content: center;\\n}\\n\\n.tc-thumbnail-caption {\\n\\tposition: absolute;\\n\\tbackground-color: #777;\\n\\tcolor: #fff;\\n\\ttext-align: center;\\n\\tbottom: 0;\\n\\twidth: 100%;\\n\\tfilter: alpha(opacity=0.9);\\n\\topacity: 0.9;\\n\\tline-height: 1.4;\\n\\tborder-bottom-left-radius: 3px;\\n\\tborder-bottom-right-radius: 3px;\\n}\\n\\n.tc-thumbnail-wrapper:hover .tc-thumbnail-caption {\\n\\tfilter: alpha(opacity=1);\\n\\topacity: 1;\\n}\\n\\n/*\\n** Diffs\\n*/\\n\\n.tc-diff-equal {\\n\\tbackground-color: \u003C\u003Ccolour diff-equal-background>>;\\n\\tcolor: \u003C\u003Ccolour diff-equal-foreground>>;\\n}\\n\\n.tc-diff-insert {\\n\\tbackground-color: \u003C\u003Ccolour diff-insert-background>>;\\n\\tcolor: \u003C\u003Ccolour diff-insert-foreground>>;\\n}\\n\\n.tc-diff-delete {\\n\\tbackground-color: \u003C\u003Ccolour diff-delete-background>>;\\n\\tcolor: \u003C\u003Ccolour diff-delete-foreground>>;\\n}\\n\\n.tc-diff-invisible {\\n\\tbackground-color: \u003C\u003Ccolour diff-invisible-background>>;\\n\\tcolor: \u003C\u003Ccolour diff-invisible-foreground>>;\\n}\\n\\n.tc-diff-tiddlers th {\\n\\ttext-align: right;\\n\\tbackground: \u003C\u003Ccolour background>>;\\n\\tfont-weight: normal;\\n\\tfont-style: italic;\\n}\\n\\n.tc-diff-tiddlers pre {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tborder: none;\\n\\tbackground: none;\\n}\\n\\n/*\\n** Errors\\n*/\\n\\n.tc-error {\\n\\tbackground: #f00;\\n\\tcolor: #fff;\\n}\\n\\n/*\\n** Tree macro\\n*/\\n\\n.tc-tree div {\\n\\tpadding-left: 14px;\\n}\\n\\n.tc-tree ol {\\n\\tlist-style-type: none;\\n\\tpadding-left: 0;\\n\\tmargin-top: 0;\\n}\\n\\n.tc-tree ol ol {\\n\\tpadding-left: 1em;\\n}\\n\\n.tc-tree button {\\n\\tcolor: #acacac;\\n}\\n\\n.tc-tree svg {\\n\\tfill: #acacac;\\n}\\n\\n.tc-tree span svg {\\n\\twidth: 1em;\\n\\theight: 1em;\\n\\tvertical-align: baseline;\\n}\\n\\n.tc-tree li span {\\n\\tcolor: lightgray;\\n}\\n\\nselect {\\n\\tcolor: \u003C\u003Ccolour select-tag-foreground>>;\\n\\tbackground: \u003C\u003Ccolour select-tag-background>>;\\n}\\n\\n/*\\n** Translink macro\\n*/\\n\\n.tc-translink {\\n\\tbackground-color: \u003C\u003Ccolour pre-background>>;\\n\\tborder: 1px solid \u003C\u003Ccolour pre-border>>;\\n\\tpadding: 0 3px;\\n\\tborder-radius: 3px;\\n}\\n\\ndiv.tc-translink > div {\\n\\tmargin: 1em;\\n}\\n\\ndiv.tc-translink > div > a:first-child > h1 {\\n\\tfont-size: 1.2em;\\n\\tfont-weight: bold;\\n}\\n\\nspan.tc-translink > a:first-child {\\n\\tfont-weight: bold;\\n}\\n\\n/*\\n** Classes for displaying globals\\n*/\\n\\n.tc-global-tiddler-body {\\n\\tpadding: 0.25em;\\n\\tborder: 1px solid \u003C\u003Ccolour foreground>>;\\n\\tbackground-color: \u003C\u003Ccolour muted-foreground>>;\\n\\tborder-radius: 3px;\\n}\\n\\n.tc-global-tiddler-body-heading {\\n\\tmargin: 0 0 0.25em 0;\\n\\tfont-weight: normal;\\n}\\n\\n.tc-global-tiddler-body-type {\\n\\tmargin: 0 0 0.25em 0;\\n\\tborder-bottom: 1px solid \u003C\u003Ccolour foreground>>;\\n}\\n\\n.tc-global-tiddler-body-details {\\n\\tbackground-color: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-global-tiddler-body pre {\\n\\tmargin: 0;\\n\\tborder: 1px solid \u003C\u003Ccolour foreground>>;\\n}\\n\\n/*\\n** Utility classes for SVG icons\\n*/\\n\\n.tc-fill-background {\\n\\tfill: \u003C\u003Ccolour background>>;\\n}\\n\\n.tc-network-activity-background {\\n\\tfill: \u003C\u003Ccolour network-activity-foreground>>;\\n}\\n\\n/*\\n** Flexbox utility classes\\n*/\\n\\n.tc-flex {\\n\\tdisplay: -webkit-flex;\\n\\tdisplay: flex;\\n}\\n\\n.tc-flex-column {\\n\\tflex-direction: column;\\n}\\n\\n.tc-flex-row {\\n\\tflex-direction: row;\\n}\\n\\n.tc-flex-grow-1 {\\n\\tflex-grow: 1;\\n}\\n\\n.tc-flex-grow-2 {\\n\\tflex-grow: 2;\\n}\\n\\n/*\\n** Other utility classes\\n*/\\n\\n/* Horizontal gaps */\\n\\n.tc-tiny-gap {\\n\\tmargin-left: .25em;\\n\\tmargin-right: .25em;\\n}\\n\\n.tc-tiny-gap-left {\\n\\tmargin-left: .25em;\\n}\\n\\n.tc-tiny-gap-right {\\n\\tmargin-right: .25em;\\n}\\n\\n.tc-small-gap {\\n\\tmargin-left: .5em;\\n\\tmargin-right: .5em;\\n}\\n\\n.tc-small-gap-left {\\n\\tmargin-left: .5em;\\n}\\n\\n.tc-small-gap-right {\\n\\tmargin-right: .5em;\\n}\\n\\n.tc-big-gap {\\n\\tmargin-left: 1em;\\n\\tmargin-right: 1em;\\n}\\n\\n.tc-big-gap-left {\\n\\tmargin-left: 1em;\\n}\\n\\n.tc-big-gap-right {\\n\\tmargin-right: 1em;\\n}\\n\\n.tc-word-break {\\n\\tword-break: break-all;\\n}\\n\\n/* Vertical gaps */\\n\\n.tc-tiny-v-gap-bottom {\\n\\tmargin-bottom: 3px;\\n}\\n\"},\"$:/themes/tiddlywiki/vanilla/metrics/bodyfontsize\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/bodyfontsize\",\"text\":\"15px\"},\"$:/themes/tiddlywiki/vanilla/metrics/bodylineheight\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/bodylineheight\",\"text\":\"22px\"},\"$:/themes/tiddlywiki/vanilla/metrics/fontsize\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/fontsize\",\"text\":\"14px\"},\"$:/themes/tiddlywiki/vanilla/metrics/lineheight\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/lineheight\",\"text\":\"20px\"},\"$:/themes/tiddlywiki/vanilla/metrics/storyleft\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/storyleft\",\"text\":\"0px\"},\"$:/themes/tiddlywiki/vanilla/metrics/storytop\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/storytop\",\"text\":\"0px\"},\"$:/themes/tiddlywiki/vanilla/metrics/storyright\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/storyright\",\"text\":\"770px\"},\"$:/themes/tiddlywiki/vanilla/metrics/storywidth\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/storywidth\",\"text\":\"770px\"},\"$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/tiddlerwidth\",\"text\":\"686px\"},\"$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint\",\"text\":\"960px\"},\"$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth\":{\"title\":\"$:/themes/tiddlywiki/vanilla/metrics/sidebarwidth\",\"text\":\"350px\"},\"$:/themes/tiddlywiki/vanilla/options/stickytitles\":{\"title\":\"$:/themes/tiddlywiki/vanilla/options/stickytitles\",\"text\":\"no\"},\"$:/themes/tiddlywiki/vanilla/options/sidebarlayout\":{\"title\":\"$:/themes/tiddlywiki/vanilla/options/sidebarlayout\",\"text\":\"fixed-fluid\"},\"$:/themes/tiddlywiki/vanilla/options/codewrapping\":{\"title\":\"$:/themes/tiddlywiki/vanilla/options/codewrapping\",\"text\":\"pre-wrap\"},\"$:/themes/tiddlywiki/vanilla/reset\":{\"title\":\"$:/themes/tiddlywiki/vanilla/reset\",\"type\":\"text/css\",\"text\":\"/*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */\\n\\n/*\\nDocument\\n========\\n*/\\n\\n/**\\nUse a better box model (opinionated).\\n*/\\n\\n*,\\n*::before,\\n*::after {\\n  box-sizing: border-box;\\n}\\n\\n/**\\nUse a more readable tab size (opinionated).\\n*/\\n\\n:root {\\n  -moz-tab-size: 4;\\n  tab-size: 4;\\n}\\n\\n/**\\n1. Correct the line height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n*/\\n\\nhtml {\\n  line-height: 1.15; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n}\\n\\n/*\\nSections\\n========\\n*/\\n\\n/**\\nRemove the margin in all browsers.\\n*/\\n\\nbody {\\n  margin: 0;\\n}\\n\\n/**\\nImprove consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)\\n*/\\n\\nbody {\\n  font-family:\\n    system-ui,\\n    -apple-system, /* Firefox supports this but not yet `system-ui` */\\n    'Segoe UI',\\n    Roboto,\\n    Helvetica,\\n    Arial,\\n    sans-serif,\\n    'Apple Color Emoji',\\n    'Segoe UI Emoji';\\n}\\n\\n/*\\nGrouping content\\n================\\n*/\\n\\n/**\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n}\\n\\n/*\\nText-level semantics\\n====================\\n*/\\n\\n/**\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr[title] {\\n  text-decoration: underline dotted;\\n}\\n\\n/**\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/**\\n1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)\\n2. Correct the odd 'em' font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family:\\n    ui-monospace,\\n    SFMono-Regular,\\n    Consolas,\\n    'Liberation Mono',\\n    Menlo,\\n    monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/**\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/**\\nPrevent 'sub' and 'sup' elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\nTabular data\\n============\\n*/\\n\\n/**\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n}\\n\\n/*\\nForms\\n=====\\n*/\\n\\n/**\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  line-height: 1.15; /* 1 */\\n  margin: 0; /* 2 */\\n}\\n\\n/**\\nRemove the inheritance of text transform in Edge and Firefox.\\n1. Remove the inheritance of text transform in Firefox.\\n*/\\n\\nbutton,\\nselect { /* 1 */\\n  text-transform: none;\\n}\\n\\n/**\\nCorrect the inability to style clickable types in iOS and Safari.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button;\\n}\\n\\n/**\\nRemove the inner border and padding in Firefox.\\n*/\\n\\n::-moz-focus-inner {\\n  border-style: none;\\n  padding: 0;\\n}\\n\\n/**\\nRestore the focus styles unset by the previous rule.\\n*/\\n\\n:-moz-focusring {\\n  outline: 1px dotted ButtonText;\\n}\\n\\n/**\\nRemove the additional ':invalid' styles in Firefox.\\nSee: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/**\\nRemove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.\\n*/\\n\\nlegend {\\n  padding: 0;\\n}\\n\\n/**\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/**\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/**\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/**\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/**\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to 'inherit' in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nInteractive\\n===========\\n*/\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\"},\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\":{\"title\":\"$:/themes/tiddlywiki/vanilla/settings/fontfamily\",\"text\":\"-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;\"},\"$:/themes/tiddlywiki/vanilla/settings/codefontfamily\":{\"title\":\"$:/themes/tiddlywiki/vanilla/settings/codefontfamily\",\"text\":\"\\\"SFMono-Regular\\\",Consolas,\\\"Liberation Mono\\\",Menlo,Courier,monospace\"},\"$:/themes/tiddlywiki/vanilla/settings/backgroundimageattachment\":{\"title\":\"$:/themes/tiddlywiki/vanilla/settings/backgroundimageattachment\",\"text\":\"fixed\"},\"$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize\":{\"title\":\"$:/themes/tiddlywiki/vanilla/settings/backgroundimagesize\",\"text\":\"auto\"},\"$:/themes/tiddlywiki/vanilla/sticky\":{\"title\":\"$:/themes/tiddlywiki/vanilla/sticky\",\"code-body\":\"yes\",\"text\":\"\u003C$reveal state=\\\"$:/themes/tiddlywiki/vanilla/options/stickytitles\\\" type=\\\"match\\\" text=\\\"yes\\\">\\n``\\n.tc-tiddler-title {\\n\\tposition: -webkit-sticky;\\n\\tposition: -moz-sticky;\\n\\tposition: -o-sticky;\\n\\tposition: -ms-sticky;\\n\\tposition: sticky;\\n\\ttop: 0px;\\n\\tbackground: ``\u003C\u003Ccolour tiddler-background>>``;\\n\\tz-index: 500;\\n}\\n\\n``\\n\u003C$list filter=\\\"[range[100]]\\\">\\n`.tc-story-river .tc-tiddler-frame:nth-child(100n+`\u003C$text text=\u003C\u003CcurrentTiddler>>/>`) {\\nz-index: `\u003C$text text={{{ [[200]subtract\u003CcurrentTiddler>] }}}/>`;\\n}\\n`\\n\u003C/$list>\\n\u003C/$reveal>\\n\"}}}"},
{"created":"20231017154430315","title":"$:/themes/tiddlywiki/vanilla/options/sidebarlayout","text":"fluid-fixed","modified":"20231017154430315"},
{"created":"20200126121530000","title":"安卓程序的构建与链接","text":"\n!! configure的改造\n\n尝试在安卓编译python，保证PATH有gcc/ar/make，再改几行脚本就行。\n\n# configure以及触发的config.sub和install-sh默认通过/bin/sh执行，要换成可以运行的sh路径。\n# configure中有CONFIG_SHELL变量默认指向/bin/sh，可以改脚步也可以通过export这个变量来修改，但必须export，只是在shell定义没用。因为configure会fork大量进程，只有export后子进程才能感知到\n# 手动修改configure的`__ANDROID_API__`为某个版本，怀疑可能个用的gcc有关，好在改完这行就能用了\n\n!! linker\n\n在termux(android5 API21)编译的程序，放到4.2的机器上执行，报`line 1: syntax error: unexpected \")\"`无法执行，第1行出现/system/bin/linker字样，故有此文。\n\n在android 2.x及4.0或更远古时代，系统在执行一个elf文件时，这个elf文件是固定加载到某个内存位置的。而后来llvm的出现，使得编译出来的elf文件，可以加载到内存中的任意位置，这种就叫pie。5.0后的android系统强制要求只能加载pie的文件，也就是说，使用gcc编译的固定基址的elf文件就再也不能执行了(大概这也是termux只支持clang不支持gcc的原因？)。\n\nAndroid在启动一个新的进程的时候，调用execv函数族trap到内核，由kernel去检查和加载可执行文件；kernel做完可执行文件的加载的同时会加载/system/bin/linker，然后由linker去加载依赖的动态库，并调用可执行文件的入口函数，完成控制权的转移。linker还参与了调试的一些东西。通俗地说，它是一个elf文件的解释器。","modified":"20200126121530000","tags":"os"},
{"created":"20160505121530000","title":"安卓野Rom手动清毒记","text":"\n去年底换了个TCL手机，因为原生Rom不好用恰好网上的Rom也比较多，反复尝试就Flyme还算好用，可惜在ROM之家或ROM基地等几个网站上下到的Flyme多少有点问题。有一天偶然在论坛上看到有人自制的Flyme包，使用后觉得算是做得比较好的Rom，就一直用到现在。期间发现流量开关经常会被自动打开，但正好过去的三个月移动送了好几个G的流量，也没觉得有关系，甚至一次被自动下了软件，也没下决心去查。直接上个月底手机自动发短信并且自动读取验证码，然后被扣6块钱时，我才觉得彻底被愚弄了。此时发现原本的root权限也没有了。此时即使查出了病毒，也无计可施了。\n\n从种种迹象来看，中毒的可能性有两个，一是野Rom自带的病毒，但是这病毒的潜伏期4个月也太长了吧，再一个就是上个月曾经下载了一个免费的VPN软件。其它都是从豌豆荚下载，可能性很小。缩小疑问点开始确认。\n\n先重新线刷野Rom，并查杀病毒，果然立刻查出一个病毒文件。但是这个文件和上一个病毒的名字也不一样，难道现在的刷机脚本还会在安装时起个随机化的名字了？然后再重装那个免费VPN软件，没有问题。且网上查了下那个VPN软件是个相当知名的软件，看来问题不是在VPN上。\n\n这样一来，就肯定可以锁定野Rom了，既然已经查出一个，那很可能就还有别的，永远不要相信杀毒软件报的无病毒假象。因为之前简单研究过安卓的文件布局，重点就落在/system/app和/system/priv-app目录里，并结合Kingroot的预装软件分析结果，陆陆续续找出有5、6个疑似病毒。比如有个叫Boot.apk的程序，居然在app和priv-app下都安装了一份，简直丧心病狂，删！再一个名字叫System.apk的程序，虽然名字很高大上，但安卓怎么会取这么个名字呢，删。安卓apk有个好处，文件内容可以直接看，尤其是AndroidManifest.xml这个文件能看出很多蛛丝马迹。举个例子，有个apk的package写的是com.android.sadk。名字一个就露着古怪，网上只查到一条有人说360报是病毒，但其它没有报。宁可错杀不能漏过，删。还有个APK，minSdkVersion居然是8，正常至少也会是15以上吧。用这么低的版本图个啥？删。还有个APK，居然申请了DELETE_PACKAGE权限，靠就凭这点，不是病毒都把丫给删了。如是断断续续地看了两天，把所有名字可疑的APK看了个遍，到后来几乎要对PicoTTS下手，还好查到svox是被google收购的公司，才放过一马。不过其实就算删了，对我日常使用也没什么影响。\n\n回想起来，最大的问题还是我自己大意了，之前虽然也听过野Rom的各种危害，但没往深处想，被自动打开流量开关也没在意。直到被自动订阅增值服务扣了6块钱才醒觉被人当了羊沽。幸运的是一方面自己多少还对系统有点了解，加上安卓毕竟比Windows要简单得多，什么dll注入，二进制感染似乎还没有发展起来（或许是我不知道），要清除还是容易多。对不想折腾的人，建议还是买iPhone算了。\n\n手机对于现在的人，已经关联了太多的隐私和金钱，这个很多人已经说得很透了。所以在这上面，投入再多的安全性关注都是有必要的。至少我自己的主手机就是iPhone，安卓上装的无非就是新闻、阅读和游戏之类的app。但这次事件之后，我也感觉到后怕，今天我还有精力去逐个APK查看是否可疑，未来还有这样的精力去做吗？安卓Rom我是不敢再刷了，下一部手机，我想也只能换iPhone（或者Nokia的1系，不知还能不能买得到），安卓终究只能作为一台游戏机般的存在了。\n","modified":"20160505121530000","tags":"os"},
{"created":"20180320121530000","title":"安卓APK内容分析","text":"\n!! 压缩包的文件构成\n\n最小的apk会有classes.dex/AndroidManifest.xml/resources.arsc文件和assets/META-INF(数字签名，记录了所有文件的SHA-1结果)/res目录，换句话说是由Java编译的字节码、资源文件原生库以及辅助文件(如编译说明、签名)共同打成的zip包。\n\n不同apk之间是依靠记录在AndroidManifest.xml的包名和数字签名共同来进行区分的。\n\n!! 执行代码说明\n\nclasses.dex文件是Dalvik字节码，也是主执行代码。java把每个源文件编译成class，而apk中只有一个dex，有点jar的味道。\n\n用户安装在/data目录下的apk，通常都包含dex。/system目录下的apk内没有dex，替代的是外部的odex文件。在真正执行前，会将dex做进一步优化，分Dalvik或ART优化，版本4.4以前使用dexopt生成odex文件，版本5之后使用dex2oat生成用于ART的oat格式(可能也是.dex的扩展名)。dex是跨平台的，odex/oat是平台依赖的，存放odex/oat位置就是dalvik-cache。\n\n!! 文件内容\n\n每个apk会在/data/data/目录下存放文件（小米会创建/data/usr/0/别名）。这个目录下的文件夹比较固定，至少有 files, shared\\_prefs, cache, code\\_cache。有些还会有databases, lib, app\\_XXX这样的目录。","modified":"20180320121530000","tags":"os"},
{"created":"20180112121530000","title":"安卓root原理小记","text":"\n最重要的两个分区system和data，这两分区默认只读，因此不能删除预装程序。要设法把su写到system分区，最好还要有daemonsu（守护的目的还不清楚），magisk能在不改动system分区的状态下实现root功能。data会做加密，具体原理不明。\n\n但并是不是把su写入system分区就完成了。这涉及安卓程序的启动顺序，系统是由boot加载的，如果boot内记录了出厂时system分区的签名值，就会拒绝启动写入su的系统，导致系统会halt住。所以锁机的型号一定要最先做unlock，使boot不再校验system分区是否和出厂一致，这样写入su才有意义。Nexus和杂牌不会锁机，像小米或华为的部分机型，需要在官网提交申请才能解锁。\n\n现在问题归结为怎么使system分区可写，有两种途径\n\n# 利用运行期漏洞提权，重新mount system使它可写\n# 启动时将system分区加载为读写方式并写入su\n\n第一种方式常见的形态是一键root软件（安卓版或PC版），会根据系统版本选择合适的漏洞。\n\n第二种方式比如重新线刷boot.img，因为启动信息是以RamDisk方式打包在boot.img里，只能重新生成一个boot程序替换，强制引导为读写方式，如果没有好心人去编译对应硬件的boot，就只有等待了。Magisk就可以针对原始的boot.img打patch生成新的boot.img，将这个patch的boot.img重新写入bootloader就能达到root的效果(理论上，未试出来)。可以从厂商提供的线刷包提取，某些recovery也提供boot分区备份，也能得到boot.img。\n\nfastboot命令可以向flash烧写boot，但有两个前提：电脑上安装手机的驱动，使adb能识别出手机；手机要处在解锁状态，才能在adb reboot-bootloader后，再fastboot flash boot patchboot.img写入，否则进入bootloader会无限循环。\n\n!! boot.img的内容\n\n文件解压得到kernel和ramdisk.gz两个文件，奇怪的是ramdisk用了多种解压软件都没辙。封包格式是安卓自定义格式，前8字节是`ANDROID!`，接着是kernel和ramdisk大小，board name/签名等一系列内容。\n\n!! 启动流程\n\n通常开机到进入桌面会经历下面3个阶段（recovery模式不确定要不要经过boot.img）\n\n```\nfastboot/bootloader -> boot.img -> system/data\n```\n\n结合magisk的systemless做法和必须要给boot.img打补丁，大概率是在boot.img做了手脚，从而能旁路system的只读保护。但仍然需要解开BL锁，才能写入boot.img。","modified":"20180112121530000","tags":"os"},
{"created":"20180805121530000","title":"版本管理工具的历程","text":"\n到今天为止，版本管理工具可以粗略地分为三代：\n\n# SCCS在1972年开创了版本管理的理念，最初是用SNOBL4开发，后来借着Unix的东风，以C语言重写并跑在PDP-11上，这个软件现在已经没有维护了。第一代中还在维护的，是诞生于1982年的RCS，在GNU上能找到最新的发布版。\n# 中心式管理，代表为出现于1986年的CVS和2000年的SVN，其中SVN至今还有旺盛的生命力，在企业市场也非常有竞争力。\n# 分布式管理，为了适应互联网出现后的开发方式，2000年出现了BitKeeper(和SVN同年)，稍后的2005年4月，同时发布了广为人知的Git和Hg，仍在蓬勃发展。\n\n第一代版本控制都是针对文件为单位，RCS使用的`,v`方式保存文件，被CVS继承。这一代并没有多人合作的概念，每次编辑文件前必须要先锁定，提交后再释放。在2010年前后，日系传统企业的软件管理，仍在使用。\n\n第二代的CVS作为中心存储式版本管理，工作路径不放任何历史，虽然每级目录下都会有CVS目录，但里面的内容都是同样的3个文件(开分支会多个Tag)，Root和Repository共同构成了仓库的存储路径，Root文件保存远程档案的路径，如果是个网络地址，要求系统中必须有rsh，所以windows下无法看到远程的历史记录。Entries的内容则多一点，要记录该目录下被管理的每个文件名。\n\n现在还在用cvs管理代码的项目里，我所知名气最大的是OpenBSD。它和cvs的渊源还有个故事：OpenBSD是开源的，但创始人Theo de Raddt觉得只开源代码而不开源代码历史是不够的，在1995年的秋天开放了anoncvs这个系统，并提出了open source repository概念，虽然现在可能有了更好的协作方式，但这在当时还是很有启发性的。\n\n观察CVS的REPO目录可以发现，CVS和第一代都是以文件为最小单元进行管理的，与之对比svn是以目录为最小单元。理论上cvs的控制粒度更精细，相应的操作也更繁琐。cvs的所有命令，都可以不带文件名，表示当前所管理的文件都受此命令控制，达到了对目录整个操作的目的。比如svn固定版本只能对目录固定到某一版本，如果基于特殊原因，想对其中一个文件使用旧版本是做不到的，用cvs就可以在整个REPO指定版本的基础上，再附加对某个文件的固化，可以做到比svn更细致的控制。换句话说这也是svn的优点，SVN相较于VSS、CVS有几个显著的区别，其中最重要的特性之一就是原子性提交，每一个提交都是由多个文件的修改组成，而且这个提交是原子性的，要么这些修改全部成功，要么全部失败。\n\nSVN的分支管理，把每个目录做了一个单独的拷贝，非常占用服务器空间，好处就是分支没用之后，直接把目录删掉就好，大概这就是所谓的易于理解吧。在第三代面前完全不够看不说，我认为甚至还不如CVS。尽管CVS说起来有很多缺陷，个人使用已足够。\n\n第三代的引领者BitKeeper在2002到2005年被用于Linux内核开发，后来针对特点，开发出了Git。除此之外Hg也广泛被认可。配套的还有工作流程的变化(Integrator workflow积分流)，这才是称之为第三代最大的原因吧。\n\n名为分布式管理，但是千万不要认为各分支平等，这其中就有一个更平等的分支，或者叫blessed repository，由项目的管理者持有。如果想把改动合并到这个`reference`分支，发起一个request，只有管理者pull并merge这个请求，才算合入。所以分布式开发模式经常会看到`pull request`。这种模式改变的是存储方式，但代码的管控仍然是严格的。","modified":"20180805121530000","tags":"tool"},
{"created":"20160914121530000","title":"北京之行","text":"\n!! 9月14日-国美、南锣鼓巷、景山公园\n\n上午10点到北京站，并入住宾馆，往中国美术馆。南锣鼓巷，景山公园。\n1楼是油画展，特别写实的只有3幅，其中两幅是山，颜料堆积高过画布，呈现立体感。但是入场的开场白表明，并不重视写实，并批评西方写实主义进入了极简主义的误区。总有点酸葡萄心理吧。3楼是书法展，5楼展示的是寨乡背扇，西南地区少数民族背婴儿所用的服饰，都是在青黑色的背景下，用浓色繁花作缀饰。\n南锣鼓巷，没有特色，各种全国各地都有的西式小吃，炸鸡排，大鱿鱼，小丸子。只有少数几个摊有卖爆肚儿，炸灌肠，卤煮等北京小吃。我也没吃，听说口味很重，可能确实不符合年轻人的口味吧。\n景山公园的万春亭是景山五座观月亭中地势最高的一座，可以看到故宫全貌，但因为雾霾看不清楚。好像看到了天安门广场的人民大会堂，但又不是很确定。景山脚下有崇祯上吊殉国处遗迹。\n\n!! 15日 奥林匹克区域\n\n先到北京的慢跑圣地奥林匹克森林公园，说起北京举办奥运会，所建的场馆中奥森公园是最受大家欢迎的，一来免费二来园内还有塑胶跑道，在这个鼓励全民健身的年代，这样的场所大受欢迎也是十分正常的。奥森很大分了南北二园，我只在南园打了半个转，有片区域种了大片莲花，仿佛置身于曲苑风荷一般。园内靠走还是比较大的，虽然从总体上看公园内森林覆盖率很高，但偏偏让走的路却没有半分的树荫，加上北京的太阳不知为何非常得晒，走了半个南园就转向到科学技术馆参观。\n\n科技馆一楼是中国古代科技成就展，对播种机印象深刻，大约是下有漏孔的推车，孔下又分三小孔，通过左右摇动，使种子成三路洒下。洛阳桥的建成也很巧妙，在石头上养殖牡蛎，利用牡蛎的吸力来牢固石头，可是这种终归是小聪明，不去弄明白牡蛎吸力强的原因，进而无法分析提纯，也就永远停留在原生的牡蛎水平了。2楼是化学物理天体馆，很多小朋友在做各种实验，有个利用吹风机一样的机器控制气球穿过环，因为很有趣玩的小朋友特别多，还有介绍伯努利定律的讲台。二楼另有一半区域是数学馆，比起来数学大概难介绍得多，我也没看明白，音乐部因为有小朋友一个劲地敲边钟，吵得没法看。\n三楼生物馆，印象深刻的是一个实验：把鹌鹑从壳中取出放在鸡蛋壳中，并注入抗生素观察发育。15天后成为鹌鹑鸟，那长成后一团血糊糊的小鹌鹑看着挺吓人。\n4楼是交通馆，去得太晚有个双足机器人表演没有看到。\n\n出科技馆到鸟巢和水立方，鸟巢外形钢架结构林立，看起来就很复杂且维护成本很高。水立方外面看着不高，而且并没有照片上那种纯净的蓝。进到里面，对比了十米台在整个场馆的比例，才能感觉到场馆的高，估计有25米不止。水立方有两个泳池，一个是开放给民用，比较贵60一次。正赛用的泳池，游览当天因为场地外租，在水面上搭了台子，说实话泳池里比较闷热，做节目观众恐怕得受罪，不知道比赛日是不是会开新风。\n\n!! 16日 天津五大道，天津博物馆\n\n五大道是民国时各种名人居所，跨越由横纵5条道故有此名。没有全部走遍，且对大部人了解不够，可能还需要进一步开发。\n天津博物馆处在天津最好的地段，建筑也非常宏伟，传曹操北征乌恒，暴雨一月困在天津，田畴指出小路才有后来的袁氏诛族的结局。天津作为京师漕运的重要一环，也是发展得很好。\n\n!! 17日 国家博物馆\n\n坐落在天安门广场，人民英雄纪念碑东侧，和人民大会堂(西侧)对称的建筑，内里气势相当恢宏。陈列展馆非常得多，涉及门类齐全，书画钱币玉器家具佛像雕塑。\n一楼看到开国大典的油画，其中第一排副总理，朱德刘少奇宋庆龄不难认，李济琛张澜高岗，恐怕连名字都很少被人提及，而且当时6位副主席有3位民主党成员，放在现在都是不可想象的。\n明清家具展，明多用花梨木而清多用紫檀和楠木，因为有了硬木，榫柳也发展起来。硬木的材质配合新的制作理念，使明清家具成熟且风格延续至今。\n\n还有个印象深刻的是甲骨文和金文展，甲骨文且不论，看到了金文的发展成熟。到了西周中期基本有了目前类似的字形，而且字形大小匀称，整体排布也非常整齐，到了西周末年，王朝衰败，钟鼎上的文字也没有中间那么严谨，又变得叛乱散漫了。经战国各个国家的文字演化，在各个不同的地域发展出不同的文字风格，经秦的小篆成了标准形制，后两千年无大的变化。因为金文是在铜上刻出，所以用笔都是直线，多少能看明白一些金文的特色，但介绍中金文刻字的波滐笔法不明其义。\n\n国博出来去了西单和王府井，比较起来王府井是步行街，显然更加高端。而西单还有有各种炸鸡排、玉米等无聊小吃，显得市井味更重一些。\n\n!! 18日 故宫\n\n午门为入口，门有两延伸如U形，又名雁翅门。其实午门是不杀人的，作为皇宫的正门，杀人显然太不吉利。但明朝在午门曾有过延杖，故坊间有误传。\n\n进门左手武英殿，李自成在此仓促继位，一天后败走，后康熙在此设立书坊，乾隆更有从永乐大典摘抄得武英殿本而成名。我去的时候武英殿正在办书法展，让我记忆深刻的是评论说明代二沈台阁体，因文字没有个性，所以并不受推崇。\n\n和武英殿对称的，是文华殿。文华殿正殿展览瓷器，瓷器在唐朝之时，有了南青北白的叫法，越窑青瓷和邢窑白瓷。后来更演化出了唐三彩，其实是陶器，有白青黄三色。\n\n故宫名叫故宫博物院，但是内部大部分是宫殿，类似于传统博物馆的，只是在其东边的一些偏殿被开辟成了展览馆。有钟表馆、珍宝馆两个大馆，其中珍宝馆是一片很大的院落，九龙壁就在珍宝馆内。钟表馆因为有个《我在故宫修文物》的纪录片，所以在去之前就很想去见识一番。\n里面陈列的各式或西洋或苏州广州所造之钟，无不令人脑洞大开。名字叫钟表馆可能不太妥贴，因为只有钟却没有表。里面更有一台钟，其内置机关小人可以用毛笔写出“八方向化、九土来往”而让人惊叹。西洋人好机关之学，远在吾国鲁班墨子之上。","modified":"20160914121530000","tags":"think"},
{"created":"20171110121530000","title":"比较词法分析和语法分析","text":"\n词法分析是一种单向的状态机。最简单的词法分析，只要不停的吞入字符并和状态表中的可选项进行匹配，并把匹配上的字符挑选出来就可以了。稍微复杂一点的则可以加入把匹配项里面的部分字符退回，但这个状态更多的像是一种人为的操纵，而不影响状态机的本质。另外在比较的时候有一个很简单的判断，就是称之为最长判断，但这种判断也不会造成过多的选择负担。\n\n由于输入的数据始终只有一种状态，所以不需要保存过去的数据，当然也不存在栈溢出问题。\n\n语法分析相比起来就要复杂很多，是一个带有栈的，且栈深度是可伸长的状态机。因为一个不带栈的语法分析器，比如LR(0)，能够分析的语法是非常少的。要想达到可用，至少要保存向前看的一个数据。另外归约时要根据向前看的数据进行选择，也要把一段时间内未归约的数据保存下来，这就需要栈，当归约的语法太复杂，或者歧义太多，保存在栈上的数据过多，就可能导致栈溢出的问题。\n\n从我查到的文献看，1965年的ACM就刊载了TMG compiler compiler语法分析文章，这个工具在70年代初移植到了最早版本的unix，但在用TMG给B语言扩展特性时却很困难，因此才基于LR解析理论重写了yacc（yet another就是针对TMG而言），并随着version 3 unix一起发布。而lex虽然更简单，但资源很少，只查到1975年lex论文发布（同年yacc论文也发表了）。由于年代久远，二者都是不可重入的。随着线程的出现就出现了可重入的需求，lex可以使用%option reentrant生成可重入代码，如果比较会发现和非重入版的代码差异极大，yacc也能生成可重入代码，而更新的语法生成工具如lemon，生成的都是可重入代码。","modified":"20171110121530000","tags":"lang"},
{"created":"20231027033400938","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'lang' sort[title]>>\n\u003C/div>","tags":"目录","title":"编程语言","modified":"20231027033416905"},
{"created":"20191206121530000","title":"编程语言的字符串内部表示","text":"\n最近在做中文字符校验，结合几种语言的使用，做个总结。除了ASCII字符集以外，其它文字普遍有定义和外部展示的区分，即使不考虑各国定义的标准外，也还存在Unicode和UTF8两种要区分。编程语言接收的输入一定是外部展示，然后在处理时再变成内部表示。\n\n!! JS\n\n因为是内嵌在浏览器，文字的编码方式不需要JS操心，浏览器会把各种编码转成Unicode再给JS。但是JS发明的时候，Unicode还只有BMP，所以内部单元都是UCS2方式，包括String.fromCharCode会截断，比如0x20041返回的是0x41。超过BMP的字符在内部以代理对(surrogate pairs)方式表示，length取得的长度是2。\n\n好在新标准定义了String.fromCodePoint方法能识别代理对，能正确识别0x20041。另外对字符串变量str，用`const i = str[Symbol.iterator]()`得到的i，可以用next()方法每次迭代一个CodePoint，利用这个方法，可以构造另一套支持全Unicode的方法。也算在无奈之下的补偿方式了。\n\n!! PHP\n\n没有语言规范层的定义，实际中可以用`mb_internal_encoding`获取内部编码方式。如果在`mb_`系列方法中编码和输入源不匹配，得到的错误结果要使用者自己承担。有点C语言的哲学。\n\n!! Python\n\n由于出现断代变迁，2和3有较大差异。2.x内部是ASCII，3.x内部是Unicode。前者无法支持多语言，后者不是通用的外部表示（因为主流是UTF-8，在那之前则是各国不同的编码标准），因此2个版本的输入文件都有文件编码参数（可以显式指定，或跟随操作系统），如果读入的字符和指定的参数有冲突会报错。\n\n2.x的文字只是字节的序列，类型是str(等价于3.x的bytes)。可以加u前缀保存成Unicode，比如u'文字'，类型变成unicode。到了3.x时代，str升级成unicode，bytes表示字节序列。在2.x里经常要对一个str类型变量用decode(\"utf-8\")方法，到了3.x会调用失败，因为str已经是unicode类型，只有encode成某种编码的序列；反之byte类型才有decode方法，将一段字节流按指定的格式解码成unicode形式。\n\npython的base64解码，由于返回值不能保证内容是unicode可编码，所以只能是bytes类型。如果想要以str方式使用，要decode(\"utf-8\")后再使用。\n\n!! Golang\n\n规范要求输入必须是UTF8。string类型是byte sequence，用`[]`的下标处理时，操作到每个字节。对string用range方法每次返回一个rune类型的值，以Unicode表示的一个字符，长度不定，由于语言出现得比较晚，避免了JS的坑，能表示全部范围。","modified":"20191206121530000","tags":"lang"},
{"created":"20190620121530000","text":"\n如今的编辑器没有插件机制都不好意思出来见人，像Emacs，所有的操作都可以对应函数，再用Elisp把已有的函数和数据结合起来，本体和扩展混然一体，非常流畅。什么是真正好的机制？\n\n!! notepad++的插件机制\n\nnotepad++插件很多，执行程序集成了scintilla库，另外还有个独立的SciLexer.dll库，做词法分析。原理是dll开发，一定要实现5个函数，另外有个isUnicode选择实现，一般是返回TRUE就好。这5个函数说明如下\n\n# getName : 给插件选个好名字，不需要和dll名相同，在插件菜单就靠这个名字找插件\n# setInfo : 初始化阶段会被npp调用，传入3个句柄，分别是npp本身，scintilla的main和second handle(分别对应编辑区的两个视图)\n# getFuncsArray : 在setInfo之后被npp调用，获取这个插件的条目，因为功能可能依赖setInfo传入的句柄，所以时序上严格晚于setInfo，返回条目数量和函数指针\n# beNotified : 产生npp专属事件时会回调\n# messageProc : 通用的windows消息回调\n\n通过记录宏发现端倪。npp的操作对应的是消息，利用记录宏保存在shortcut.xml文件的信息，就可以反窥出这个动作要怎么表示，再在插件中发起这个消息，也可以达到融合的效果。这是一个宏的记录\n\n```\n\u003CMacro name=\"Trim Trailing and save\" Ctrl=\"no\" Alt=\"yes\" Shift=\"yes\" Key=\"83\">\n    \u003CAction type=\"1\" message=\"2170\" wParam=\"0\" lParam=\"0\" sParam=\" \" />\n\u003C/Macro>\n```\n\n猜测action type 0 is for Scintilla commands with numerical params, type 1 is for commands with string parameter, 2 is for Notepad++ commands.\n\n!!! npp的脚本化插件\n\n如果只能开发dll插件成本还是太高，LuaScript提供SendEditor/MenuCommand等函数，可以发送所有的SCI消息给编辑器，消息的枚举要查看scintilla.iface。或者执行菜单命令，具备了相当程度的整合能力。\n\n!! EditPlus的扩展机制\n\n不提供内嵌语言方式的扩展，只能通过filter钩子来实现一些基于文本的动作，可以替换也可以执行一些其它指令，但不能获取到编辑器的内部状态，因此觉得算不上插件，但也算是一种很简便的和外部程序的协同。\n\nfilter的原理是逐行从stdin读入，处理后写到stdout，写出的内容按指令替换或打开新的文本。\n\n!! 一些小众编辑器\n\n也许工作中不会用到这些编辑器，但是看到有趣就记录下来。\n\njed，取名是作者名字的3个字母，扩展语言称为SLang。快捷键默认和emacs一样，记住ctrl X ctrl C退出，Alt X执行命令。如果在site.sl中加载vi.sl插件，再执行`command_mode`命令，就能用反引号（注意不是ESC键）进入vi模式。\n\njasppa，一个MicroEmacs的发布版。\n\nvile，全名是vi like emacs，非常轻量似乎也有扩展模式。\n\n要具备IDE功能的编辑器是越来越难，具备语义的自动补全，跳转和跳回，和编译链的结合性。只有深厚积淀的编辑器才能承载前行。","title":"编辑器的扩展机制","modified":"20231027131828555","tags":"tool"},
{"created":"20161031121530000","title":"变倍与聚焦","text":"\n监控行业的相机有枪式和球式两种，还有种半球但实质上和枪式一样，只是安装方式不同。\n两种相机因为外形和机械结构的不同，使用场景也有很大差异。\n比如枪式相机主要安装在室内，而球式相机装在室外的较多。\n这种场景的不同，导致对图像的调校也不一样，典型如白平衡，两者的侧重点就很不一样。\n\n这里从变倍和聚焦出发，谈谈两者的不同。先说说两者的异同：\n\n* 变倍的主要作用是调节透镜的物距，进而影响成像的大小，变倍主要有光学变倍和电子变倍。\n* 聚焦则是使物体成像于焦点上，能看到清晰锐利的图像。\n\n从光学镜片的物理特性来说，单个镜头的曲率固定，焦距也固定，无法实现变倍。要变倍必须有多片镜头组，通过调节互相之间的位置，得到一个整体的等效焦距，这个焦距才能变化，焦距变化后就能达到变倍效果(准确的说是视角的变化)。而调焦是由于焦平面没有落在sensor上，整体移动镜头组，在此过程中焦距不会变。\n\n为什么很多人会说分不清楚两者呢，因为在使用的过程中，\n变倍和聚焦在直观上都有一个物体由模糊变清晰的过程，所以会觉得两者很相似。\n但仔细区分的话，会发现，变倍会引起物体大小的变化，而聚焦只会变清晰，\n但并不会改变成像的大小。而且更进一步说，变倍并不会使物体自动地变清晰，\n往往是镜头实现了自动聚焦这一动作。\n\n变倍尤其是光学变倍，都会调整透镜和CCD或CMOS的距离，因此都需要配备电机，\n或者更高级的会使用步进电机，这就必然导致成本上升。\n因而低价位的枪式相机大多不具备变倍功能，因为没有变倍，焦距也能在出厂前就调节完成，\n所以既没有变倍，也没有调焦功能。\n\n而球式相机由于自带云台，能够各种方向的旋转，在旋转的过程中很自然的有了变倍的需求，\n因此球式相机在行业里又称为PTZ，P和T是Pan(水平)和Tile(垂直)的意思，\n指的是云台底座的运动方向，而Z则是Zoom，即相机镜头的变倍。\n当然带云台的相机也可以没有变倍，两者并不强关联。\n由于球式相机大都具备变倍功能，在日常使用的过程中也经常要调节倍率进行物体的跟踪，\n往往要配备比较强大的聚焦算法，否则跟踪物体就会发虚模糊，用户是不能接受的。\n因此对球式相机来说，变倍是其基本功能点，而自动聚焦则是必备条件，\n但是又由于球式相机经常处于运动状态，对于聚焦只要能达到人眼可见的清晰程度，\n就能满足用户的使用了。\n\n枪式相机，如果具备变倍功能，通常也会同时提供聚焦的调节功能。\n当用户购买了变倍相机，并在安装时根据场景选择好倍率，就会仔细地调节聚焦，\n力求画面清晰锐利，因为枪式相机的视野比较固定，一旦安装好，变倍就固定下来不会轻易改变，\n因此对聚焦就会有更多微调节的需求。\n\n因此在枪式相机上，能看到单独的变倍和聚焦页面，而球式相机则往往只有变倍的按钮可以使用。\n\n上文说到聚焦的目的是使物体变清晰，那么这个清晰要如何定义呢？\n如果是手动聚焦，一切依赖肉眼那就全由人来完成，但是往往相机都能自动地调整好焦距，\n这又是怎么做到的？这就涉及图像处理的算法了：比如在画面中有一个人，\n那么这个人的轮廓和画面的背景交界处，一定会出现较大的差距\n(当然如果你非要穿着黑衣在黑夜里，就没得谈了)。\n那么我们就可以通过计算图像中这些亮度差距较大的地方，来勾勒出轮廓，\n并通过调节画面，找出亮度差最大的一个场景，这时从理论上说，就是焦距最准确的位置。\n这个找最大差的原理则类似数学中的求导，当然具体细节复杂得多，只是一个约略的近似。\n除了这种自动聚焦的方式，还有一种辅助聚焦，在手动调节焦距时，\n由相机反馈一个当前聚焦峰值，一边手动调焦一边观察聚焦峰值，当这个峰值达到最大的一刻，\n就找到了焦点。有种把自动聚焦的内部参数，开放给手动调节的感觉。\n\n所以虽然都是变倍和聚焦，由于相机的使用方式不同，这两个功能的呈现和侧重也会有所差异。\n概括地说就是\n\n* 枪式相机更注重聚焦，达到更好的画质\n* 球式相机更注重变倍，达到运动过程中更好的观看体验\n","modified":"20161031121530000","tags":"protocol"},
{"created":"20150705121530000","title":"变量类型与Lua的local关键字","text":"\n对变量来说，有几个属性：1 类型，2 可变性，3 作用域\n\n对1.类型来说，动态语言不需要事先声明，所以这一点是没有的。C或Java需要，(C++11的auto看似做了简化，其实只是给编译器的一个提示，还是会转变成真实的类型再编译)\n\n2.可变性，纯函数式比如Haskell是不可变的，也就不需要这个修饰。但大量其它语言还是需要的，比较多见的是const/volatile关键字，ES6也引入const了，Lua中还没有，另外好像Scala是用var和val来区分变量是可更改还是恒定性\n\n3.作用域，Lua语言在声明一个变量时，是可以指定local的，表示这是一个位于当前chunk的变量，如果没有，则变量被声明到了全局空间，语义上对应js中的var关键字。\n\nlocal和当前函数的作用域在一起，因此访问速度也最快，全局变量则要依次向上查询，速度显然要慢一些。所以很多Lua代码，都会在开始处用local方式把全局重新定义一遍，目的就是为了提高速度。对于默认声明变量都不在局部域这点，我很不理解，为什么可以在一个函数内部声明一个外部的变量？而且显示调用local声明变量的方式，还可以声明一个变量但不使用。因为这本质上只是预留了一块空间，无非是空间的位置在哪里而已。\n\nRnRS中有这样一句：对变量的每一次使用都对应于该变量在词法上的一个明显的绑定，因此只声明变量而不使用的行为，在Scheme中是不允许的。\n\n纯函数式理论上是不是需要声明变量的，一切都在计算中传递。但冯诺依曼的计算机模型却让变量成为了计算的基础。另外全部做成在计算中传递也比较难以书写，于是Scheme中也保留了局部的变量绑定语法，就是let系。它的作用域就是局部的，可以认为是必须放在函数开头处，且必须显示声明绑定关系的local语句。个人以为这种规定比js中随意放置var声明要严谨得多。\n\n再提一点RnRS对define的定义是Top Level Definition，而let系是Internal Definition。我用TinyScheme测试，是可以在lambda内部使用define语句，但kawa就通不过。考虑到Tiny毕竟是一个极小的实现，对一些限制也不严格，因此对define的使用还是在全局较好。\n","modified":"20150705121530000","tags":"lang"},
{"created":"20161019121530000","title":"表单的请求类型","text":"\n有很多的文章会讲http协议里，Post和Get的区别，说点我的补充理解。\n\n不管是Get或者Post请求，除非是单纯获取信息类请求，总是会带些参数，如果参数有多个，就存在多参数的区分问题。Get请求通常只使用Url(注意这只是HTML的用法，不是HTTP的规定)。所以就需要定义规范，在1994年的时候Berners Lee等人制定了RFC1738规范(URL定义)。特殊字符用%[0-9A-F]{2}方式转义，使用&来区分多个参数，每个参数再通过=分成key和value。\n\n所以Get的URL往往像这样：`example.com/act.cgi?key1=value1&key2=value2`。\n但是Post的请求内容并不在Url中，而是在http协议头之后，这段内容没有规定，只是一段无格式的Buffer。为了解决Post的body无约束的缺失，在http规范里有个Context-Type字段，比如定一个Application/Json，Application/XML等等的格式。\n\n!! Application/x-www-form-urlencoded\n\nhtml中表单Form元素，使用post method时默认会使用`Application/x-www-form-urlencoded`格式。这个命名的`x-`表示它是个扩展规范，`www-form-`和HTML的表单能很自然地联系，最后的urlencoded表示它和Get请求在Url中带参数的风格是一样的，也是用&和=来区分，从而减少开发者的学习成本。如果输入内容包含=或+，也会按urlencoded方式转义，也就意味着内容如果是base64的内容，不需要额外对=进行转码。\n\n我不知道为什么当时会用这么一个略显冗长的格式，也许在定义的时候，JSON或XML都还不引人注目，而Get又是urlencode编码，也许为保持一致于是就用了它。\n\n当`Content-Type`使用了`x-www-form-urlencoded`时，PHP会把Post内容按上面说的格式来解析，最终赋值给`$_POST`变量，其它方式不会赋值到`$_POST`。\njQuery的post方式也使用HTML的默认格式，在js语言层面看起来写的是json数据，但网络传输时最终把json转化成用`=`和`&`分隔的URL方式，\n到了PHP侧再用`$_POST`来提取。这个过程中，js/传输/PHP各自用符合自己特性的方式，但最终仍是无疑地进行交互。\n\njson比urlencoded方式更有表现力的地方在于支持数组，抓包后发现jQuery把数组arr:[1, 2]转换成arr%5B%5D=1&arr%5B%5D=2来发送，\n相当于服务端依次收到arr[]=1和arr[]=2两个值。至少PHP能够识别这种数组表示法。\n\n!! multipart/form-data\n\nurlencoded的方式有个不足，就是传输二进制数据的效率非常低，极端情况如果全是不可打印字符的话，数据量会增大3倍。\n如果是传输图片或大文件，Form表单的input使用file类型，enctype要使用`multipart/form-data`(如果不指定则默认urlencoded方式)。\n\nmultipart表示这个请求有多个部分，每个部分会标记`Content-Disposition: form-data; name=\"xxx\"`，如果是file，会额外多出一个filename=\"file real name\"。这时二进制数据就不做任何转换地发送到服务器。\n如果有多个二进制数据(即multipart)，就用Boudary来区分。`$_POST`能解析不带filename的部分，惟独文件不能解析，即使`file_get_contents(php://input)`方式也不支持(就这一种不支持)，还不知道该怎么读取。\n\nGet是否支持在body中携带参数？标准没有规定不允许，但是浏览器不支持。为了兼容性考虑，只在URL中带参数是更好的选择。如果真的构造了在body的get请求，可以用原生内容，也可以从`$_REQUEST`变量读取。但PUT请求时，无法解析，也许是PHP的原因，暂未追究根因。","modified":"20161019121530000","tags":"web"},
{"created":"20181230121530000","title":"并不神秘的深度优先搜索","text":"\n在图中搜索到某个点的路径，把图映射成一张二维数组，每个坐标的值，区分障碍物，未走过，已走过等状态。\n\n深度优先的核心思路还是递归的应用，先确定下一步的寻路方向，然后把下一步的坐标点直接以递归的方式调用，虽然看起来只是一次函数调用，但已经穷举了这个坐标点后所有的可能。但是穷举这个方向不一定会有结果，所以当函数结束后，要回退这一步的尝试，换一种寻路的方向，再次递归尝试。如果是数组，只要单方向前进就够了，如果是地图寻路，可以在4个方向上做尝试，4个方向都尝试过，所有寻路的可能就穷举尽了。\n\n深度优先也属于穷举，只是用了递归的方式让代码看上去比较简洁。\n\n```\n#include \u003Cstdio.h>\n#include \u003Cstdlib.h>\n\nint gmap[6][5] = {\n  0,0,0,1,0,\n  0,0,1,0,0,\n  0,0,1,0,0,\n  0,0,0,1,0,\n  0,1,0,0,0,\n  0,0,0,0,0,\n};\nint move[4][2] = {1,0,  0,1,  -1,0,  0,-1};\n\nint gshort = 100000;\nint gall = 0;\nint gway[100] = {0};\n\nvoid printway(int cnt){\n  int i = 0;\n  for (; i\u003C=cnt; i++) {\n    printf(\"%02d \", gway[i]);\n  }\n}\n\n#define ISREACH(x, y) ((x==4)&&(y==0))\nint sf_step(int x, int y, int cnt){\n  int eps;\n  int i=0;\n  printf(\"EPS:%p\\n\", &eps);\n  gway[cnt] = 10*y+x;\n  gall++;\n\n  if (!ISREACH(x,y) ) {\n    for (; i\u003C4; i++) {\n      if ( (x+move[i][0]\u003C5) && (x+move[i][0]>=0)\n        && (y+move[i][1]\u003C6) && (y+move[i][1]>=0)\n        && (gmap[y+move[i][1]][x+move[i][0]]==0) ) {\n        gmap[y+move[i][1]][x+move[i][0]]=2;/*reach this slot*/\n        if (1==sf_step(x+move[i][0], y+move[i][1], cnt+1)) {\n          cnt+1\u003Cgshort? gshort=cnt+1: 0;\n          return 1;\n        }\n        gmap[y+move[i][1]][x+move[i][0]]=0;\n      } else {\n        continue;\n      }\n    }\n   } else {\n      printway(cnt);puts(\";\");\n      return 1;\n    }\n    return 0;\n}\n\nint main(int argc, char** argv) {\n  int x,y;\n  x = atoi(argv[1]);\n  y = atoi(argv[2]);\n  printf(\"%d,%d\\n\", gall, sf_step(x, y, 0));\n  return 0;\n}\n\n```","modified":"20181230121530000","tags":"design"},
{"created":"20170304121530000","title":"并发和并行","text":"\n先比较两者的定义：\n\n* 并发是concurrent，指多线程编程存在对同一资源的竞态情况，往往需要加锁操作，Perl6提供了OO::Monitor和OO::Actor两种原语来支持。\n* 并行是parallel，指多进程可以互不干扰地执行程序，因为处理的数据不同，自然不用加锁。并行存在数据的归集操作，Perl6也提供了Promise等原语支持。\n\n并发必然涉及锁，说说线程和条件变量和信号量\n\n先说说创建线程的两种属性join和detach。\n\npth的线程实现有5个队列NRWSD，分别是new/ready/wait/suspend/dead。join属性的线程在退出时加入dead队列，因此依然被调度，而detach属性的线程则不会，因此直接把线程控制变量free掉不再调度。所以退出时也不一样，join用`pthread_exit`可以捕获退出状态，detach可以直接用return。\n\n条件变量必须配合锁，在wait前显式地获取锁，在wait函数内进入cond等待队列并释放锁，然后线程block住，将将调度权交还系统。直到另一个线程signal或broadcast才重新执行。而signal函数如果发现cond队列为空，不执行任何动作直接返回。\n\n信号量并不是pthread定义的，各个平台函数名也不同，等效于mutex和condition再外加一个计数器的总和。因此mutex和condition可以认为是线程同步的原语。\n\n比如公司的RPC网络框架库，后台启动4个业务线程，平时以semaphore的方式等待，消息到了就在epoll线程执行加1操作，接着就会有一个业务线程被执行。但是这个场景中直接用condition是不行的，试想如果4个业务线程都还在执行中，此时又来一个请求，如果是condition的语义，由于所有业务线程都在执行导致cond队列没有等待，这时的signal没有任何意义，导致这个请求丢失。当然如果真用condition，RPC框架也不是这么实现了。\n\n!! perl6对于同步和并发的探索\n\n从slide上摘录要点。\n\n* 线程 存在数据竞争\n* 锁 会导致死锁\n* 条件变量 spurious wakeups？不清楚是什么\n\nPerl6给出的解决方式，用start启动一个promise，再await就可以得到promise结果。\n\n支持monitor和actor模式，类似Java的synchronizised同步块语法，可见多线程抢夺资源是如此的普遍，编程语言都会作出方便的支持。\n\n!! 异步接口转为同步接口案例\n\n起因是图片识别人脸的协议最早的对接方式是阻塞的，新品改成异步方式，本来以为异步转同步很简单，真正实做才好现细节值得思考。\n\n首先异步通常意味着执行的结束时间很长且不确定的，但转同步的时候必须要加上限制约不能无限等待，等待的最长时间全凭经验，是无法量化的因素。\n\n接着考虑多线程同步的问题，异步通常需要订阅回调函数，执行并等待的线程A和回调执行结果的线程B间就必然存在资源竞争的问题。常见的等待方式就在是A线程启动一个带超时的信号量(semaphore/event)，并由线程B来释放它。但是如果线程B被触发时线程A的信号量已超时并过期，B就不应该释放。但目前基础库中并没有办法探测A的信号量是否还在等待。因此提高了复杂性。\n\n再进一步考虑，执行函数能否并发执行，如果不能并发则在上层调用前就要加锁防止重入。","modified":"20170304121530000","tags":"design"},
{"created":"20190504121530000","title":"博客网站功能扩展记录","text":"\n!! 调试\n\n一直以来对Web开发调试都没有好的办法，知道了`error_log`函数可以记日志。记录的文件名通过php.ini来设置`error_log = php_errors.log`\n\n这种相对路径的方式把日志保存到index.php同一个目录下。除了写文件还支持发邮件等格式，对网管来说很实用。如果是php-fpm还支持slowlog，在php-fpm.conf加上\n\n```\nrequest_slowlog_timeout = 5s\nslowlog = /var/log/php-fpm-slowlog.log\nrequest_terminate_timeout = 10s\n```\n\n!! 账号切换\n\n账号就是对session和cookie的控制，通过增加切换账号的页面，让同一个cookie在不同时间段对应不同的session。原有的auth机制没有做成通用，最初的修改甚至直接导致鉴权之后回到主页，而主页又鉴权的死循环。cookie保存的是PHP计算的哈希值，持久化的session文件记录的是数据库名，并不会记录密码，不过目前版本还没有做切换账号时的密码加密，也没有做cookie防劫持。\n\n账号切换按钮做了个简单的隐藏，只有登陆过或者芝麻开门方式才会显现出来，不算很高明。\n\n随着多账号的实现，以文件方式缓存首页也调整为数据库方式，却因SQL语句少了右括号浪费了半个小时才看错误，PDO错误通过errorInfo方式返回数组，错误码由ANSI定义。另一个缺陷是原来以文件方式保存，用include导入即完成代码到变量执行，换成数据库后要显示执行eval，无法避免失败的情况，需要继续想办法。\n\n将鉴权函数从全局函数修改为类的static函数，好处就是可以利用类的自动加载机制，省去了显式加载auth文件的步骤，另外将密码映射表移到类内部，减少暴露的数据。\n\n!! 单页化\n\n在安卓上写程序久了，渐渐萌生了把博客网站也做成前后分离，不再依赖后台模板的想法。\n\n改为SPA后，有以下几个点很不同\n\n# 首页会变大。因为用后台模板时，需要切换页面时才会请求，并进入新的页面。而用SPA方式只有数据流，所有的布局在一开始就已全部加载到浏览器上，如果页面很多，首页加载速度多少会有点影响。\n# css样式写法变化。原来多个页面时，每个页面对应的css是直接写body、p的样式，显然要合并成一个，并用都按类的方式重写。\n# 所有的表单请求，换成用ajax并将内容绑定到DOM\n# 生成DOM树的元素，手写`\u003Cbr/>`，真正到了浏览器却变成了`\u003Cbr>`，难怪都说前端坑多。\n\n分离后JS得到的都是JSON数据，除了把静态内容渲染到DOM，还有一块就是要构造带有交互功能的按钮。\n\n!! 支持标签\n\n首先数据库要支持增加列，使用`alter table blog add column tag text default '';`语句增加一列。\n\n由于数据从一列变为两列，返回到页面的格式就不能再用字符串，比如用json。在PHP侧把array用`json_encode`转换输出，虽然是json但网络传输的还是字符串，所以js得到的数据不能按json操作，好像版本3的时候还没有纳入规范，直到版本5才正式成为规范。有个通用的技巧直接用eval(string)就可以转成对象，还有种说法是用eval('('+str+')')格式，似乎前面简单的做法就够了，不清楚两者的差异。\n\n总的来看多个数据在浏览器和服务器之间的交互格式是不同的，请求要按照URL规范，因为也只有这个规范，加上PHP天然就很好地支持这种格式，所以是最佳选择，回复因为是给js解析，所以用json无疑就是最好的格式。\n\n还有个问题，在赋值时究竟用innerText/innerHTML/value的哪一种？\n\n# innerText是id为object的闭合标签内的文本,输入输出的是转义文本(字符串);(label控件用innerText有效)\n# innerHtml是`\u003Cdiv>`标签内的文本,输入输出到该DOM内部纯HTML代码(流);(获得td、div等html元素时候,它们是没有value或是text属性,只能用innerHtml)\n# value是表单元素特有的属性,输入输出的是转义文本(字符串);(Button、CheckBox、Radio)随表单一起发送的值;(Reset、Submit)标签;(Text、Hidden)默认值;(File、Password)(注: Text控件用value有效)\n\n其实对textarea标签，也就是多行文本编辑框，innerHTML和value还有更大的区别\n\n# innerHTML 仅在 textarea 初始化的时候对 value 有影响，value 的内容就是从 innerHTML 来的；除此之外，innerHTML 和 value 没有任何关系，修改 value 不影响 innerHTML，修改innerHTML 不影响 value；\n# 界面上呈现的永远是 value 的值，而不是 innerHTML，比如通过代码修改 innerHTML 之后，界面上 textarea 里面的内容还是 value 的值；\n获取文本框的内容，自始至终都应该读取 value；\n# value 获取的是原始内容，innerHTML 获取的内容会自动将 `\u003C` 和 `>` 这2个符号转义；\n# 初始化 textarea 的内容只能写在 `\u003Ctextarea>` 和 `\u003C/textarea>` 的中间，不能像 input 那样写在 value 属性上面；\n\n所以 value 一般用于一些表单元素的获取值，input，select 等，textarea 也算表单元素，而 innerHTML 用于 div, span, td 等其他元素。总之切记 表单元素别用 innerHTML！\n\n!! 回归静态与CGI by23.01\n\n因为外网穿透失灵兼PHP程序不知为何不能用，从10月份断断续续改了多次，开始用sdf提供的web服务，做成用lua动态渲染markdown，但访问速度实在太慢。后来知道了frp还是决定用回自己的主机，但免费的frp偶尔会断，加上lua渲染不支持表格，干脆用python预生成HTML回归纯静态展示，还能部署到github page，对主机没有要求。动态部分只保留CGI编辑，支持电脑和手机端多端同步。","modified":"20190504121530000","tags":"web"},
{"created":"20200411121530000","title":"不可打印字符与转义序列","text":"\nplan9的老人们建过一个网站cat-v.org，影射cat命令加上-v选项是邪恶的。这个选项的作用是把不可打印的控制字符显示出来，低128用^，高128用M-前缀，在一些终端类软件上会用到这些符号。\n\nASCII的编码0到31，0对应^@，接下来是^A-^Z，从27到31依次是`[\\]^_`，127是^?。从128开始，显示的时候前面会有M-前缀，比如128对应0，显示为M-^@，依此类推。而从160开始，对位字符是可打印字符，在前面加上M-，比如33是!，则161显示为M-!。\n\n用cat -v显示的话，制表符和回车不会按^I和^J显示，要分别用-T和-E选项，-T会把Tab显示为^I，而-E会把回车显示为$，且实际上也会另起新行。用-A则是结合了vET这三个选项，显示所有不可打印字符。\n\n题外话：按下键盘上的回车键，相当于按下Ctrl+M，而Tab键则相当于Ctrl+I键。在bash中用bind -P查看按键映射，会发现自动补全的按键序列只显示Ctrl+I，一旦把Ctrl+I映射成其它功能，Tab键的功能也就跟着变了。\n\n!! ASCII码中不可打印字符\n\n偶然间看OpenBSD开发的mandoc.db格式，提到用了3种格式，32位int和NUL结尾字符串都很普通，但第3种字符串列表的表述`lists of NUL-terminated strings, terminated by a second NUL character`，0是NUL，second NUL查看了ASCII表，对应的是2，含义是start of text。\n\nASCII的前32个是控制字符，用在电传打字时代，来看看相近的几个描述，1-SOH(start of headling), 2-STX(start of text), 3-ETX(end of text), 4-EOT(end of transmission)。可以看到1开始文章标题，然后是2文章正文，3文章结尾，到4结束传输之间可能还有些附录、索引要添加。包括其它的请求应答、回车制表换行等，不可打印字符在文章结构划分、控制版式上是有实实在在的作用的。\n\n!! 转义序列\n\n开发出Unix最早版本的PDP系统，既没有光标也没有删除，更没有上下左右键，有兴趣的可以体验[模拟器](http://pdp11.aiju.de/)。更友好的显示肯定是刚需，于是各厂商就开发各种转义协议，让屏幕出现光标、重绘、颜色等特性，起初厂商间各自为战，好在美国人向来有搞标准的习惯，1978年的VT100便是符合这个标准最初的成功样本。\n\n规范规定，转义序列在带内传输，序列总长度不固定，但必须以ESC开头，后面再跟0x40-0x5F字符(`@A–Z[\\]^_`)。比较常见的有\n\n* \\033[ 终端显示色彩用的就是这个命令\n* \\033] 操作系统命令\n* \\033_ Application Program Command(APC)\n* \\033\\\\ 字符串终止，可以用于APC的结束\n\n最早的颜色序列只有3位，共8种颜色，加上粗体被实现为亮色，只有4位。后来又逐步扩展出8位，而libvte库更是支持24位颜色(需要依赖X11，比如xterm等图形界面)。","modified":"20200411121530000","tags":"protocol"},
{"created":"20200301121530000","title":"布尔代数与三段论","text":"\n莱布尼茨发明微积分时已定义一套符号体系，更设想了一套通用的代数体系。到了乔治布尔时，提出了用符号代表类别的理念，比如\n\nx表示绵羊，y表示白色，则xy表示白色绵羊。显然xx仍然表示x，如果想把符号和数字打通，只有0和1能满足，所以看起来简陋的布尔代数实在有其不得已的限制。再往前推一步，0表示空集，1表全集。\n\n再说三段论的证明，如果x满足y，y满足z，则x一定满足z。其中x满足y意味着x是y的子集，同时意味着x和y的补集的交集是空，即x(1-y)=0，得到x=xy。整个连续的推导\n\nx=xy=xyz=xz 于是得到x满足z\n","modified":"20200301121530000","tags":"design"},
{"created":"20231027032947844","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'os' sort[title]>>\n\u003C/div>","tags":"目录","title":"操作系统","modified":"20231027033014581"},
{"created":"20180809121530000","title":"操作系统启动器的故事","text":"\n看看几大主流操作系统的启动区别。\n\n!! 启动顺序的差异\n\nWindows是先认硬盘，再从硬盘分辨分区，其中系统分区中找到ntldr并引导。\n\nLinux要先有根文件系统，由于还没有读硬盘，必然在内存中建立根目录，有了根目录硬盘才能挂载。抛开硬盘后，有UBoot(BIOS)、内核、内存文件系统和init进程等关键元素。如果用mount命令查看，`/`的类型并不是rootfs，像我的Cent7虚拟机是xfs，Alpine则是ext4。看不到rootfs不代表没有，它确实存在过，只因为rootfs是ramfs的一个空实例，挂载后大部分系统会把硬盘上真正的文件系统替代rootfs，所以用mount就看不到了。但是在硬盘被挂载前，rootfs基于的ramfs使内核有栖身之处，显然是有意义的。\n\nLinux启动的三大部分，boot/kernel/rootfs，常见组合是BIOS把控制权交给grub，grub显示启动菜单，并把用户选择的kernel即vmlinuz文件加载到内存。内核自带虚拟文件系统，由于只管调度并提供调用接口，要让用户使用，必须在内存中安装根目录，initramfs.img就负责干这个。它的前身叫initrd，两者的区别是initrd把内存模拟成硬盘，制作时要关联到loop back device，再mount后才能找到init。而ramfs方案直接把内存模拟成文件系统，一步到位。把initramfs.img解压到根目录（又叫rootfs），这个initramfs.img其实是个`gzip+cpio`的文件，用gunzip加cpio -idv \u003Cfile的方式能看到内容，包含/bin/,/usr/这些文件夹。开始是只读，只要挂载完校验完整性通过，才会改成可写方式。加载完并有了init后，就可以彻底进入用户态加载各种服务了。\n\n!! Unix系的init\n\n!!! Linux\n\ninit是最初启动的程序，必然是静态程序，用ldd不会看到有关联的动态库。其它的程序都是由它fork之后运行的。Linux的0号进程是Idle，不过ps不会显示它。传统Unix系PID为1的程序是/sbin/init，也可以是个指向其它程序的软链接，到了Linux则支持向内核传参来改变启动程序。随着开机启动服务越来越多，出于对速度的追求,init也演化出了很多派别（我的cent7启动耗时为2.098s kernel + 7.568s initrd + 15.753s userspace 总计 25.420s）。wiki把归于Service Management，有两大类：\n\n# 可移植实现：目前还活跃开发的只有OpenRC（Gentoo主导），其它runit和initng似乎已经停止很久了。\n# 系统专属实现：Linux有Systemd和Upstart，Mac是lauchd\n\nVoid使用runit\n\ninit指向runit-init，负责启动器，还自带简单的一套sv/runsv服务管理程序。\n\nAlpine 使用OpenRC\n\n> init是指向busybox的软链接，而后由openrc-run程序引导，可见两者是分离的，是为可移植。/etc/init.d/目录下平铺着所有的服务，3.7版的AlpineLinux，会偶现启动时chrony非常耗时问题，要禁止chronyd，直接把文件移走就可以了。程序运行稳定后，用pgrep无法找出openrc相关的进程，不确定是不是运行完就退出了。\n\nCentOS 7.x 使用Systemd。（6.x及以前使用传统的/sbin/init）\n\n> init指向/usr/lib/systemd/systemd，同时也控制启动服务的顺序和依赖关系，是结合式的。而/etc/init.d/目录指向rc.d/init.d，又根据runlevel分了数个目录，要复杂得多。\n\nPID从2开始的前几个程序都是kthreadd/ksoftirqd/kworker/migration/md/watchdog/crypto等，都是Linux必须要启动的服务。\n\nLinux和FreeBSD的ps都会把无法获取args的进程（通常是内核线程）标记上方括号，用ps auxfc可以看到这些进程间的父子关系。而OpenBSD不会显示带括号的进程。\n\n!!! OpenBSD\n\nBSD系的init都是独立的可执行程序，大小分别是1M和300K，启动脚本都在/etc/rc.d，没看到init.d。但也有不同，比如FreeBSD，PID为0的进程叫kernel，Idle是11号，2之后的进程名也是内核进程，而OpenBSD却看不到2之后的进程。\n\nBSD风格的init和传统的Unix风格或者叫SysV不一样，最显式的差异在于读的文件是/etc/rc文件，传统的SysV读取/etc/inittab文件，现在Linux中用的比较多的是systemd方式，不过这个程序使用了cgroup和fanotify方式，导致无法迁移到BSD系统。\n\n程序只有一个C语言文件，非常干净。真正业务开始是个非常有趣的循环\n\n```\ntransition(state_t s)\n{\n\tfor (;;)\n\t\ts = (*state_funcs[s])();\n}\n```\n\n通过给定一个s的初始值，确定一个初始函数，通过这个函数返回下一个状态，又会进入下一个函数，如果反复恰如完整的状态机在运转。\n\n默认的循环共有三重，`runcom->read_ttys->multi_user`，第一个runcom就是读入/etc/rc脚本，这也是rc这个文件名的由来。\n\n最后一个multiuser阶段就是做了waitpid操作,对每个waitpid返回的进程号，会尝试从RB树中找对应的session，因为unix有远程登陆概念，登陆的上岸点则是tty，每次的登陆就是一个session。如果没有就结束了，如果还有session需要清空会话的日志并从RB树中去掉这个节点。login/logout是BSD的系统函数，会操作/var/log/wtmp和var/run/utmp文件，并记录登陆的用户名。还会用到utmp.h的头文件，根据man的描述，是用于login record。正因为有这些文件，用who命令才能实现。\n\ninit的程序体现了很多login/logout/tty的概念，因为Unix在出现的时代就是用于远程访问的，只是当时访问的介质不是网线，而是电传打字的设备。因为只是介质不同，和网络访问的概念是相通的。程序本身是静态的，一旦运行起来就要归属到session，通过login/logout来创建和销毁session。常规的login一定是由物理硬件发起，这个硬件就被抽象成tty。除了远程登陆的session，也存在fork出的程序，这些程序可以在同一个session，也可以另起一个会话，如果要新建会话，就用setsid()函数。init程序所属的会话，并没有谁主动来login，只能通过setlogin(\"root\")方式手动指定会话所属用户。每个会话只能有一个login name。","modified":"20180809121530000","tags":"os"},
{"created":"20180209121530000","title":"查询协议与资源回收","text":"\n遇到一个查询业务资源未回收的问题。查询的返回数量不确定，因此会有同步和异步的方式考虑有两种返回形式。如果是异步，在查询前传入一个回调函数，所有的查询结果逐步回调给调用方。如果同步方式，由查询方每次给出一个偏移量和一次查询的数量，逐步地查完。这次的问题就出在同步方式上。\n\n由于是个连续的过程，第一次查询会返回一个句柄号，接下来的查询每次都从这个句柄获取，查询完成后释放该句柄。暂不考虑客户端恶意查询而不释放的问题，当网络断开时，也会存在句柄未关闭从而导致资源泄露问题。原因在于定义查询接口时，和其它的业务定义在同一个类里，而所有的类要服务化，都以单件的形式存在，当网络断开时即使协议库调用了析构函数，实现侧无法做到查询句柄的回收。\n\n服务化和单件不是错，但对这类存在资源分配的业务，把接口都定义在单件中，就使得单件拥有了两种不同生命周期的业务，增加了维护的复杂度，这种情况要避免。","modified":"20180209121530000","tags":"protocol"},
{"created":"20160424121530000","title":"程序的被集成性","text":"\n算是一点杂想吧。起因是调试一个bug引起的。\n\n公司产品的通信协议一直都是明文，为了达到安全审计的要求，就对信令做了RSA+AES的加密，虽然达到了安全的要求，可是对开发来说再也不能抓包看到数据，调试就很不方便了。组里的同事在转岗前做了一个小工具，但我也一直没关心过这一块，这次重新提起这事，却发现解密小工具不能用了。好在向已经转岗的同事要到了小工具的源码，源码是用MFC写的，我以前一直没有好好学过MFC，也不知道该怎么下手，决定还是从源码中，把GUI之外的解密部分，做成个命令程序，先把问题解决了再看。\n\n还好解密和GUI部分代码是分开的，写了命令行的wrap，跟踪后很快就发现问题，是个Base64反解后长度处理不对，没有对齐到16的倍数，导致无法进入AES解密流程。可能当时测试的时候用例正好没触发，也没现这个问题。改了长度，在命令行下面很快就调试通过了。于是我把修改的两处代码给了另一个同事，让他重新编译一个MFC程序，却不知道什么原因在MFC下一直失败。我和同事聊了下，既然解密部分和GUI已经分离，那就不用MFC做界面，自己重新写一个好了。事实证明，我和同事各自用Lua和Python重写一个界面，工作量的确不大。\n\n这里的问题就在于，解密的接口原来是用C++写的，在MFC程序里，这种做法没有问题，但要整合到其它语言时，C++就非常地困难了，这次因为只有一个接口，改写成C并导出成dll的改动量不大，但如果有大量的接口都是用C++写成，恐怕做Wrap也是件很烦燥的事情。我们写软件，通常都是先集成其它人的库，然后能力到了，自己做的东西也期望能被集成，在被集成这一点上，C是当之无愧的王者。从接口的封装性上来说，C++并没有比C抽象得更高，'.'语法的调用，也只是把this指针从函数的第一个参数移到了函数的前面，仅仅是一个写法上的差异，Go的语法就很清楚地体现了这一点。但这种风格却很难更广泛地被各种语言所兼容，再加上更花样繁多的参数重载、默认参数，却没有一个统一的二进制规范，也使得各种语言最终选择了虽然简陋却也朴实无华的C作为约定。C语言的规范进化了好几版，似乎也没有引入甚至以后也不会引入参数重载、默认参数这样的机制。\n\n写一个小工具，按我的个人偏好，也是先有个命令行（或者有相同入出参格式的so/dll），然后基于此做个GUI的Wrap。但做Windows开发的人来说，似乎这种做法也显得老土，这大约也是习惯使然，至少*nix系下，先有命令行，再有GUI的传统现在依然保留着。","modified":"20160424121530000","tags":"design"},
{"created":"20190220121530000","title":"程序语言的依赖包管理","text":"\n没有人可以写从到尾写完一个程序，除了内核这种项目，多都需要依赖其它库或源码，解决依赖也成了各种语言的基本功。又细分了两个需求：全局的包管理和项目级的包管理，不同的语言支持程度各不相同。\n\n!! JS\n\nnpm是Node.js的首选模块依赖管理工具，仓库npm config get/set registry修改成国内的镜像http://registry.npm.taobao.org/。有本地和全局两种安装模式。\n\n* 本地模式: 在当前目录创建 package.json 文件来描述模块的依赖，在这个文件里你可以定义你的应用名称( name )、应用描述( description )、关键字( keywords )、版本号( version )等。npm会下载当前项目依赖模块到项目中一个叫做node_modules的文件夹内。\n* 全局模式: 惟一的区别就是 install 命令后多了 -g 选项。安装到 prefix 目录的node_modules文件夹。但有一点不同，全局安装的依赖在主入口目录内，而本地则是平铺开。举个例子\n\nnpm的2.x版本采用嵌套式依赖方案，适合某个依赖在一个项目中多版本并存的问题，比如node；而3.x则换成扁平化的方式，更适合前端。npm的依赖可以指定版本区间，锁定，任意版本都支持。\n\n安装A库，A依赖B。如果是本地安装，node_modules下有 A 和 B 两个目录。但是如果是全局安装，node_modules只有A目录，A目录内又有node_modules，在这个嵌套子目录内会有B目录。\n\n对node来说，require的参数如果是核心模块，不会搜索磁盘目录直接加载核心模块，如果不在核心列表内，就会在路径后依次用找package.json的main字段/.js/.json/.node方式寻找，找到第一个文件停止搜索，且npm还有缓存机制，如果在缓存中就不会重复加载。\n\n与maven/gradle不同的是，maven最终会分析依赖树，把相同的软件默认扁平化取最高版本。而npm支持nested dependency tree。nested dependency tree是每个模块依赖自己目录下node_modules中的模块，这样能避免了依赖冲突, 但耗费了更多的空间和时间。由于Javascript是源码发布，所以开发态与运行态的依赖都是基于npm，优先从自己的node_modules搜索依赖的模块。\n\n!! Lua\n\nrocks安装时要指定属于全局、个人或项目。\n\n!! Python\n\npip只有全局模式，不支持项目级别定制包。默认放在python的lib/site-package目录，两个目录或是一个文件加一个目录（一个是执行模块或包，一个是描述元数据）。比如安装jedi包，成功后会有一个名为jedi的目录，还有一个jedi-0.16.0.dist-info目录。jedi目录放py代码，而带版本号的目录则放requires.txt、SOURCE.txt、PKG-INFO等元数据文件，依赖关系就记录在requires.txt里。将这两个文件以zip方式压缩，就是wheel包。\n\n!! PHP\n\n出现较早的pear只支持全局下载包，后出现composer称自己是依赖管理器（也支持pear的包模式），可以在全局或项目中管理包更新，另外还自带PSR4的加载规范。\n\n!! Java\n\n没有全局包的概念，只能在项目层面用pom.xml来控制版本，指定的版本号必须精确匹配，又走到了另一个极端。如果仓库没有想要的版本，就失败了不能模糊匹配。\n\n开发态，可以通过maven和gradle工具编辑依赖清单列表/脚本，指定依赖库的位置/版本等信息，这些可以帮助你在合适的时间将项目固化到一个可随时随地重复编译发布的状态。这些工具对我来说已经足够优雅有效。但maven中也有不同依赖库的内部依赖版本冲突等令人心烦的问题。尤其是在大型项目中的依赖传递问题，若团队成员对maven机制没有足够了解下，依赖scope的滥用，会让整个项目工程的依赖树变得特别的巨大而每次编译效率低下。运行态，目前Java也没有很好的依赖管理机制，虽有classloader可以做一定的隔离，但像OSGi那种严格的版本管理，会让使用者陷入多版本相互冲突的泥潭。\n\n展开说说maven，可以理解为Makefile的网络版，得益于java原生的网络支持，远程仓库的jar包和本地/lib下的so在软件层面等效。lifecycle由多个阶段(插件)构成，类似的也有clean, test, compile等目标，不同的是只能输出一种目标，package输出到当前工程，install进一步写入本地仓库，可以给其它工程链接，deploy多一步发布到远程仓库，给其他人用。\n\n!! C语言\n\n最多的还是Makefile，但和其它语言比，只能说是半残。接口头文件和库之间没法校验匹配性，也不容易指定库的版本。链接时通常是指定库名称，到底指向哪个库，只能听由操作系统的软链接。所以现在的发行版在.so后面还会跟一个数字，形成类似.so.2这样的文件名，如果出现重大不兼容，可以指定大版本。\n\n!! 语义化semver\n\n开源产品的迭代难免引入不兼容修改，通过目前社区都认同的语义化版本方案，依赖时必须要限定版本号，否则大版本升级就无可挽回了。npm有`~`和`^`两种标识符，比较体现版本依赖的思想。\n\n* `~`，tilde range。只接收bugfix，不会改功能版本，可以理解为约等号。比如`~1.2.0`，即使上游开发了1.3或1.4，仍停留在1.2.z的最后一个版本。是早期npm的默认策略，也是比较稳健的策略。\n* `^`，caret range。只要保证兼容性，尽量往新了更，会保证左侧第一个非零值不动。比如`^1.2.0`会追踪上游的1.3.x，但是`^0.2.0`则会停留在0.2.x，因为左侧第一个非零是2，必须保证不变。这大概是语义化版本对0的理解有不稳定的意思，所以稳妥起见遇到0选择跳过。\n\n我倒觉得都用`1.*`这种方式表达依赖，更少学习成本，也更直观。","modified":"20190220121530000","tags":"lang"},
{"created":"20170826121530000","title":"处理权限校验问题的反思","text":"\n公司产品的权限校验问题做了半年，前期我没有参与，最近因为人员调整所以换我来继续处理。说实话对于嵌入式产品却有多达6、70种权限的历史遗留问题，我很不认同。我觉得Onvif的权限模型把用户固定地划分到3个组，同时定义了几个固定的权限等级，语义清晰且一致性也很好。\n\n经过上半年的处理，总算把6、70种权限归约到15种权限，结果产品又开始不停地提增加权限需求，我本来想限制权限种类不允许扩充，想想这样做在理论上站不住脚，还是要思考权限问题真正重要的根本约束(出发点)是什么，以及要达成的归约状态又是什么。\n\n约束点就是每次的请求都需要权限校验。但是仅仅这样，就又会发散成不同产品各自定义权限，导致同一个请求却有五花八门的权限定义。甚至更加粗暴直接的是把权限和Web界面绑定。于是就出现今天开发提交给我的，增加一种日程这个请求的权限甚至包括了存储权限和编码权限，原因就是产品的惯性思维，因为录像和动检界面可以增加日程，所以增加日程的权限也要涵盖存储和编码。这类错误根本不值得讨论。\n\n不同的嵌入式产品最终归约到统一客户端来展现，为了达成操作的最终的一致性，有必要限制权限和请求的关系。权限涉及安全产品线、产品线、协议模块和客户端，各自有各自的诉求，初步设想的处理基调是这样。\n\n# 原则上每种请求都要有权限，但如果是非敏感信息的只读操作，可以不校验权限，需要知会到安全产品线。\n# 协议模块对每种请求默认只提供一种预先定义的权限，且这种权限就是展示在客户端上的权限定义。多种权限增加使用认知难度，在处理上歧义也很多。\n# 如果产品线不认同这种权限，可以定制请求的权限列表，配合产品的Web界面，可以满足产品需求，不过这样的产品在接入统一客户端时还是会显示异常，终究无法做到全面的平衡。","modified":"20170826121530000","tags":"protocol"},
{"created":"20180905121530000","title":"词法语法之后","text":"\n以前写过3篇词法语法工具使用的记录，对完整的编译过程来说，后面的代码生成和执行却一直忽略了。\n\n如果只是写计算器，到语法生成勉强还够用。但要想支持分支，函数定义、调用等，\n复杂性就真正体现出来了。\n\n为了引入函数，必须把解析分为定义态和执行态。从函数定义开始到结束，要做代码生成。其它情况则取指令执行，是两个完全不同的处理，可以加标志位控制，也可以决定是否允许嵌套函数定义，简单起见可以先禁止。\n\n要保存函数定义，就要有一套指令码和虚拟机来执行。指令可以不必多，但基本的Load/Save/Cmp/Jmp/Call是不可少的。从Load/Save又可以分为基于栈和基于寄存器两大流派。\n\n构建指令集，先确定用定长或变长，基于栈还是寄存器。以定长寄存器为例：将若干bit位解码为指令，指令一旦确定，剩下bit位的操作数的解析方式就随之确定了。不同指令需要的数是不同的，1到3个都有可能，所以操作数的解析并不固定。使用拉掩码方式分别提取对应位数构成数据。\n\n指令集除了表示做什么外，寄存器和立即数都是用索引号代替，所有的寄存器用栈形式分配，立即数要有常量池来存储和索引。如果不允许函数内嵌套定义函数，指令集+常量池这种模式就足以表示了。如果允许嵌套定义，要函数原型内递归地存储，难的是要处理upvalue。反观C语言，既不允许嵌套定义，最外层只能是main函数为入口，实现就相对简单而纯粹了。\n\n有了指令集，还必须记住当前的指令执行位置，IP指针，在Lua中用savedpc变量保存。取指令用`*(savedpc++)`，执行当前指令时，IP指针已经向前走了一步。IP指针和函数在全局栈上的位置共同构成一个函数的必备元素。\n\n指令通常顺序执行，加上比较和跳转后，就能实现分支和循环，跳转步数需要一些技巧获得。\n\n指令，变量环境，常量环境，这3者构成函数原型的全部，运行时再将常量加载到变量。也可以将常量全部做成伪变量，只是写代码会非常繁琐。","modified":"20180905121530000","tags":"lang"},
{"created":"20170604121530000","title":"从串口功能的封装看如何抽象","text":"\n串口并不是不可分割的一体，就好像网络socket的TCP和UDP是差异巨大的两个类别，232和485的差别也是非常之大。之所以会混为一谈，只是对它了解不够，所以必须区别对待。\n\n232串口有点类似TCP，类似虚电路的点到点连接，且一个串口只能连接一个设备。而485串口则类似UDP，一条总线挂载多台设备，以类似广播方式发送消息。从硬件层面(PAL)抽象无非就是把一个串口作为一个对象，把设置串口属性、读、写都作为独立接口，这无可厚非，但应用层如果也只是简单封装，232可能没问题，485则会有严重不足。\n\n设想485上挂的两台设备使用的波特率、奇偶位都不相同，但又因为硬件限制要共用一个硬件，每次发送消息前都要先设置串口属性再发送，如果是等待结果的消息，还必须等待读返回。三步操作如果任何一个被其它线程从中切入都会造成数据异常。因此485串口属性设置和读写必须是原子化的，应用层的操作接口要基于硬件层原始接口封装,而且PAL要提供锁接口才能保证不同上层使用同一把锁。\n\n综上，485串口比较理想的抽象应该是PAL层提供原子化的设置/读/写接口，并提供接口间的锁。应用层基于这些基础设施，提供更高一级的设置写读一体化接口，才能满足一个串口接不同设备的通信需求。","modified":"20170604121530000","tags":"design"},
{"created":"20170526121530000","title":"从ifconfig接口看网卡","text":"\nifconfig显示的除了网卡，还有网桥bridge，因为if表示接口，没有限定必须是网卡。\n\nip命令比ifconfig显示的网卡数量多一些，ip能显示的网卡，都在/proc/net/dev里保存着。\n\nip区分了link和address命令，link显示的接口，会显示出attach到ether/loopback/ipip。address显示的是link的超集，有些网卡有多地址，用link只有一条，而address就会把所有的地址都显示出来。\n\n!! 网络工具包的变迁\n\nifconfig/route/netstat/arp/rarp等网络管理经典软件（属于net-tools包），起源于BSD TCP/IP工具箱，旨在配置老式Linux内核的网络功能。自2001年以后，它在Linux社区的发展就止步不前，很多发行版默认不安装该包，甚至有弃用net-tools的打算，改而使用iproute2替代。net-tools通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置，而iproute2则通过netlink协议与内核通讯（这套协议和unix域套接字、inet在同一层级）。由于netlink是Linux独有，BSD社区依然使用net-tools工具。\n\n网卡的模式在if.h定义，有十多种。这些状态大多是可以组合，少数互斥(环回LOOPBACK，bond的MASTER/SLAVE)。说几个可能不那么常见的\n\n* LOWER\\_UP：注释表明Driver signals L1 up (since Linux 2.6.17)，是物理层的标志。LOWER\\_UP表示以太网线已插入，并且设备接入到网络。而UP在LOWER\\_UP的基础上，还要求网卡使能（个人理解是被ifup）。\n* NO-CARRIER：可以和UP一起，但表示网络不通。可能的原因有：网线故障、无线未在SSID认证、驱动故障（极少数）。\n* NOARP：对于BORADCAST型网络（以太网或无线电packet radio），ARP标志默认打开，如果显示NOARP则表示ARP被禁用，可能是网络形态不同，也可能确实遇到故障。\n* PROMISC: 混杂模式，接受目的MAC不是本网卡的包。抓包软件和虚拟网卡会用到。\n\nifconfig会显示发送和收到的包数据，单位多见MiB，这个单位表示2^20，在1998年12月定义的ISO/IEC80000规范里可查，同一家族有kibi, mebi, gibi, tebi, pebi, exbi, zebi, yobi，i取自binary的第2个字母，所以这些单位都用bi后缀。而平时常见的MB往往会视场景，可能是10^6，也可能是2^20。以精确而言，MiB是更好的写法。\n\nRX和TX的包数据里，会另外显示5种异常状态的数据（frame和carrier是单向）\n\n* Errors: The total number of transmit or receive errors detected by the device driver.\n* Dropped: The total number of packets dropped by the device driver.\n* Overruns: 驱动拿到的包，会放到内核的Ring Buffer（FIFO队列），如果网络流量过大超过CPU处理速度，就会导致overrun。ethtool -g查看，ethtool -G修改参数。\n* Frame: 收包特有，一般表示收到的帧过小或过大，比如不符合8bit的帧。\n* Carrier: 发包特有，carrier原意是调制用的载波，此处表示因载波异常或不匹配导致数据发不出去。\n\n!! Linux与BSD的网卡差异\n\nLinux下的网卡只有lo和eth两张，但是OpenBSD还额外多两张虚拟网卡，enc和pflog。这两张网卡都是基于pf而存在，因此也就好理解为什么是OpenBSD特有的网卡。\n\nenc和ipsec特性配套，pflog则是pf log的简写。IPSec有四大特点：\n\n# 数据加密\n# 内容完整\n# 身份认证\n# 防重放攻击\n\nIPSec有两个协议族，ESP(Encapsulating Security Payload)和AH(Authentication Header)，差异在于\n\n* ESP具备以上四条特性，但只对IP的负载生效，不保证IP头的安全\n* AH重心在认证，因此缺少数据加密功能，但它能保护IP头\n\n如果要让socket启用IPSec，OpenBSD的netinet/in.h下定义了很多IPSec的宏，如`IP_AUTH_LEVEL/IP_ESP_TRANS_LEVEL/IP_ESP_NETWORK_LEVEL`以及`IPSEC_`开头的很多宏，可惜这些并不跨平台，Linux系统定义在linux/ipsec.h中，且是通过枚举方式，数量也没有OpenBSD详细。\n\n从默认网卡的配置和头文件定义就能看出，OpenBSD的确是在践行着最安全操作系统的理念。\n\n!! bond网卡制作\n\n服务器通常有多张网卡，要求配置为bond模式，对cent系来说，并不用特殊的命令，只要添加一个ifcfg-bond0的纯文本文件，重新启动网络服务就好。\n\n展开了说，bond是由普通eth网卡组成，同时修改那几个ifcfg-eth的文本，使它们映射到bond，而所有的IP，网关，掩码都在bond配置。似乎还要启动一个内核模块，具体原因不明。\n","modified":"20170526121530000","tags":"net"},
{"created":"20170620121530000","title":"从Javascript函数类型理解计算和对象","text":"\n对任何程序语言来说，函数的设计是最核心的特质，函数涉及的变量作用域、参数的值和引用语义这些基础概念体现了语言设计的核心价值。JS的原则是一切皆对象，typeof null的结果是Object，自然function也是对象。定义一个function foo变量，可以用foo.xxx语法取成员变量。原因是凡是对象都可以用点号来索引成员，既然foo是函数（对象），当然也可以用点号语法。\n\nJS的对象可以和Lua元素的`__call`元方法或者`C++`的operator()比较。由于JS的函数是对象，因此可以用`.`符号从对象中索引成员，这就是[].push.apply这种神奇语法的来由。这里的两个点号分两段理解，第一个点从[]这个空的数组对象中取到push方法，第二个点从push方法提取apply方法。注意push是函数，但同时也是对象，因为函数对象有apply成员，所以可以从push索引到apply。\n\n以上这几种语言中，函数可以认为是一种拥有计算能力的对象，而计算则是在一个有限的环境下进行变量操作。对JS来说，环境就是this变量，对Lua则是`_ENV`。换句话说把`C++`成员函数的第一个this参数理解成环境，也未尝不可。这一点从MuJS的C接口`js_call`必须先压入一个this参数可以体现出来。\n\n!! prototype和constructor\n\nJS的对象体系最大特色是原型和constructor。记住一个概念，JS的12种类型里，所有变量都有隐式原型`__proto__`，只有Function类型才有显式prototype，由于prototype是Object类型对象，所以它只有`__proto__`属性。\n\n通过new Function获得的值，如果不是Function，就不会有prototype，只有隐式的`__proto__`，且指向Function的prototype。这样做的目的是维持继承体系。用代码展示更直观：\n\n```\nvar obj = new afunc()\nobj.__proto__ === afunc.prototype    // 非函数类型的值没有prototype，但会有个隐式的变量指向其构造者的原型\n```\n\nconstructor也是函数衍生出的概念，只有函数和prototype指向的对象才有constructor。用function foo()定义一个函数，foo.constructor指向Function()，而foo.prototype.constructor指向foo，这是两个不同的对象，要注意区分。new一个构造函数在MuJS通过专用的`js_constructor`语法来调用，和`js_call`惟一的差异就是少了压入this这步操作。\n\n任何函数都可以作为构造函数被使用，考虑new的语义是先创建一个空的对象，把这个函数中涉及this的语句操作，作用在新创建出的空对象上。最后返回这个对象，因此return语句就自动失效了。","modified":"20170620121530000","tags":"lang"},
{"created":"20211115121530000","title":"搭建最小化的Linux系统","text":"\n有个很有名的发行版Linux From Scratch，非常地繁琐，我们可以从一个近似的形态去一窥究竟，也从中了解很多和二进制执行相关的内容。\n\n看过toybox作者给aboriginal写的介绍可知，最小化的系统只要具备4个文件就可以运行：linux、toybox、musl、tcc。linux作为内核没什么要说的，其它3个值得一说\n\n* toybox: 另一个同样定位但更强的软件是busybox，这几乎是惟一的应用层全静态链接软件，不依赖libc，只要选对CPU指令集，就可以在主机工作。为什么全静态链接如此重要，稍后解释\n* musl: 虽然看起来只是个C库，但同时它也是个动态加载器\n* tcc: 编译器自然是少不了的，在编译的时候可以指定interp的路径，可以适配不同系统的动态加载器名\n\n极简环境可以从Android的终端开始进行模拟，首先在这个终端中放入busybox，至少具备了各种操作能力。\n\n!! 遇到的问题\n\n在低版本安卓编译的程序，到版本7后，因为要求可执行程序必须用*-fPIE*方式编译，通常动态库为了动态加载到多个不同进程，都会添加-fPIC标记，但执行程序本身是独立的虚假内存空间，可能出于安全的考虑吧，不是PIE编译的话就不能运行了。","modified":"20211115121530000","tags":"os"},
{"created":"20221122121530000","title":"打包软件的故事","text":"\n起因是想解压rpm和deb包，发现并不是zip压缩，rpm需要rpm2cpio工具转成cpio做进一步处理，而deb要用ar x命令解压得到内容。cpio和ar都不是最常见的打包软件，于是诱发我去了解背后的原委。\n\n最为人熟知的打包软件应该是tar了，有史可查最早在1978年随着system 7发布，后来也搭载在III和V以及BSD一起发布。tar会递归地遍历目录然后打包，这个递归动作不能取消，由于命令行操作的便利性，tar成了最流行的打包工具。tar有很多变体，支持的格式不尽相同，后来出了POSIX规范，至少我没有遇到需要特定版本的tar才能解析的问题。\n\ncpio是copy in copy out的简称，不支持递归查找源始文件，所以不适合命令行，通常提供文件清单或配合find一起用。常见的似乎只有rpm和initrd会用cpio方式。\n\n如果说tar和cpio还算打包软件，ar则更多的归属到编译体系。ar最常见的用法，是把多个.o文件合并成.a，并用ranlib给.a添加符号索引，进而加快链接速度。具备把多文件合并的功能，更偏向cpio的定位。把deb文件解开后，得到数个tar文件，不明白为什么会选择这种方式。","modified":"20221122121530000","tags":"os"},
{"created":"20160930121530000","title":"大华设备协议兼容策略说明","text":"\n大华设备在发展的过程中，产生了二代和三代两套协议。\n三代协议使用前期由于缺乏管控，同样功能的三代协议会有不同的表现形式，\n(比如摄像头属性的配置)。且在不同产品线间使用也不一致。\n另外同样功能也存在三代协议和二代协议的冗余，\n曾经试图不再使用二代协议，但从市场接受度和技术角度两方面看，\n这种作法既不可行，也没有必要。\n但是存在多套协议的混乱局面，必须要明确协议与业务功能的对应关系，\n本文档定义两套协议的适用场景、及如何选择的原则。\n\n!! 二、三代协议的使用总原则\n\n先来简单看看两套协议的特性：\n\n* 二代协议：所有设备都支持，但协议为二进制，Web无法使用\n* 三代协议：协议扩展性好，支撑业务迅速\n\n综上协议总原则：SDK的基础业务使用二代协议，扩展业务则使用三代协议。\nWeb全部使用三代协议。\n\n!! 登陆协议\n\n* SDK -- 0xA0\n* Web -- global.login\n\n登陆协议作为使用设备的第一步，基础性不言而喻。\n由于二代和三代协议有各自的登陆协议，\n但是一台设备显然只需要一种登陆协议就够了，\n综合考虑设备使用面、协议扩展性，NetSDK使用二代协议作为设备的登陆协议。\n设备保留三代登陆协议给Web使用。\n\n!! 音视频类协议\n\n作为一个监控厂商，视频是基础功能。音视频部分包含流的获取、\n音视频参数设置、语音对讲等功能。\n\n!!! 媒体流协议\n\n* SDK -- 0xF4\n* Web -- RTSP(前端)/0xF4(存储)\n\n视频流协议有三种，其中二代支持静态多连接和动态多连接两种，\n同时三代协议也有部分产品线在使用。\n从协议使用的覆盖面和演进方向综合评估，\nNetSDK使用二代的动态多连接协议，即0xF4作为未来的支持重点。\n使用登陆返回的版本号是否为6，来区分设备是否支持动态多连接。\n\n!!! 摄像头属性(SDK/Web使用相同协议)\n\n* 如果产品定义包含CameraAttribute，则使用VideoInXX配置族\n* 如果产品定义不包含，则使用VideoInOptions/VideoInPreviewOptions配置\n\n!!! 通道标题\n\n* SDK -- 0xA8\n* Web -- VideoIn/ChannelTitle\n\n!! 存储类协议\n\n设备通常都带有一定的存储介质，比如相机的SD卡或者存储类设备带硬盘，\n这部分涉及的协议，主要包括管理这些介质，或者查找存储介质上的录像/图片。\n其中尤其以查找录像/图片最为重要。磁盘管理对于运维平台来说，也有很大的价值。\n\n!!! 录像查询\n\n* SDK -- 0xF6 or 0xA5\n* Web -- MediaFileFind.xxx\n\nSDK通过0xA4查询设备的返回，如果xxx，则支持0xF6，否则使用0xA5。\n\n!! 外设功能\n\n!!! 云台控制\n* SDK -- 0x12(基础)+0xF6/Json(扩展)\n* Web -- Json Over HTTP\n\n!!! 事件上报\n\n* SDK -- 0x68/0x69+0xF6\n* Web -- 如何保持长连接？\n\n!! 网络功能\n\n包括有线、无线网卡的管理\n\n!! 用户管理\n\n* SDK -- 0xA6\n* Web -- UserManager.xxx\n","modified":"20160930121530000","tags":"protocol"},
{"created":"20181121121530000","title":"大华视频云框架","text":"\nPaaS/IaaS八大服务群\n\n* 容器\n* 云存储\n* 云数据库/数仓\n* 挖掘/图数据库\n* 图像识别，智能分析\n* 视频/接入\n* 中间件\n* 运维\n\n中间件，视频，运维必须，其它都是选配。\n\n分布式带来的变化\n\n# 网络复杂化，双网多网，网闸摆渡\n# 消息传递不确定，真RPC，事件中心MQ由嵌入式组件的CPU敏感，变为内存敏感\n# 服务的注册，发现，调用。没有嵌入式有一个全局的工厂map，职责由运维承担，安装时将各服务的地址配置到各处。\n\n接入，云存储，数据库，挖掘是重点。转发，消息推送是伪需求。2B的业务，数据是核心，分发和消费并不重要。数据包括视频，图片，结构化，报警共四大类，减少视频，增强结构化间的关联，分析报警的规律，才真正把数据用好。\n\n!! 三大服务群\n\nPaaS、SaaS、统一运维是整个产品的三大集群。一体机产品由于是打包在一起，看不出之间的关系。三者目的是不同，部署完全可以分开。\n\nPaaS管理物理资源，比如设备、硬盘存储、数据库等。它有3大块内场，管理节点、子节点、鉴权中心。因为要管理的数据多，管理节点和子节点的区分就成了必要。\n\nSaaS管理用户的业务数据，比如设备的点位分布、用户部门、录像计划等，数据往往是中心化的，最多就是主备，不存在主从概念。\n\n统一运维则是整体上辅助PaaS资源管理，并将PaaS和SaaS做一定程度上的隔离。安装整个系统的第一步，就是先装运维，虽然它本身不管理资源，但所有PaaS管理节点都被运维接收。而SaaS要找到资源，也会委托运维去查找。如果一个SaaS业务平台有多个机房(相当于多个PaaS)，这些PaaS间的是否有故障，故障时的迁移方式也都有赖于运维通知给SaaS。","modified":"20181121121530000","tags":"design"},
{"created":"20200509121530000","title":"代码写法中的状态与异常","text":"\n最近在做构造数据的工作，代码是另两人写的python，在改造过程中，修正了我以往对对象和异常的认识。\n\n以前写代码既不爱用类和对象，也不用异常捕获，这次造数据的代码全部是定义各种函数和调用，用法不复杂。但造数据的需求很多，从而就导致函数参数非常多，写起来代码非常啰嗦。参数多的另一个坏处是在多处调用时，不容易一致。\n\n!! 有状态的执行体\n\n构造表数据需要带入参数，但是这个数据其实是和函数绑定的，完全可以合并到一起，用闭包或对象来表达。函数式推崇无状态，但我不确定闭包是否为函数式所接受，但在具体的工作中，带状态的可执行体是非常有用的。\n\n!! 使用异常\n\n有些表数据的构造有依赖关系，如果前置表没有被构造，这张表就不应该被构造。这时有两个选择：\n\n# 隐式构造被依赖项\n# 返回错误或抛异常\n\n开始想隐式构造，动态构造函数在main函数中被sys.argv给绑定了，于是转而返回错误，至少显示提示也不失为一种选择。如果返回错误，由于表很多，代码会显得非常啰嗦，所以想到用异常。异常有个好处，具备穿透性，不管层级多深，可以直接穿过多层直到被捕获的地方，另外异常还必须要能携带值，否则只有异常类型，捕获了也无法进一步处理。python3的异常语法和2不兼容，似乎只能带str类型的变量，于是通过这条路径，把缺失的表名用异常抛出来，在main函数中显式地补上。\n\n反思这次的代码修改，以往偏好理论派的东西其实在实际工作中并不能很好地应对。以我现在的状况，也不可能在理论上有太多的造诣，让更多实际的代码能写得优雅，利用好常见语言的特性，更为重要和实际。\n\n!! 模拟的隐患\n\nPython的异常没有ruby的retry机制，为了模拟在try块的外围加了一层while循环，并在except里用count计数累加，保证重试N次后能退出。但过了一段时间，又加了一个种异常捕获，这里忘记对count累加，导致循环无法退出。模拟的方式终归只是权宜之计，最好的办法仍是以DSL配套完整的机制才可行。","modified":"20200509121530000","tags":"lang"},
{"created":"20170608121530000","title":"灯光和相机差异的关联和协议需求","text":"\n不同相机对灯光的需求差异很大，交通相机、普通IPC、球式相机都有各自的特点。\n\n比如交通相机工作重点在于车牌抓拍，最主要的就是如何把车牌拍清晰，重在静态的图片而不是视频，另外车牌和相机的距离必须在一个固定值，否则拍出来的照片内车牌尺寸就不合适。基于此，交通相机补光的范围只要保证在一个固定范围能恰好能打亮就行，加上车牌必须是彩色，只能用白光灯，红外灯是没有价值的。因此交通相机的补光灯有频闪、爆闪和常亮三种灯，频闪和爆闪更是只追求瞬间亮度，保证这一时刻车牌清晰就足够了。\n\n球机除了旋转功能，缩放也是一大亮点。目前球机的比拼很大一块也投入了比谁看得更远。30倍甚至40倍变焦都已出现。所以球机的指标里距离是很重要的。为了配合距离灯光也有近中远的区分。而灯光又分为红外、白光、激光。红外主要用于晚上距离可以达到几百米，白光可以照亮但距离也短得多，往往只有几十米。\n\nIPC主要使用场景是室内，一般只配备红外灯，和IPC体积小散热结构有关，白光的热能比红外更大。\n\n可见仅仅是补光一项，必须根据不同相机的使用场景搭配适当的灯光。\n\n灯光差异这么大，灯光协议也很容易入坑。比如球机的灯光配置要从全时扩展成分时，就怎么修改都无法满足。\n\n最初的灯光协议只说明是补光，未说明是红外还是白光。了解到原来球机因为只有一种灯，如果是复合灯则用另一套配置。虽然暂时解决了问题，但Lighting配置的作用到底是夜视还是全彩，依然不确定。这是协议的第一个问题。教训，不要把一种配置作多种明显不同的用途。\n\n配置的形式是数组，但只用了第一维元素。不知道最初设计数组的目的是什么，然后需求来了，对不同的时间段要有不同的灯光配置。但问题又出在是否启用日夜模式并不在Lighting配置，就会出现A客户端修改了灯光模式，结果B客户端无论如何修改都无法成功。所以模式必须也在Lighting配置中。","modified":"20170608121530000","tags":"design"},
{"created":"20180801121530000","title":"电话协议的发展","text":"\n写这篇的起因，是确定了SIP协议更直观的翻译应该叫电话初始化协议。Session在IT领域是个很宽泛的词，只表示两者之间持续的一段互动。而话音业务却有很多的特殊性：\n\n# 双向交互。光这一条就干趴下当前互联网界最常用的HTTP/1.1，一个只能单向通信的协议。\n# 兼具信令和媒体流，而且媒体流非常在意实时性。\n\n很多业务虽然非常复杂，难于拆解，但承载的协议却非常简单，往往HTTP就足够。但话音业务却是业务非常容易理解，也不复杂，但对协议的要求却非常得高。\n\n贝尔(AT&T成立的贝尔实验室就是纪念他)在1876年发明了电话，从此话音业务就渐渐成为了很大的市场。从模拟线路时代以来，以1975年为分界点，之前是In-Band协议，最后一代是SS5(Signaling System 5)，在那之后发展出了Out-Band，并最终进化并定格在SS7。直到IP时代到来，SIP协议产生于1996年。也是沿着Out-Band的脉络发展。\n\nIn-Band时代，只有一条承载话音的模拟线路，为了解决在语音通道上发送号码，贝尔实验室在二战后发明了MF多频技术，定义5个频率，每次同时发出两种频率，一共能组成10种组合对应十个数字。基于MF，在1963年发展出了DTMF，至今仍在使用。在那之前的电话都是转盘式拨号，之后就是现在常见的按键式拨号。MF包括R2 Signaling，R1(仅北美)，SS5。由于把控制信号在语音通道上传输，1960年代，phone phreaking发明了blue box，最大的好处可以免费打长途电话。为了防御这种攻击，加上数字技术的成熟，Out-Band开始登上历史舞台。\n\nSIP使用了很多HTTP和SMTP的元素，形式上也非常相似。SIP首先从Internet发展起来，并被IETF承认，H.323系也是话音业务。两者从大的功能上都服务于电话，但设计思路却并不同，且H323兼容电信网络更好，所以ITU更偏好。","modified":"20180801121530000","tags":"protocol"},
{"created":"20170920121530000","title":"动态链接库与符号表","text":"\n起因是前天向吴惠敏请教gprofile的时候，这个工具要用.a库，不要用.so否则程序会挂掉，原因是gprofile的设计思想在20年前就已固化，而动态加载的重定位细节又经常变化，所以干脆gprofile就只支持静态库了。本篇不说gprofile，单说说动态链接库。内容并不会超出《程序员的自我修养》这本书，更多的还是个读书和操作记录。\n\n现在的Linux默认都用动态库，比如我最常用的CentOS，/lib/目录下几乎看不见.a库，gcc默认也找的是动态库(真实选项-Bdynamic)，除非用-static选项告诉ld只用静态库。(不过MinGW的gcc即使用了-Bdynamic，在静态和动态都存在的情况下依然会用静态库，原因不详)\n\n加载动态库是一段专门的程序，它和系统用的C语言库强关联，在不同的系统表现形式也不一样\n\n* CentOS(也是绝大多数Linux)：/lib/ld-2.xx.so 和 /lib/ld-linux-xx.so.2\n* Alphine(一个轻量级的Linux)：因为库体积的原因，使用了musl这个C库(libc.musl-xxx.so)，动态加载库和libc是合二为一都指向/lib/ld-musl-xxx.so.1\n* Aboriginal(一个更轻量的Linux)：使用uClibc库，动态链接/lib/ld-uClibc.so.0，从版本号看，libc、libm、libdl、libnsl、librt、libpthread、libcrypt、libresolv、libutil都在uClibc库的范围内\n* FreeBSD：/libexec/ld-elf.so\n* OpenBSD：/usr/libexec/ld.so\n\n其实Cent下ld-linux只是个指向ld.so的软链接，只是因为历史上ld.so处理a.out格式，ld-linux处理ELF格式，为了兼容名字一直保留到今天，其实程序是同一个。从FreeBSD的名字也可以看出，最初的名字叫ld.so，出现elf格式后，FreeBSD不再保留ld.so，全换成ld-elf.so了，但OpenBSD依然沿用。ld.so文件名在Linux中保留了版本号，我猜测这正是它和libc库强关联的证据，即根据编译时链接的libc库版本号，换算成对应的ld.so程序名，进而执行动态加载。\n\n动态加载必然涉及从遍历目录的过程，这必然涉及配置和更新目录集，虽然不同的系统配置名字不一样，Linux用ld.so.conf，而FreeBSD用libmap.conf，但最终都要通过ldconfig程序将配置转换成更高效率的格式，ldconfig和ldd最早都出现于SunOS 4.0，所以现在大家依然沿用这个名字。\n\n!! 符号表\n\nso文件有.symtab和.dynsym两种符号表，dynsym看名字就知道是动态，而symtab是normal又称regular符号。用strip只能去掉symtab，但是dynsym不能被删。\n\nnm默认找symtab，如果被strip会提示no symbol，加-D能显示。objdump的-T是同样功能。\n\n!! 动态库的版本规则\n\n使用GNU Autotools编译动态库会用到libtool工具，是对不同平台和编译器的封装，在编译前要指定三段式版本：current:revision:age。第一次发布时为0:0:0。这3个字段的变动规则是\n\n# 只要源码有变动，revision加1\n# 如果是兼容性扩充，current和age加1，revision归0\n# 如果不兼容改动，current加1，age和revision归0\n\n最终生成的版本号：(current-age).age.revision\n\n编译出的动态库通常有3个文件\n\n# libxx.so: 软链接，编译时用到\n# libxx.so.major: 软链接，运行时寻找so一般都会锁死major，这个值不匹配会报加载失败\n# libxx.so.major.age.fix: 按以上规则生成的完整版本号，age表示接口有过多少次兼容性增加，fix表示代码修改次数\n\n有时虽然major能匹配，但如果用到的是age更大的版本才加入的接口，虽然加载能成功，但运行过程中还是有可能报错。\n","modified":"20170920121530000","tags":"os"},
{"created":"20170423121530000","title":"对《谈谈架构》的理解","text":"\n以下是《谈谈架构》这本书的目录，内容没有看，但从目录上已经有很多启发。\n\n第一部分 认识架构\n\n第 1 章 生命周期\n\n1.1 生命周期的识别\n\n1.2 核心与非核心生命周期\n\n1.3 生命周期与分工\n\n第 2 章 时间\n\n第 3 章 为什么会产生架构\n\n3.1 分工\n\n3.2 分工和生命周期\n\n第 4 章 什么是架构\n\n4.1 架构产生的条件\n\n4.2 什么是架构\n\n4.3 架构的生命周期\n\n第 5 章 架构和树\n\n5.1 树与增长\n\n5.2 架构和树\n\n第 6 章 概念\n\n6.1 何为名相\n\n6.2 究竟什么才是相\n\n6.3 概念是沟通的基础\n\n6.4 把握概念的力量\n\n第六章说概念，经常我们会被要求用一句话把一件事件概括出来，看似是考验我们的表达能力，但却有个前提就是双方必须有共同的概念基础。概念是对一件事件的浓缩提炼，要想一句话把一件复杂的事件说清楚，必须是把很多复杂的事件，以一种合乎逻辑的顺序表述出来，如果缺少对概念的共识，一句话就不可能达到好的效果。\n\n第 7 章 什么是抽象\n\n7.1 个性与共性\n\n7.2 个性是基础\n\n经常会经历过度抽象的错误，一方面原因是对忽略了两个事件之间细节的差异，导致认为可以抽象，典型的是把监视和回放合二为一。我也认为个性即差异是根本，在不确定的时候宁可分开，分开也许会造成冗余，但冗余后如果发现合并就是了，但如果开始就合并在一起，随着对细节认识的加深，就会在一份代码中加入越来越多的分支判断，导致代码无法拆解，最后变成一个大麻团。合并易于拆分，所以我对抽象持谨慎态度。\n\n第 8 章 识别问题\n\n8.1 面对问题有哪些困难\n\n8.2 如何识别问题\n\n8.3 寻找问题主体\n\n第 9 章 切分的原则\n\n9.1 切分就是利益的调整\n\n9.2 为什么需要切分\n\n9.3 切分的原则 \n\n9.4 树和分层\n\n9.5 切分与建模\n\n9.6 切分的输出和组织架构\n\n前段时间在公众号上看到类似的观点，架构是发现stakeholder，然后解决之间concerns的工作。使用视点和视角与利益相关者合作。\n\n第 10 章 架构与流程\n\n10.1 什么是流程\n\n10.2 流程和架构拆分的关系\n\n第 11 章 什么是架构师\n\n11.1 架构师做什么\n\n11.2 架构师也是人 \n\n11.3 人人都是架构师 \n\n11.4 架构师和权利 \n\n第二部分 软件架构 \n\n第 12 章 什么是软件 \n\n12.1 以模拟人为目标的冯诺依曼结构和图灵机 \n\n12.2 成本为王 \n\n12.3 天空才是极限 \n\n12.4 软件的作用 \n\n第 13 章 软件的生命周期 \n\n13.1 软件的开发生命周期 \n\n13.2 软件开发的增长 \n\n13.3 软件开发的迭代 \n\n13.4 软件的运行生命周期 \n\n第 14 章 什么是软件架构 \n\n14.1 要解决什么问题 \n\n14.2 分别是谁的问题呢 \n\n14.3 分别有什么问题 \n\n14.4 分析问题 \n\n14.5 会生成哪些架构 \n\n14.6 什么是软件架构 \n\n第 15 章 什么是软件架构师 \n\n15.1 软件架构师的区别 \n\n15.2 软件架构师的困境 \n\n15.3 生命周期的思考 \n\n15.4 软件架构师的权力 \n\n15.5 软件架构师和技术人员对技术的态度区别 \n\n15.6 架构师是技术的使用者 \n\n15.7 如何保障架构落地 \n\n第 16 章 业务、架构和技术三者的关系 \n\n16.1 什么是技术 \n\n16.2 业务和架构及技术之间的关系 \n\n16.3 技术人员和业务人员的关系 \n\n16.4 重新发明轮子 \n\n16.5 开源技术 \n\n第 17 章 软件研发 \n\n17.1 软件工程师的兴起和使命 \n\n17.2 分工的困境 \n\n17.3 软件的迭代 \n\n17.4 软件开发的分工 \n\n17.5 软件开发模式和架构 \n\n17.6 软件工程师的支持者 \n\n第 18 章 软件的架构拆分 \n\n18.1 软件拆分的原动力 \n\n18.2 软件开发团队的拆分 \n\n18.3 软件的拆分 \n\n18.4 软件开发的基础技术 \n\n18.5 软件拆分的第二动力 \n\n18.6 架构一步到位 \n\n第 19 章 如何写好代码 \n\n19.1 什么叫业务逻辑 \n\n19.2 业务逻辑分散的危害 \n\n19.3 业务逻辑内聚的好处 \n\n19.4 代码架构实例 \n\n19.5 代码误解 \n\n19.6 软件的拆分 \n\n第 20 章 单元测试 \n\n20.1 什么是单元测试 \n\n20.2 单元测试的困境 \n\n20.3 单元测试测什么 \n\n20.4 如何改造代码 \n\n20.5 为什么要做单元测试 \n\n20.6 如何做单元测试 \n\n第 21 章 软件架构和面向对象 \n\n21.1 什么是面向过程 \n\n21.2 什么是面向对象 \n\n21.3 生命周期和面向对象及面向过程 \n\n21.4 架构和面向对象及面向过程 \n\n21.5 面向对象的误区 \n\n21.6 对象和生命 \n\n第 22 章 软件架构与设计模式 \n\n22.1 模式以及模式的意义 \n\n22.2 什么是设计模式 \n\n22.3 软件设计模式 \n\n22.4 设计模式和架构 \n\n22.5 设计模式的误区 \n\n第 23 章 软件架构和软件框架 \n\n23.1 访问类框架 \n\n23.2 业务类框架 \n\n23.3 什么是框架 \n\n23.4 框架的特点 \n\n第 24 章 软件运维 \n\n24.1 软件运行生命周期\n\n24.2 什么是软件运维\n\n24.3 运维的业务模型\n\n24.4 控制变化\n\n24.5 监控变更\n\n24.6 预警变更\n\n24.7 主导变更 \n\n24.8 提升变更质量 \n\n24.9 运维的架构拆分 \n\n第 25 章 软件访问生命周期 \n\n25.1 软件访问的业务模型 \n\n25.2 软件访问路径的架构拆分 \n\n25.3 大规模软件访问的架构拆分 \n\n25.4 集群 \n\n25.5 数据中心 \n\n第 26 章 软件架构和大数据 \n\n26.1 什么是大数据 \n\n26.2 如何做好大数据 \n\n26.3 软件大数据 \n\n第 27 章 软件架构和建筑架构 \n\n27.1 软件架构和建筑架构的目标之异同 \n\n27.2 软件和建筑的架构扩展之异同 \n\n第三部分 软件架构的应用 \n\n第 28 章 交易 \n\n28.1 什么是交易 \n\n28.2 货币的出现 \n\n28.3 企业的实质 \n\n28.4 软件对交易的影响 \n\n28.5 软件的交易 \n\n28.6 企业的核心 \n\n第 29 章 产品 \n\n29.1 什么是产品 \n\n29.2 什么是商品 \n\n29.3 识别产品 \n\n29.4 产品系统 \n\n29.5 产品列表 \n\n29.6 产品详情 \n\n29.7 商品的规则 \n\n第 30 章 用户 \n\n30.1 什么是用户 \n\n30.2 为什么需要用户 \n\n30.3 客户的出现 \n\n30.4 用户的生命周期\n\n30.5 用户的识别\n\n第 31 章 订单\n\n31.1 什么是订单\n\n31.2 订单的生命周期架构拆分\n\n31.3 订单支付\n\n31.4 订单生命周期\n\n第 32 章 交易系统\n\n32.1 企业的架构拆分\n\n32.2 软件系统的建模\n\n32.3 访问业务模型\n\n32.4 交易软件系统的架构拆分\n\n32.5 服务的产生和粒度\n\n32.6 用户系统的拆分\n\n第 33 章 事务\n\n33.1 什么是事务\n\n33.2 软件中的事务\n\n33.3 数据库事务的滥用\n\n33.4 数据库的正确使用方式\n\n33.5 服务调用","modified":"20170423121530000","tags":"design"},
{"created":"20190506121530000","title":"对称加密实践","text":"\n所有对称加密的核心是XOR运算，因为XOR运算有一个非常神奇的特性A\\*B\\*B=A。也就是说A与B进行XOR运算之后的结果再和B运算就能复原A。A是明文，B是密钥，就是所有对称加密的基础。主流的AES采用块式加密，每次固定加密128位，密钥不能短于块长度（奇怪的是DES的密钥比块要短），当原文比块要长时，显然要迭代进行，如何迭代就分化出ECB，CBC，GCM等众多模式，而AES我的理解是如何把加密块和密钥进行XOR的方式，两者的阶段不同，所以合称AES-GCM。\n\n!! AES填充\n\n* PKCS5 : java原生和PHP的默认行为\n* PKCS7 : java需要导入bouncy包，PHP的`OPENSSL_RAW_DATA`\n\n这两种按文档说明是没有差别的，实测下来不同的pad的输出大部分一样，但有差异。而且解密时如果选错pad会解密失败。\n\n!! AEAD\n\n全称Authenticated Encryption with Associated Data。是一种同时具备保密性，完整性和可认证性的加密形式。\n\nAEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的。也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据，而不知道密钥是否是正确的，也不知道解密出来的原始数据是否正确。因此，需要在单纯的加密算法之上，加上一层验证手段，来确认解密步骤是否正确。\n\nAEAD的实现方式可以是单纯的CBC和SHA1组合而成，也可以是AES-GCM，AES-CCM，chacha20-poly1305（chacha对称加密，poly是MAC验证）等直接完成。TLS1.2引入AEAD后，1.3就只允许这种算法了，可见安全界的认可。\n\nGCM本质上是AES的CTR模式加上GMAC（又叫GHASH）进行哈希计算的一种组合模式。GCM来自于AES的CTR模式，CTR是指计数器模式。GCM是利用GMAC（基于伽罗华域的MAC）和AES的CTR模式的组合。GMAC比普通的MAC算法快（毕竟冠以伽罗华之名），GCM模式与CBC的一个最大的区别是GCM模式不再把上一个数据块的计算结果输入到下一个数据块的计算，而是在分好的数据块中任意位置开始计算，由一个计数器和一个不变的IV值（nounce）来控制每一次计算的随机性。由于下一次的计算并不依赖于上一次的结果，所以GCM模式可以实现大规模的并行化，并且Intel还专门推出了clmul指令用于加速GCM的运算速度，可见其应用之广。纯软实现的chacha比aes有4倍的优势，但随着硬件指令加持AES-GCM有一统天下的趋势，也确定了AEAD的演进方向。\n\nGCM是一种加密范式，不是一种特定的加密算法，在AES中可以应用GCM范式，在Camellia中也可以。除了这种范式外，CCM是另一种广泛应用在Wi-Fi上的范式。","modified":"20190506121530000","tags":"security"},
{"created":"20210322121530000","title":"对公有云上数仓的调研","text":"\nSnowflake的数仓产品在架构上分为三级，从下到上的功能分别是（以Amazon为例，这块有论文相对详细，MG两家没什么资料）\n\n# DataStorage：基于Amazon S3，存储数仓数据。选型时在S3和自建HDFS间有过权衡，最终还是选择了S3，从经济上更合算，且关注点聚焦在应用层。\n# VirtualWarehouse：每个VW由数量不等的Amazon EC2弹性计算实例构成，在向用户销售时，使用S->M->L这种服务尺寸，用户看不到EC2的数量。由于计算规格的单价已经分档，后续的付费就是基于时间来计费，Snowflake还贴心地给用户提供了超过多少时间停用的选项，有点类似运营商流量套餐超限保护，避免按调用次数付费场景下，写出了烂SQL，结果账单爆表的问题。\n# CloudServices：这块是Snowflake的核心自研产物，包括SQL执行引擎（三大特性：列存、向量化、push方式，上游主动给下游推数据，据说能提高缓存效率，之前很多引擎，都是基于Volcano模型的pull方式）、表的元数据管理（KV形式存储）、并发控制和事务管理。\n\n计算存储分离\n\n业界有一种主流的架构称为Shared-Nothing，指对一个很大的表数据，系统把它按照某种规则拆分成N份，拆分之后由N个worker来分别处理其中的一个分区。这样的好处是架构比较简单，所有worker上的处理逻辑都一样，worker节点之间不共享任何数据，查询执行的过程中没有资源的争抢，效率很高，而且拆分之后普通的机器就可以计算很大的查询，不再需要什么特殊的高配机器。它最大的缺点是，把计算资源和存储资源捆绑在一起，引起以下问题：\n\n#  当集群的节点数发生变化(升级，扩缩容等等)的时候，Shared-Nothing 需要对数据重新进行分布，而这个是需要消耗大量的计算资源的，在这期间用户在线查询的性能会受到影响。\n#  不同场景对于机器配置的要求不一样，一个对于数据导入很好的配置(IO intensive)对于复杂的在线查询(CPU-intensive)就不一定适合，而为了支持所有的场景，最后机器的配置要取个折中，从而无法达到最好的性价比。\n#  集群的软件版本有升级的需要。虽然理论上可以一个接着一个地升级，但是工程实现会很复杂。\n\n由于Snowflake把存储和计算分别部署在S3和EC2上，实现了分离。对前面提到的Shared-Nothing的几个问题，对于异构工作负载的问题，用户可以为不同的场景分配不同的计算层机器，用完了之后可以释放掉（这点和Snowflake的计费模式也有关）。又因为EC2和S3没有任何关系，在计算节点扩缩容时，当然不需要对数据进行重分布操作。\n \n技术特性问答\n\n* 如何解决存算分离带来的性能问题？\n\n每台Worker节点都配备了SSD，这个SSD并不保存原始数据，而是保存被之前查询请求过的热数据，做到在性能和成本间的平衡。为了提高缓存文件的磁盘命中率，Snowflake的查询优化器在调度TableScan的时候会根据表对应的底层文件名，以一致性hash的算法把数据加载的请求分到这些worker节点上，保证对同一个文件的请求可以尽量落到同一个worker节点上去，提高命中率。\n因此从大的架构来看Snowflake做了计算和存储的分离，但是如果看缓存的设计，会发现计算和存储又绑定到一起了。只不过这个绑定不明显，而且只存储被查询的数据，不是全量数据。\n\n* 如何实现更新？\n\nSnowflake系统里面的数据文件都是只读的，当用户对数据进行更新的时候，系统会产生新的文件，把老的文件替换掉，但是每个文件本身是只读的，这样的模式特别适合S3的存储特性（只能覆盖写，不能追加写），同时也方便实现MVCC -- 只要让每个查询始终读查询开始时的对应的版本的文件就好了。\n\n* 如何实现事务？\n\n事务是通过 Snapshot Isolation的方式来实现的，所谓的Snapshot Isolation, 指的是一个查询能看的数据是这个查询开始时整个系统的一个快照，跟类似系统一样，Snowflake也是通过MVCC来实现Snapshot Isolation的。\n\n* 为什么不用索引？\n\n# 索引依赖对文件随机读，而S3系统并不适合随机读取。\n# 索引会降低查询、加载的效率，数仓数据量都特别的大，降低了加载的效率在需要做数据恢复的时候是很大的问题。\n# 索引需要用户手动创建，会加重用户使用成本。\n\n* 索引的替换方案是什么？\n\n在每个数据文件上保存数据的min/max类统计数据，通过对这些元数据进行扫描可以判断是否要扫整个文件，避免扫描所有文件。这种方案在顺序大块数据时效果很好，对数据载入、查询优化、查询执行的影响也非常小。\nSnowflake对半结构化的列也会生成min/max。除了静态剪枝，Snowflake还会运行期动态剪枝。例如在hash join时，Snowflake会在构建端统计join key的分布，再传到探测端用来过滤数据，甚至有机会跳过整个文件。\n\n* 如何做到数据加密？\n\n数据会在两个地方加密，一个是网络传输时，一个是磁盘写入时（如Amazon S3）。\n存储数据的加密滚动策略：磁盘上保存数据用的加密key是一直在变化的，具体策略是定期创建新的key，之后旧的key只用来解密，不能再加密了。当确定一个key要被弃用后，用这个key加密的文件会被用新的key重新加密。","modified":"20210322121530000","tags":"data"},
{"created":"20210901121530000","title":"对昼伏夜出和朝九晚五两个技战法的分析","text":"\n单看这两个模型的名字，含义好像是非此即彼的，研究它的时间划分，以及计分细节，才体会到这两个模型想表达含义的差异。\n\n!! 模型定义\n\n昼伏夜出定义了4个时间点，晚上11点到早上的5点，如果出现就加一分；从早上9点到下午1点出现就减一分，其他时间段不计分。而朝九晚五划分了6个时间点，早上7点到10点以及下午的4点到7点出现会加一分，晚上的10点到早上的4点，出现会减0.5分。累计10天，总分大于一定阈值就判定为对应人群。\n\n!! 模型意图分析\n\n从时间划分来看，昼伏夜出的昼仅指上午，定位的是经常在夜间出没的人员，所以晚上出现加分，同时因为上午要休息，所以上午出现会减去同样的分数。该模型针对比如有盗窃嫌疑的人，这些人往往是习惯于晚上踩点，上午休息。而另一种三班倒的人群，是晚上出工，差不多早上8,9点会回家休息，通过对上午出现减分，就把踩点的小偷和三班倒的人员做了一个区分。因为这个模型关注是盗窃人员，所以对于下午的活动就不在意了。通过这样的时间划分方式，就比较准确的找出昼伏夜出人员。\n\n朝九晚五从时间段来看，想表达的是在早上和傍晚的通勤时间常出现，深夜到凌晨少出现，从单次的扣分和加分不相抵，能看出来该模型并不要求晚上不出现，这里也有个细节，并不关注中午这个时段是否出现。因为他想找出的就是在早晚通勤时段有活动的人，所以中午是否活动并不影响判断。\n\n相比于昼伏夜出模型，朝九晚五想做的是对白天活动的人群做细分，就是上班时间比较规律的这群人。典型的如公务员或一些窗口办公人员。如果我们把这个模型的时间段调整一下，比如把早上的时间不变，晚上的时间定义在8点到12点，能得到了一个早出晚归的人群，就是加班时间比较久。\n\n以上是一天的记分规则，像这种模型一般来说都会统计过去一周或者一个月的总分值。在这方面也有一个很有趣的点，就是它在算每天的总分时，会设定一个上下限阈值，最低不低于0分，最高不高于两分。如果直观地看规则，对朝九晚五规则来说，如果某个人白天不出现，晚上出现了是会变成负分的，但因为阈值的存在，并没有出现负分。我分析他的意图是考虑如果周末的晚上出没较多，这个负分就会对其他天的出行造成一个负面的影响，但是这个周末晚上的活动又是在允许范围内的。既然这个模型是要找出具备通勤规律的人，那么偶尔一两天晚上频繁出现，就不应该对评价造成一个很负面的影响。","modified":"20210901121530000","tags":"think"},
{"created":"20161225121530000","title":"对Lua中Enviroment的理解","text":"\nLua5.2文档对编译基本单元chunk是这么说的：\n\n> Lua把每个chunk看成一个带有可变数量参数的匿名函数体。而这个chunk在编译时，\n> 又外接一个local的变量`_ENV`。因此每个chunk(或者函数体)总是有`_ENV`。\n\n顺便说句，require的返回并不强制要求table，也可以是function，\n比如markdown这个扩展返回的就是函数，保存require的值后，可以直接运行。\n在写扩展代码时，一定要注意定义函数会否污染全局环境，如果不加local的话，\n这些定义是一定会带到主程序的，避免的办法有两个\n\n# 不希望导入全局的函数加local前缀，这了非常直观\n# 使用`_ENV`或setfenv来隔离。比如这样写\n\n\u003Cpre>\n-- Set up a table for holding local functions to avoid polluting the global namespace\nlocal M = {}\nlocal MT = {__index = _G}\nsetmetatable(M, MT)\nlocal lua_ver = tonumber(_VERSION:match(\"(%d.%d)\"))\nif lua_ver > 5.1 then\n  _ENV = M\nelse\n  setfenv(1, M)\nend\n\u003C/pre>\n\n先把`_G`保存在一张本地表，对全局变量的引用变在本地变量中了。当然更重要的还是保护写，\nLua5.1以前是用setfenv这个函数，1是require的那个环境，如果0就表示_G，这样会毁了全局变量。\n而Lua5.2引入的`_ENV`这个有点像SELF的变量，就不再需要setfenv函数。\n\n看完lua层面不同版本对环境的兼容，再看C接口的兼容。\nluasys库的方式是：`#define lua_setfenv lua_setuservalue`。当然还是有差别，5.1版本，设置的值一定是table，而被设置的则是function/thread/userdata三种之一，5.2版本后，任何类型都可以设置，但是被设置值必须是full userdata。版本间的交集是table绑定到userdata上，luasys就按着这个限定去用。\n\n吐槽一句，文档偏要说`_ENV`完全只是一个普通的名字，In particular，\n可以用local `_ENV`定义一个新的变量来掩盖常规意义上的`_ENV`，对这种人，我只想送他四个字**走好不送**。\n这种时候应该写： `We strongly recommend do not override _ENV`。\n而不是含糊不清的In particular。\n还有个原因是`_ENV`名字可以在luaconf.h中使用宏`LUA_ENV`重新定义，为了在社区能正常的交流，\n劝你别这么干。`_ENV`定义在LexState里的一个TString类型变量里，在lparser.c中会用到。\n\n流程是这样的\n\n# luaX_init，起因是lua_newstate时需要一系列初始化，就包括了词法初始化。\n这里被创建的名字是全局的，永远不会被GC。\n# luaX_setinput。这句是在luaY_parser中调用，和刚才那句不同，\n这里创建的变量就要归属某个LexState，这个LexState是在luaY_parser的一个栈上变量。\n从注释来看，luaY_parser是专用于主文件的，luaX_setinput之后的mainfunc会close这个栈上变量，\n风险是没有的。\n","modified":"20161225121530000","tags":"lang"},
{"created":"20221218121530000","title":"对netcat的探索","text":"\n有些很弱的主机无法安装sshd，又需要远程操作时，完全可以用nc。\n\n大多数教程讲nc用GNU版本，用-e选项就能反弹shell，但为了学习原理，不妨用更原始的下面这种方式。\n\n`cat tmpf | bash 2>&1 | /system/bin/toybox nc -l -p 6666 > tmpf`\n\n即使是toybox自带的nc，都能正常工作。来解释下原理。\n\nnc是把cat的功能应用在socket上，而cat的原意除了打印，首先是用来concatenate files。平时我们操作的是文件，但在nc的场景，更重要的是concatenate socket and stdin/out。所以我们倒着看上面的命令，nc监听端口后，将来自这个端口的输入输出消息，和终端的stdin/out绑定；绑定后再重定向到fifo文件。\n\n其实真正要绑定的是nc监听的端口和shell，但管道符只能单向流，所以最开始引入fifo文件，利用cat把fifo的输出端绑给shell，最后的时候把fifo的输入端绑给nc，借fifo把nc和shell间的双向循环变成形式上的三角循环，虽然不够优雅，却非常巧妙。","modified":"20221218121530000","tags":"net"},
{"created":"20210106121530000","title":"多核CPU之间的异同","text":"\nPower是标准的SMP架构，而X86则是NUMA。由于SMP访问内存速度一致，因此Power可以轻松上16socket，而NUMA对内存区别对待，访问别的核内存要通过QPI总线，所以很难上4socket。\n\nPower的每核线程数能到8甚至16，但X86只有2线程，还被大肆商业鼓吹。好在X86的单socket核数并不差，还略高一些。\n\nPower在负载很高甚至99%的情况下能持续运行几周甚至月（也许和CPU架构未必强相关），而X86就容易不稳定。尽管如此X86通过价格低廉，辅以外围集群技术的弥补，仍然成为主流。\n\n!! 差异说明\n\nNUMA出现得晚（20世纪90年代），解除了SMP内存的bandwith限制，但需要软件优化。\n\n因为是对内存访问的差异，所以到底是NUMA好还是UMA好，是要看具体应用的。如果应用本身是每个CPU（或者CPU内部的单个核心）长时间持续运行一个线程，那么NUMA把这个线程用到的数据尽可能放到这个CPU的本地内存中当然会更有性能优势。如果是把大量的数据加载到内存中，根据外部请求创建不同的线程随机访问内存中的一部分数据，短时间的处理后线程结束，则是UMA的平均延迟会更低。一般来说，前者通常是一些运算量很大的应用；后者通常是各种服务器（例如网站、数据库等）。这也是为什么Linux内核允许配置为NUMA或者UMA两种模式，多路系统的BIOS通常允许配置为NUMA模式或者UMA模式的原因。\n\n从另一方面来说，现代的多核CPU，内部都有独立的1级缓存和2级缓存，也可以认为本质就是NUMA架构。但如果扩展到所有内核都有独立的内存控制器，则会导致成本过于高昂；此外也无法通过内存交错技术提升内存带宽。","modified":"20210106121530000","tags":"os"},
{"created":"20200830121530000","title":"多进程与进程间通信","text":"\n在linux中，fork和vfork的系统调用都是clone，当然标记是不同。\n\n* fork: CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD\n* vfork: CLONE_VM|CLONE_VFORK\n* pthread_create: CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID\n\n以目前的性能优化而言，两者的开销区别并不大，更大的区别在于执行流程和内存空间不同。fork执行后，父子进程一定会被执行到，规范没有规定执行顺序，一般都是同时开始调度。而vfork则一定是子进程先执行，而且**如果子进程没有调用\\_exit（不是exit）或exec函数的话，父进程不会被执行**。\n\nfork是COW，而vfork的子进程可以修改父进程的变量（纯share，没有copy），这也是为什么父进程必须等待子进程调用\\_exit后才会被执行的原因。\n\n用strace观察锁，绝大多数都是futex函数调用，且操作都是FUTEX_WAIT_PRIVATE，很难看出区别，只有一次触发了FUTEX_WAIT。看资料说现在的锁实现，大多是先自旋一定次数，如果还获取不到，再用户态等待，不会轻易进入内核态，毕竟futex的目的就是防止程序进入内核态。子线程结束调用exit，而主线程结束调用exit_group。\n\n创建线程的身份是tid，但由于操作系统的进程API在前，所以同一个主线程，不管创建多少子线程，这些子线程的pid都一样。\n\n!! 僵尸状态\n\n为什么会有这个状态呢？我能想到的惟一原因是父进程要取得子进程的退出状态等信息。僵尸状态是每一个进程退出前的必经过程（只有init进程例外，因为不会退出）。僵尸态只记录一个整型状态，但不止一种信息，用wait.h的特殊宏可以解析出是exit还是stop，收到的信号量等等，而且处在僵尸态的进程，/proc/\u003Cpid>/目录的文件会的owner会变成root。但僵尸进程毕竟占用内核的pid资源，所以必须回收。\n\n结束僵尸态有几种方法\n\n# 父进程调用wait()\n# 父进程显式忽略SIGCHLD信号，必须用SIG_IGN才能自动结束僵尸，其它注册函数没用\n\n另外好像用llvm编译的程序，虽然没有注册SIGCHLD，也不调用wait，子进程仍能结束不会变成僵尸。\n\n!! 进程会话和作业\n\n多个进程间会进行分组，有几种分组方式。\n\n* session: 一般指shell session，一次登录sh导致的所有进程都在这个session下，而sh进程就称为session的领头进程，通过ps的SID列可以查到\n* job: 最典型用管道符串起来的多个进程，称为一次job。第一个进程是job的领头进程，通过ps的PGID列可以查到\n\n!! 7种进程间通信机制\n\n# pipe 管道，最简单，对应syscall有pipe和pipe2两种，pipe2多支持几种选项，是linux在2.6.27才加入的接口\n# fifo 有名管道，对应syscall是mknodat，因为有名，且对应磁盘上的文件，因此用mknod方式创建。\n# mmap 文件映射共享IO，速度最快（原理：在内存开辟一片缓冲区，把文件映射到内存上，你直接去操作内存就可以了）。shell中的管道符用的就是这种，但不管输入端的内容有多大，都只调用两次mmap（必须有MAP_SHARED标记），大小都是128K。\n# 本地socket 最稳定\n# 信号 携带信息量最小的\n# 共享内存 开辟一块内存区域，大家都能访问，一个进程退出之后，这块内存还会给你保留下来，后来者还可以继续使用\n# 消息队列\n\n!! 匿名管道\n\n先从匿名管道说起，在shell中执行 `ls | grep xx` 时，背后的流程是当前的sh为父进程，fork出两个子进程，分别exec执行ls和grep，而且这两个子进程之间会有匿名管道pipe()连接起来。由于两个子进程的父进程都是shell，因此存在亲缘关系，匿名管道以fd方式存在，通过fork方式被两个子进程共享，这就是匿名管道可以工作的原因。\n\n顺便说一句，读管道要用read语句，而读命令行输入则是$#一系，由于输入形式的不同，处理逻辑也不同。\n\n!! 有名管道\n\n用读方式打开有名管道，默认是BLOCK模式，意味着当没有进程写入时，会一直堵塞。而一旦有数据写入，会源源不断地读到数据，即使没有数据写入，也不会阻塞读动作。因此对有名管道的读，每次读到空，就要关闭管道，并再次尝试打开，否则CPU会急剧升高。形如以下\n\n```\nwhile true {\n    fd = open('fifo', 'r')\n    line = fd.read()\n    fd.close()\n}\n```\n\n观察这两种管道的使用，会发现都使用`pipe_wait`系统调用，因此都叫管道。\n\n匿名管道因为使用形式的关系，数据流动是单向的。而有名管道形式上是文件，当然是双向，打开用读写方式。而且有名管道涉及进程间交互，往往是双向流动。如果A到B，B直接打印到终端，人眼看上去没有区别，程序是无法捕获这段打印，有点类似内核输出报警，你能看到却没有任何方式拦截并重定向它。\n\n引申一点，shell脚本中怎么判断是命令行启动，还是接在管道后？这两种情况下，stdin没有区分，这时就要再往前想一步，stdin这个逻辑概念指向谁？匿名管道模式，stdin指向的显然是管道，而命令行模式下，stdin指向的是终端，真实的终端叫tty，后来网络化后叫pts，但只是表示不同，终究有个对应的实体。tty命令就是打印stdin所对应的终端，如果stdin对应的是匿名管道，则会返回错误并提示`not a tty`。除了tty，用`[ -t 0 ]`也能判断0是否为tty。对应的C函数是isatty。\n\n!! 文件锁\n\n文件锁用flock保证一个进程启动时独占","modified":"20200830121530000","tags":"os"},
{"created":"20200207121530000","title":"多终端打开软件用法","text":"\n!! GNU screen\n\n修改默认的引导键C-a时，命令行启动时使用screen -e^tt绑定到C-t。前一个t表示自定义命令字符，相当于所有命令的触发按钮，后一个t表示转义字符，因为C-t被占用了，必须按C-t t才能被screen里面的程序理解为C-t，这个特性很少用。也可以在.screenrc中加上escape ^yy转义。\n\n离开screen环境的常用命令(以下用sr表示)\n\n* sr -ls 展示当前已有的会话，本质是列出已连接的socket(有几个连接，就在~/.screen/目录下有几个文件)，如果socket断开，会显示dead，这时用-wipe可以清除这些socket\n* sr -r [pid] 恢复，如果只有一个不用输入pid\n* sr -xRR 如果后台有一个现有的screen，则连上去，否则创建一个新的\n\n在screen内的快捷键(cmd表示映射的)\n\n* C-? A 修改窗口名称\n* C-? \" 展示所有窗口，进而切换\n* C-? : 进入交互式命令行窗口，方便临时修改配置\n\n一些发行版(termux、alpine)在执行时，窗口大小会变化，手动改width会提示your termcap does not specify your terminal width。原因是那些发行版使用terminfo，需要转换后才能修改终端窗口。[这里](https://www.math.utah.edu/docs/info/screen_15.html)有完整的说明。\n\n进入screen默认没有任何显示，通过修改hardstatus来表示(hardware的意思，似乎这个是硬件内嵌吧)。\n\n!! tmux\n\n配置文件.tmux.conf\n\n```\n# Send prefix\nset-option -g prefix C-a\nunbind-key C-a\nbind-key C-a send-prefix\n\n# Use Alt-arrow keys to switch panes\nbind -n M-Left select-pane -L\nbind -n M-Right select-pane -R\nbind -n M-Up select-pane -U\nbind -n M-Down select-pane -D\n\n# Shift arrow to switch windows\nbind -n S-Left previous-window\nbind -n S-Right next-window\n\n# Mouse mode\nset -g mouse on\n\n# Set easier window split keys\nbind-key v split-window -h\nbind-key h split-window -v\n\n# Easy config reload\nbind-key r source-file ~/.tmux.conf \\; display-message \"tmux.conf reloaded\"\n```\n\nSend prefix\n把prefix的ctrl+b变为了ctrl+a，因为这样按起来方便些。基本上用tmux的都改了这个。\n\nUse Alt-arrow keys to switch panes\n不用按prefix，直接用alt+箭头在pane之间switch。实际用过之后才发现真是太方便了！\n\nShift arrow to switch windows\n不用按prefix，直接用shift+箭头在window之间switch。太方便了！\n\nMouse mode\n开启鼠标模式。用鼠标就能切换window，pane，还能调整pane的大小，方便！\n\nSet easier window split keys\n这一部分是用来更方便切分pane的。prefix + v 代表竖着切，prefix + h 代表横着切。比起默认的切割方法不仅直观而且方便。\n\nEasy config reload\n下一次如果修改了.tmux.conf的设置的话，不用关掉tmux。直接用prefix+r,就能重新加载设置。\n\n2 Panes\n\n分割pane\n\nprefix + % :水平分割pane\nprefix + \" : 竖直分割pane\n退出\n\nexit ： 退出一个pane，直接在shell里输入即可，这个比快捷键方便\n放大一个pane\n\nprefix + z : 把当前一个pane放大（zoom in)。比如在用ls查看output的时候，因为一个pane可能空间太小，所以把这个pane放大，你可以把注意力全放在这个pane里。回到之前的多pane状态的话只需要重复一遍命令即可(zoom out)\n在pane之间switch\n\nprefix + 上下左右的箭头 :这个说实话还是不方便，之后会有设置的方法来用鼠标选择pane\nresize the pane\n\nprefix + （ctrl）+上下左右箭头 : 与上面命令不同的是，ctrl + b按完之后，不要松开ctrl，一直按着，然后再按箭头来调整。不过因为在mac下ctrl+箭头是切换屏幕，所以还得在偏好设置->键盘->快捷键->Mission Control里把对应的快捷键取消掉。\n3 Windows\n创建window\n\nprefix + c : 创建一个新的window。最下面会多出window的编号。有*号所在的window就是当前正在操作的window。\n在不同的window间移动\n\nprefix + 数字1，2，3 : 因为能看到不同window的数字编号，所以直接输入想去的window的数字编号即可\n关闭window\n\nprefix + & ： 关闭当前window\n重命名window：因为创建新的window后，下面除了数字编号不同外window名称都是一样的。所以为了知道每一个window是什么，最好重命名一下。\n\nprefix + , (逗号）：更改window名称。但是这里遇到一个问题。更名后，我随便使用ls或cd命令后，window名称会随着目录的不同而变化。google后发现这个是zsh下oh-my-zsh的特性。于是打开~/.zshrc, 讲DISABLE_AUTO_TITLE=\"true\"这一行反注释掉。source ~/.zshrc后，测试更改的名称，发现一切正常。\n\n5 Session\n查看所有的session（在terminal输入）\n\ntmux ls : 这个命令是在terminal里输入的。当前正常运作中的tmux server会显示（attached）。没有的话就是已关闭，tmux server在后台运行。\n更名session（tmux状态下输入）\n\nprefix + $ : 更名后好让自己知道每一个session是用来做什么的。通常一个session对应一个project\n创建session的时候直接命名(在terminal输入）\n\ntmux new -s py35 : 新建一个名为py35的session\n断开一个session(detached) （tmux状态下输入）\n\nprefix + d ：退出session。在只有一个window的状态下，直接输入exit也能退出\n重新连接某一个session wich name（在terminal输入）\n\ntmux a -t py35 : 重新连接py35 session。这里的a是attach的意思\n偷懒连接上一个session（在terminal输入）\n\ntmux a : 如果只有一个session的话，这个是最快的连接方法\n删除session（在terminal输入）\n\ntmux kill-session -a -t py35 : 删除除了py35以外的所有session\n\n!! 附录\n\nvim支持的终端库有5种：tinfo, ncurses, termlib, termcap, curses。应该只是实现不同，都有相同的函数。","modified":"20200207121530000","tags":"tool"},
{"created":"20201101121530000","title":"二三层网络和MAC地址","text":"\n根据OSI的七层模型，二层协议包含PPP、ARP，而三层包含IP、IGMP。\n\n# 不同网段（子网）的ip通信，需要经过三层网络。相同网段的ip通信，经过二层网络；\n# 二层网络仅仅通过MAC寻址即可实现通讯，但仅仅是同一个冲突域内；三层网络需要通过IP路由实现跨网段的通讯，可以跨多个冲突域；\n# 二层网络的组网能力非常有限，一般只是小局域网；三层网络则可以组大型的网络。\n# 二层网络基本上是一个安全域，也就是说在同一个二层网络内，终端的安全性从网络上讲基本上是一样的，除非有其它特殊的安全措施；三层网络则可以划分出相对独立的多个安全域。\n\n二层交换机实质就是一张大的查找表，记录MAC和IP的对应关系，因此有ARP协议也是很自然的事情。但是受限于交互机的内存以及以太网络的冲突，网络容量不会太大，这也是子网掩码大多都设置为255.255.255.0的原因。\n\n!! MAC地址拾遗\n\n通常认为MAC地址是全球唯一，其实MAC地址的本意是保证在一个广播域内唯一，因为MAC是以太网下的概念，帧中继、ATM等通信方式都是没有MAC地址的。\n\nMAC地址的高24位被称为OUI，组织单位标识符，正规厂商需要花钱向IEEE购买之后才能使用。这就有一则历史趣闻，1990年代，steve deering在研究IP组播时，希望能拿到和组播IP地址相等数量的MAC地址，D类IP地址有效位数是28位，意味着需要购买2^4个OUI，当时一个OUI的售价是1000美金，steve的经理jon postel觉得1万6美金太贵，但是愿意在预算外再购买1个OUI，并分出其中一半给steve研究，于是MAC的组播地址就变成了OUI为01-00-5E，有效位数低23位的地址空间。进而导致组播时，IP地址只有后23位被映射到MAC，也就是说每32个组播IP地址共用同一个MAC地址的现状。","modified":"20201101121530000","tags":"net"},
{"created":"20210202121530000","title":"防火墙与iptables","text":"\n至少要两块网卡分别控制流进和流出，才能实现完整的防火功能，即使是纯软防火墙也要两张卡。\n\nLinux中起防火墙作用的是Netfilter，而iptables是管理控制netfilter的工具，可以使用它进行相关规则的制定以及其他的动作。iptables是用户层的程序，netfilter是内核空间的。\n\niptables有两个版本，legacy依赖getsockopt/set内核接口，功能上相对受限，新版本改为依赖`nf_tables`接口。从名字就能看出是对table的操作，每种table有不同类型的内置chain，每个chain又有条数不等的rule。\n\ntable有以下5种\n\n* filter 默认table，3种内置chain(INPUT/FORWARD/OUTPUT)\n* nat 4种内置chain(PREROUTING/INPUT/OUTPUT/POSTROUTING)\n* mangle 下面这3个没看到有效信息，先跳过\n* raw \n* security\n\n!! 命令解释\n\niptables的命令，就是选哪个table(-t)，对链做哪些操作(-I/-R/-A/-D/-S)，最后的参数是rule。看例子 iptables -I FORWARD -o br0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n\n首先没有-t表示默认filter，-I表示向FORWARD这条转发链添加动作，具体的rule包括转发目标接口br0，-m和-j是rule-specification，连起来表示转发到br0的包，只要匹配到连接跟踪时，则接受，复用该连接回到连接发起的地方。\n\n-j有3种特殊的jump动作: SNAT, DNAT, MASQUERADE\n\n!!! iptables-save\n\n把所有table打印出来，有:和-A两种链\n\n# :INPUT ACCEPT [3:180]，:KUBE-SERVICES。表示chain名，有内置5种和用户自定义\n# -A OUTPUT或-A KUBE-SERVICES，后面跟具体的-d -j选项表示动作","modified":"20210202121530000","tags":"net"},
{"created":"20220204121530000","title":"分布式哈希技术摘录","text":"\n简称DHT，是一种广泛应用在分布式存储和P2P网络的技术概念，具体实现方式有多种。最初的4种实现CAN（内容可定址网络）、Chord、Pastry、Tapestry都发表于2001年，从此以后该领域的研究就日渐深入。\n\nDHT由于离散性、伸缩性、容错性的特性，有个关键的技术点：任一个节点只需要与系统中的部分节点沟通，当成员改变时，只有一部分工作必须要完成（数据或键的发送、刷新哈希表）。\n\n技术构成上，基础抽象是键空间，键空间分区则将键空间分成数个区域，整个系统中的节点被分到键空间的某个分区。分布式系统必然有频繁的节点进入和离开，就需要一种算法来减少节点变化对系统的影响，业界比较成熟的有3种\n\n# 一致性哈希 consistent hash\n# 最高随机权重哈希 rendezvous hash\n# 近邻匹配哈希 locality preserving hash","modified":"20220204121530000","tags":"net"},
{"created":"20220312121530000","title":"分布式计算在Spark上的实现","text":"\n分布式计算是个很早的课题，在一个集群环境下，必然会利用多个节点共同计算，注意不是同时计算，因为数据会有倾斜，只是会尽可能多地把节点利用起来。当前技术在对待多个节点的身份并不对等，都会分为主从类型，各自叫法不同\n\n| - | hadoop | spark | flink |\n| ---- | ---- | ---- | ---- |\n| 主节点 | JobTracker | Driver | JobManager |\n| 从节点 | TaskTracker | Executor | TaskManager |\n\n!! MapReduce与shuffle\n\nHadoop普及了MapReduce概念，其实map和reduce是很大的概念，Spark在宣传上最大的特点是RDD，但计算模型仍然可以划分为map和reduce两个阶段。经常在Spark听到shuffle术语，其实Hadoop也有这个概念。它是数据在Map Task和Reduce Task之间流动时的一种重新分配，是否进行shuffle由数据的依赖关系决定。shuffle有以下3种\n\n* 流式shuffle：左端Task每当处理完成一条数据，就序列化到缓存，并立刻传送给右端的Task。\n* 批式shuffle：左端Task每当处理完成一条，序列化到缓存（缓存不够需要压到磁盘），但并不立刻传送给右端的Task，而是等到所有数据处理完成之后才传送给右端的Task。Hadoop和Spark采用的模式与此类似，不过是右端主动来取，而不是左端主动发送。\n* 兼容shuffle：左端Task每当处理完成一条，序列化到缓存，等到缓存满了之后再传送给右端的Task。\n\n理论上说，在兼容shuffle模式下，如果缓存仅容纳一条记录，那么就是流式shuffle；如果缓存无限大，那么就是批式shuffle。实际中，通过设置缓存块超时值：超时值为0，则为流式处理，超时值无限大，则为批式处理。Flink可以设置数据传输的模式。\n\n!! 内存划分\n\nHadoop饱受诟病的是节点间的数据交换依赖HDFS，节点把数据落盘导致速度缓慢，Spark和Flink都以不同的方式来解决该问题\n\n| - | 负责执行的内存块 | 负责缓存的内存块 | 其它内存块 |\n| --- | --- | --- | --- |\n| Spark | Execution Memory | Storage Memory | other |\n| Flink | Memory Manager | Network Buffer Pool | Remaining Heap |\n\n其中负责缓存的内存块就是上一个节点计算完成并等待下一个节点来取数的的暂存区域，SparK由下游Task来取数据，而Flink是上游主动向下游发送数据，如果下游没有空间上游就不推送同时也会停止消费。因此Flink天然没有反压的问题。\n\n!! 计算的序列化\n\n分布式计算的关键是调配代码和数据，由于数据量远大于代码，因此核心是**代码分发到各个数据节点**。由于计算的灵活性加上节点处理器的不确定性，要求代码是平台无关且可灵活序列化，在MR时代采用分发Jar来实现计算的分布，而Spark则利用Scala语言更进一步实现函数的分发。Spark为了扩大使用面，和Python做了深度整合，因此也必然要求Python代码能以函数为粒度实现编译和分发。Python原生的序列化库Pickle会把函数和类以引用的方式序列化，这在分布式环境下显然是不够的，于是最早由PiCloud公司（13年合并到了DropBox）扩展实现了CloudPickle库，它能将函数和类序列化成值，解决了分布式环境下的分发问题，当时的CloudPickle只能序列化Py2，Spark继续扩展使它能支持Py3和PyPy。\n\n理论上CloudPickle可以序列化任意Python对象，但Spark的计算框架要求Driver和Executor各司其职，因此不允许Python对SparkContext序列化（自然也就不允许对SparkSession序列化），具体的方式是在`__getnewargs__`方法抛异常来提示用户。这也解开了我最初对collect函数返回结果给Driver的疑问，既然collect不能在Executor调用，那么collect的发起者只能是Driver，结果当然也返回Driver。\n\nSpark和Python的交互在进程级别是socket通信加Arrow的内存列式存储，而语言层面则是udf装饰器，udf有几个重要的参数：函数本体、返回类型、执行类型和是否确定性。前两个很直观，解释下后两个参数。\n\nPySpark的执行类型有`BATCHED_SQL`、`SCALAR_PANDAS`、`GROUP_MAP`、`GROUP_AGG`、`WINDOW_MAP`多种。BATCHED是最简单的Row-at-a-time，而后面几种则是对Column或DataFrame进行处理与合并，效率会高一些。而确定性则是一个比较冷门的概念，输入输出确定的函数称为确定性，而即使输入确定输出也不确定的则称为不确定性，典型的如日期函数或统计总量。之所以要特意强调这点，是因为执行器会对确定的udf做一些优化合并，如果写的udf是非确定性但引擎不知道，可能会引起结果不正确。这个是理论上的解读，我没有实际遇到过，没有很深的理解。","modified":"20220312121530000","tags":"data"},
{"created":"20180406121530000","title":"冯东的Lua","text":"\nLua vs. Python\n\n在《 Programming in Lua 》系列里谈了 Lua 的 stackless 实现。说到 stackless 设计，难免和 Python 的 stackful 实现比较一下。\n\n以前总有一个疑惑。为什么 Python 既要采用 native thread，又要用 great-lock 将其变成实质上的协作式 thread。像 Lua 这样的 coroutine 不好么？现在知道了，非不为，不能也。既要尽量保证虚拟机的可移植性，又采用了非常依赖 CRT stack 的 stackful 设计，语言本身没有 synchronous primitive，不能应付真正的 preemptive 多线程。这种情况下，多线程加 big-lock 是唯一的折衷了。由此也知道了 Python 的 generator 为什么只允许在第一层函数中 yield，因为 stackful 设计不允许保存 call stack (说老实话，只允许在第一层函数中 yield 的 coroutine 不过是两个函数调来调去，在 C 里实现起来也不难)。Python 3.3 开始支持更宽松的 yields，不过实现的方式和 Lua 的 yields-in-C 差不多，作为基于虚拟机的语言是比较原始的手段。\n\n拿 Lua 和 Python 做比较令人恍惚感觉正在比较 Objective-C 和 C++。Lua/Python 和 Objective-C/C++ 都是在共同基础上发展出来：后者扩展 C 语言；前者用 C 语言实现基于 byte-code 的虚拟机。它们都有理想的「标杆」：Objective-C/C++ 的标杆是 Smalltalk/Simula 等面向对象语言先驱；Lua/Python 是 Lisp 这样的高级动态语言先驱。努力的方向都是降低「标杆」过大的性能开销和简化「标杆」过于复杂 (或者过于精简) 的概念。Python 和 C++ 相对较早的尝试，都采用了比较低级的机制：C++ 用函数指针模拟成员函数；Python 依赖 CRT stack 直接实现 byte-code stack。这些「第一次」都没能「do things right」。后来的第二次尝试才作出了更妥当的取舍。\n\n在《 The Art of UNIX Programming 》里指出了系统设计的「第二系统综合症 (second-system effect)」。乔布斯也提到过「第二个产品」的问题。在一个成功的系统上衍生的第二个系统有时会因为没有理解第一个系统成功的真正原因而失败。但是，如果还有机会的话，由此衍生的「第三系统」往往会做得更好。对于上面所说的语言发展来说，它们的基础 (C 语言) 和「标杆」是「第一系统」，第一次改进的尝试毁誉参半，而后来的「第三系统」更加出色。\n\n2013/05/13\t Leave a reply\nProgramming in Lua（五）－ Coroutine, Lua Stack\n\n在《 Programming in Lua（三）－ Yields in C 》里讨论了 Lua 虚拟机对 yields-in-C 及其 stack 的处理。当时还未读 Lua 虚拟机的实际代码，只根据语言的行为来推测，有些术语也不符合通常用法。最近从 Lua stack 的实现入手，发现了一些以前没想过的问题：为什么 resumes-in-C 从来不是问题？为什么有 lua_yieldk() 而没有对应的 lua_resumek() ？\n\n首先从术语的标准化说起。《 Programming in Lua（三）－ Yields in C 》里有多处这样的描述：\n\n「stack 上 ⋯⋯ 的执行层次」；\n「virtual stack 上的 Lua 部分的 stack」；\n「Lua stack 段」。\n其中「执行层次」、「部分」、「段」这样的字眼应该替换为「stack frame」这个更常用的术语。线程运行时，stack 呈现两层意义。一是后入先出的简单线性结构；二是把此线性结构划分成与函数调用层次一一对应的若干段，这样的一段就被称为一个 stack frame。大多数语言的 runtime 或虚拟机中，stack frame 并无单独的数据结构表示。在 64-bit x86 的 C runtime (CRT) 中，每个 stack frame 的首项是上一层 stack frame 的最低地址 (base)，称为 stored frame pointer (SFP)，最顶层 stack frame base 存储在 %ebp 寄存器中 。即每次生成新的 stack frame 时，首先将 %ebp 寄存器入栈形成 SFP，然后把当前的 %esp 赋给 %ebp。通过这种方式让需要解析 stack frame 的程序 (比如 debugger) 得到所需信息。(SFP 并非一定存在，臭名昭著的 omit-frame-pointer 编译器优化会去掉 SFP，这时 debugger 只能借助额外存储的 symbols 来解析 stack frame。)\n\n就需求本身来说，Lua stack 要解决的问题比 C 复杂的多，甚至比同为动态语言的 Python 更复杂。基于虚拟机的语言的 call stack 有两种可能的设计：一是借用虚拟机本身的 CRT stack。Byte-code 的函数调用指令对应虚拟机本身 native 代码的函数调用，虚拟机的 CRT stack 随 byte-code 函数调用的层次增加而增长。二是由虚拟机维护额外的 call stack 数据结构。Byte-code 的函数调用指令和其它指令一样，在虚拟机的同一个循环中完成，虚拟机的 CRT stack 不体现 byte-code 函数的调用层次。后者通常被称为 stackless 方案，前者暂且对应称为 stackful 方案。\n\nLua 是 embedded/extension 语言，byte code 的运行总会夹杂 C 函数。这些 C 函数的 call stack 在逻辑上是 byte-code 运行状态的一部分，实际上则间杂在 Lua 虚拟机的 CRT stack 中 (在涉及 Lua 的情况下讨论 CRT stack 时，要始终说明是虚拟机的 CRT stack 还是 C 函数的 call stack)。从这个角度来说，embedded/extension 语言更倾向于选择 stackful 设计。但 stackful 设计的固有缺陷在于 stack 结构是平台相关的，很难用跨平台的方式实现诸多功能，比如协作式多任务 (cooperative multi-threading)，跟踪垃圾回收 (tracing-GC)，lexical closure。尽管不是全部原因，Python 缺少诸多高级特性与其 stackful 实现有很大关系。\n\n为了遵守 ANSI C 的跨平台性和更好的实现高级动态功能，Lua 采用了 stackless 实现。这给处理 C 代码的 call stack 带来了一些挑战。Lua 的 stack 存储在 struct lua_State 的 stack field 中，是一个 TValue* 的数组。其内容包括：\n\n函数指针。Proto* (Lua 函数) 或者 lua_CFunction (C 函数)。注意函数指针不是函数的返回地址。\n函数的参数和返回值。包括 Lua 和 C 函数之间传递的参数和返回值。\nLua 函数的局部变量。\n在这个 stack 上缺少一些属于 call stack 的东西：\n\nC 代码本身的 call stack。\n函数的返回地址。\nStack frame 信息，类似 SFP。\n这是因为 Lua 采用了双 stack 结构。对应的 stack frame 信息存储在一个 struct CallInfo 链表中，每个节点对应一个 stack frame，它对 TValue* 数组 stack 的描述如下：\n\nField func 表示 stack frame 在 TValue* 数组上的起始位置 (之所以用 func 作为 field 名称是因为在 TValue* 数组上这个位置永远是函数指针)，field top 表示结束位置。\nField union u 存储和函数类型相关的信息。Lua 函数信息存储在 u.l 中，C 函数在 u.c 中。\nu.l.savedpc 表示函数的返回地址。这个值仅当 Lua 函数作为 caller 的情况有效。C 函数作为 caller 时，返回地址在 CRT stack 中。\n当 C 函数中发生 yield 时，CRT stack 被破坏，该 coroutine 下次被 resume 的执行地址由 u.c.k 来承担。详见《 Programming in Lua（三）－ Yields in C 》。\n这里值得多说一句，为什么在 C 函数中执行 yield 会破坏 CRT stack？上文说过，Lua 的设计主要是 stackless 方式，其具体实现是通过 luaV_execute() 中的循环执行 byte code，通过额外数据结构 (其实是双数据结构) 而非 CRT stack 来维护 call stack。但在 resume coroutine 时，luaV_execute() 间接地递归调用自己并在 callee 的循环中执行 resumed coroutine。也就是说由 CRT stack 来维护 coroutine 上下文切换。Yields 的机制是 longjmp 回到 luaV_execute() 函数递归调用自身的下一条指令 (虚拟机的 native 指令而非 byte-code 指令)，同时把 CRT stack 恢复到 resume 前的状态。所以 yields-in-C 会破坏 C 函数的 call stack。\n\n尽管 coroutine 涉及了对 CRT stack 的操作，但是和 error 一样，仅限于 ANSI C 支持的 longjmp，不会破坏 Lua 虚拟机的跨平台性。问题是，为什么 Lua 要在总体的 stackless 设计中制造这个 stackful 例外？首先退一步说，即使采用 stackless 方式实现 coroutine 切换，仅仅能避免在 yields-in-byte-code 中使用 longjmp，仍然无法避免在 yields-in-C 中使用 longjmp。这是因为，虽然不再有必要 longjmp 回到最近一次 resume 之处，但是仍然需要从 yield 之处回到最近的 Lua 虚拟机代码。不仅如此，stackless 方式还要给 resumes-in-C 引入类似的 longjmp (因为不再利用 CRT stack，所以 resumes-in-C 也必须立即回到 Lua 虚拟机代码)，破坏调用 resume 的 C 函数的 call stack，给 resumes-in-C 加上同现在的 yields-in-C 一样的局限性。而现在的 stackful 方法则完全没有这方面的问题。这正是无需 lua_resumek() 的原因。Stackful coroutine 是一个非常巧妙的设计。\n\n2013/05/09\t Leave a reply\nProgramming in Lua（四）－ Nil 和 List\n\n粗浅地看，Lua 的 nil 很容易被等同于「无」。如下面这段代码：\n\nfunction r_nil()\n    return nil\nend\n\nfunction r()\n    return\nend\n\na = r_nil()\nb = r()\n\nprint(a .. \", \" .. b)  -->  nil, nil\n尽管函数 r_nil() 和 r() 的返回语句分别带有和不带有 nil，接受它们返回值的变量 a 和 b 的值都是 nil。另一个例子是 nil 对 table 的作用。\n\ntab_v = { attr1 = 1, attr2 = 2 }\nfor k,v in pairs(tab_v) do\n    print(k .. \", \" .. v)\nend  -->  attr1, 1\n     -->  attr2, 2\n\ntab_v.attr1 = nil\nfor k,v in pairs(tab_v) do\n    print(k .. \", \" .. v)\nend  -->  attr2, 2\n将 table 的一个 field 赋值为 nil 不仅仅改变其值，而是让这个 field 本身消失了 (这个例子中是 field attr1)。\n\n分析 nil 的实际含义可以从 Lua 的另一个比较特殊的概念 —— list 入手。List 的特殊性在于它不是 first-class 类型。「First-class」是动态语言中常被提及的概念。编程语言有越多的构成元素符合 first-class 标准，其概念模型就越一致、越简单。Lua 的基本数据类型 (包括 nil) 和函数都符合 first-class。满足 first-class 标准通常有四个要求：\n\n可以被赋值给变量；\n可以作为参数；\n可以作为返回值；\n可以作为数据结构的构成部分。( 注意 nil 并不完全符合这个要求，但是可以通过某个 field 的缺失来表示 nil。)\n在《Programming in Lua, 2ed》的第 5.1 节提到 list 只能用于四种情形：\n\nThese lists appear in four constructions in Lua: multiple assignments, arguments to function calls, table constructors, and return statements.\n\nList 有两种具体的表现形式，一种是用逗号分割的一组表达式，表示一个具体长度的 list；另一种是三个点构成的省略号 (...)，表示其长度和内容不定。第二种表示方式不能用在 multiple assignments 的等号左方，也不能创建新 list，只能从函数的形式参数列表中获得。由此可以看出，list 不符合 first-class 标准：\n\n它的部分内容可以赋给几个变量，但本身不能作为整体赋给变量；\n它是参数列表的全部或一部分，但不是任何参数 (注意两者的区别)；\n它不能作为数据结构的构成部分。注意，「...」不能作为 closure 的 upvalue。用 first-class function 存储 list 的方式行不通。\n作为非 first-class 类型，list 无法被生命周期较长的数据结构存储。短期的完整传递 list 的内容只能利用函数调用/返回的方式：\n\nfunction f_outer(...) -- important: f_out() must accept\n                      -- \"...\".\nend\n\nf_outer(f_inner())\n-- pass the list returned by f_inner() to\n-- f_outer() as the latter's argument list\n\nf_outer(1, 2, f_inner())\n-- pass f_outer() a new list, which is \"1, 2\" appended\n-- by f_inner()'s returned list\n\nfunction f_caller(...)\n   f_callee(...) -- pass argument list of f_caller()\n                 -- to f_callee()\n\n   return f()    -- pass list returned by f() to one\n                 -- level up\nend\n另外还有一些反例：\n\nfunction f_caller(...)\n   a, b = ...   -- not pass a list, \"a, b\" is\n                -- a different list of two elements\n                -- obtained by adjusting the \"...\",\n                -- and this list is very short-live,\n                -- existing in this line only\n\n   tab = {...}  -- not pass a list, tab won't\n                -- have fields for nils in the \"...\"\n\n   local function test(a, b)\n   end\n   test(...)    -- not pass a list, test()'s\n                -- argument list accepts only the first\n                -- two items of \"...\"\n\n   for i in ... do  -- the \"for\" uses only the first\n                    -- three elements in \"...\"\n                    -- (two accepted by for internally,\n                    -- and one received by i)\n   end\nend\nList 会成为 Lua 中为数不多的非 first-class 类型是因为它实际代表了 stack 上的一段数据。一般只有动态分配的数据能作为 first-class 类型，操纵 stack 上的数据则只能通过函数调用的参数和返回值等有限的方式进行 (这也是因为 stack 在一定程度上代表了程序的 continuation)。不过在其它语言中，stack 的内容并没有被抽象为类似 list 这样可以被操作 (尽管不能像 first-class 类型那样自由地操作) 的概念。因为 Lua 提供了多返回值，鼓励可变参数以及参数/返回值和 table 的互相转化，特别是它著名的 C 接口就以 stack 为中心来设计，所以它有了独特的 list 概念来操作 stack。\n\n如果在 Lua 中一定要将 list 和 first-class 混用怎么办呢？比如说，一个函数返回的 list 通常还是要存储在变量中，或者应用在某个表达式中。这是上面的反例代码中已经提及的机制 —— adjustment。Adjustment 并不是真的传递一个 list 的内容，而是用一个 list 的内容构建另一个新的 list。当新 list 的长度小于原 list，多余的值被丢弃，当新 list 长度大于原 list，就用 nil 补齐。\n\nLua 的 nil 担当了三种角色：\n\n一般的数据类型，通常标志某种特殊情况 (应用或算法本身的特殊情况，而非语言的特殊情况)。\nTable field 的删除器。\nList adjustment 的补全值。\nLua 的 nil 不代表「无」，反而恰恰起到了「有」的作用。在应用 adjustment 的情况下，我们往往用新 list 末尾的 nil 来判断原 list 的「无」。这个做法有一个缺陷：无法辩别原 list 末尾本来就确实含有的 nil。如果需要区别对待 list 结束和 list 本身含有 nil 这两种情况，既可以自行编写 C 代码来检测 stack，也可以使用 Lua 现成的 API select()。回到第一个例子，稍加修改就可以区别两种情况：\n\nfunction r_nil()\n    return nil\nend\n\nfunction r()\n    return\nend\n\na = select(\"#\", r_nil())\nb = select(\"#\", r())\n\nprint(a .. \", \" .. b)  -->  1, 0\n下面是精确区别 list 结束的一个实际例子 —— 关于 stack 的递归终止条件。若希望一个函数对它的 argument list 中的每个参数执行 op() 操作：\n\nfunction map_list(op, ...)\n    if select(\"#\", ...) == 0 then\n        return\n    else\n        local a = ...\n        return op(a), map_list(op,\n                               sub_list(...))\n    end\nend\n函数 sub_list() 返回的 list 是其接受的 argument list 去掉第一个元素。这个函数的实现如下 (如果用 C 语言来实现会更简单)。如果 op() 允许接受 nil 并且在此情况下返回有意义的值，或者 map_list() 接受的 list 在中间含有 nil，那么 map_list() 的递归终止条件就必须基于 select() 而不可以基于对 nil 的判断。\n\nfunction sub_list(...)\n    local list_start\n    function list_start(start, ...)\n        if start > select(\"#\", ...) then\n            return\n        else\n            return select(start, ...),\n                   list_start(start + 1, ...)\n        end\n    end\n    return list_start(2, ...)\nend\nList 是 Lua 中最不符合 first-class 的数据类型。但由于其不能作为变量但可以被函数的返回值构建的特性，List 反而可能是 Lua 中最纯粹的 functional programming  元素。放弃 table 而完全用 list 来编写 Lua 程序也许是把 Lua 转化为一种 FP 语言最简单的手段。\n\n2012/12/22\t Leave a reply\nProgramming in Lua（三）－ Yields in C\n\nHandling Yields in C 是 Lua 5.2 的重大改进之一，最早从 blog《Lua 5.2 如何实现 C 调用中的 Continuation》了解到。这些资料围绕新 API lua_yieldk，lua_callk，和 lua_pcallk 来介绍这个新特性，自然有很多关于新增加的 continuation 参数的讨论。其实以 continuation 参数作为切入点介绍 yields-in-C 容易混淆问题的实质。首先回顾一下《Programming in Lua, 2ed》(中文版) 中的一段话 (第 30.1 章)：\n\nThe only way for a C function to yield is when returning, so that it actually does not suspend itself, but its caller — which should be a Lua function.\n\n这段话针对 Lua 5.1 而写，当时尚无 continuation 参数。严格地说这会误导读者。根据描述本身，可以理解为 Lua 无法在 C 代码中 yield (包括被 C 代码再次调用的第二层 Lua 代码以及之后的 stack 上更深的执行层次) 是因为无法纪录这种情况下 resume 所需的信息 —— C 代码的 stack 和 program counter。这种解释的推论是，在 C 代码即将返回 Lua 前，由于 C stack 已经恢复为调用前的状态 (可以称为「空 stack」)，program counter 也处于即将进入 Lua 代码的状态，所以可以调用 lua_yield。原理上这个结论可以推广到 lua_call/lua_pcall。如果程序在 Lua 和 C  代码之间调用切换多次，整个 virtual stack 上的 Lua 部分的 stack 会被 C 代码分割成若干段。不过只要这三个 API 总是在 C 代码即将返回 Lua 前被调用，那么这些 C stack 都是空 stack，Lua VM 只需知道 C 代码在 Lua stack 段间的位置，不需要实际纪录 C stack/program counter 本身的内容。「在多于一层 C/Lua 切换的情形下 yield」应该正常工作。\n\n问题是 Lua 5.1 不支持「在多于一层 C/Lua 切换的情形下 yield」！\n\n根据上面的分析，这个限制并非 Lua 语言或 C API 本身的设计所固有，它是一个纯粹的 VM 实现问题。也就是说，即便 Lua 在 5.1 之后不引入 continuation 参数，保留「lua_yield (以及 lua_call/lua_pcall) 只能在即将返回到 Lua 之前调用」这个限制，也还是可以支持从 C 或者从第二层及以上的 Lua 代码中 yield。\n\nLua 5.2 实现了「在多于一层 C/Lua 切换的情形下 yield」，这是一个 VM 内部改进，仅仅为此并无必要引入 continuation 参数。 Continuation 参数解决的是另一个问题 ——「Lua 无法跟踪程序在 C 代码中的 stack 和 program counter」，但仍保留诸多限制：首先，它无法解决纪录 C stack 的问题，所以，仍然不允许在 C stack 上有多于一层 C 函数时调用新 API；其次，它也无法纪录 program counter，编写 C 代码时必须手工把可能发生 yield 之后的 C 代码 factor 到一个单独的 C 函数中，通过函数分割这种变通方式部分的模拟 yield 时的 program counter。由于没有真正的管理 C stack，充当 continuation 参数的 C 函数在运行中不能依赖 caller 的 C stack (实际上这个问题不大，因为它只能接受一个 lua_State 结构)。最后，仿照某些评测给 Lua 5.2 的新特性做一个「优雅 / 有待改进 / 丑陋」的总结：\n\n优雅\n\n实现了「在多于一层 C/Lua 切换的情形下 yield」。对于「Lua 无法跟踪程序在 C 代码中的 stack 和 program counter」这个问题的剪裁得当，既扩大了支持的应用场景，放松了对 C 代码的限制。同时避免了编程接口过分复杂化，和使用底层 C runtime 机制破坏 VM 的跨平台性。\n\n有待改进\n\n文档没有分别说明两个问题，混淆了 VM 内部实现的改进和 API 改变的原因。\n\n丑陋\n\n新 API 在 continuation 参数为 NULL 时沿袭旧 API 的限制 —— 禁止在多于一层 C/Lua 切换的情形下 yield。这是不必要的，也是混淆两个独立问题的误解最大的来源。现在，对于那些已经在「即将返回 Lua 之前」被调用的 lua_yieldk/lua_callk/lua_pcalk，也必须传入一个 no-op 的 continuation 函数。不过，Lua 5.2 的发布已经有段时日，估计这个 API 上的小问题也不会再未来更改了。\n\nProgramming in Lua（二）－ 异常与错误码\n\n我不喜欢编程语言用「异常处理 (exception handling) 」的方式处理错误。从以往经历看，先有 C++ 创造了最差的异常实现 —— 没有 GC 帮助内存管理，扰乱 C 的二进制接口 (Application Binary Interface, ABI)。为了绕过这个拖累，维护 C++ 代码往往要花费双重开销来完成没有异常的语言可以免费获得的东西：code review 必须保证代码的「异常安全 (exception-safty)」[1]，同时不写会抛出异常的新代码。\n\nJava 提供了 GC，解决了安全实现异常处理最大的的先决条件。不过凡事皆 checked-exception 的方式令人毫无好感 [2]。Objective-C/Cocoa 中没有跨越 block 的异常机制，基本上采取传统的返回错误码方式，让我舒了一口气。但是接下来，Lua 通过 longjmp 实现跨函数的类似异常处理。一方面，让我怀疑 Lua 以简洁著称的设计是否在这点上采取了错误方式；另一方面，longjmp 并未实际引起麻烦，让我好奇异常处理是否也有某些价值。\n\n异常处理和传统的返回错误码 (error code) 两种处理错误的方式是一场持久的争论。就在最近，围绕 Go 语言完全抛弃异常处理的语言特性，《Why I’m not leaving Python for Go》的作者表了极大失望。\n\nRuss Cox 针对上文为 Go 语言进行了辩护。其中提到了 Raymond Chen 两篇旧日的 blog：\n\n《Cleaner, more elegant, and wrong》\n《Cleaner, more elegant, and harder to recognize》\nRaymond Chen 用严密的逻辑和实例说明了编写正确异常处理的代码 [3] 非常非常困难。特别要注意 (但不限于) 以下两点：\n\n正确管理资源，特别是资源的回收；\n关键数据的修改尽可能滞后。在中间可能抛出异常的步骤中，随时保证数据处于一致 (integral) 的合法状态。\n关注第一点也许会令人假定，如果程序不涉及内存以外的资源，并有成熟的内存管理机制，就足以保证写出正确的异常处理代码。毕竟把异常处理放到 feature list 中的语言无不首先重视提供 GC 机制。由于需要根据异常的 stack unwinding 情形考虑内存回收，这些语言一般采用 root-tracing GC 而非 ref-counting [4]。但是，将资源管理局限于内存并不足以对第二条豁免，比如复杂的图结构 (graph structure)，或者更常见的情形：对象需要向多个相互关联的全局表注册自身的引用。而且话说回来，「纯」内存数据操作除了内存用尽 (out of memory) 之外又有什么值得担忧的错误需要处理呢？归根结底异常处理是一个主要面向 I/O 问题的机制。\n\n在「纯」内存无 I/O 的环境下，能体现异常处理价值的领域并不多，仅存的适用领域之一是语言虚拟机。这正是 Lua 采用 longjmp 类似异常处理的原因，主要用于类型检查和数组越界等语言虚拟机问题。而且这时处理的错误往往不是最终产品代码 (production code) 期待的行为，并不真正用来弥补错误，只是起一些辅助作用，比如揭示 bug 和收集诊断信息，防止应用完全退出，在多文档应用中让用户有机会保存其它信息，或者让应用以 reset 之后的状态接受其它请求。类似于 Go 中的 panic 机制和 Java 中的 runtime-exception (unchecked excpetion)。\n\nGC 虽然是实现安全的异常处理机制的先决条件之一，但只是朝向最终解决问题的很小一步。因为真正能体现异常处理价值的地方是 I/O 密集程序。有哪些 I/O 机制目前可以做到「关键数据的修改尽可能滞后。在中间可能抛出异常的步骤中，随时保证数据处于一致的合法状态」呢？作为 naive 的尝试，C++ 提出了 RAII。但是很遗憾，异常安全的需求明显超出了 RAII 的能力。除了关系型数据库事务处理 (RDBMS transaction) 的二步式提交 (two-phase commit)，我不知道还有什么 I/O 机制满足这个要求。也就是说，在日常需要的软件工具中包括图形化窗口化 UI，网络，打印等等常见 I/O 操作中，只有纯粹的数据库 CRUD 系统这个特殊领域适于异常处理机制。正因为如此，非数据库的 I/O API 的错误处理都应该采取返回错误码形式。特别是，以异常处理文件访问错误的 API 都是失败的设计 [5]。Java 正是被鼓吹适合数据库 CRUD 领域，所以其异常处理机制获得了一些正面评价。但是当其野心不限于此时，将仅限于数据库领域用的还不错的异常处理机制匆忙的推广到其它问题就招致了恶名。\n\n某些系统通过异常处理或者类似异常处理的机制来解决某些问题，而且解决得还不错。这是它们的设计者针对一些能体现异常处理价值的特定领域选择的方案。这些成功案例并不能简单地推广。保守地说，要采用异常处理，必须保证所有资源置于二步式提交的事务管理之下；或者限于虚拟机内部对类型检查等非 I/O 操作的「粗粒度」错误处理。「粗粒度」表示一旦发生错误，系统采取的应对策略是放弃整个粒度较大的操作，异常处理仅仅保证程序不退出，收集 bug 诊断信息，或者保留机会处理其它请求，而不是去弥补刚发生的错误。特别是对于 Lua，这个问题还有一层含义。Lua 允许用 C 编写扩展。这种情况下要把基于 longjmp 的异常处理部分限于开始的参数类型检查，置于触及关键数据和 I/O 操作之前，一旦 C 代码涉及了实质的数据和 I/O 操作，错误处理方式就必须变为返回错误码机制。Lua 支持多返回值特性正是为返回错误码方式的应用提供便利。显然，Lua 的可扩展性也是其基于 longjmp 的机制彰显天下的原因，对于 Java 来说，虚拟机内部的具体实现和使用它的程序员是毫不相关的。\n\n脚注：\n\nC++ 中所谓的「异常安全」也不过就是尽量使用 on-stack 对象 (以及基于 on-stack 对象的「智能」指针) 和 RAII (下文还有涉及) 而已。\n错误处理有经常被人混淆的两个方面。一是如何保证程序员不忽略可能的错误；二是在程序员意识到可能的错误时，如何编写正确的处理代码。本文只讨论第二个方面。因为，如何「不忽略可能的错误」属于程序员掌控应用逻辑的问题，已经超出了编程语言的能力。Java 的 checked-exception 试图用语言解决这个问题，但是即便是 checked-exception，也允许程序员相当容易的把异常遗留给上层 caller。其结果是，越多的错误集中在一处处理，而且远离错误发生的地点，这段异常处理代码的正确性就越难保证 (或者这段代码除了 crash/quit 无法做任何其它有意义的工作)。也许，这正是没有任何其它语言借鉴 checked-exception 机制的原因。\n注意这里的「异常处理的代码」指程序员用具备异常处理机制的语言编写处理实际错误的代码，不要和异常机制本身的实现混淆。\nObjective-C/Cocoa 舍弃异常处理的可能原因之一。另一方面，如果在 stack unwinding 时进行特定的处理，也可以用 ref-counting GC 配合异常。比如 C++ 调用 destructor 以及由此衍生的「智能」指针，还有 Python 的机制。但是我不喜欢这种将 unwinding 复杂化的机制。\n导致每行一个 try-catch block。\n","modified":"20180406121530000","tags":"lang"},
{"created":"20190708121530000","title":"感悟项目开发和问题分解","text":"\n最近做完两个网站类项目，流程还是很有必要的。一个功能从产品经理构思，到UE/UI设计交互，到程序员编码，到最后测试反馈是一个完整的闭环，谁先谁后，哪个时间点做什么都有讲究。\n\n立项初期，往往是产品经理和系分先讨论大致思路和技术可行性和选型，等思路确定后，就将交互告知UE，UE/UI具象化后提供给开发，开发听完后再给项目经理/系分做反串讲，同时测试要在场，确保实现和测试验收依据不会偏离，整个开发过程由项目经理跟踪进度。\n\n一个需求从诞生到验收，大约经历以下步骤\n\n# 产品经理构思，并在纸上给出交互，系分确保技术可行性（所以产品经理通常要会Axure）\n# 产品经理把想法告知UE，UE给出更完整的交互作品，并知会UI，确保风格一致\n# UE评审交互流程，开发介入并理解需求。后端构思接口，前端确保交互可行性，UI出素材\n# 开发反串讲，和测试确保理解一致，技术问题找系分确认\n# 开发编码实现自测\n# 转测试验证、提单修改或裁决\n\n!! 问题决策经过\n\n讨论两个平台功能，不仅给答案，还给出整个解决思路的做法，看起来简单，但并不是人人都会的，尽管看来很平凡，却需要多年反复实践。比如一个变量名优先级取舍，看起来是策略问题，其后确是程序设计领域有指导性的理论在指引，甚至最后结束，突然想到输出变量的命名空间归属，并不容易想到这件事","modified":"20190708121530000","tags":"design"},
{"created":"20170905121530000","title":"给应届生出题看指针的易错点","text":"\n上周领到给18届毕业生出题目，我被分到OS方面的基本题和两道编程题，基本题不能简单考能查到的题目，最后出了几个Linux偏操作的题目。两道编程题中有一题，在自己实现时遇到了两个指针方面易错点。\n\n题目是这样：N个人排队，每个人都有个编号（数字），要求排序后让这些编号连在一起之后组成的那个整数最小\n比如 14  78  132  56  8，排列后的顺序是132 14 56 78 8。这道题目难点并不在排序算法，主要是看能不能读懂排序比较函数，比较两个字符串，首字母小的认为小，如果前N个字母一样，先结束的认为小。\n\n我在提供标准答案时，直接用C语言的qsort函数，原型是这样 `void qsort( void *buf, size_t num, size_t size, int (*compare)(const void *, const void *) );`\n\n第一个参数显然要对数组排序，因此排序`*`后，void就要换成元素的真实类型，比如这道题目是`char*`，第二、三元素很好理解，重点在第四个函数指针的原型，刚才已经分析过，真实元素类型是void，对比函数原型是`void*`，说明函数参数要多一重指针，即`char*`传到比较函数时时`char**`，这个开始没发觉，反复调试并才意识到错误。\n\n再就是比较函数，这道题是比单个字符，如果两个字符串是`char *p1, *p2`，开始我用了`p1-p2`，并误以为是字符串首字母比较，其实从类型看到，相减的是`char*`即指针地址，这样比较结果不会影响数组排序，原因就是比较指针地址当然不可能影响排序，所以比较要用`*p1-*p2`才能得到想要的结果。","modified":"20170905121530000","tags":"lang"},
{"created":"20190815121530000","title":"公安数仓总结","text":"\n和阿里建设大数据为了提高转化率留存率不同，公安并没有明确的提高指标，而是建立尽可能完备的数仓，在遇到案件时能尽量多地挖掘出可能有用的信息。\n\n!! 数据中台\n\n中台是在数仓上的概念，为了应对业务变化快速，基于数仓的宽表去碰撞出更有效的数据。\n\n建设数仓的工具计算平台，整合各种工具，如采集kettle、计算MPP、Hadoop或Spark，调度XXL.job，并辅以运维监控，提高项目落地速度。\n\n!!! 数据组织\n\n数据元（公安另外定义的数据基本单位）：DE开头，如DE90088 事权单位代码。有类型和长度，但编辑点开没有具体的值。通常是选择关联字典表，数字编号和关联的字典相同。有近1500条数据。\n\n数据字典：DM开头，遵照规范复制得来的字典，有发布按钮。可以编辑或删除字典值\n\n逻辑模型：台州分5大类，新增逻辑模型可以认为是一张表。可以开启分区，这个功能不明白。模型的每个字段可以和数据元关联\n\n* 原始数据 STG    Stage，通常是原始数据的镜像，台州未见STG\n* 基础数据 ODS    逻辑模型没有，但物理表有ODS，计算平台部署在公安网，直接从公安Oracle原始库拉。和原始采集对象对应的表，会做字段全名标准化\n* 明细数据 DWD    旅馆基本信息 常住人员信息 接处警反馈信息。从ODS经过去特殊字符，全角转半角，字典转换得来\n* 融合数据 DWS    主题表 or 中间表，比如 人员主题表·人员主题中间表 车辆主题表 车辆主题中间表\n* 应用数据 ADS    暂未开始建设业务库\n\n对一些有图片或长文本的数据，需要由8902先写入云存储，得到云存储地址再导入kafka，最后被中台消费。8902会做轻度清洗，包括1. 字段名重映射 2. 从源数据摘取一部分关心的数据。\n\nDWD明细物理表，前缀都是`dwd_`。每张表涵盖一类原始库的内容，比如卡口设备信息、旅馆入住信息\n\nDWS主题物理表，前缀有`theme_`(主题)和`res_`(关系)两种。\n\n部标定义7种主题。相关性含关联和关系：物品要素关系、人员要素关系等很多种。\n\n每种类目包含的表数目不一样，`theme_`类目开始是4张表，后来改成3张表。比如人员、车辆、设备、警情。有1个主题表和3个对应的中间表，分别是主题中间表、主题数据中间表、主题元数据中间表。最终给业务方的是主题表，其它3张中间表是在生成主题表过程中产生的副产物，具体流程附后。\n\n`res_`类目2张表，比如主题对象关系、物品要素关系、物品要素关联、案件要素关系、案件要素关联、人员要素关系、只有关联表和1个中间表。\n\n人员主题表 含有具体的年龄、性别、身份证号、出生日期信息\n\n主题中间表：惟一标识、一级描述维度、二级描述维度、属性标识符、属性代码、属性中文名称、属性类型、属性值\n\n主题数据中间表： 对象属性标识符，对象属性值，数据优先级\n\n主题元数据中间表(后来被删除了)： 惟一标识、数据元内部标识符、限定词标识符、一级描述维度、二级描述维度、对象属性代码、对象属性代码、对象属性中文名称、对象属性类型\n\n警情如接警来源，报警方式，报警电话，报警地址\n\n逻辑模型的每张表，字段信息要关联数据元(目前没做)\n\n物理模型：加入项目后才能在数据库真正创建。新建物理模型时，可以选择从逻辑模型导入表定义，建表后对应到mpp中会有真实的表，比如：挂号信息增量表 `ods_wjj_wj_ga_ghxx_delta_ds` (保留30天)，每天采集最新的数据入库（要求原始库有标识时间的字段，否则要自己分析），和 `ods_wjj_wj_ga_ghxx_ds`(保留7天)。dd表示每个分区放完整数据，ds表示每个分区放增量数据。\n\n!!! 数据接入\n\n离线数据(历史数据)用DataX，增量数据中台直接连业务库。输入表属性 增量 增量字段 ETLTIME，没有增量字段的话，用触发器导出流水表。\n\n采集配置 `conf_wjj_wj_ga_ghxx_zl` 输入 `wj_ga_ghxx` ， 输出 `ods_wjj_wj_ga_ghxx_delta_ds`。每天都有增量数据，所以表名`delta_ds`。\n\n采集管理 `job_wjj_wj_ga_ghxx_zl` 关联配置 `conf_wjj_wj_ga_ghxx_zl`\n\n!!! 数据开发\n\nODS环节，会从增量数据汇总到历史表， 示例: `INSERT INTO _ds() SELECT DISTINCT FROM _delta_ds WHERE`\n\n数据开发DWD环节，数据清洗示例\n\n`INSERT dwd_ghxx_ds SELECT DISTINCT string_agg(), min() from ods_wjj_wj_ga_ghxx_ds`\n\n`INSERT dwd_rk_wjj_ghxxb_ds SELECT uuid() FROM SELECT cls_special_character(清洗) / CASE WHEN ELSE END FROM ods_wjj_wj_ga_ghxx_ds LEFT JOIN dwd_rk_wjj_jzryxxb_dd(就诊人员信息表) LEFT JOIN dwd_jg_wjj_yyxxwdb(医院信息维度表)`\n\n类似的出院信息只看到 INSERT 一张表，可能没完成？\n\n!!! 建议\n\n* 生产和开发项目要隔离。\n* 表名后台保存是全小写，但前台显示的是用户输入名，要统一。\n* 开发模块的连接线不能编辑和删除\n* 开发面板的高亮功能不友好\n* 数据巡检要依靠人，不能做到机器报警\n* 迅飞的平台分成8个子平台，可以考虑分拆\n\n!! 业务概念\n\n公安部标对自身业务有明确定义，有原始库，资源库，主题库，非常详细到字段级(类似传统DWS)，最有用的业务库并没有详细定义，只要求数据向上级单位汇总。\n\n数据开发有两种\n\n# 传统数仓的清洗。 有1或2个步骤，ODS和DWD。 ODS做增量处理，数据不能丢(是不是采集模块做的事？)，DWD做维度退化(把外键关联数据回填到一张表)和标准字典(不同的数据源，字典定义不同，归一化处理)\n\n# 从各种业务表提取主题表(有虚拟节点start、join)。流程： DWD ->(行转列操作) 主题数据中间表datamanager_tmp ->(列转行) 主题中间表data_tmp ->(通过优先级合并，会用到rand窗口函数) 主题表data_result\n\n!! 现场困难\n\n数据治理 架构（4人）-> 接入(3人) -> 分析(2人) -> 开发(5人)\n\n接入时，用户会很随意，提的需求和表名无法对应，依靠分析团队猜测和定义。\n\n!! 警务业务和图库\n\n对数据的利用，有三大方向\n\n* 实体画像：打标签，分析出实体各种维度的属性\n* 人物扩线：找出和某人有关联的人员列表，最好排序\n* 时空复现：找到某人的出没瞬间，还原出前后时间空间上的轨迹\n\n图谱的典型应用场景（搜索、问答、决策、推荐）来说，我觉得存在如下分析：\n\n决策（情报）、推荐更强调的是关系密集型，是图结构的关系连接，是网络特性；\n搜索、问答则更强调语义规则，强调语义精准性；\n\n所以关于情报决策以及推荐类的应用可能使用属性图更合适，而搜索、问答类的应用使用更完整的知识图谱则显得更靠谱。","modified":"20190815121530000","tags":"design"},
{"created":"20221201121530000","title":"公私钥格式的认识","text":"\n公私钥对做为一个概念，最后一定会有形式用来记录与传输，以RSA为例展开讲讲。\n\nRSA公钥由n和e两个数字构成，e通常是65537，重要的是n，这是一个非常大的质数。一些函数库会用类甚至数组来表示RSA公钥。但这只是内存中的表示，并不适合序列化，又分ssh和ssl两个流派，而ssh的两个版本又不同。\n\n!! SSH-1\n\nSSH 1协议只支持 RSA 算法，所以公钥也为RSA特化，格式为所有字段以单个空格符分隔，各字段依次为选项、位数、指数、系数、注释。第一个字段是可选的，表示该条目（行）是否以数字开头，选项字段不会以数字开头。最后一个字段注释，如果在生成密钥时没有给定注释，默认注释为密钥的创建者，注释仅仅是提供给用户查看密钥时作为一个辨识标记，在 SSH 使用中没有任何作用。\n\n```\n2048 65537 1234 username@hostname\n```\n\n!! SSH-2\n\n非对称加密肯定不能局限于RSA，所以公钥格式也做了改变。所有字段仍以单个空格符分隔，各字段依次为选项、密钥类型（keytype）、base64编码后的密钥、注释。第一个字段是可选的，表示该条目（行）是否以数字开头，选项字段不会以数字开头。最后一个字段注释同样只起提示作用。\n\n密钥类型（keytype）可能是 ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521, ssh-ed25519, ssh-dss 或 ssh-rsa。\n\n```\nssh-rsa AAAAB3 username@hostname\n```\n\n除这种格式外，ssh还支持IETF SECSH 公钥格式，像这样\n\n```\n---- BEGIN SSH2 PUBLIC KEY ----\nAAAAB3 username@hostname\n---- END SSH2 PUBLIC KEY ----\n```\n\n!! SSL\n\nssl工具的默认编码方式默认就是这种带BEGIN和END页眉页脚的块，块的内容称为PEM格式Privacy Enhanced Mail，是一种特殊的base64。从两端可以很清楚的看出内容的类型。RSA公钥类型是RSA PUBLIC KEY。没有任何前缀的PUBLIC KEY则代表X509公钥。\n\n!! PKCS#8\n\n私钥可以用PKCS8方式存储。私钥首先会使用PKCS#5的标准进行加密，然后将其进行base64编码，转换成为PEM格式进行存储。\n\n!! 题外话\n\n虽然ssh的公钥格式自成一派，但它的私钥却遵循了PEM格式，标识符OPENSSH PRIVATE KEY。也意味着openssl工具可以操作ssh私钥。\n\nPKCS是Public-Key Cryptography Standards的意思，它是RSA公司提出的公司私有规范，共15条。但由于RSA公司的行业影响力大，部分规范也被RFC和openssl软件支持。除了#8外，#7和#12是影响很大的标准，PKCS12可以看做是PKCS7的扩展，在PKCS12中可以存储证书，私钥或者CRL。和PKCS7相比，PKCS12可以额外存储私钥。","modified":"20221201121530000","tags":"security"},
{"created":"20140712121530000","title":"功能重用与接口设计","text":"\n最近在做内部的维基网站，内容是从Word文档解析然后以页面形式呈现。Word可以导出Html，解析也就是针对Html的标签做些过滤并对需要的内容做分类提取。第一期的工作，原有的协议内容绝大多数是一份表格为一个请求/应答，由于表格和章节号都是一一对应关系，即一个标题下也只会有一张张表，解析的时候，就以表结束作为时机，在此时刻插入数据库。这种做法其实是比较死板的，只适合于这一类文档，当出现一个标题下有多张表格，或是除表格外有文字甚至图片时，就难以处理。虽然这类文档都以网页形式呈现，但其中少量的图片，除非对原有解析代码做伤筋动骨的改动，修改起来是十分困难的。\n\n第二期开始的文档，格式就变得多变了。这时我才意识到，只有以章节标题来划分，才是比较通用的做法。并需要对章节内的信息作归类，把标题下的内容按类别加入数据库，这样才更符合日常的整理思维。\n\n虽然第一期作了很多解析功能，函数却不容易被复用，由于接口的注释不明，或是对入参有些隐含的期望，在第二期的工作时，很多函数看起来能用，却忘记了原先的期望，得到的结果自然也就不正确了。这和我虽然计划要做单元测试，却没有真正去实现也有关系。好在函数本身还是可重入的，补上测试用例，单个都可测，测完补上注释就好。回想起来，接口文档里除了描述接口功能，对出入参的描述也是非常重要的。像Python或者Common Lisp都有函数功能描述的专门语法，是个很好的语言设计。\n\n对于表格的解析，一期的文档是按列解析，而二期的文档由于关联性不强，按行比较方便。按最小功能划分，把功能细分成每个单元格才是最通用的设计。这个编译原理中视单元格为词法，将词法按需要的语法规则拼装是一个道理。\n","modified":"20140712121530000","tags":"design"},
{"created":"20150616121530000","title":"函数参数的传值与传引用及语义","text":"\n一年前因为工作上的需要，把一些文档在Apache上以网页的形式呈现出来，当时为赶着快速上线，就边学PHP边对着HTML语法，用最原始的方式把网站给搭出来了，做完后又忙着其它事，网站就放着没去优化它。\n\n最近偶然看网页时，看到有文章提到PHP的函数是显式区分传值和传引用的，如果不在参数前加上&，就按传值调用。可怜我之前一直以为PHP和Java一样，是自动根据类型做判断，复杂对象类型自动转引用的。结果回头再看代码，大量的数据库中查找出来的记录，在传参时都把array以值的方式复制了一遍再做处理。因为流程是单向的，数据库中取到的数据也就是在网页上展现一下，当时能看到效果就没去深究，才导致这个问题一直过了一年才发现。\n\n今天和大牛聊起这个事情，大牛说学任何语言，第一步就是要搞明白函数的传递模型。在任何语言中，函数都是最基本的抽象单元，一门语言可以没有类，可以没有原生Hash，但一定会有函数。而函数的边界，也基本就是语言的边界了。比如是传值还是传引用，静态词法定界还是动态词法定界，函数是否可匿名等。\n\n简单地记一下，C/C++，PHP默认是传值调用，可以用&显示指定传引用调用。\n\nLua，Python的函数定义中参数没有修饰符，也没有提领提作，因此语法上没有传值还是传引用的区分。数字和字符串出于实现的方便，会被inline，表现出的行为类似传值调用，复杂类型如Lua的table，Python的List、Dict的行为类似传引用。\n\n除函数之外，像foreach的循环，PHP也是可以使用引用的。比如\n\n$vec1  = array([1, 2], [3, 4], [5, 6]);// 此处语法不正确的，只为示例二维数组\n\nforeach ($vec1 as $r) {$r}这里的$r也是值，即使它指向的是个数组，但仍然是复制了一份，不能修改。如果想显示地表示引用，需要写成foreach($vec1 as &$r)。而像这种for循环，在Lua里如果值是简单的数字/字符串，是值类型，如果是复杂结构，就是个引用，可以修改原始值。\n\n以我所知的语言像Java，Ruby，JavaScript都不提供语法级的值和引用区分，当然像Perl这种词法超级复杂的语言是支持通过'\\'显示引用的。\n\n追记：在读R5RS的1.1语义节看到这么一句，Scheme过程的参数总以值的方式传递，即无论过程是否需要实参的值，实参表达式都会在过程获得控制权之前被求值。ML、C和APL是另外三种总以值的方式传递参数的语言。也就是说从Scheme的层面来看，不论是传值还是传引用，由于都是eager eval，都算是Call-by-Value，至于传的是值是引用，都是要计算的。这与Haskell语言懒惰求值(Lazy-evaluation)的语义，或Algol 60语言按名调用(Call-by-name)的语义截然不同。在Haskell和Algol 60的这两种语义中，直到过程需要实参表达式的值时，才会对它们求值。为什么Scheme中不区分传引用和传值呢？一来因为函数式语义，根本就不赞成传引用这种会改变参数的行为，在那里变量只有在返回时才允许被改变，另外Scheme也多少有点脱离实际机器，更偏向于理论研究的语言，那么为了提高速度而只传一个const&的方式，在它的语言规范里也被认为不是必须的，所以没有被记录。因此在Scheme看来，这些过程式语言中传值与传引用的区别，那都不是事，究竟是Call-by-Value还是Call-by-Name才是它真正要关心的语义。\n\n学一门语言，最重要的是学idiom，而最基础的，则是理解函数的行为，是为记。\n","modified":"20150616121530000","tags":"lang"},
{"created":"20170219121530000","title":"函数式和对象式，表达式和语句","text":"\n伞哥在微博提到，ML的函数语法如果有多个参数，当参数没有完整传入时，并不是像Lua/PHP等一样赋值为nill，而是返回一个curry化的函数。这种思路如果移到协议处理上来，和组件化的实现是不同的拆分方式。\n\n协议入口收集所有的参数，如果用curry化的思路，则每个步骤只处理一个参数，然后返回新的函数，并处理剩下的参数。如果第一个参数要做分派，则可能会返回两个不同的函数。通过这种方式，把过程拆分。\n\n如果是对象化的拆分，则根据业务划分若干阶段，每个阶段对应一个类，这种方式不会严格限定参数个数，可能第一次就处理所有的参数。不过函数式其实也可以处理所有参数，返回的函数接收新的参数也无妨。不管怎么样都是一个拆分的过程。\n\n!! 函数式典型函数的理解\n\nscala没有break和continue关键字，因为它并不鼓励中途退出或跳过机制，而应先待循环的数据进行过滤再完整处理。引申出对函数式几个最典型函数的思考。\n\n* filter 传入函数 x => bool，只保留返回true的内容，达到缩减原始数据的效果\n* map 传入函数 x => z，返回一个新的，但长度不变的向量数据集\n* reduce 传入函数 x, y => z，返回一个“标量值”。之所以打引号，是形式上返回的结果可能不是一个简单的数字，但维度上，和原始向量数据的任一项是相同的\n\n如果要取向量的前3项怎么办？这时可以在filter中传入闭包，用闭包的状态是否到3来控制返回true还是false，因此这三个构成函数式处理的完备集合。另外从这种处理方式可以看出，只要顺序迭代器就能满足计算，并不需要随机迭代器，但从处理的便利性和效率上来说，随机迭代器有其不可替代的优势。\n\n对一个数据集做groupBy操作的结果，就是典型的顺序迭代器，一方面不知道总长度，更重要的是内部数据的无序性，导致随机访问没有意义。\n\n!! 表达式和语句\n\n在PL界，不管平时有没有注意，大都会区分expression和statement。expression的定义是计算并返回值，而statement表示操作，对返回值没有要求，甚至干脆禁止。看似都有计算过程，无非是对返回值的区别，但细想下去，如果没有返回值，就只能靠全局变量来通信，显然是不行的。对函数式编程而言，expression是强要求。\n\nJS细分了语句和批语句，批语句必须有{}，典型如switch,try,catch,finally。而像if,for,while都可以省略。Lua严谨，只有批语句的概念。\n\n最直观体现两者区别的就是赋值。lua或python的赋值是statement，没有返回值，因此print(a=1)会报语法非法。而C、JS则把赋值后的左值返回，python3.8也加入了:=，使赋值成为表达式。还有scheme的set!实现了赋值，但返回是未定义值，可以打印但无意义。\n\nLua的函数返回0到多个值，而JS的函数只能且一定会返回一个值。返回多值的函数如Lua和Go，一种惯用法是返回值第一个为bool表示成功或失败，剩下的是实际需要的返回值。而JS和PHP都只能返回单值，加上JS的函数签名不支持显式引用，如果JS要从函数出参取值，只有使用对象才可以。","modified":"20170219121530000","tags":"lang"},
{"created":"20190108121530000","title":"环境变量的继承","text":"\n操作系统有一片空间保存环境变量，我猜测这只是一片只读空间，每次用户登陆会创建一个会话，这个会话首先继承了全局的全局变量，如果脚本中export了某些环境变量，会作用到这个环境，但是其它用户登陆后，完全不受影响。\n\n典型的同一个账号，先export A=123，另一个会话也指定export A=456，不会影响前一个会话，这是两个完全隔离的会话。export的效力仅及于该此登陆操作。\n\n再看看同一个会话中启动一个shell进程会如何。每个shell创建的进程，除了argc, argv 就是env了，父子间的env到底能不能打通呢？事实表示，父改了，子会受影响；但子改了，父是感知不到的。\n\n如果不考虑fork子进程，仅仅当前环境使用的话，不需要export，仅使用 A=123 就会在当前环境创建变量，只是子进程无法看到这个变量罢了。\n\n综上export不是定义环境变量必须的语法，只是为了让子shell能感知到，将环境变量**提升**到可被子shell感知到的区域。\n\n说了shell顺便说说tty和terminal这两个概念。远古时代的计算机需要穿孔打印机和纸带进行操作，自从有了电传打字机，打字机输入，输出会打到纸上，虽然有些费纸，但已经比纸带有了巨大的进步。大型机体积巨大，但多人需要使用，所以每个人看到的就是terminal，tty算是最原始的终端形态。\n\n打印到纸上也勉强能算，毕竟不方便，随着70年代末出现的CRT显示器，terminal更多地被用于video terminal的简写。至于现在的软tty，包括各种stdin, stdout只是保留这个概念，形式上已经差别很大了。","modified":"20190108121530000","tags":"os"},
{"created":"20171015121530000","title":"回看晚清七十年历史","text":"\n小时候因为清朝是满族统治关系，非常不愿意学。现在回看这段整个民族在转型过程中的历程，颇为沧桑。\n\n晚清的界定通常从第一次鸦片战争开始，到辛亥革命共七十一年。对个体来说这就是一辈子了，不能简单的把这么长一段岁月用一句苦难深重就带过了。我觉得这七十年分三段去描述。三个节点分别是第一次鸦片战争、第二次鸦片战争和中日甲午战争。\n\n第一次鸦片战争打开国门并开了五口通商，但朝野上下并没有深刻的震动，因为仗是在广州打的，开放的口岸也在长江以南地区，离北京太远，虽然领教了坚船利炮仍没有自醒。所以到第二次鸦片战争期间二十年，没有引起改革。倒是这场仗后十年的太平天国运动还更引起朝廷的重视，战争持续了十余年，人口大减，武汉更因三次攻防战彻底成为废墟。曾国藩中兴，但我更觉得湘军这种制度创新是这场战争为将来变革留下的伏笔。\n\n第二次鸦片战争则深深地触动了朝廷，这场战争的原因我不了解，不表。这里还有个小趣事，明清两朝都是一帝一年号，但同治在正式改元前还另有个祺祥年号，不过只用了咸丰死后剩下的半年，改元后用了同治，此后慈禧登上历史舞台。这场战争后，清廷才真正被打醒并开始走上变法图强的路子，洋务运动就此开始，不仅开始追赶科技，在国政上光绪年间收复了新疆并正式改为郡县制(之前一直是伯克制，有点像改土归流)，还神奇地从毛熊手上通过谈判拿回了伊犁，1883年更是和法国人打了一次少有的胜仗。后世称这段时间为同(治)光(绪)中兴，如果不是后来的甲午战争，还真是中兴了。\n\n甲午之败，导致全国上下的震动，所有人都陷入了怀疑，到底怎样才能真正走向强大？之后经过戊戌变法，还是无可避免地发生了庚子国变(八国联军)，此仗在南方各省引发的东南互保致中央威权消解，虽然清廷努力地改革新政，但大势已成，最终在十年后武昌起义导致了清帝的退位，从此进入了更为动荡混乱的民国时期。","modified":"20171015121530000","tags":"think"},
{"created":"20171205121530000","title":"几个安卓ROM的体验报告","text":"\n因为手欠把flyme的stk.apk(SIM程序)删除之后，一直报com.android.phone停止运行，加上flyme用了两年也有些厌倦，TCL M2M这款机型各路网上爱好者做了很多ROM适配，故得以把几大主流厂商的ROM都体验一遍。机型为4.4，各ROM普遍是15年的版本，不新但能体验出很多差异。\n\nFlyme用得最久的系统，界面小清新风格比较对我的胃口，悬浮球是大特色，不过用起来总感觉会误触，还是关了。操作比较方便，各种UI设计都很赏心悦目(我的感受)，用得最久反而没什么想说的。\n\n锤子桌面，只用了桌面没有适配的ROM，桌面第一眼感觉很新鲜，很有设计感。九宫格布局但不能换壁纸只能换背景配色，用下来最大的不便就是非常耗内存，1G内存会经常出现回到桌面时要等待2到3秒的场景，2G的话会好很多，偶尔也会要等待不到1秒，可能3G内存会杜绝，但没有这样的手机，无法实测。操作上重于点选，对滑动支持很差，新鲜劲过去就不怎么样了。\n\n华为系统，EMUI桌面朴素得没法看，不知道算不算理工男的设计，总之和锤子桌面完全不具备可比性，系统功能也很理工化，但对我来说很贴心，各种流量控制、锁屏提示都很到位，内存管理不错，用了很久之后，清理任务后的内存占用和开机时是一样的，这点其它几个系统都做不到。\n\nOPPO的ColorOS系统，桌面中规中矩，最大的亮点是突出了音乐和拍照。桌面左划就是音乐界面，有个一键HiFi的按钮，开起后声场变大，没有具体的音效设置。打开相机甚至还有相机商店，可以下载自拍相机、慢动作相机等，不过我对相机不感兴趣，看看就好。设置界面划分成3个tab页，声音和显示各占一个，可以算是最日常的功能吧，这种划分对日常使用向的用户来说挺友好的。但开机时内存有1.1G剩余，用到后来不管怎么清理任务栏都只有700M左右的空余。一些小功能屏幕边角向中间划切换为单手模式，比如自带FTP方便的传数据，插入USB口后切换模式直接在通知栏完成，甚至可以选择仅照片模式，都是力求做到对普通用户友好。\n\nViVo的funtouchOS，我是和OPPO进行比较，毕竟这两个品牌的定位比较近似，但实际用下来总体感觉不如OPPO的思路清晰，系统设置的菜单做了些调整，但没有突出重点，把蓝牙藏得很深，也可能这是版本关系，至少从今年看蓝牙耳机非常普遍，因为做为一级菜单。开发者选项只能在拨号盘输入`*#*#7777#*#*`来临时打开一次，每次都要输入如此冗长的一段，不知道意图的是什么。音乐自带了BBE音效，回想起大学时买iRiver的MP3就以BBE为卖点，现在再看这种音效不过尔尔，不过其它系统都没有，也算是在音乐上做了优化。相机可以切换普通模式和专业模式，开放ISO、曝光时间，但是这些参数想来普通用户并不会买账吧。ViVo的桌面可以由用户自己创作，称之为情景桌面，完全看不到图标，只是一幅风景画，但新鲜感过后，还是用图标来得实在，对我来说手机终究是用的，不是看的。\n\n嘉域系统，因为ROM做得比较简洁，没有额外附加的程序，这是我用的第一个设置中直接集成ROOT开关的，可以配置每个程序是否可以访问su，定制度不高，缺少流量管理软件，真正用起来的时候后台程序流量控制不住。只能用原生的流量限制功能，限制流量的坐标轴滑条使用安卓原生，按对数增长，0～100M的操作区间很宽，越往上过渡得越快，比线性数轴要好。不过其它ROM也都一样，不算嘉域的亮点，作为原生系统的亮点也要写出来。\n\n联想ViBeUI系统，本来还有点期待，结果装上后彻底失望，制作者甚至都没有集成输入法，在常规的设置之外另有Tab页，但却都是些快捷操作，比如熄屏时双击home键拍照，甩手机锁屏之类。就是些奇技淫巧但又要单独出来，仿佛只有小聪明却找不到重心。开发者选项被阉割得连关闭动画的选项都没有了，每次新手机我都会把动画效果关闭，联想虽然不隐藏这个入口，却直接把功能删了，更加可恶。只用了一个下午，就决定不再使用了。\n\n金立Amigo系统，是西班牙语朋友的意思，起初我是不看好的，但可能是ROM制作者的用心，调整妥当后非常地好用，流量控制、后台关流量、也很省内存，是第一个原生支持修改字体的系统，缺点是铃声居然不能设置，只能按root方式直接修改系统文件夹，自带的相机程序无法使用(装第三方就行，不算问题)，另外开发者选项单单把进程统计给删除，不知何故。\n\n大可乐系统本身没什么要说的，制作者集成了xposed，故还在使用中\n\n另外小米系统最初也装过，不过时间久了没什么印象，这次就不再写报告了。\n\n总结下来一共8个系统加1个桌面，flyme的画风最好，OPPO的系统最友好，华为最理性，锤子桌面比较注重设计感，剩下的都没什么特色，甚至联想还要打负分。","modified":"20171205121530000","tags":"os"},
{"created":"20211102121530000","title":"几种语言的包加载和管理机制","text":"\n!! Python和Lua\n\n算是比较经典的中心化包管理和分发机制，官方或半官方地提供中央仓库，本地开发需要包时从中央仓库下载到本地的某个公共目录，然后各个项目都从本地公共目录引用（但不会复制到项目下）。比较有意的是，中心仓库可以保存同一个包的多个版本，也可以指定版本下载到本地，但却只能保存一个版本，换版本只能采用覆盖机制。我所知的大部分90年代的动态语言都是这个机制。\n\n!! Go\n\n设计初衷是分布式库管理，下载包就是很原始的去各种网站获取，于是就有了代理方把各种常用的库进行汇总，虽然是代理但间接担当了中心仓库的功能。\n\nGo的本地仓，通过将库名和版本号分成两级目录方式，保存了同一个库的所有版本内容，但是代价是v2及以上版本的库和v1库被认为是两个不同的库。\n\n!! Java\n\n总体来说包管理和Go的机制有点像，官方没有考虑过包管理机制，由社区逐渐开发完善。支持在本地缓存保存多版本，最终在具体项目则引入对应版本的包。\n\n!! PHP\n\n相比其它语言，2012年发展出的包管理软件composer算是比较晚的，因此也受了js的npm和ruby的bundle很多影响。由于语言在加载特性上也更少，并不适合作为全局工具，因此更偏向项目级，默认是对某个项目的包管理，也导致多个项目间的代码重复问题。当然composer的global命令也提供本地的公用仓，但毕竟加载机制相比其它语言弱一些，要依赖额外的文件，总有些不完备的感觉。","modified":"20211102121530000","tags":"lang"},
{"created":"20160718121530000","text":"\n!! 起因\n\n一段lua程序\n\n```\nwhile do\n  local ctx = ...\nend\nsaveToFile(ctx)\n```\n\n程序执行到最后，总会报一个写入nil的错误。我一度以为是在处理数据时没有赋值，但反复核对都没有遗漏，\n最后也不知怎么就想到可能是执行saeToFile函数时，ctx出了while作用域，导致引用了一个新的变量，这时ctx就是nil。\n果然尝试把ctx的local限定词去掉，程序就执行正常了。\n\n!! lua\n\n这个疑问引起了很大的好奇，在C语言里，变量的构造和使用是严格区分的，带了类型就是声明变量，而不带类型则是使用。由于动态类型语言没有类型，该如何区分？重新看了Lua的手册，local的说明中有一句：Notice that each execution of a local statement defines new local variables.\n说明用local声明的变量，是定义(即创建一个存储位置)。那么没有用local声明的变量，文档中并没有明确的说明，按我的理解，没有local则是变量查找。\n\n如果这个scope之前有local定义或是同名变量，则引用已定义变量。如果没有，由于Lua的可见性是内部可以看到外部，\n即`_ENV`层层向外的链表结构，在本层找不到，会向外部寻找，直到最外层的global范围。如果global也没有的话，\n就会自动在global创建这个变量。可见沿着`_ENV`向上查找才是本意，找不到情况下创建变量只是个副产物。\n因此Lua语言中尽量使用local的意义就在于，避免对外部环境的污染。又或者不经意间就修改了同名的global变量(在好的编码风格中不太会发生)。\n\n如果拿Lua的local和JavaScript的var相比较，作用很相似，带var表示定义一个变量，没有var则是向上查找，\n同样也会在全局空间创建该变量。(但是注意，这两门语言的祖先Scheme，却不允许这种未经声明的变量访问。\n当然如果改写Lua中顶级_ENV的元表或是修改js的prototype，也能达到同样效果，只是默认是允许而已)。\nJS的编程风格也一直倡导要尽可能用var定义变量，防止不经意间污染全局空间。\n但是JS的作用域中没有block作用域这一层，因此对照上例，即使在while内用var定义变量，超出while的语法作用域，仍然访问到。\n除非到了function定义结束标识，这个变量的作用域才结束。\n\n!! JS\n\n作用域混合了动态和静态两种，用this捕获的变量是上下文决定，或者说可以用apply指定。非this捕获的变量是静态的词法作用域。动态作用域臭名昭著，定义lambda语法时，就限定了这种情况下的this是静态捕获的。固然好，但一个this有两种作用域，很多人是迷惑的。\n\n!! PHP\n\n作用域和JS有点像，只有function能创建新的作用域，花括号不构成块作用域，但比JS更弱的是，PHP不能链式地向外查找变量。有人说因为解释器用了barrier方式控制变量的绑定，取巧地控制变量的解析规则，这样实现很简单。他认为，严格意义上PHP没有作用域概念。\n\n在PHP函数作用域内无法直接看到外部定义，所以PHP增加了global关键字，表示这个变量是向最外部环境的引用。以下两句话的效果是一样的。\n\n```\nglobal $var;\n$var =& $GLOBALS[\"var\"];\n```\n\n同样，用unset($var)也不会影响全局变量，因为只是删除了局部作用域内创建的引用变量而已。\n\n但是global关键字的局限也很明显，试想定义一个嵌套函数，在内层嵌套中想访问外层函数，但非全局变量，就没有办法了。\n只能在访问全局变量或者访问本函数定义变量中二选一。\n至少我在PHP5.6版本，是无法实现内层函数访问外层函数变量的效果。\n因此PHP也不是一个lexical scope的语言（Lua和JS是的）。在闭包的实现时，\n需要用和global类似的use语句，才能实现向上一级的变量引用。但也不能等同于穿越作用域，而是在这个函数域内新建变量而已。\n至于use中使用&，是被Scheme放弃的动态词法范围语义，在PHP和C++11中，都还是被保存了下来。\n\n链式访问我能想到的典型应用是用函数来实现对象，即让函数有状态。Lua或JS通过定义一个函数，并返回这个函数内嵌套定义的另一个函数来实现。\nPHP无法链式访问，但和C语言一样，支持函数内的static关键字，使得函数可以记录一些状态。但是PHP创建的函数，无法多次实例化，而且PHP虽然可以在函数内嵌套定义函数，但语法的限制(变量必须带$前缀，函数没有，类似lisp-2的双命名空间)，不能返回这个函数，也就没有很多烧脑的写法。\n从灵活性来看，使用static变量的函数显然是弱于链式访问构造的闭包。\n\n''PHP虽然加入了namespace机制，但只能保护类、函数、常量。global访问的变量，仍然共享全局命名空间。''\n\n!! Python\n\n没有块作用域，也没有链式作用域。Py3加入了nonlocal，可以在定义空间向上访问。\n\nPython的global关键字，和PHP有两点区别。\n\n# Python只能访问全局空间的变量，加上global的目的，是未了改写这个全局变量，如果以只读方式用这个变量，不需要加global。\n# Python的global只能访问这个文件的命名空间，相当于寻找module内的变量\n\n!! Ruby\n\n由于语法要素没有花括号，没有块作用域，遇到module/class/def这三个关键字会打开一个新的作用域，这个作用域和外部是隔绝的，无法链式向上级访问。这就造成一个很奇怪的现象，class内定义def却不能访问def外的局部变量。不过Ruby的思想是用`@`代表实例变量，`@@`代表类变量的方式来控制。而不是简单的局部变量。加上Ruby的全局变量用$表示，就造成了Ruby有四种变量命名的特色。\n\n如果想打破常规的作用域，可以用Module.new/Class.new/define_method这三个等价的方法名来替换关键字，使作用域平铺。\n\n!! 环境和实现\n\nSICP介绍计算模型有个很重要的概念环境。在教学概念中环境是个链接，当前函数栈帧是链表的最末端，如果当前环境找不到变量unbound，会向外层层寻找。\n\nlua的环境没有使用outer的概念，但mujs为求简单是这么用的。catch和with会创建新env并用outer指向当前环境，JS除了这两个关键字，callfunction会创建，等执行完再restore旧环境。\n\n!! 总结\n\n从作用域访问灵活性看：Lua/ES6（有块有链式） > ES5（无块有链式）> Python（无块有受限链） > PHP/Ruby（无块无链式）\n\nPython和Ruby本来就没有块作用域的语法要素，比较有无块作用域有失公允。","title":"几种语言作用域的比较","modified":"20231028134715377","tags":"lang"},
{"created":"20231027033219843","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'security' sort[title]>>\n\u003C/div>","tags":"目录","title":"加密与安全","modified":"20231027033232505"},
{"created":"20161113121530000","title":"简说CSRF","text":"\n网络攻击中有种技巧，叫CSRF(Cross-site Request Forgery)，跨站请求伪造。\n什么意思呢：\n\n正常用户和服务器之间的请求是真实的请求，而CSRF的请求，仍然是用户和服务器之间的请求，\n但这种请求并不是用户主动有意发起的，而是被黑客施以社工的方式，诱导用户点击，\n由于最终仍是用户发起，所以服务器在技术上是无法区分到底是客户真实的用途，\n还是被社工诱骗的结果。这种攻击技法技巧在技术上是这样的：\n\n首先HTTP协议是无连接的协议，但实际的应用场景很多时候是需要连接的，在编程上就会通过\nsession方式来记录这个会话。但是和C-S模式往往使用TCP连接不同，浏览器的socket连接是无法控制的。\n因此服务端无法做到把session和连接绑定，只能退而求其次和IP绑定。\n可想而知，如果用户的浏览器有多个标签页，这些页签发起的请求，在服务器看来都是合法的。\n这时黑客布置一个诱骗点击，用户点击后，会触发一个向服务器的请求，比如向黑客汇款，\n因为是在同一个浏览器上发出的，就让服务器以为是用户主动向黑客汇款，于是一次攻击就成功了。\n\n原因是浏览器发起连接的行为不可控制，而根本恐怕还在于HTTP在协议设计之初的无连接性。\n因为无连接，所以默认是短连接，而浏览器为了提高加载速度，又以用户不可控的方式去建立连接。\n当然HTTP的设计之初，只是一个内部的信息交互系统，正是这个系统的极大成功，\n被告后人用来做各种各样的业务，才引入这样一种本不该有的问题吧。\n","modified":"20161113121530000","tags":"web"},
{"created":"20170309121530000","title":"接口设计的原则与反思","text":"\n先说说VideoEncode类的感想，\n目前的Encode类的构造函数，需要传入一个视频通道号和编码类型，然后返回一个对象。现阶段遇到有个需求，需要解码后的YUV数据经过智能分析，对分析结果的区域进行局部抠图。这时也需要编码资源，但这个编码器似乎又和视频通道并不强关联，再多的还是和解码器的输出有关，这时原先的假设就不再适用了，需要定义新的构造函数才能使用。\n\n再说两个接口的反思\n\n在MCU头文件增加了一种读数据的枚举值。看起来小得不能再小的改动，但还是发现了问题。\n\n原来的头文件中有两个类似接口，分别是recv和recvData，接口注释分别是阻塞等待事件和读取数据，但是看阻塞等待事件的接口，返回的数据结构似乎也能表示数据，为什么偏偏要加在recvData，这两个接口的差异在哪里？\n\n细问之下才知道原来recv的内部实现是把代表MCU的fd加到select的读和异常集合，且超时时间为无限，recvData只是个读数据的接口，不会阻塞。看了实现才明白原来是用recv来等待数据到来，结束后调用recvData。说实话这样的命名方式实在太糟糕，加上接口注释又不清晰，导致这次新增的枚举在recvData中又增加了select操作，原来是上层没有调用recv。这种改动虽然不影响原有逻辑，但从整体功能上造成了recvData的含义不同，阻塞或非阻塞的特性还会随着读取的数据类型而变化，这就很明显地破坏了接口含义的一致性。\n\n再说一个错误的例子，有个createNetBrigde接口，入参有个`const char *name`，从接口看，无非创建一张网桥，然后用name来标识一下，类似创建线程操作，何曾想实现代码中竟然要求name必须是br开头且第3个字符必须是数字，否则不予创建。无论怎么看接口注释，都看不出有这样的限制。而且既然限制必须用br开头，何不把参数定义成uint8，只让调用者传入数字，在实现层构造出br0这样的名字，不仅没有歧义还减少空间。\n\n以前看接口，最多能看出参数是否合适，最近越来越意识到接口的用法、使用前提、使用预期等隐含的语义。\n\n软件工程总是提复用，我的理解复用是有范围的，比如接口恰恰是最不能复用的，一个萝卜一个坑，绝对不能有二意性，且最好功能尽可能单一。只有接口不复用，业务代码才能尽可能地复用。","modified":"20170309121530000","tags":"design"},
{"created":"20160812121530000","title":"接入协议、账户体系和权限","text":"\n视频监控行业有个Onvif协议，作用是通过这种协议来控制设备。\n由于Onvif是个行业级的通用标准，修订比较漫长，甚至很多定制的协议根本不可能纳入Onvif标准。\n一般稍大一些的厂商，都会有自己的接入标准。对于网络接入来说，\n因为涉及权限，就一定有身份概念。对存在两套接入标准的设备来说，\n账户体系究竟该怎么设置，这是本文想讨论的问题。\n\n如果把Onvif仅仅看成是一套XML格式的网络接入协议，那么它就和账户体系没有关联，\n但是Onvif标准定义了4种用户组，同时也规定了每个组所对应的权限，\n而账户，或者说身份，应该包括完整的四层概念，又名4A。\n包括Account、Authentication、Authorization、Audit。由于Onvif定义了登陆的加密方式，\n和登陆后的权限定义，包括了Authentication和Authorization这两级。\n也就是说是有完整的账户体系的。\n\n而厂商如果也定义了账户加密方式和权限，且两者不能一一对应，这时两种接入协议，\n就可以认为是两套独立的账户，互相并不干扰。即使能对应，也只是为了简化模型而做的优化。\n从这个角度再去看产品的逻辑：第一次用admin登陆会提醒用户修改密码，\n同时把这个密码也同步到Onvif账户的admin(注意这里只是恰好重名而已，\n完全可以做到一个体系用root作为管理员名称)。而后续对admin的修改，并不会同步到Onvif。\n因为第一次，可以认为是用户的初始化动作，做一次自动同步是出于简化操作的目的。\n而当用户体系已建立，从一个账户体系下修改另一个体系，显然就不合适了。\n\n但这种做法最初我是很困惑的：私有协议和Onvif协议只是一种接入方式，和用户没有关系，\n既然要做密码同步，就应当每次都同步，或者不同步，同步一次这种半调子的行为，让我非常难理解。\n\n但是看了Kerberos的一些介绍后，对这个问题重新理解后，觉得应该是这样的：\n客户端希望向服务端申请做一些业务，服务端需要对这个申请作一个判断，\n是否允许客户执行这个操作。即客户提供一个双方都知道的信息，当这个信息被验证后，\n才会让客户去执行。在这里用户名和密码，除了证明客户是否作假，\n有了一个更重要的作用，即业务的授权性。\n甚至更进一步，把用户名这种带有强烈倾向性的命名，换成服务名理解起来会更容易。\n客户端向服务端提交一个服务名和密码，服务端验证后，允许操作。\n又因为服务端提供了很多种服务，如果把服务种类分得太细，\n会导致客户端不停地验证，比较烦琐，此时把多个服务名称合并成一个，\n产品把这个多合一的名称取名为用户名，就造成了一些概念上的混淆。\n\n那么在广义的C-S模式下，这个会话开始之初发送的名称、密码究竟归属谁呢？\n这就取决于业务形态和资源的归属了。\n\n对监控相机而言，所提供的服务主要是音视频流，或者磁盘的存储功能，\n这些都是属于设备，不会因使用者而改变的。\n这种情况下，建立会话的这个名称就归属服务端，更准确的叫法，应该是服务集名称。\n\n再对比经常使用的微信或者QQ，虽然我们发送文字或语音，要经过服务器的中转，\n但是我们选择发给谁，即这些好友名单并不属于服务器。\n这些好友都是使用者一个一个地添加进通讯录的，从资源所有权角度看，理应属于客户端。\n\n最后来看私有协议和Onvif协议的问题：这两套协议都是在设备上，也就拥有各自的服务集，因此两套体系之间是不能同步的。为什么第一次又要做同步呢？\n可以理解为产品在发到用户手中，需要做一个初始服务集密码的修改操作，\n如果不做同步，就要用户操作两遍，显得比较烦琐。为了提高使用便利性，\n才做了这个相当于全局初始化的动作。","modified":"20160812121530000","tags":"design"},
{"created":"20190918121530000","title":"进程线程和协程的切换开销","text":"\n测试Context Switch time(进程上下文切换时间) ，创建两个进程(实时进程)并在它们之间传送一个令牌，如此往返传送一定的次数。其中一个进程在读取令牌时就会引起阻塞。另一个进程发送令牌后等待其返回时也处于阻塞状态。发送令牌带来的开销与上下文切换带来的开销相比，可以忽略不计。 (利用管道传递令牌)\n\n!! 测试程序(1)\n\n```\n#include \u003Cstdio.h>\n#include \u003Cstdlib.h>\n#include \u003Csys/time.h>\n#include \u003Ctime.h>\n#include \u003Csched.h>\n#include \u003Csys/types.h>\n#include \u003Cunistd.h>      //pipe()\n\nint main()\n{\n    int x, i, fd[2], p[2];\n    char send    = 's';\n    char receive;\n    pipe(fd);\n    pipe(p);\n    struct timeval tv;\n    struct sched_param param;\n    param.sched_priority = 0;\n\n    while ((x = fork()) == -1);\n    if (x==0) {\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        gettimeofday(&tv, NULL);\n        printf(\"Before Context Switch Time %u us\\n\", tv.tv_usec);\n        for (i = 0; i \u003C 10000; i++) {\n            read(fd[0], &receive, 1);\n            write(p[1], &send, 1);\n        }\n        exit(0);\n    }\n    else {\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        for (i = 0; i \u003C 10000; i++) {\n            write(fd[1], &send, 1);\n            read(p[0], &receive, 1);\n        }\n        gettimeofday(&tv, NULL);\n        printf(\"After Context SWitch Time %u us\\n\", tv.tv_usec);\n    }\n    return 0;\n}\n```\n\n测试结果(进程切换时间不超过5us)\n\n```\nBefore Context Switch Time 617087 us\nAfter Context SWitch Time 702420 us\n\n702420us - 617087us = 85333 us\n85333us / 20000    = 4.26665 us\n\n进程切换时间为4.26665 us\n\n注： cpu MHz         : 2801.042\n```\n\n!! 测试程序(2) 使用rdtsc()获取当前时间\n\n```\n#include \u003Cstdio.h>\n#include \u003Cstdlib.h>\n#include \u003Csched.h>\n#include \u003Csys/types.h>\n#include \u003Cunistd.h>\n\nlong long rdtsc()\n{\n    __asm(\"rdtsc\");\n}\n\nint main()\n{\n    int x, i, fd[2], p[2];\n    char send    = 's';\n    char receive;\n    pipe(fd);\n    pipe(p);\n    struct sched_param param;\n    param.sched_priority = 0;\n\n    while ((x = fork()) == -1);\n    if (x==0) {\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        printf(\"Before Context Switch Time %lld\\n\", rdtsc());\n        for (i = 0; i \u003C 10000; i++) {\n            read(fd[0], &receive, 1);\n            write(p[1], &send, 1);\n        }\n        exit(0);\n    }\n    else {\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        for (i = 0; i \u003C 10000; i++) {\n            write(fd[1], &send, 1);\n            read(p[0], &receive, 1);\n        }\n        printf(\"After Context Switch Time %lld\\n\", rdtsc());\n    }\n    return 0;\n}\n```\n\n测试结果(进程切换时间不超过5us)\n\n```\nBefore Context Switch Time 16208184381648\nAfter Context Switch Time 16208424333213\n\n16208424333213 - 16208184381648 = 239951565(clock cycle)\n239951565      * 0.357009998 ns = 85665107.74074687 ns\n85665107.74074687 ns / 20000    = 4283.255387037 ns = 4.283255387037 us\n\n注： cpu MHz  : 2 801 042 000Hz\nclock cycle = 1 000 000 000 ns / 2 801 042 000 = 0.357009998ns\n```\n\n!! 测试程序(3) 可直接获得进程上下文切换时间\n\n```\n#include \u003Cstdio.h>\n#include \u003Cstdlib.h>        //drand48()\n#include \u003Csched.h>\n#include \u003Csys/types.h>\n#include \u003Cunistd.h>\n#include \u003Csys/time.h>      //gettimeofday()\n#include \u003Ctime.h>\n\ntypedef unsigned long long u64;\ndouble clockCycleTimeS,clockRateHZ;\n\n/* 获取当前时间，返回秒 */\ndouble second() {\n    struct timeval tv;\n    gettimeofday(&tv,0);\n    return tv.tv_sec + 1e-6 * tv.tv_usec;\n}\n\n/* 获取当前时间，返回clock cycle */\nu64 rdtsc() {\n    u64 tsc;\n    __asm__ __volatile__(\"rdtsc\" : \"=A\" (tsc));\n    return tsc;\n}\n\n/* 睡眠us微秒 */\nvoid selectsleep(unsigned us) {\n    struct timeval tv;\n    tv.tv_sec = 0;\n    tv.tv_usec = us;\n    select(0, 0, 0, 0, &tv);\n}\n\n/* 计算当前CPU的工作频率 */\nvoid calibrate() {\n    double sumx = 0;\n    double sumy = 0;\n    double sumxx = 0;\n    double sumxy = 0;\n    double slope;\n    const unsigned n = 30;\n    unsigned i;\n\n    for (i=0; i\u003Cn; i++) {\n        double breal,real,ticks;\n        u64 bticks;\n\n        breal = second();\n        bticks = rdtsc();\n        selectsleep((unsigned)(10000 + drand48() * 200000));\n        ticks = rdtsc() - bticks;\n        real = second() - breal;\n\n        sumx += real;\n        sumxx += real * real;\n        sumxy += real * ticks;\n        sumy += ticks;\n    }\n    slope = ( (sumxy - (sumx*sumy) / n) /\n              (sumxx - (sumx*sumx) / n) );\n    clockRateHZ = slope;\n    clockCycleTimeS = 1.0 / slope;\n    printf(\"%3.3f MHz\\n\", clockRateHZ*1e-6);\n}\n\nint main()\n{\n    calibrate();\n\n    int x, i, p1[2], p2[2], time[2];\n    char send    = 's';\n    char receive;\n    u64 old_time;\n    pipe(p1);\n    pipe(p2);\n    pipe(time);\n    struct sched_param param;\n    param.sched_priority = 0;\n\n    while ((x = fork()) == -1);\n    if (x==0)\n    {\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        old_time = rdtsc();\n        write(time[1], &old_time, sizeof(old_time));\n        for (i = 0; i \u003C 10000; i++) {\n            read(p1[0], &receive, 1);\n            write(p2[1], &send, 1);\n        }\n        exit(0);\n    }\n    else\n    {\n        u64 new_time;\n        sched_setscheduler(getpid(), SCHED_FIFO, &param);\n        for (i = 0; i \u003C 10000; i++) {\n            write(p1[1], &send, 1);\n            read(p2[0], &receive, 1);\n        }\n        new_time = rdtsc();\n        read(time[0], &old_time, sizeof(old_time));\n        printf(\"Latency time = %3.3f us\\n\",\n                1e6 * (new_time - old_time) * clockCycleTimeS / 20000);\n    }\n    return 0;\n}\n```\n\n测试结果(Linux-2.6.21 + RealTime Patch) Latency time = 8.129 us\n\n2801.226 MHz\n\n!! 协议的意义和测试\n\n前面用实验的方式验证了Linux进程和线程的上下文切换开销，大约是3-15us之间（）。这个开销确实不算大，但是海量互联网服务端和一般的计算机程序相比，特点是：\n\n* 高并发：每秒钟需要处理成千上万的用户请求\n* 周期短：每个用户处理耗时越短越好，经常是ms级别的\n* 高网络IO：经常需要从其它机器上进行网络IO、如Redis、Mysql等等\n* 低计算：一般CPU密集型的计算操作并不多\n\n即使3-15us的开销，如果上下文切换量特别大的话，也仍然会显得是有那么一些性能低下。例如之前的Web Server之Apache，就是这种模型下的软件产品。（其实当时Linux操作系统在设计的时候，目标是一个通用的操作系统，并不是专门针对服务端高并发来设计的）\n\n为了避免频繁的上下文切换，还有一种异步非阻塞的开发模型。那就是用一个进程或线程去接收一大堆用户的请求，然后通过IO多路复用的方式来提高性能（进程或线程不阻塞，省去了上下文切换的开销）。Nginx和Node Js就是这种模型的典型代表产品。平心而论，从程序运行效率上来，这种模型最为机器友好，运行效率是最高的（比下面提到的协程开发模型要好）。所以Nginx已经取代了Apache成为了Web Server里的首选。但是这种编程模型的问题在于开发不友好，说白了就是过于机器化，离进程概念被抽象出来的初衷背道而驰。人类正常的线性思维被打乱，应用层开发们被逼得以非人类的思维去编写代码，代码调试也变得异常困难。\n\n于是就有一些聪明的脑袋们继续在应用层又动起了主意，设计出了不需要进程/线程上下文切换的“线程”，协程。用协程去处理高并发的应用场景，既能够符合进程涉及的初衷，让开发者们用人类正常的线性的思维去处理自己的业务，也同样能够省去昂贵的进程/线程上下文切换的开销。因此可以说，协程就是Linux处理海量请求应用场景里的进程模型的一个很好的的补丁。\n\n背景介绍完了，那么我想说的是，毕竟协程的封装虽然轻量，但是毕竟还是需要引入了一些额外的代价的。那么我们来看看这些额外的代价具体多小吧。\n\n协程切换CPU开销测试，测试过程是不断在协程之间让出CPU。Go代码如下。\n\n```\nfunc cal()  {\n    for i :=0 ; i\u003C1000000 ;i++{\n        runtime.Gosched()\n    }\n}\n\nfunc main() {\n    runtime.GOMAXPROCS(1)\n\n    currentTime:=time.Now()\n    fmt.Println(currentTime)\n\n    go cal()\n    for i :=0 ; i\u003C1000000 ;i++{\n        runtime.Gosched()\n    }\n\n    currentTime=time.Now()\n    fmt.Println(currentTime)\n}\n```\n\n总的来说线程切换的时间和协程的比值约是**几十倍**，线程切换在10us级别，协程在1us以下。","modified":"20190918121530000","tags":"os"},
{"created":"20200314121530000","title":"经度纬度和GeoHash","text":"\n对经纬度对应的长度，我一直有个错误的认识，经度共360度纬度180度，而地球又非常接近球形，意味着每1经度的距离只有纬度的一半。但是在看了GeoHash后发现在赤道上，1个经度或纬度的地理距离是一样的，每度约111.3km，每秒31米，换算成小数点后4位是10米，和民用GPS精度一致。有些项目要求到小数点后5位甚至6位，精度1米甚至0.1米，其实是不可能达到的。随着纬度越来越高，1个经度间的距离会逐渐减少，到北纬50只有71km，更往北则缩减得越快。\n\n经度是整个地球一周，此时纬度只需要标识出半周，两者结合就可以唯一定位一个点，因此纬度的范围是经度的一半，但每度是一样的。比方说从东经和西经可以区分中国和美国，但北纬却无法区分。\n\n网上文章说GeoHash5的分块，精度约为5km的正方形。由于到南北极点会收缩，其实每个分块是球面梯形。GeoHash5的纬度方向，严格的说只在赤道附近才是5km，北纬45度的边长只有3.93km（5km x pi x 45/360），而北纬45度以上的块，是个球面三角形，面积只有靠近赤道的1/3。当然附着切分越来越细，上下两条边的差距会变小，但始终不能认为相等。\n\nGeoHash有12级，因为每4级间相差1024倍，只要记4级就很快能推导出全部。每级相差8倍和4倍。\n\nGeoHash第1级划分是8x4个块（2纬3经），第2级则是4x8个块（3纬2经）。在编码层面，每层下探时矩阵会转置，对角值也会互换。\n\n以杭州为例，GeoHash5约横跨0.05个经纬度，GeoHash7跨0.0015个经纬度。","modified":"20200314121530000","tags":"protocol"},
{"created":"20140303121530000","title":"精巧的安全和DH算法","text":"\n连续的每周六天上班着实太累，周日外面阳光明媚可却在家睡了一下午觉，到了晚上才缓过劲来。基本就在昏睡中度过一个周日。周末只有一天的感觉真是太不好了。\n\n一周的工作计划总是被意外的紧急情况打断，这周是安全问题。以前总是看到××公司安全意识薄弱，今天算是到自家头上了，由于协议久远，从现在看来几乎是弱智般的加密防范，也许那个时代根本不知安全为何物吧。从去年年中开始不停地爆出安全漏洞，今次又发现一个问题。因为这次的问题加上上周刚做的加密方案，把以前模糊不清的各种加密原理重新梳理一遍，不需要明白算法，至少对称非对称和信息摘要的应用场合，以及如何组合这些算法达到安全加密的过程，有了个完整的概念。回过头去看，就发现加密算法的精巧。就算知道了加密流程和算法，但设计完整的流程就是能让人徒呼奈何。\n\n因为工作太多，自己的学习也被耽搁了。写了小段Scheme代码，但解释器不给力，报了变量未定义错误，却不知道究竟是哪一行的变量，而Scheme的移植性又相当差，稍微有用点的函数都是与实现相关，换个解释器还不知道要修改多少代码。看来以后还是要用Racket，其他的实现都不够完整。用Emacs写代码暂时还没发现特别的好处，一切都可以定制的特性让它成为神的编辑器，可是对不熟悉的人来说实在太难用，我还算是对Lisp比较了解的，用到今天才明白它的设计思路和好处，但真正掌握还需要慢慢熟练，就如这篇教程说的，花一年时间，并且做到理解而不是判断。\n\n在不安全的信道建立加密会话，又叫密钥协商，RSA是密钥传输算法，但它完全由客户端决定密钥，严格得说不算协商，只有Diffie–Hellman，简称DH算法是真正的协商，它基于离散对数，A准备a,g,p三个数，B准备b。其中g取2或5，a,b,p则是非常大的质数。p至少1024位，相当于300多位的十进制数。\n\n```\nAlice --- g, p , (g^a) % p, 正文用A表示 --> Bob\nAlice \u003C--   (g^b) % p, 下文用B表示      --- Bob\n```\n\n也有些文章把A和a称为Alice的DH公私钥，B和b称为Bob的DH公私钥。通过以上交互，Alice和Bob分别计算 (B^a) % p = (A^b) % p = K，接着K就可以用于对称加密的密钥。\n\n以上算法解决保密，认证还是要依赖PKI或其它方式。\n\nDH算法又细分静态DH和临时DH(EDH)两种，静态的p是不变的，保存在硬盘上，固然节约了计算开销，但和RSA一样都不能实现前向安全，只有临时DH才满足前向安全。DH的生成步骤比RSA要多一步，先生成参数（上文提到的p），再根据参数文件生成DH公私钥对。对应的openssl命令分别是dhparam和genpkey。\n\n除了离散对数，也可以用椭圆曲线实现，ECDH。但是从量子计算角度看，椭圆曲线弱于离散对数，考虑到量子计算还不成熟，ECDH还是被广泛接受的。","modified":"20140303121530000","tags":"security"},
{"created":"20181027121530000","title":"跨域和同源策略","text":"\n浏览器的三大线程\n\n# javascript引擎线程(GUI渲染也在这个线程)\n# 浏览器事件触发线程\n# HTTP请求线程\n\n问题是这样：在localhost页面用XHR发起请求，始终回调error函数。\n\n原因：首先这是个跨域的请求，而规范定义XHR不允许跨域请求。出于安全考虑，所有的JS请求都不能跨域，但为了使用CDN的多个源加载机制，对script或img标签的src属性开了个口子，允许跨域，但为了防止被滥用，只支持GET方式，对于CDN分发来说已经足够了。所以就有人基于此开发了JSONP机制。\n\n我需要POST，所以JSONP不通。为求简单用了同步方式，同步请求规定withCredentials属性必须false，跨域却必须是true。因此要想跨域，只能用异步方式。\n```\nxhr.withCredentials = true;\nxhr.open(method, dst, true);\n```\nJS不能跨域展开一下，浏览器并不会拦截跨域请求(不严谨，如果content-type有值还是会会改动，下述)，抓包能看到浏览器发出了数据，但是在收数据后，会对数据做校验，不符合规范就不把收到的数据给JS。\n\n网上很多说通过响应header增加`Access-Control-Allow-Origin: *`来解决，但都没有细说是在哪个server端增加。来分析一下跨域定义：访问A页面，这其中有一段JS脚本向B页面请求数据，虽然跨域，浏览器还是会向B请求数据，请求的头中会加上来自A站的标识`Origin: http://localhost` 。直到发现有刚才那段申明，才把数据给JS，否则就不给JS。从字面意思也好理解，对B来说，Origin指的是A。只有B允许A（或`*`所有人）来请求数据，浏览器看到既然B都特地声明数据开放给A了，才会把给JS。如果B没有说这句话，默认是不给JS的。\n\n再说说跨域的高级变化，又称为preflight机制。只有简单请求能够直接发出去，而复杂请求浏览器会修改XHR发出的请求。简单请求包括HEAD/GET/POST，且不允许设置Content-Type等若干头部。一旦发现违反，就会把方法改成Options向服务器探探路，只有应答带了`Access-Control-Allow-Origin: *`等若干字段，才允许重发真正的请求，且即使这样，仍有些头是不允许带的。\n\n如果HTTP的请求头中有特殊字段，同样会触发浏览的preflight机制，必须在响应端增加`Access-Control-Allow-Headers: *`，否则浏览器也会不予显示。\n\n而表单不受同源限制，因为表单一旦发出，整个页面就切换了，原页面拿不到新页面的内容。所以说同源策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。\n\n用异步就一定会涉及回调，看看MDN上关于回调的写法\n```\nvar xhr = XMLHttpRequest();\nxhr.onreadystatechange = function () {\n    switch(xhr.readyState){\n      case 1://OPENED\n        break;\n      case 2://HEADERS_RECEIVED\n        break;\n      case 3://LOADING\n        break;\n      case 4://DONE\n        xhr.response; //do something\n        break;\n    }}\n```\n我最疑惑的就是function中的xhr表示谁？函数无参也无定义，xhr只能链式地向上查找，回调这个函数的主体是xhr，所以向上找的时候，一定能找到xhr变量。但我觉得更好的写法还是`switch(this.readyState)`，引入一个同名变量太容易引起混淆。\n\n上述写法是早期xhr的推荐做法，现在新的浏览器还可以用onload和onerror方法，看起来更简洁\n```\nreturn new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url);\n    xhr.onload = resolve;\n    xhr.onerror = reject;\n    xhr.send(...)  // POST has string body\n}\n```\n\n这两个方法回调时的惟一参数是ProgressEvent类型，target.response就是对端返回的内容。target是其父事件Event的属性，ProgressEvent继承得到target属性，表示这个事件被分派的对象，此处代表XHR对象。","modified":"20181027121530000","tags":"web"},
{"created":"20190820121530000","title":"类型理论","text":"\nnull最好是提升到类型级别，而不是作为特殊值，编译器会推导保证类型正确，而值只能在runtime时直接崩溃。\n\n函数是不是first class不重用，可以用object封装函数，object一等函数二等照样可行。\n\nRust 错误处理本质上还是基于返回值的，很多基于返回值做错误处理的语言是将错误直接硬编码到正确值上，或者返回两个值，前者例如 C 在很多时候都是直接把正常情况永远不会出现的值作为错误值，后者例如 Go 同时返回两个值来进行错误处理。而 Rust 则将两个可能的值用 enum 类型表示，enum 是和类型(sum type)，表示两个可能的值一次只能取一个。\n\n!! ADT\n\n函数式语言的代数数据类型ADT(algebraic data type)，简单的说就是组合类型。不要和抽象类型abstract data type混淆。\n\nsum type是tagged union(值域是每种field的sum)，product type典型例子是tuple或struct(值域是每种field的cartesian product)。\n\ntuple强调不可变，python用tuple作为函数的出入参，利用的就是immutable，而且因为不可变，一定程度上就具备hashable特质。\n\n拓展:思考元组、函数参数、函数返回值，命名参数和 Record 以及 list 的关系(比如像 SML 那样设计)\n\n!! symbol和string\n\n在lisp中符号的历史比字符串更加久远，在LISP 1.5中SYMBOL 和 CONS是最重要的数据类型。\n\n> 数字是一种特殊的符号。——摘自《LISP 1.5 Programmer's Manual》\n\n而字符串是后来加上的。用来表示字符序列的概念，至此，再用SYMBOL的NAME来表示字符序列已然成为不好的行为了。\n\n举个例子`'abc`作为一个原子（atom），不可以拆开；而`\"abc\"`是复合数据，可以提取出\"a\"。因此symbol的存在大大扩充了原子世界，以便于写符号计算和元编程。\n\n字符串是无结构的，符号是有结构的，符号中的数字类型也不是以字符串形式储存的而是单纯的数字，原子的符号受到标识符规则的限制而字符串没有。\n\n换句话来说不是任意一段字符串都可以找到相对应的符号。","modified":"20190820121530000","tags":"lang"},
{"created":"20170613121530000","title":"礼让行人和车流量协议问题反思","text":"\n礼让行人协议的问题是，在说明时忽略了背景介绍。原文是这样的\n\n    Direction : [\"Left\", \"Right\"]; Left表示向左，Right表示向右，数组为空表示表示不关心方向，即行人即使不动也表示违规。\n\n这句注释的后半句还好，但前半句就很可笑了，谁不知道Left表示左呢。因为左右是相对的概念，如果不说明坐标系是没有意义的。我初以为是俯视图，但怎么也想不出来，另外同事认为是面对红绿灯的视角，直到问了做过这块业务的开发才知道是以相机预览画面视角，车为上下行故人为左右行。因此把视角补上才完整，另外方向已经解释，但单方向如左表示违规的情况没有给出示例，需要说明比如左车道只有左行，即和车方向靠近时才表示违规，这样的解释才是个好的说明。\n\n再说车流量协议，原稿描述很简单，分别显示机动车/非机动车流量。初看并没有问题，但车流量有很多分类，除了机/非方式，还有按左转/右转/直行分类，也可以按轿车/卡车分类。所以在显示之前要先定下分类模式，然后展示。另外机和非的定义其实也不够确定，比如按车长定义，以4/6/9/12米长度为界把车分为5类，这样的定义相对更严谨一些。","modified":"20170613121530000","tags":"protocol"},
{"created":"20210611121530000","title":"理解shell的换行和打印","text":"\n写sh时想把一段文本的json变量传给程序，但因为带了换行符，总是失败。大概是因为sh面向终端操作，而换行符又是命令发起的标志，哪怕这个换行符被放在字符串中，也会认为是命令提前结束。因此要把文本中的换行去掉。\n\n网上说用cat xx | xarags可以实现，实测会把双引号也去掉，对于json来说不可接受，最终用sed的':a;N;s/\\n//;ta;'语句实现。\n\n带换行的文本\"ab\\ncd\"存入变量时，直接echo的话，换行会显示成空格，用echo -e才能显示换行，var=$(cat xx)把文件内容赋值，回车会真的转成空格，即使echo -e也还是显示空格。但是：文本最后不管多少个换行，只要换行后没有内容，都不会记入变量。\n\n!! 动态更新已打印文本\n\n`printf \"%s\" abc;sleep 1;printf \"\\r%s\" def`\n\n这句语句会先显示abc，1秒钟后用def替换。奥妙有两处\n\n# \\r回车来到开头打印，进而更新已打印出的内容\n# 用printf而不是echo，因为echo会默认在末尾追加换行，而回车只能回到这一行的开头，如果已经换行就再难回头，所以必须用printf才能实现动态刷新效果\n\n终端控制有个非常有名的软件包ncurses，6.2版本自带了1750种历史上曾经存在的终端序列描述，不过现在仍活跃的恐怕不超过10种了。这个包里最有用的命令也许是tput，`tput cup x y`可以自由地定位光标位置。准确地说参数所对应的位置，是PS1的首字符的位置，而光标位置则会被推到后面。\n\n!! Excel的回车符读取和替换\n\nexcel导出的csv中，正常回车是0D 0A，单元格内的回车是0A。\n\nfread的r模式无法识别0D，严格说是连着0A起读，直接被吞了。只有rb模式才会逐个字节识别。换句话说，r模式fread(1,1)的次数比总字节数要少，rb才等于总字节数。\n\n!! 光标控制\n\n编程语言用`\\`作为转义序列的起始符，而终端则选择了ESC（033或0x1B或\\e）作为转义序列的首字母，之所以只是首字母，是因为ESC后面还要跟二级转义符，范围是`@A–Z[\\]^_`，这32个中又以`ESC+[`这组称为Control Sequence Introducer（简写作CSI）至今仍广泛使用在光标控制和色彩显示上。","modified":"20210611121530000","tags":"lang"},
{"created":"20170421121530000","text":"\n健身不必追求健子肉，平衡也很重要\n\n> 外行看腹，新手看胸，高手看背，大师看腿。\n\n!! 部位练习法\n\n!!! 练习肱二头肌\n\n提臀收腹，腰部要正。因为我腰椎前倾，一定要摆正。不耸肩夹紧肘关节，手腕必须和臂平直。发力过程吐气，想象抗东西要大喝“起”，大喝就是吐气！发力后恢复过程中吸气，为下次运动储能。练习肱二不同的速度会造成形状不同，如果始终快上快下，则只会造成中部发达，如果下放时速度缓慢，则可以使整个上臂都变得粗壮。\n\n!!! 练习卷腹\n\n腿呈90度，手沿腿向上肩离开地面以背不离开地面为宜。下巴收起，脖子不要上拉，否则就是颈部肌肉带动用力。\n\n!!! 练习背部肌群\n\n长期桌前久坐导致胸小肌过紧，背部无力，人就会圆肩驼背。\n\n坐立下拉，拉到锁骨位置，肩部与背交汇处发力。向上时吸气，向下发力到最后吐气。\n\n!!! 练习腿\n\n小腿垂直站立，大腿与小腿平齐，背靠墙站立，坚持1分钟。\n\n# 鸟飞，站直，膝盖不弯，上身放松，前脚掌用力，练习浅面股群。\n# 半蹲鸟飞，膝盖弯曲，上身不用力（站直），后跟不着地，前脚掌用力托起身体，练习膝内侧，膑骨。\n# 台阶步，前脚掌站于台阶，后跟悬空，用力顶起身体，练足弓\n# 单腿抬，一脚踏楼梯，另一脚悬空，靠单脚力弹支撑身体。练单腿力量\n# 三弓同动，身弓（髋和腰之间夹角，上身笔直）\n# 箭蹲，弓步蹲，上身下压，手可上举，缓解下压力。两脚三脚宽。\n\n大成拳摩擦步，步行过程中，后脚尖先抬起，想像脚底踩着滚木向前，脚不要抬太高。\n\n!! 不当健身影响\n\n练胸大肌脖子会疼的原因\n\n# 发力时使用了后背的斜方肌，左右斜方肌力量不平衡，挤压颈椎。\n# 推时腰部会发力，后腰左右两块肌肉通过脊柱带动，力量传递到颈椎，使颈部发力导致紧张。\n# 颈椎僵硬加上左右斜方肌力量不对等，产生侧倾，长期造成颈部歪曲，双肩不平衡。\n\n!! 器械要点\n\n划船机：小腿垂直站地，拉下时肘不要弯，背略向后，脖子不前倾，拉开背和肩。\n","title":"练习健身纪要","modified":"20231028133722457","tags":"think"},
{"created":"20171010121530000","title":"两个嵌入式JS引擎的介绍","text":"\n最近在开发一个协议转换工作，脚本决定使用JavaScript。JS的实现非常得多，除了浏览器里那些重型武器，还有非常多小型的实现版本，大多都实现了ES5.1的特性，这些之中我用了MuJS和Duktape，这两个接口风格和Lua很像，基于引擎按栈式操作，Duk速度比MuJS明显要快得多，也支持部分ES6的特性，但缺点就是接口也较多，掌握起来更难一些。以下逐一说明。\n\n我先用的是MuJS库，引擎类型是`js_State`完全和Lua一样，感觉是Lua出现后照着Lua的接口抄的，来看和C的交互接口(顺便对比Lua的定义)\n\n```\ntypedef void (*js_CFunction)(js_State *J);\ntypedef int (*lua_CFunction) (lua_State *L);\n```\n\n惟一的差异在于不需要返回值，这个差异也是JS不支持multi-return导致的，规范(至少5.1)要求必须且只能返回一个值，在实现时哪怕没有值也要push undefined才能返回。(但是Duk有返回值，正文再述)\n\n再说说函数的执行，记得在call之前一定要压入this，这也是JS语言导致的，因为Function就是自带call/constructor方法的Object，执行后一定要记得弹出压入的返回值。\n\nMuJS在执行出错后直接abort非常不友好，因为abort会导致栈丢失，用GDB的bt无法追溯，这里我修改了jsrun.c改为exit，并在jsstate.c打印了调用栈，出了问题很容易回溯。\n\n它的值类型和Lua几乎一样，tag value风格，标记GC的字段。由于JS语言的特性，每个值对象还多出prototype和properties字段。以及配合ES5对象的extensible/seal/frozen特性的extensible字段。\n\nDuktape的函数声明和Lua一样\n\n`typedef duk_ret_t (*duk_c_function)(duk_context *ctx);`\n\n返回值有四种情况\n\n* 1 正常情况，向栈内压入一个值并返回\n* 0 由Duk引擎自动压入undefined，感觉和1差别不大，不需要多此一举\n* 小于0 相当于抛Error异常，并列举了几种Error的值。从完整性角度来看是有必要的，JS毕竟是门显式支持异常的语言，没有\u003C0就强制剥夺了这个特性\n* 大于1 预留，为了以后支持multi-return做的预留\n\n还是Duktape考虑得更全面。\n\nDuktape有多种编译脚本，比如命令行模式，会额外包含print, console, module, log共4个模块，因为这些接口在某些平台并不存在。甚至还有debug接口。\n\n!! 和C语言的交互\n\n两种都是用了lua的语义，总体差不多。各种pushXXX和pop接口，但duk的接口比较冗余，比如pop竟然有4个接口，有`duk_pop_2`和`duk_pop_3`这样特化的接口，完全想不出有什么必要。\n\n在C语言执行JS函数也表现出duk的冗余，不仅区分了call和pcall，call还有自身,`call_method`和`call_prop`，后两个需要显示指定执行时的this，call没有指定，因此这个函数内了不要调用this。\n\n!! 编码格式\n\njs标准规定字符串内部以Unicode保存，这两种实现都只支持外部输入UTF8，甚至外部输入带BOM的Unicode也会报转码失败，考虑到多语言编码的复杂性，可以接受。\n\n!! MuJS裁剪\n\n首先Date和Math库是最没有依赖的，删除后完全不影响编译。\n\n接下来Regex就有点麻烦，因为gc中要释放regex，string的match,split,replace都依赖正则。\n\n删除URI相关的4个global函数。去掉ES5追加的extensible属性，大约300行代码左右，非核心。","modified":"20171010121530000","tags":"lang"},
{"created":"20230208121530000","title":"两个小微JS库的使用","text":"\n因为网站重构，本来不想使用JS用了htmx库，奈何实在拉胯，只得重新用JS，但不想用太复杂的库遂选了两个，一个MVVM一个类jQuery库，记录一些JS的惯用法。\n\n!! psQuery\n\n说说$变量的构造，在库的开始定义一个单变量的函数，在函数定义完成后惯例性的调用，此时传入this参数（对应window）。然后在代码中用了句`n.$||(n.$=t)`。这个n就是this，t则是构建好的类jQuery对象，先判断全局是否已经定义$变量，没有就把自己挂接上去。\n\n!! DB.js\n\nMVVM库，希望监听的DOM元素增加类似`db=\"text:spanText,class:red\"`属性。当你手动执行DB.scanHTML后，会扫描document所有节点，如果有db属性就会用DB.observable转化成可监听对象，然后把db属性去掉。接下来操作js对象就能自动触发DOM元素的变化。只要保证js的对象名，和db属性某个冒号后的名字一样，就能绑定。\n\n单纯的绑定没大价值，有意义的是compute属性，实现了一个元素依赖其它元素的自动更新。","modified":"20230208121530000","tags":"web"},
{"created":"20151129121530000","title":"两个一直理解错误的编译问题","text":"\n1.dll是可以直接替换而不需要重新编译的。\n\n一直以来，我都以为只有so可以做到直接替换，而dll则不同。因为dll可以选择在编译时候通过.lib方式将dll中的符号表进行绑定。此前我一直认为只有代码中显示的调用LoadLibrary方式调用才是真正安全的。但简单写了个例子，发现如果dll导出的全是C函数的话，则可以直接替换，至少在我验证中是没有问题的。而所说的dll hell更多的是发生在导出类的场景下。反正我是严格使用C风格，也不喜欢导出类这种使用方式。至于具体原因，还要再仔细看看书。\n\n2.MingW可以使用第三方提供的.lib/.dll方式编译，且可正常用。\n\n遇到目标机器只安装了MingW，但库却是给VC准备的。但既然MingW可以编译出.lib/.dll，且看了下MingW自带的.a，二进制文件从结构上和.lib是大致一致的。于是修改.lib为.a，当然还要加上前缀lib，用-l选项可以编译成功，跑了几段程序都正常运行。原因我想是在windows平台，.a只是个命名习惯，最终二进制层面还是要遵守习惯，.dll肯定是PE结构，现阶段大胆猜测.a也是和.lib是一样的。\n\n以上两点只有不完整测试，不敢保证一定正确。后面如果从资料里看到解释的原因，再回到这里修正。","modified":"20151129121530000","tags":"os"},
{"created":"20190420121530000","title":"浏览器的网络请求发展史","text":"\n偶然间推论出的历史脉络\n\nHTTP0.9版只有GET，加上当时浏览器最初的定位就是互相看文档，初代只是个能在地址栏发起GET的图形程序。\n\n慢慢地应用开始丰富起来，估计和CGI同时代，要从浏览器提交数据到后台，于是出现了form表单。这时表单传输数据的格式和GET一样，后来者总会借鉴前面的标准。随着上传文件功能被纳入标准，表单加入了multipart格式，具有独立的特性，至少从数据支撑来说，已经是完整了。\n\n但表单数据会导致整页刷新，并不适用所有场合，微软开发了XHR的前身，各厂商发现这是个好东西，标准化之后有人整出了AJAX概念。到这时既然可以更新数据无跳转，那就干脆更进一步，整个应用都驻留在一个页面，SPA和前后端分离的理念才发扬光大。\n\n网络层面的问题解决了，但响应数据如何与视图层绑定仍是大问题，直接操作DOM便产生了jq这样的面条代码，于是三大框架响应人心，不约而同地实现了双向绑定。\n\n后人看来很自然的开发方式，其实是由多个独立的节点渐渐地串起来。","modified":"20190420121530000","tags":"web"},
{"created":"20180421121530000","title":"浏览器对文件的处理","text":"\n协议工作经常遇到Web开发问及如何处理二进制数据的问题，查了资料并记录。\n\n最早的HTML浏览器实现，是李在1990年实做的，IETF在93年中发布了相关草案，在95年11月24日发布的HTML2.0规范RFC1866，这份规范的内容非常简洁，只有77页。它定义了HTML的MIME类型、基本元素，紧接着在次日，发布了名为《HTML中基于表单的文件上传》的1867。后来的RFC1942又扩充了table的表示法。\n\n1866的HTML表单规范为INPUT元素的TYPE属性定义了八种可能的值，分别是：CHECKBOX, HIDDEN, IMAGE, PASSWORD, RADIO, RESET, SUBMIT, TEXT。另外，当表单采用POST方式的时候，表单默认的具有\"application/x-www-form-urlencoded\" 的ENCTYPE属性。1867则建议对HTML做出了两处修改：\n\n# 为INPUT元素的TYPE属性增加了一个FILE选项。\n# INPUT标记可以具有ACCEPT属性，该属性能够指定可被上传的文件类型或文件格式列表。\n\n另外，本建议还定义了一种新的MIME类型：multipart/form-data（因为urlencoded效率太低了），以及当处理一个带有\nENCTYPE=\"multipart/form-data\" 并且/或含有`\u003CINPUT type=\"file\">`的标记的表单时所应该\n采取的行为。\n\n由于ENCTYPE不同，每个文件都必须配备一个单独的表单。不能和文本类的form共用一个表单。\n\n随着HTML的发展，IETF也就是RFC的责任方决定将它交给W3C组织专门维护，也就没有RFC来记载HTML的描述了。\n\n!! 上传\n\n时间来到了HTML5标准，file元素配合FileReader对象，有了更多的变化。通过getElementById拿到这个file对象后，一个files的数组(虽然我没见过支持多文件选择，也许是为了以后扩展吧)，取`files[0]`就是文件对象，这个对象可以传到FileReader.readAsXXX。由于JS的异步属性，读取到的内容惯用法是在回调函数中返回\n\n```\nreader=new FileReader;\nreader.readAsDataURL(files[0]);\nreader.onload = function(){ this.result;// this指向reader，读取成功onload，不考虑成功失败，用onloadend也行}\n```\n\n奇怪的是即使用二进制读出图片数据，再用base64转换得到的长度始终有问题，只能用DataURL获取图片，原因未知。\n\n!! 下载\n\n静态方式的下载用href标签可以实现`\u003Ca href=http://www.xx.com/xx.zip>点击下载\u003C/a>`，但是问题不少，用PHP实现，核心代码\n\n```\n  header(\"Content-Type: application/octet-stream\");\n  header(\"Content-Length: \".$fsize);\n  header(\"Content-Disposition: attachment; filename=xx.zip\" );\n  @ob_clean();\n  flush();\n  readfile($f);\n  exit;\n```\n\n把文件类型改成octet，然后用readfile函数把文件写入标准输出流，由于PHP的stdout已经绑定到HTTP连接，客户端就能得到完整的文件。通常Content-Length是规范要求必须有的，没有的话浏览器也会兼容，但下载过程中无法显示总长度和当前进度。标准中这个字段表示传输过程中的长度，嚼字眼的话说明不是文本的原始长度，比如开启了gzip压缩，传输长度和实体长度就不一样，如果PHP外面的nginx又套了gzip，由于nginx无法事先知道要代理的内容长度，干脆全部用chunk方式传输，此时Content-Length会被chunk遮蔽，也不会有问题。","modified":"20180421121530000","tags":"protocol"},
{"created":"20181110121530000","title":"论为什么CSS难学","text":"\n很多人以为CSS是给DOM元素设置属性（attribute），其实CSS规定的并不是属性，而是行为（behavior），DOM里的每个元素都可以看成是一个独立的物体，按照CSS规定的方式运动，最后稳定下来的结果就是最终布局的结果。所以有人说CSS不正交，它当然不是正交的，因为它的设计就是要求协变，要求在其他元素做出调整的时候，即便本元素的样式没有发生任何变化，也可以跟着调整位置和大小，以适应新的内容，维持设计风格。\n\n为什么CSS要设计成基于选择器和多种各异的behavior，而不像其他框架那样直接将显示样式绑定到每个元素呢？恰恰是因为正交性，因为CSS和DOM是正交的，这样DOM内容变化时，CSS可以规定一组不变的特性，从而以灵活的方式适应内容的改变。传统的GUI通常每个元素都有固定的位置和大小，要实现根据内容动态调整，就必须针对各种情况（如视口大小改变，内容改变）专门编写代码；WPF则有网格、流式、绝对三种不同的定位方式，与CSS有不少共同点，但是自适应的功能少了不少，也没有选择器的功能，这样动态生成的内容就需要更多的代码来调整。而CSS只要将DOM组织成特定的格式，就会自动启用相应的样式。WPF制作的界面毕竟变化比较少，大部分元素仍然是固定的，而网页通常要求更高的灵活性。\n\n前期准备：首先理解 HTML的一些常用的基本元素和常用样式属性的约束定义\n\n基本元素\ndiv, span, a, p, input, textarea, select, ul, li, h1-h6, hr\n\n常用样式\ndisplay\nmargin\npadding\nborder\nbackground\ncolor\nwidth\nheight\nposition\nfloat\n\n基础：把以下几个常用的CSS样式，记熟\n\n# 固定长宽的圆角有边框的头像\n# 三角形， span (这个前端面试特别喜欢考\n# 横向的导航条，像知乎网页版导航条\n# 竖的的菜单栏，比如gitbook章节列表\n# 同时纵向和横向都居中对齐（暂时没想到其他的\n# 进阶：前端排版布局练习\n\nhttps://github.com/dodoru/40LayoutExercise\n专门做的40个排版练习的演练，前端排版布局都还挺轻松。主要训练，float display position","modified":"20181110121530000","tags":"web"},
{"created":"20180609121530000","title":"论RESTFul特性","text":"\n产生RESTFul的领域，似乎不能涵盖API风格。要求URL以名词性单词结尾，典型的比如心跳，要作为什么样的资源呢？也许可以强作令牌，但其它需求未必有适合的名词。\n\n再提一点很现实的问题，浏览器的GET不能携带body。RFC7231说明payload是no semantic的，XMLHttpRequest的实现会不允许发出，PUT/POST/DELETE可以。这就导致复杂的查询请求只能用POST来实现，已然破坏了获取语义。\n\n再说点XHR作为本地页面，会把PUT和DELETE作为OPTION发出，内容不变，这就涉及到浏览器跨域场景中额外加入的preflight特性，POST如果Content Type改了也会遇到，GET似乎不会。\n\n转载一个观点，带来几个问题：\n\n数据定制的问题：我们的应用数据现在越来越丰富，已经不是10年前可以相比的了，也就是说数据的返回可能很丰富，非常大，而我这次可能只要其中一小部分，比如说我请求一个用户的数据/user/1，我只要他的名字和头像，而并不需要他几千个好友。传统的Rest，你可以加个Mask参数，例如/user/1?friend=false 这种方式无疑增大了前后端的代码复杂度，增加了开发的强度，而且也不够灵活，难道我要给每个字段都加个Mask？后端要依赖各种可能的Mask组合来生成查询也是个麻烦事儿，这种代码写出来也是难维护。\n\n多次请求的问题：类似上面提到的灵活性问题，上面说我们要少要点数据，那我们这次想多要些数据。比如说我想要一个用户的所有好友，还没完，再加上每一个好友的所有好友。这在传统Rest里面，往往我们就使用多次的请求，拿到1度好友的列表，然后写个循环，依次拿到所有2度好友。这当然不够优化，于是可能你会再设计一个专门的API去一次性拿到所有2度好友。同样的问题，这增大了前后端的代码复杂度，不够灵活，万一下次我要3度好友呢？\n\n异常处理的问题：这个很多朋友都会有自己的办法，有些朋友会返回特定的http response code: 4XX, 5XX，有些朋友可能会返回特定的Json消息。比如说/get/user/8527, 如果这个用户不存在，你可以返回404，你也可以返回自定义消息｛msg：“user not found”｝。这很多时候也不是问题，但我觉得如果使用更结构化的异常处理方式，应该会好些。\n\n发出一个请求，我不知道会得到啥：结合上面几点，其实你会发现，如果你请求一个资源，例如/user/1，你并不知道结果里具体会有什么，你可能需要查阅文档，但文档可能已经过期。你可以自己实验，但你不知道是否覆盖了全部可能的情况。这是一个很痛苦的过程。\nPUT和DELETE也是个坑：这需要前后端框架的支持，如果不支持怎么办？其实我也不知道，我这么多年一直尽量避免使用PUT和DELETE来设计API。\n\n每个resource都有自己的一组end point或者说URL，这会带来管理和维护的麻烦。\n安全问题：Rest难以避免的从URL上接受各种参数（parameter），不严格的使用Get等都会造成安全的隐患。有些问题GraphQL上也有，而且我不是这方面的专家，就不细说了。","modified":"20180609121530000","tags":"protocol"},
{"created":"20190502121530000","title":"蒙古帝国","text":"\n成吉思汗传位给窝阔台再传给贵由后，却不能守，被拖雷之子蒙哥抢了帝位，最终传于忽必烈改为元朝。\n\n蒙哥、忽必烈、旭烈兀、阿里不哥是拖雷的4个儿子，蒙哥升为汗后，忽必烈为建立军功，38岁始终大理并最终攻克，得以对南宋形成犄角的攻势。由于一路过于险峻，记过一处险径时，46名随从最后只有2名平安，其余都坠落悬崖。而旭烈兀向西进发，打下了巴格达并终结了阿拔斯王朝、顺道进攻阿勒坡、大马士革。就在此是传来了蒙哥的列讯，不得不返程，留下1万名士兵守卫，但这些士兵不久就全军覆没，蒙古的控制终究没能在中东根植。\n\n旭烈兀建立伊尔汗国、另有金帐汗国(钦察汗)、察合台汗。忽必烈号称天下共主，但其实不过是名义上的。也有说法把窝阔台汗国也算作其中之一，其规模较小也灭亡最早。","modified":"20190502121530000","tags":"think"},
{"created":"20170908121530000","title":"面向对象中的类与应用场景","text":"\n记得我刚学`C++`的时候，第一眼记住的特性就是引入了class关键字，但是由于一直以来的工作，更多是以C语言为主，自己编码也很少用到类，只能把我的理解记录下来，希望未来能有更好的认识。\n\n程序的基本元素是数据和函数，类的出现意味着数据和函数的绑定，类的构造函数会产生对象，而所有同一个类的对象共同持有相同的函数，即只有数据是对象的核心，面向对象就是面向数据的风格，从编码上看，数据拥有了自己的行为，这种方式很符合人的思维习惯，或者说面向对象就是以数据为轴心的思考方式，一个对象就是一个状态机，随着行为而不停地引起内在数据(状态)的变迁。类的特性一旦确定，那么适用于围绕数据的场合，就适合按类建模。但是以数据为中心，在并发环境下一定会遇到锁的问题，很难做到并发。\n\n来到数据的另一边，以函数为主体，数据只是构建结果的一部分，并不是核心要素，比如统计学等需要大量数据的情况下，如果围绕最终数据结果，可以是对象，但过程中那些海量的数据，并不适合作为对象来理解。\n\n映射到比特币和以太坊，似乎正是这两种思维的差异。以太坊的账户体系是典型的面向对象思维，每个人都有各自的账户，并针对账户操作，是集中式的。而比特并没有一个归总的数据，全是分散在各处的UTXO，每次UTXO操作完，就生成新的UTXO，以交易(操作为中心)，数据只是附带的产出物。\n\n是否类就是面向对象的惟一呢？由于`C++`/Java这些面向对象语言非常流行，导致绝大多数人把类和OO合一，从分类角度看，面向对象至少分为class-based和object-based两大类(其实还有些小的分类，还不熟悉先不介绍)。目前主流语言中最有名的object-based的是JavaScript，千万不要因为ES6导入了class关键字就认为JavaScript是class-based语言，它的核心仍然是object-based语言。更准确的说JavaScript是object-based分类中的prototype这个分类，还有一种称为closure的分类。\n\nprototype类型下又细分了embed和delegate两种，它们之间的区别是method的存储模型，把method放在对象内的，称为embed，而存储在对象外，用到的时候临时去找的方式，就是delegate了。","modified":"20170908121530000","tags":"lang"},
{"created":"20180615121530000","title":"明朝与文官集团","text":"\n对明史的一些理解，不贴史料更多是一些论述性的东西。\n\n明太祖立国大杀功臣集团，对官僚集团也是异常残酷，俸禄为历朝最少，剥皮实草戴枷上堂都是只在这一朝独有的特点。也许正是这种苛法，也为后来的反噬做了铺垫吧。建文帝即位，本来是对文官集团的一次修好，但是成祖起兵与燕，凭着朵颜三卫不4年打下南京，后更大杀方孝孺十族，其一朝武力强盛，文官集团自然被压得抬不起头来。\n\n但是武力是很难持久的，随着天下承平，后来的统治者一定会趋于文弱，所以仁宣之治一方面是皇帝本人向平均线的回归，获得治世之誉也是文人集团对历史纠正的一次行动。\n\n土木堡之变是明朝早期一次大的转折，皇帝对于太监的宠信原因不详，但随着兵败，皇权失去了京畿26卫（太祖上12卫，成祖增10卫，宣宗增4卫）中21卫的控制权，仅留下锦衣卫为皇帝统领、腾骧左右卫、武骧左右卫未撤，其余归兵部辖下。\n\n随后皇权逐渐衰落，到弘治朝更是成了文官集团最喜爱的傀儡皇帝。其子正德帝意图再染兵权，却不幸因落水而死，这落水极大可能是文官集团的反制。\n\n嘉靖朝大礼议，是皇权和文官集团的一次激烈冲突，本以为扶藩王入继大统可以回到隆庆朝的风气，但嘉靖是聪明人，以炼丹为名消极抵抗，在位45年算是高寿，炼丹一说真伪我是有疑问的。在位期间发生宫女试图勒杀的奇事，有言是文官集团在背后指使，证据不足且存疑。\n\n万历朝的张居正算是文官中的异类，非其改革王朝恐怕早50年便要终结。","modified":"20180615121530000","tags":"think"},
{"created":"20200102121530000","title":"命令行工具用法探索","text":"\n!! ls\n\n`--hide`可以隐藏不想看的目录\n\n!! find\n\n最核心参数是path和expression，这两个参数都有默认值，path是当前目录，expression就-print，相当于只输入find和tree的效果类似。所有的expression一定是`-`号开头，find解析就以此为依据。\n\nwindows用 `dir \u003Cfindname> /-n /b /s /a-d` 模拟。\n\n!! xargs\n\nxargs和find同属于findutils包，xargs原本就是为find而开发的\n\n!! pkill\n\n默认仅process匹配，-f变为command line匹配\n\n!! info\n\nH 打开按键帮助\n\n{} 向前或向后查找上一次的关键字","modified":"20200102121530000","tags":"tool"},
{"created":"20160313121530000","title":"模块功能的划分与解耦","text":"\n这周工作上解决了一个困惑我很久的需求，记一些要点。\n\n在C-S模型中，向来都是客户端发请求服务端应答，偶尔也会有服务端推送业务，但已经是比较不常规的方法了。服务器的推送是不做确认的，即发了就发了，也不会要求确认，更没有重传机制。至少我看iOS的推送也是不承诺这些的。但是需求总会时不时来一个推送确认/重传来恶心一下。\n\n当前代码的订阅推送是采用传统的观察者模型，事件源向事件中心发消息，所有向事件中心订阅过的模块都会收到消息。事件中心是与业务无关的，即不关心事件来自哪里，也不关心事件发给了谁。在这种前提下要做事件确认，而且必然是向事件源确认，是件很困难的事情。现在留存的确认机制，是直接向事件中心确认，向分发器发送确认，但真正需要关心的，是事件源，这就把两个功能放在一个模块里，造成了职责的混乱。也许当初认为这两个都是事件相关，就放在一处了吧。\n\n不过好在内部实现时，事件分发dispatch和事件确认receipt最终还是分成了两个组件，只是在dispatch组件中直接调用receipt的接口，把消息又转出来了，需要关心事件是否被客户端确认的源模块，主动向receipt注册，在收到事件确认后，会回调出确认函数。考虑到事件确认毕竟是定制化为主的需求，即使增加事件源模块的注册代码量，也是比较容易接受的做法。\n\n这周因为又收到了事件重传的需求，起初我理解重传restore既然在确认步骤之后，这两个功能就可以放在一个组件里面，但代码实现时意外发现receipt的代码是实现在基础组件的(原来我以为是在定制模块实现的)，这就直接导致了restore不可能和receipt做到一起，因为基础组件组是不可能接受这样的业务需求的。也正因为这种组织上的制约，反而让我重新思考，确认和重传真的需要放在一起吗？还是我想当然地一种认识。只能说重传依赖于确认，但不能说确认会推导出重传。这是典型的必要非充分条件。既然这样，那就更应该把这两者给区分开来，所以最终dispatch、receipt、restore是按三个组件的接口来划分。\n\n这件事的反思就是，需求分解要做到好的解耦，其实是非常难。稍一被客户表示的需求给带着，就会把并不强相关的内容合并到一起。不知为什么往一个接口或组件里增加内容似乎总是很容易，但要从原有的接口把内容剥离出来，则是千难万难。软件工程所追求的高内聚低耦合，又或者正交的高组合性，需要对概念非常清晰的认识，稍一含糊可能就会破坏两个概念的边界，进而造成模块间职责错位，再往后就是代码一团麻无法理清。\n\n这周正好读到一些文章，也是讲到人类的认识原理中，概念是个非常重要的东西，概念的多少，区分度直接导致了知识的广度和深度的不同，甚至语言对概念描述的详实程度，都会影响认识。比如英语单词数量之多是有目共睹的，甚至很多就是完全无意义的组合，但即使这样，所包含的信息量，和各信息之间的区别，就天然地会在单词不同目有体现，也就迫使人去理解单词间的不同，进而区分、明确概念，这就是语言对认识的推进作用。姑且不论对错，这个观点至少是有启发性的。","modified":"20160313121530000","tags":"design"},
{"created":"20231027032635878","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable '目录' sort[title]>>\n\u003C/div>","tags":"$:/tags/SideBar","title":"目录","modified":"20231027033057769"},
{"created":"20191107121530000","title":"目录服务和NetBIOS协议","text":"\n目录代表实体，可以是一个文件或某个人的信息，通常这些信息以树状形式保存，类似目录树。目录服务是按照树状信息组织模式，实现信息管理和服务接口的一种方法。目录服务系统一般由两部分组成：第一部分是数据库（一般是分布式数据库），且拥有一个描述数据的规划；第二部分则是访问和处理数据库有关的详细的访问协议。\n\n目录服务与关系型数据库不同的是，读非常快，但写比较慢，也缺少事务机制，是针对特定场景的特化机制。目录不支持批量更新所需要的事务处理功能，目录一般只执行简单的更新操作，适合于进行大量数据的检索；目录具有广泛复制信息的能力，从而在缩短响应时间的同时，提高了可用性和可靠性。目录服务技术的国际标准有两个，即较早的X.500标准和近年迅速发展的LDAP标准。\n\n!! X.500协议族\n\nX.500不是一个单一协议，它是由一个协议族组成：\n\n* X.501模型强调目录服务基本模型和概念\n* X.509认证框架是如何在X.500中处理目录客户和服务器的认证\n* X.511 抽象服务定义X.500被要求提供的功能性服务\n* X.518 分布式操作过程表明如何跨越多台服务器处理目录服务\n* X.519 协议规范即是X.500协议，包括目录访问协议DAP、目录系统协议DSP、目录操作绑定协议DOP和目录信息Shadowing协议DISP\n* X.520 选定的属性类型要求是X.500自己使用的属性类型\n* X.521选定的对象类即为X.500自己使用的对象类\n* X.525复制是如何在目录服务器之间复制目录内容\n\n这些X.500标准中主要定义有多种内容。一个信息模型：确定目录中信息的格式和字符集，如何在项中表示目录信息(定义对象类、属性等模式)；一个命名空间：确定对信息进行的组织和引用，如何组织和命名项——目录信息树DIT和层次命名模型；一个功能模型：确定可以在信息上执行的操作；一个认证框架：保证目录中信息的安全，如何实现目录中信息的授权保护——访问控制模型；一个分布操作模型：确定数据如何进行分布和如何对分布数据执行操作，如何将全局目录树划分为管理域进行管理——目录管理模型，客户端与服务器通信的协议—目录访问协议DAP，将用户请求在服务器之间进行链接所需的目录系统协议DSP，将选定的信息在服务器之间进行复制所需的目录信息映像协议DISP，用于自动在服务器之间协商连接配置的目录操作绑定协议DOP。\n\nX.500虽然是一个完整的目录服务协议，但在实际应用的过程中，却存在着不少障碍。由于目录访问协议DAP这种应用层协议是严格遵照复杂的ISO七层协议模型制定的，对相关层协议环境要求过多，主要运行在UNIX机器上，在许多小系统上，如PC和Macintosh上无法使用，因此没有多少人按照DAP开发应用程序，TCP/IP协议体系的普及，更使得这种协议越来越不适应需要。\n\n!! LDAP协议族\n\nLDAP协议从1993年批准，产生了LDAP V1版本，随后于1997年发布了第三个版本LDAP V3，它的出现是LDAP协议发展的一个里程碑性标志，它使LDAP协议不仅仅作为X.500的简化版，同时提供了LDAP协议许多自有的特性，使LDAP协议功能更为完备，具有了更大的生命力。\n\nLDAP典型应用是保存用户名和账号，并用于大型系统的认证。协议自身是明文的，所以v3版本加入了SASL支持，结合kerberos可以对整个通信过程做到加密。\n\nLDAP V3协议也不是一个协议，同样是一个协议族。\n\n* RFC 2251——LDAP V3核心协议，定义了LDAP V3协议的基本模型和基本操作\n* RFC 2252——定义了LDAP V3中的基本数据模式（Schema）（包括语法、匹配规则、属性类型和对象类）以及标准的系统数据模式\n* RFC 2253——定义了LDAP V3中的分辨名（DN）表达方式\n* RFC 2254——定义了LDAP V3中的过滤器的表达方式\n* RFC 2255——LDAP统一资源地址的格式\n* RFC 2256——在LDAP V3中使用X.500的Schema列表\n* RFC 2829——定义了LDAP V3中的认证方式\n* RFC 2830——定义了如何通过扩展使用TLS服务\n* RFC 1823——定义了C的LDAP客户端API开发接口\n* RFC 2847——定义了LDAP数据导入、导出文件接口LDIF\n\n这些协议主要定义了LDAP的内容，同时主要定义了一个信息模型：确定LDAP目录中信息的格式和字符集，如何表示目录信息(定义对象类、属性、匹配规则和语法等模式)；一个命名空间：确定对信息进行的组织方式——目录信息树DIT，以DN和RDN为基础的命名方式，以及LDAP信息的Internet表示方式；一个功能模型：确定可以在信息上执行的操作的通讯协议以及在客户端进行这些操作的API接口；一个安全框架：保证目录中信息的安全，匿名、用户名/密码、SASL等多种认证方式，以及与TLS结合的通讯保护框架；一个分布式操作模型：基于Referral方式的分布式操作框架；一个LDAP扩展框架：基于控制和扩展操作的LDAP扩展框架 。\n\n但在LDAP协议中尚未定义通用的访问控制模型和复制协议（对应X.500的映射协议DISP），尽管不同的LDAP厂商均实现了自己的控制模型和复制机制，但是LDAP标准的发展正集中在访问控制模型、复制协议（DUP）以及扩展操作上，这些扩展操作包括查询的分页和排序、语言标签、动态目录、LDAP服务发现等。\n\n!! NetBIOS\n\n起因是有机器被人格式化，定位到某IP但未能锁定是谁。得知nbtstat可以反查并确认工号。\n\n此协议是IBM在1983年发布，微软85年实现，比较多见确实在win系统。仅适合用于局域网且不支持域名。最初的时候跑在网络切换，虽然后来也做了over ip但依然改变不了不能路由问题\n\n有自定义的帧头格式，和TCPIP更类似平级关系。\n","modified":"20191107121530000","tags":"protocol"},
{"created":"20211218121530000","title":"内存使用的观察和理解","text":"\n!! 内存使用表现\n\n进程能使用的内存肯定是有上限的，如果慢慢增长，VSZ会持续增长，RSS会到一定量开始波动，但最终还是会因超限被内核kill掉。如果突然申请大量内存，会更早地被kill。VSZ一旦增长，就不会再减少，即使用不到，也会保持这个大小。\n\n比如一台8G内存的安卓7.1，每次分配50M内存，VSZ在接近4G、RSS接近3G时退出，但如果调大成先1.25G再750M，即使还不到2G的VSZ也会被kill。\n\n!! free命令输出\n\n为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。\n\n!! 用ulimit限制\n\nVMEM和AS同义词，AS表示Area Space。python3.10如果只设置soft上限，超过后会收到异常但不会被kill。如果设置内存阈值时低于当前进程使用量，会收到SegmentFault错误然后退出。ulimit有soft和hard两个值，在控制上二者并没有区别，都会限制资源的使用，区别是：\n\n# 无论何时，soft总是小于等于hard\n# 无论是超过了soft还是hard，操作都会被拒绝。结合第一点，这句话等价于：超过了soft限制，操作会被拒绝\n# 一个process可以修改当前process的soft或hard。但有一些要求：\n * 修改后soft不能超过hard。也就是说soft增大时，不能超过hard；hard降低到比当前soft还小，那么soft也会随之降低。\n * 非root或root进程都可以将soft可以在[0-hard]的范围内任意增加或降低。\n * 非root进程可以降低hard，但不能增加hard。即nofile原来是1000，修改为了900，在修改为1000是不可能的。（单向，只能降不能升）\n * root进程可以任意修改hard值。\n\nbash内建的ulimit默认显示soft，修改时同时影响soft和hard。","modified":"20211218121530000","tags":"os"},
{"created":"20170108121530000","title":"排版和字体的关系","text":"\n上一篇说了排版，排版之所以这么复杂，和字体有很大关系。\n西文字体每个词长度不一致，在排版上首先要处理的是一行文字的fill/justify/hyphen问题。\nroff的任务就是处理文字的这3大问题，其它的诸如表格、公式、图片则需要tbl/eqn/pic来辅助。\n\n要解决好justify问题，必须要知道每个文字的宽度。至于文字怎么描绘，\n其实排版软件可以不关心，丢给打印机就行。这里要引入两个字体中基础而重要的概念：\n\n* metric 指文字尺寸，具体包含字符编码定义、字符宽度和四个角的坐标。\n* glyph 指某个文字的外形，即要怎么描绘。早期是点阵方式，现在都是矢量字库，给定字符的一些点，并用贝塞尔贝曲线把这些点连接起来。\n\n刚才提到排版软件不关心glyph，roff也确实是这么做的。它的字体就只含metric不含glyph。发送给output device的只是文字的编码和尺寸。\n\nroff和TeX把字体中的metric和glyph分离，二者由于历史久远，用的都是现在很少见的字体格式(严格说是metric)。\nroff叫DIT(Device Independent Troff)。而CTeX目录下能找到很多后缀是.TFM文件(TeX Font Metric)。\n\nAdobe的metric叫AFM文件(Adobe Font Metric)，含文字的宽度和四角坐标。字形glyph是PFB格式。\nPFB是Type1字体的Binary形式，可以用pfbtops转成pfa文件(其实就是ps源码)，因而支持矢量方式放大无锯齿。\n\n以上3种metric格式可以互相转换，roff目录下的afmtodit和tfmtodit，miktex下的afm2tfm，都是用于metric转换。\n\nroff做完排版，渲染就交给具体的机器，不关心字形，用的glyph也是随着不同的机器而不同。比如devps，输出为ps就依赖pfa文件。而高德纳为了追求TeX的效果优美，给制作glyph开发了METAFONT。这是一个独立完整的工具链。\n\nTeX输出的字体格式，早期当然是 MetaFont -> 点阵 GF(generic font) -> 输出设备驱动；后来有 pk 点阵字体(其实是gftopk转换后的压缩格式，是PacKed简写，好随便啊)；再后来有 PostScript 矢量格式的 Bluesky 人工重制的 computer modern字体和程序自动重制的 cm-super 字体等。\n\n最早的TeX只支持读取tfm文件，一个完整的TeX字体（MetaFont生成的）为一个tfm文件和pk文件，前者负责字体的抽象部分（如ligature，kern等），后者负责描述字体的实体部分（即字体的glyph具体长什么样子）。TeX出现的时候Adobe还没成立，为了让打印机能复用pk字体，后来一些开发者将MetaFont的字体转换成PostScript的字体，通过dvips或者dvipdfm将dvi转换成ps或者pdf文件。\n\n!! 现代字体格式\n\nroff和Tex都是相对古早和偏极客的技术了，说说更被大众熟知的字体吧，按历史发展脉络大致如下\n\nType1 -> TrueTypeFont -> OpenTypeFont(Type2) -> WebOpenFontFormat\n\n从名字就能看出，Type1是Adobe众多Type X中最早也是最有名的，原因有几个:和PostScript一起出现得最早，标准开放，支持hint因此在小字号效果较好。作为对比Type3虽然支持完整的PS特性，但没有hint，也缺少在各平台编辑软件。所以尽管现在不是主流格式(相对TrueType)，但在技术上无法忽略。\n\n为了对抗Adobe，微软和苹果联合发布了目前依然是最常用的TrueType字体，但后来微软又和Adobe一起发布OpenType，由于微软同时参与两个标准，所以OpenType如果包含TrueType字体，后缀仍用.ttf；如果包含PostScript，则用.otf后缀(叫Type2顺理成章)。也许大家都觉得分离式字体不好，所以自TrueType以后，都是整合成一个文件的路数。\n\nwindows上常见的字体还是TrueType，一般以.ttf结尾。中文宋体的后缀是.ttc，意思是TrueType Font Collection，是把多个文件整合到一个文件中，多用于CJK的字体包。\n\n随着Web化普及，为克服传统的字体文件过大问题，2009年诞生了WOFF字体，使用压缩技术，通常比TrueType小40%。后来的WOFF2则更进一步用brotli替代了原先的zlib算法，达到更高的压缩率。这些字体都采用sfnt封装技术。\n","modified":"20170108121530000","tags":"tool"},
{"created":"20170106121530000","title":"排版软件的故事","text":"\n英文中把文字处理分为Typewrites和Word Processors两大类。平常用的Microsoft Word\n是所见即所得的字处理系统，适合日常的书信、报告。而专业的书籍排版由于周期长，\n版面要求精细往往有更高的要求。当前最有名的是TeX，在TeX之前是贝尔实验室诞生的roff系统\n(GNU实现版叫groff)，不过现在比较式微。另外还有XSL-FO也经常被企业用来制作文档，\n好像Apple的一些文档就是用这个格式。不过这个标准实在不怎么样，2013年11月后，\nW3C推荐CSS3 Page作为替代标准，这个XSL也就永远地停留在1.1版本不再演进了。\n\n先说句题外话，由于这两个排版工具出现的年代还是Unix的远古时期，那时的编辑器分为\nline editor和screen editor。line的典型就是sed，screen则是现在耳熟能详的vim/Emacs。\n不过现在硬件性能提高，各种编程语言也很易用，惟一还有人知道的sed也显得无关紧要了。\n\nTeX的第一版是1978年发布的，通常也称为TeX78。而roff要早一点1973年。\n既然roff的历史更早，就从它说起吧。roff的全称是run off，和所见既所得的排版区分，用off表示离线的概念。\nroff分为nroff和troff两种实现。现在我们用的GNU groff则是对这两个版本的封装，和gcc封装\ncpp、cc1、as、ld是一个意思。\n\nnroff使用等宽字体，行为像打字机，man的背后就是用它，在终端上至今都运行得很好。\n而troff可以用各种字体，适合于打印机。最早的nroff只能用在C/A/T打印机上(phototypesetter)，\n原因就是贝尔实验室在1973年买了台C/A/T。这是台1971年设计的打印机，共支持4种字体：\n英文字符Roman的regular/bold/italic再加一个特殊记号的Special。\n买了之后Ossanna才基于C/A/T硬件写出了nroff，在今天看来，只为一种打印机写程序是很死板的，\n直到1979年Brian Kernighan重写了ditroff，取意device independent troff。\n现在看到的troff都是ditroff了。直接的现象是groff程序字体目录下devps、\ndevlbp这些带dev前缀的目录，就是能被ditroff处理的字体。\n\n高德纳发布的TeX由于只支持英文，在东亚国家是无法使用的。最早着手解决这个问题的\n是日本的ASCII社，发布了pTeX程序，p是publishing的意思。慢慢的TeX社区也意识到这个问题，\n就有了XeTeX，后来又有了luaTeX，都能支持Unicode编码。\n\n中文地区很有名的是CTeX套装包，安装后程序的目录结构是这样的：\n最重要的是miktex目录，是个windows下很好的移植版本。这个目录下的miktex/bin包含各种可执行程序。\n包括pdfTeX、XeTeX、luaTeX三大著名引擎以及其它各种需要的程序。\n其中pdfTeX是三者中最老的，它最早支持了pdf特征，不过似乎不支持Unicode。\n和bin平级的还有各种辅助目录，比如font等等。\n\n其次重要的就是CTeX目录，这里包含了旧式的cct包和其它中文宏包。\n也是这个套装的命名来源。处理程序有了，Ghostscript和GSview则用于预览。\nWinEdt目录是TeX的集成开发环境，最后一个UserData放的好像也是字体和配置。\n\n想要从命令行直接运行LaTeX，即使是我都感到非常困难，背后的概念实在太多。\n所以有Lyx这样的套件来简化，它只用到了XeTeX和luaTeX这两种引擎。","modified":"20170106121530000","tags":"tool"},
{"created":"20190528121530000","title":"批处理的用法","text":"\n!! 语法篇\n\n!!! 基本语法\n\n分支和判断，如果是字符串比较，一定要两侧加双引号。\n\n```\nif \"%1\" == \"\" (\n  command\n) else if %1 equ 5 (\n  command\n)\n```\n\n变量捕获\n\n网上说通过重定向到文件再`set /P a=\u003Cxx` 方式读取回来，一则看上去不优雅，更麻烦的是前一步写入的文件在此时经常会读不到，原因不明。最好的方式还是用`for /f`语句。\n\n```\nfor /f \"delims=#\" %%A in ('your commad %*') do (\n  set VAR=%%A\n)\n```\n\n只有for的/f选项才能在SET中执行命令，否则只会当作字面量或文件名来解析，其次command要用单引号包围，其中的%参数会正常解析，最后变量一定要写两个%（只有在cmd直接输入允许一个%）。/f后面的选项可以为空，默认会按空格会Tab对内容进行切分，如果希望不切分，找一个不会在内容中出现的字符作为切分键，但无法用\\n，因为会被识别为\\和n两个字符。另外for语句支持嵌套。整个语句看下来，将输出先按行切分，再进行行内切分，值赋给一个变量，接下来用这个变量，用法有一点像awk的getline函数，甚至连选项名f都和awk一样。\n\n!!! 函数用法\n\n用 :func 加 goto eof的方式可以定义一个块，但它还算不上函数，如果执行流到了定义开始处，会继续执行块中的语句，这显然不是函数的行为。根本原因是批处理只能按规定执行(顺序或跳转)，不具备全局哈希表，无法把一个块从执行流中摘出来。所以我能想到的办法，把所有要定义的函数放在最后，然后在第一个函数前加上一句goto eof防止函数被执行。把主执行流程写在开头。\n\n这种做法能行得通，多亏批处理有call机制，函数执行完，能接着上一句call继续走下去。\n\n从中可以得知，函数最朴素的实现，便是开始标记、结束标记、执行后的返回地址。和汇编指令没有区别。\n\n命令中经常能看到类似`%~dp0`的符号，分开解读它。最初的原型是%0，执行命令本身，如果%后面是~符，表示对变量参照进行扩展替换，有一系列的修饰符，d表示盘符，p表示路径，n表示文件名，x表示扩展名，详细文档可以用for /?看到。利用%~dp0可以实现一个小技巧，一个文件夹下有a.exe文件，想利用批处理调用它，又想这个批处理能做到可迁移，写作`%~dp0\\a.exe`就能达到此效果。\n\n从命令行交互使用set /p var=[prompt]方式，之后用%var%就能得到用户输入。\n\n!!! 特殊命令\n\n* cd /d xx: 如果不带/d，切换路径不能换盘\n* start: 类似fork，会新开窗口，不阻塞当前脚本继续执行。也可以用/wait选项等待\n\n!!! 嵌入其它脚本\n\n通用法\n\n# @more +1 %~f0 | script_engine & exit /b   # 一行代码，利用more打印第2行以后内容，缺点是不能传参，但可以交互式\n\n适用于python\n\n# @SETLOCAL ENABLEDELAYEDEXPANSION & python -x \"%~f0\" %*  # 利用了-x选项来跳过第1行，如果语言支持同样功能也可以。甚至我感觉前面的SETLOCAL都没用\n# 不是一行式，且比较难懂，由于这段代码同时符合bat和py，技巧上很高明，但实用价值没有上一条高\n\n```\n1>2# : ^\n'''\n@echo off\npython \"%~f0\" %*\nexit /b\nrem ^\n'''\nimport os\nimport sys\n# python code to compute the time elapsed\nprint(sys.argv)\n```\n\n!! 用法示例\n\nruby的gem.bat写成这样 `ruby.bat \"%~dpn0\" %*`\n\n%在windows批处理中相当于shell中的$表示变量，~是必要的前缀否则会把后面的dpn当成变量名，有了~以后dpn就可以各自表示对应的意思。d表示盘符，p表示路径，n表示程序名。还原到上面这个例子%~dp指向gem所在的路径，n就对应了gem(没有扩展名，也不需要)。整句话解释下来，就是ruby.bat gem %*。而gem刚好是ruby的源文件，因此gem就被执行到了。\n\n!! 与Windows上其它功能的联动\n\n!!! WSH和COM\n\nWSH的全称是Windows Script Host，win95时代研发，win98起成为标配的自动化工具。对应cscript.exe和wscript.exe两个Host程序，但这俩只是壳，最终要根据脚本的后缀加载不同的dll。比如.js就加载jscript.dll，官方只有vbs和js，如果安装了ActivePerl这类包可以加载perl.dll并用perl语法写脚本。\n\n随着微软自身的演进，WSH还封装了COM技术，从OLE1.0 -> COM OLE2.0 ActiveX。比如在js中用new ActiveXObject可以获取COM对像，进而操作宿主中的Office对象，这也体现了COM底座的价值。\n\nWSH环境自带了14个对象，而Wscript则是root对象，其它对象都要通过Wscript.CreateObject()才能实例化。有4个一级对象\n\n* WshShell: 主要负责程序的本地运行, 处理注册表项, 创建快捷方式, 获取系统文件夹信息, 处理环境变量等，存在wshom.ocx文件，通过CreateObject(\"Wscript.Shell\")得到，该对象的Run方法可以执行命令\n* WshArguments: 作用是获取全部的命令行变量\n* WshNetwork: 作用是开放或关闭网络共享, 连接或断开网络打印机, 映射或取消网络中的共享, 获取当前登陆用户的信息\n* WshController: 创建一个远程脚本对象\n\n!!! 图形化\n\n利用hta方式，实现所有平台的图形化开发一致。加上hta可以利用WScript，于是就打通了和批处理的双向调用，示例如下\n\n```\n// bat_file: 和hta同目录的批处理文件，返回运行结果\nfunction popen(bat_file){\n\tvar ws = new ActiveXObject(\"WScript.Shell\");\n\tvar s_name = document.location.pathname;\n\tvar pos = s_name.lastIndexOf(\"\\\\\")\n\tvar ro = ws.exec(s_name.substring(0, pos+1)+bat_file);\n\treturn ro.stdout.readall()\n}\n```\n","modified":"20190528121530000","tags":"lang"},
{"created":"20170917121530000","title":"千岛湖公司旅游","text":"\n这周五部门组织去千岛湖旅游，再不去就只能杭州一日游了，加上毕竟是和自己组一起去，路上好歹有个伴。周五吃过中饭出发，大概花了两个半小时入住千岛湖的海外海宾馆，据说是四星级不过房间没有觉得特殊。这次旅游是轻松游，所以安排的行程比较宽松，离饭点还有一段时间，一行人提议到湖边走走，顺便买副牌。宾馆就在湖边，不过也没什么特别的景致，千岛湖是漫水而成的水库，放眼望去都是散落在湖中各个小山包。来到导游说的当地最大的联华超市，不过从超市收银台都没什么人来看，当地的居民确实非常少。\n\n晚上吃的是团餐，三桌每桌10个菜左右，人还没到，所有的菜都已经上齐了，大家吃的也非常快，照例抱怨菜太差，我倒觉得不错，至少吃得有胃口。吃完饭就回到宾馆，因为张文强要打王者荣耀，所以我们凑了4个人(黄立棉、周夏杰、钟超)打双扣，到快11点的样子夏杰和钟超回去了，我和立棉又讨论了一会儿RPCServer的自动化方案，不过依然没什么好的办法。\n\n第二天安排9点半出门，比较悠闲地吃了自助早餐，没觉得四星级有多好。去森林氧吧，我走得非常慢，听说松树和松香的故事，看一路松树被割得树皮几乎无存，觉得对松树未免太残忍。其他小伙伴走得非常的快。中午照例是团餐，吃完之后回到宾馆，还在宾馆里休息了两个小时，去湖边骑自行车。这是我第一次骑山地自行车，才知道该怎么换档，在湖边大概骑了一个小时吧，景色还是挺好的，阳光也非常好。这一天的晚饭自行安排，组里有千岛湖本地人，他点的菜还剥了虾，味道都非常不错。不过有桌人喝酒总是很墨迹，瞎逼逼却不喝，所以喝到后面很没意思。我们受不了这么墨迹，于是一群人就走回宾馆了，由于白天的活动，有些人觉得运动量有点大，就没来打牌，人少凑不起一桌就聊聊天看看电视。\n\n第三天是去千岛湖心，我本来以为今天是节目的核心。第一个岛看海瑞祠，我们四个人还在岛上拍了VR照。第一次接触全景相机的效果。之后去第二个岛梅峰岛，主要是爬山看整个湖景为主，但是我们几个都不想爬了，所以就在山下借着wifi看了会儿绝地求生的游戏直播。第三个岛更加无趣，在船上就开始介绍钢管舞和泰国表演，我们都觉得太低俗，就在湖边散心。因为船是三个团拼一个，所以我们就要互相等，大概两点半的样子从千岛湖出发回杭州，回到公司五点钟了。\n\n这次的行程可以说真的是非常放松，而且不累，只不过千岛湖这个地方确实也没什么好玩的，或许是好玩的岛没让我们去吧。比起之前去的常州恐龙园，还有桐庐巴比松啊，这次玩后留下深刻印象的东西太少，小伙伴们也没再一起玩，这么多次旅游，最怀念的还是在巴比松的杀人之夜。","modified":"20170917121530000","tags":"think"},
{"created":"20200402121530000","title":"嵌套加载的目录查找方式比较","text":"\n动态语言的加载通常会有一个路径列表，加载时按列表顺序寻找。这个列表里大部分是绝对路径，但也会有当前相对路径，当嵌套加载时，相对路径如何定位就是个容易迷惑的问题。以下的目录结构为例\n\n```\nmain.lang\nutil/\nlib/\n    a.lang\n    config.lang\n```\n\n入口是main.lang，在main里导入包不会有歧义，但是在a.lang如何导入config就不那么明确了。下面列举不同语言的作法。\n\n!! lua\n\n不管当前执行加载语句在哪个文件，相对路径查找的参考系，始终是入口执行文件。因此在a中加载config，只能写成require 'lib.config'\n\n!! python\n\nimport加载没见过绝对路径方式，默认的相对路径参考系，是入口执行文件，但可以通过`.`或`..`（但不能带`/`符）来改变相对路径所指向的目录。\n\n* 在a.py加载util，写成 import util，表示按main的路径来寻找\n* 在a.py加载config.py，写成 import .config，通过.告诉解释器，以a.py的路径为相对路径，寻找包，此时config和a在同一目录下，因此.config能加载\n\n!! php\n\ninclude或require语句的参数有3种形式\n\n# 绝对路径，以`/`或`C:\\`等开头的文件，没什么好说的\n# 相对路径，以`./`或`../`开头的文件，始终以解释器执行入口的文件作为查找参考系，a加载config必须写作include './lib/config.php'\n# 未确定路径，搜索路径包含`.`时，会从执行入口文件和当前嵌套加载的文件都查找一遍，在a加载config写成include 'config.php'或include 'lib/config.php'都可以，不愧是最强大的语言\n\n网上有说PHP的惯用法是在入口定义`__ROOT__`变量，其它模块文件都引用这个变量，并用绝对路径的方式加载。","modified":"20200402121530000","tags":"lang"},
{"created":"20170806121530000","title":"区块链的运行机制","text":"\n区域链本质上是一种由交易驱动的，由共识确认并跃迁的状态机。区块链由区块以单向链表方式连接，并利用哈希的特性保证了数据的不可篡改性。\n\n交易可以是BTC的转账支付，也可以是ETH的智能合约。每个人都可以发起交易(相当于向区块链提交一个合并请求)，这笔交易会保存在矿工节点的内存中(普通节点只传播，但不保存)，当这笔交易没有记入主链前，就不具备合法性。要合入主链需要矿工的确认，由于每个块的容量有限，矿工只会选择手续费高的一些交易合入区块。如果块容量上限太小，或出现爆发性的交易数量，就一定会有交易驻留在矿工的内存(常说的网络堵塞了)，才有BTC的扩容争议。一旦交易被矿工commit，且最终被成功地seal(以上两个词取自ETH的日志)。这条交易就具备了永久的合法性(严格地说还要再加上若干次确认，否则有可能出现在分支上，最终还是被更长的链超越而视作无效)。\n\n众多矿工同时竞争向主链的提交，依赖共识算法来决定哪个矿工取得这一轮的权利。方式有很多，如PoW或PoS等。PoW算法达成共识非常消耗成本，因此对完成条件的个体会有激励，这个激励的形式就是增发的数字货币。\n\nBitcoin交易有Coinbase、P2PKH、P2SH几种（隔离见证后，又增加了P2WPKH和P2WSH）。\n早期的交易（高度62061以下）的交易数都是1，这些交易都是coinbase交易，输入没有签名，长度也比较短，典型长度0.215K，sequence通常是0xFFFFFFFF。P2PKH的`tx_in`脚本比较长了，包含签名和公钥，71(签名)\\+65(公钥)\\+1\\+1=138(两个都分别是长度占位)。但是从密码学角度看，有了签名(即R和S)，只要再配上个`rec_id`(范围0-3)是可以反推出公钥的，如果采用这种方式能极大地减少输入脚本长度。\nP2PKH交易的`tx_out`，脚本长度25(用1字节表示)，脚本中5字节是操作符，20字节是HASH160的结果，加上8字节的金额总共是34Bytes。\n\n以太坊来目前也是PoW共识机制，它的挖矿算法称为Ethash，这是个比较高层的概念，每个Ethash持有GenericFarm，这个Farm下再持有多个miner，从这个结构看，应该是受了farm和miner的关系就像矿池分解任务给节点的关系。最终的验证通过farm来完成。验证的术语是seal，cppeth自带的seal只有CPU，也许要用上GPU挖矿要用另外的程序吧。seal的封印对象是BlockHead，另外BlockChain对象的作用还没有明白。\n\n以太坊Trie的设计，对轻客户端友好，每个区块头的三个指针代表了三个核心的树：状态、交易、收据。\n\n交易树比较简单，收据是一个RLP编码的数据结构，除了索引变得更加简单，logbloom的使用也让轻客户端使用起来非常方便。\n\n区块头的设计和轻客户端是密切相关的。绝大多数节点并不需要完全同步，但要求访问数据的便利性。\n\n区块内的主要数据结构是MPT，这里面稀疏区域用KV节点。在状态和账户的树里，diverge nodes 深度为64，使用sha3(k)作为key，非常难以DOS攻击。\n\n目前整个状态的访问查询可以变得更快，全节点的全同步也可以变得很快。因为紫皮书带来了新的方向，压缩算法或是uncle区块实现等，紫皮书引入了POS机制，更友好的轻客户端同步实现，计分和测了实现， 分片以及跨分片通信等。\n\n作为公开链的区块链，必然需要密码学为依托，比特币选用了非对称算法中的椭圆曲线SECP256K1，经历了时间的考验被证明是安全可靠的，以太坊和BitShares也沿用了相同的椭圆曲线。\n\n以上是相同的部分，当然也有些不同的部分，不过这些不同只是在使用链的方式不同，不影响区块链的特性。\n\nBitcoin中只有一笔笔的交易，这些交易会存入一个地址，但并没有帐号。可以想象成有很多张支票，每张支票都有一个谜题，谁能解开这个谜题谁就能使用这张支票，如果一个人说他有很多比特币，或者他有一张大额支票，或者他有一堆小额支票。而以太和Bitshares是有帐号概念的。又比如链的生长速度差别就更大了，Bitcoin基本固定10分钟，以太则15秒，但是因为依赖PoW，并不是严格遵循这个周期，而Bitshares用的DPoS机制，能严格保证3秒出一个块(其实是1～30秒范围内可设置，取决于committee的投票结果)。\n\n按老董的讲解，至少符合三个条件的区块链的项目才有可能是好项目：\n\n# 必须是在线上建立信任，并基于此信任生发出的项目\n# 逻辑必须是清晰明确且简单的，一方面区块链的计算能力偏弱，另外从技术上写出安全的智能合约极难，为避免风险，也应用用简单的方式\n# 使用区域链所带来的收益要高于成本(任何商业项目都适用)","modified":"20170806121530000","tags":"protocol"},
{"created":"20180119121530000","title":"人脸查询协议的理解","text":"\n一个人脸查询协议反复看了大半年，每次看都有新的体会，直到现在我也不确信是不是完整理解它。\n\n人脸比对涉及两种对像，历史库和注册库，保存的虽然都是人，但历史库是对人一瞬间的描述，注册库则是对人精确描述，两者差异极大。比如年龄，在历史库是年龄但到了注册库却变成了生日，同一件事要用两个角度去解释。\n\n既然两种不同性质的库，查询条件就应该不一样，合在一个接口已经容易引起误解，偏偏最重要的，从哪个库查询字段却放在中间很不起眼的位置，人的理解思维总是头尾相对容易重视，中间如果太多往往会不耐烦地跳过，偏偏这个协议的协议字段有二十多个。\n\n我的调整是，首先按历史库和注册库拆分成两条协议，并对查询条件分类。比如上面提到的年龄，另外像历史库用到的眼镜和注册库用到的家族住址。\n\n除了指定信息查找外，人脸还有种好玩的查询叫以图搜图。给一张照片，会返回若干张和这个照片最像的候选人像。如果有图片，图片本身就表示了一切属性，此时检索条件又不一样，因此又再细分为信息查询和以图搜图。而以图搜图的条件也多是一些模糊性的条件，比如按人脸哪个区域比对（选眼睛还是鼻子）。\n\n经过这样分解拆分成4条协议，再结合对业务理解，可读性才勉强到可用的程度。\n\n再说说库相似度。有需求要求修改人脸库时可以修改相似度，最初我也觉得可以，但经人提醒意识到，为什么会有相似度，是因为人脸识别算法的不准确性需要阈值，但既然是阈值一定要结合当时的环境一起考虑，不应一概而论。环境就是视频通道，经过讲解让需求方接受了这个用法。看一个概念要理解其背后代表的含义和适用场景，否则就容易用偏。","modified":"20180119121530000","tags":"protocol"},
{"created":"20190625121530000","title":"如何学习emacs","text":"\n!! 写在前面\n\narm版的emacs的安装包35M，vim是20M，虽然大一些但还是同一量级，执行体emacs约4.7M，而vim约2.2M。之所以emacs给人感觉很大是其自带3K多个el文件，而vim自带插件数量远没有这么多。runemacs是专为图形界面做的外可覆程序(不会出现控制台)，支持emacs所有的命令行选项，还可以通过修改环境变量比如HOME来调整加载文件。配置文件全部放到.emacs.d/目录，原来的.emacs文件建议转移到.emacs.d/init.el，只有一个目录会比较整洁。\n\n!! 概念\n\n由于没有像vim般众多的模式，emacs的概念比较纯粹，所有的行为都是elisp函数，加上(interactive)的函数又被称为命令，可以通过M-x调用。而快捷键就是对函数的绑定。没有行的概念，就是把文本放到buffer并显示出来，通过fill-column变量还控制在屏幕上的折行位置。\n\n!! 帮助系统\n\n除了退出`C-x C-c`和取消`C-g`外，最需要熟练运用的就是帮助系统，\n\n* C-h f 查看函数的帮助信息， F 查看命令的帮助\n* C-h v 查看变量的帮助信息，包含当前值和默认值\n* C-h k 查看快捷键对应的函数名称和功能，c在minibuffer展示摘要\n* C-h w 在minibuffer展示命令摘要及是否有快捷键， a功能类似支持正则\n\n写elisp时候想要验证某个函数，有时C-x C-e会不管用，可以换成M-x ielm 打开elisp的REPL试验。\n\n!! 插件\n\n用spaceemacs如果觉得速度慢，改成国内镜像，到 .spacemacs 的 dotspacemacs/user-init() 添加\n\n```\n(setq configuration-layer--elpa-archives\n    '((\"melpa-cn\" . \"http://elpa.emacs-china.org/melpa/\")\n      (\"org-cn\"   . \"http://elpa.emacs-china.org/org/\")\n      (\"gnu-cn\"   . \"http://elpa.emacs-china.org/gnu/\")))\n```\n\n!! Elsip\n\nquote和list的区别，用quote创造的对象，只要值一样，永远是同一个引用；而list是每次都创建一个新的对象并返回这个对象的引用。","modified":"20190625121530000","tags":"tool"},
{"created":"20170818121530000","title":"如何在struct里追加指针","text":"\n这在其它公司或开源项目没有什么用，但至少在我目前的工作上还是有一定价值的。想象一下不同的部门共用同一份头文件，头文件中复杂的类型只能用结构体。如果要在结构体增加任何元素，都要保证结构体长度不变。对char或是int32问题不大，指针在不同平台长度是不一样的，如果一个部门用32位编译，增加指针，试问要怎么减长度才能保证在64位平台长度不变？曾经考虑过32位平台加宏，在指针后面带一个int32并用宏控制，但是想找到各种平台都能识别的宏很困难。\n\n先说思路，既然要保证32位和64位相等，肯定是向上取长度，即让指针占据8字节，有三种做法：\n\n# 把指针和int64用union包裹起来放到结构体里，如下\n\u003Cpre>\n    struct {\n        int elem1;\n        int elem2;\n        union {\n            char* p;\n            int64_t placeholder;\n        }u;\n    };\n\u003C/pre>\n\n这样做不好的地方在于取指针p必须要多一重u，使用者会感觉不方便。\n\n# 既然用union看起来别扭用着也不方便，让struct强制以8字节对齐，然后把指针放在8字节位置，同时指针后面的元素必须是int64/double，这样32位系统下，指针后面会有4字节的隐藏字节，但也不能用，64位就是按8字节对齐的。缺点是指针后面的元素必须是8字节，有时会很浪费。如下\n\u003Cpre>\n    struct {\n        int elem1;\n        int elem2;\n        char* p;      /// 32位系统，p后面有4字节空间，但不要使用\n        int64_t ensureAlignBy8;\n    };\n\u003C/pre>\n\n# 定义一个占位宏，根据系统特性将宏展开成int32_t或是空语句，也是最终我决定采用的方式，宏类似这样\n\u003Cpre>\n#ifdef (_WIN64)\n#define POINTER_ALIGN8(n)\n#elif (_WIN32)\n#define POINTER_ALIGN8(n) int32_t unused##n;\n\u003C/pre>\n\n这里有个小坑，宏的展开必须包含`;`，我最初的实现是宏的调用尾部加分号，过了几个月有人向我反馈编译不过。原因是VC在编译C语言模式(即.c后缀)时，要求结构体的定义中不能出现一行单独的`;`，但是在执行块中可以这么用。VC编译`C++`模式或GCC都没有这个限制。当我遇到这个错误时，曾尝试通过将64位下的宏扩展为一个空结构体，VC会报C标准不允许结构体没有成员。","modified":"20170818121530000","tags":"lang"},
{"created":"20231027033430083","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'tool' sort[title]>>\n\u003C/div>","tags":"目录","title":"软件工具使用","modified":"20231027033445601"},
{"created":"20150926121530000","title":"软件可靠性硬件可靠","text":"\n通常我们在写软件时，总会做各种各样的错误或异常判断，比如输入非法啊，执行异常之类的。但我们很少去怀疑是不是硬件本身出现问题，仿佛这个世界，只有逻辑错误而不会有电路错误一样。\n\n以前听一次云存储的入门讲座，其中就讲到硬盘的存储位出错机率是10e-12，换算下来一块1个T的硬盘，在一年里总会发生一次非正常的bit位翻转。那是我第一次听到有人这么仔细地计算硬件错误机率给软件设计带来的影响。\n\n今天在吃饭时，又听到两个有意思的异常问题\n\n1.软件经常莫名其妙地死机，甚至一天之内死机十数次，经过调试发现总是内存地址的最高位变成错误的1，把1改成0就不会发生死机。从软件层面问题已经无法解答，最后硬件部的人承认是电路设计有问题，类似是电磁兼容一类的，导致内存受影响，引起最高的bit位翻转。\n\n2.某个版本的主程序启动后，会引起busybox死机，但只在那个版本上会出现，经过反复调查，最后偶然发现死机版本的busybox的内存映像竟然和静态编译出的汇编代码不同。考虑到其它版本没有问题，排除加载器问题，于是只好对主程序的内核调用一条条地排查，最后果然发现是某条内核调用，因为代码写得不完善，将某一内存地址的bit位做了翻转，而busybox正好加载到该内存地址。通常code页的内容是不可修改的，但因为这个奇怪的bit翻转，导致汇编指令从Mov变成了Shift，进而导致后续的内存映射异常。又因为异常的内存地址是编译期固定的，所以只在某个版本会影响到busybox的代码段，引起奇怪异常。\n\n这两个问题我没有亲身参与，具体细节也是听说而已，但却让我对软件的底层可靠性有了不一样的认识。平时我们写程序，一般是不考虑内存bit位异常翻转，一方面民用的内存、主板在出厂前还是做了相对完善的检验，电磁兼容也必须要通过3C认证，故这种问题反映较少，但公司产品，尤其低成本平台，研发周期又短，发生这种问题，也就不足为奇了。\n\n第二个问题则是系统层的奇怪异常，以前我自己写代码，如果遇到底层的函数异常，一般也就不去深究了，一方面是信任，另一方面也确实是看不懂。但从实际情况来看，只要是人写的代码，不论它在哪一层，都有出错的可能。\n\n以前还听说过IBM的Z系列大型机，用在金融领域，有个特性就是两个一模一样的CPU同时计算，如果计算出的结果不一致，则丢弃该次计算，当时我看到这段介绍，觉得根本就不可能，今天再去反观，才发觉自己真是见识太少。","modified":"20150926121530000","tags":"design"},
{"created":"20231027033240810","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'design' sort[title]>>\n\u003C/div>","tags":"目录","title":"软件设计","modified":"20231027033255681"},
{"created":"20161102121530000","title":"设计方案的不动点和弱化点","text":"\n软件开发领域里有句教训：手里拿了锤子，看什么都是钉子。这句话也可以反过来看，并不是所有的需求都是钉子，面对不是钉子的需求，也就不应该用锤子的解决方案。架构也是一样，并没有一个包罗万象、适用于所有需求的架构。必须要先理解需求，到底是木钉子还是螺丝钉又或是水泥钉，再选择合适的工具。\n\n我把设计架构的法则称为定义不动点，设计一个系统前必须有一个核心前提是不能变动的，也可以称为约束点。所有的演化都是基于这个约束前提得到的，约束的宽度和系统最终演化的宽度成负相关关系。\n\n举17年4月智能库重构的例子，应用层视频智能库的不动点就是基于视频分析器做业务。首先要定义分析器是什么，它是这样一个实体，必须接受一路YUV数据，包含了若干个算法(这些算法统一以Scene的名义暴露给外层)，并输出各种分析后的元数据的物件。为什么很多的系统会遇到未来无法扩展，是因为前期的约束条件太多太严苛，比如基本约束太接近原始需求，导致需求稍有变化，尤其发生冲突时，基本约束就被破坏，整体体系的不动点也随之动摇。所以在设计前，对基本约束的定义，一定要原子、明确化。原子是便于组合，明确是把各种条件正交化，不要耦合。\n\n说完约束点，再说说弱化点。以设备初始化需求为例，一直以来设备出厂会有默认用户和密码，由于安全因素被提到越来越高的位置，要求去掉设备上的默认密码，\n演化为用户第一次开机时，必须要输入初始密码。此处有两点要关心：\n\n# 不仅要初始化大华用户密码，也要同步Onvif密码\n# 传输密码必须加密，且加密算法要可逆，进而能还原出明文密码(Onvif要求保存明文)\n\n要对称加密，就必须要在初始化之前得到公钥，否则对称加密就无从下手。\n传输有两种，单机的HTTP方案和批量的组播方案。HTTP方案无非就是请求公钥，传输密文密码。\n而组播方案，由于UDP报文长度的限制，获取密钥要和组播发现分开，经两次交互来完成初始化密码过程。\n\n明文密码到了设备后，接着就是怎么存储的问题。大华帐号仍使用带Salt的MD5方式，\n\n从以上内容看到，设计一个方案是由非常多步骤组成，这些步骤间的组合性就是评价方案的关键。\n就像函数式编程一样，如果每个函数都是无状态，则整个流程一定是可并发不会受限的，一旦有一个函数包含了状态(全局或静态变量，又或是成员函数)，\n则整个调用链就受制于这个环节。方案设计也是一样，如果每个环节的流转都是无损的，则整个方案就不会有问题。上面的例子，激活密码从客户端经明文发送到设备，\n一旦保存到大华账号，就退化成hash值，这个过程发生信息丢失，以后想用明文密码的地方，就不能再使用序列化后的内容，必须在客户端再一次输入明文，\n因此这个明文密码的序列化过程，就成了方案中的弱化点，会在某些程度上限制方案的拓展空间，在设计时要特别注明存在弱化的环节。弱化也是约束的一种延伸。\n\n很多系统在开始阶段缺少约束和弱化的说明，仿佛害怕他人知道这个架构的短处，但这样做的后果往往是，过一段时间，随着需求的变化，原始的架构约束已经被破坏，于是整个架构呈现出很多的不适，后来加入团队的新人不知道前期留下的约束是什么，以致被破坏了还不自知，然后抱怨为什么这个架构这么差，其实这个差，从需求改变那刻起就已注定。","modified":"20161102121530000","tags":"design"},
{"created":"20200727121530000","title":"神经网络来源与分类","text":"\n!! 早期历史\n\n神经网络技术起源于上世纪五、六十年代，当时叫感知机（perceptron），包含有输入层、输出层和一个隐藏层。输入的特征向量通过隐藏层变换到达输出层，由输出层得到分类结果。但早期的单层感知机存在一个严重的问题——它对稍微复杂一些的函数都无能为力（如异或操作）。直到上世纪八十年代才被Hinton、Rumelhart等人发明的多层感知机克服，就是具有多层隐藏层的感知机。\n\n多层感知机可以摆脱早期离散传输函数的束缚，使用sigmoid或tanh等连续函数模拟神经元对激励的响应，在训练算法上则使用Werbos发明的反向传播BP算法。这就是现在所说的神经网络NN。\n\n神经网络的层数直接决定了它对现实的刻画能力——利用每层更少的神经元拟合更加复杂的函数。但问题出现了——随着神经网络层数的加深，优化函数越来越容易陷入局部最优解，并且这个“陷阱”越来越偏离真正的全局最优。利用有限数据训练的深层网络，性能还不如较浅层网络。同时，另一个不可忽略的问题是随着网络层数增加，“梯度消失”现象更加严重。（具体来说，我们常常使用sigmoid作为神经元的输入输出函数。对于幅度为1的信号，在BP反向传播梯度时，每传递一层，梯度衰减为原来的0.25。层数一多，梯度指数衰减后低层基本上接受不到有效的训练信号。）\n\n!! 大发展与大突破\n\n在2010年代的后半程，图像和文本领域分别产生了堪称革命性的ResNet（深度残差网络）和Bert模型。\n\n图像领域一直沿着CNN的方向发展，最早取得突破的是Yann LeCun在1998年提出的LeNet，在32x32的小图片效果有突破，但不能处理大图片。但毕竟奠定了现代卷积神经网络的原型，即卷积，池化，全链接。\n\n在这之后CNN的锋芒开始被SVM等手工设计的特征盖过。随着ReLU和dropout的提出，以及GPU和大数据带来的历史机遇，CNN在2012年迎来了历史突破，这一年的ImageNet上AlexNet一举夺冠，开启了神经网络识图的时代。但AlexNet没有在方法论上给出方向，之后的VGG使用一系列大小为3x3的小尺寸卷积核和pooling层构造深度卷积神经网络，并取得了较好的效果。\n\n2014年的ImageNet冠军是GoogLeNet，它的主要特点是网络不仅有深度，还在横向上具有“宽度”。2015年ImageNet的冠军ResNet，更是将图像分类识别错误率降低到了3.6%，超过了正常人眼识别的精度。\n\n而文本领域由于前后相关性，起初都是基于RNN在做，但RNN存在串行缺陷，很难并行。文本领域的突破稍晚于图像，2017年Google提出Transform，这个模型由Encoder-Decoder组成，它的Self-Attention和Position Embedding可以替代RNN来做Seq2Seq任务。Attention是个精妙的词法袋（由Yoshua Bengio提出），但不能识别位置，配合上Position Embedding就完整地解决了机器翻译的问题。\n\n2018年出现的Bert也是以Transformer为基础，但只使用Decoder部分，因此只有Self-Attention，没有普通的Attention。\n\n2006年Hinton最早提出深度学习的概念，具体是利用预训练的方式缓解了局部最优解的问题，将隐藏层增加到了7层，实现了真正意义上的“深度”。LeCun、Hinton和Bengio一起因深度学习上的贡献获得了2018年图灵奖。\n\n!! 各种网络的简单比较\n\n对主要的3种分类归纳如下：\n\n# DNN：为了克服梯度消失，ReLU、maxout等传输函数代替了sigmoid，形成了如今DNN的基本形式。结构跟多层感知机一样。\n# RNN：DNN无法对时间序列上的变化进行建模，但时间顺序对于自然语言处理、语音识别、手写体识别等应用非常重要。为了适应这种需求，就出现了循环神经网络RNN。\n# CNN：图像中存在固有的局部模式（如人脸中的眼睛、鼻子、嘴巴等），所以将图像处理和神将网络结合引出卷积神经网络CNN。CNN是通过卷积核将上下层进行链接，同一个卷积核在所有图像中是共享的，图像通过卷积操作后仍然保留原先的位置关系。\n\n在普通的全连接网络或CNN中，每层神经元的信号只能向上一层传播，样本的处理在各个时刻独立，因此又被成为前向神经网络(Feed-forward Neural Networks)。而在RNN中，神经元的输出可以在下一个时间段直接作用到自身，即第i层神经元在m时刻的输入，除了(i-1)层神经元在该时刻的输出外，还包括其自身在(m-1)时刻的输出！表示成图就是这样的：\n\n为方便分析，按照时间段展开如下图所示：\n\n（t+1）时刻网络的最终结果O（t+1）是该时刻输入和所有历史共同作用的结果！这就达到了对时间序列建模的目的。RNN可以看成一个在时间上传递的神经网络，它的深度是时间的长度!正如我们上面所说，“梯度消失”现象又要出现了，只不过这次发生在时间轴上。\n\n所以RNN存在无法解决长时依赖的问题。为解决上述问题，提出了LSTM（长短时记忆单元），通过cell门开关实现时间上的记忆功能，并防止梯度消失。在序列信号分析中，如果能预知未来，对识别一定也是有所帮助的。因此就有了双向RNN、双向LSTM，同时利用历史和未来的信息。\n\n事实上，不论是哪种网络，他们在实际应用中常常都混合着使用，比如CNN和RNN在上层输出之前往往会接上全连接层，很难说某个网络到底属于哪个类别。不难想象随着深度学习热度的延续，更灵活的组合方式、更多的网络结构将被发展出来。\n\n简单总结如下：\n﻿\nCNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)的内部网络结构的区别\n\n先说DNN，从结构上来说他和传统意义上的NN（神经网络）没什么区别，但是神经网络发展时遇到了一些瓶颈问题。一开始的神经元不能表示异或运算，科学家通过增加网络层数，增加隐藏层可以表达。并发现神经网络的层数直接决定了它对现实的表达能力。但是随着层数的增加会出现局部函数越来越容易出现局部最优解的现象，用数据训练深层网络有时候还不如浅层网络，并会出现梯度消失的问题。\n\nCNN与RNN的比较\n\n相同点\n\n# 传统神经网络的扩展。\n# 前向计算产生结果，反向计算模型更新。\n# 每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。\n\n不同点\n\n# CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算\n# RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出\n# CNN可以达到1000+深度，RNN深度有限","modified":"20200727121530000","tags":"design"},
{"created":"20170928121530000","title":"实战flex和bison注意事项","text":"\n日常处理协议要做太多的转换工作，想试着能否用类似google的proto描述方式来自动化生成。决定用flex和bison再配合一个script语言如lua或js来做。期间走了不少弯路。\n\n语法解析的bison会强制要求实现`yyerror(char*)`函数，但其实回调的信息很简单，基本就是syntax error没有指向性，这是LALR的固有缺陷，但有两个改善的办法\n\n在yyparse()调用之前打开调试开关\n\u003Cpre>\nextern int yydebug;\nyydebug = 1;\n\u003C/pre>\n能打印出每个符号读入，shift/reduce的步骤。\n\n如果嫌错误信息太长，可以语法分析错误时增加行号显示，要做两件事\n\n# 让flex对行号自增，加这条规则 `\\n {yylineno++;}`\n# 让bison在yyerror中显示行号\n\u003Cpre>\nextern int yylineno;\nvoid yyerror(const char* str){\n  printf(\"\\nBison error at line:%d, %s\\n\",yylineno, str);\n}\n\u003C/pre>\n\n还有个小的细节要注意，打印到stderr而不是用printf输出到stdout，在后期会体现出便利性。\n\nflex解析后的token的内容保存在yytext，同时yyleng记录了有效长度。通常这个值要传递给bison，并在语法规则匹配后再利用这些值做逻辑，但是最好不要在bison直接用yytext，因为等到触发bison的规则时，yytext/yyleng表示的是最后一个token，前几个token的值无法直接用yytext得到。通常作法是把词法匹配后的字符串dup一份，这就要求bison在匹配后还要做free的动作，不仔细配对很容易出错，我的办法比较讨巧，既然要dup字符串涉及内存管理，不如直接把这时的yytext传给script engine，利用脚本的垃圾收集机制管理内存。即脚本在flex阶段收集素材，而bison阶段处理素材。\n\nbison的规则允许直接用单字符的终结符，要用上这个特性，flex规则的末尾要写上`. {return yytext[0];}`，如果不写，yylex()不会返回这个单字符，而使用flex默认的ECHO规则将这个单字打印到console上，并不会传递给bison。\n\n脚本引擎和分析代码之间的交互有两个接口，分别是在flex调用的push(token, str)和bison调用的reach(rule)。语言先用lua，最终还是决定换成更大众的JavaScript，一是为了自己熟悉，另外JS的受众更多，维护人员会更好交接。关于JS的引擎单开一篇写。","modified":"20170928121530000","tags":"lang"},
{"created":"20180510121530000","title":"实战flex和lemon要点","text":"\n以前写过flex和bison的实战，这两个工具出现在70年代，bison生成的主函数入口名只能是int yyparse(),内部强制调用yylex函数，语法驱动词法，传递数据使用全局变量的形式，从代码美学角度看相当令人不快。最近学习了SQLite项目下的lemon，从语法分析上来说比bison更简洁一些。PHP开发组在10年曾发起动议用lemon替换bison，不过后来不知何故不了了之。使用lemon配合flex可以直观地解决重入问题，bison也可以，但略复杂。\n\n先说flex生成可重入代码的方式，使用`flex -R`或者用%option reentrant都能达到效果。生成的函数原型变为`int yylex (yyscan_t yyscanner);`。通过yyget_text(yyscanner)和yyget_leng(yyscanner)的调用方式，取代了以往全局变量yytext和yyleng的使用方式。\n\n在使用前后要分别调用`yylex_init`和`yylex_destroy`。如果要指定输入文件，用`yyset_in`函数(非重入版也有这个函数)。和lemon配合时，flex是驱动者，每条规则匹配的执行动作不需要return，而是在执行动作中从yyscanner提取token，处理并交给lemon进行解析。\n\nlemon只是生成解析函数，被词法驱动调用，函数原型如下，函数名可以自定义。\n\n```\nvoid Parse(\n  void *yyp,                   /* The parser */\n  int yymajor,                 /* The major token code number */\n  ParseTOKENTYPE yyminor       /* The value for the token */\n  ParseARG_PDECL               /* Optional %extra_argument parameter */\n)\n```\n\nmajor表示符号类型，所以固定为int就够了。相应的minor是该符号的值，需要自定义union才行。minor主要用在shift和报错时用。\n\n用%name xyz指令可以替换Parse成你想要的函数名，一共会导出7个函数，其它都是以static约束并以`yy_`开头的内部函数。这7个函数只有主函数和Alloc及Free必须使用，Init和Finalize似乎不应该暴露，还有两个Trace和StackPeak是辅助用途。\n\n类似%name这样的指令共有23个\n\n```\nname\ninclude\ncode\ntoken_destructor\ndefault_destructor\ntoken_prefix\nsyntax_error\nparse_accept\nparse_failure\nstack_overflow\nextra_argument\ntoken_type\ndefault_type\nstack_size\nstart_symbol\nleft\nright\nnonassoc\ndestructor\ntype\nfallback\nwildcard\ntoken_class\n```\n\n改为可重入后，很多函数声明被改变，但工具并没有自动生成对应的接口申明，必须手工补齐，是个不足。\n\nflex和bison配合的时候，每当识别到一个符号动作的最后，都会return该符号对应的枚举。但和lemon配合时，如果在词法动作中执行lemon的Parse函数，就不需要return。因为lex函数内有个while循环，只要不return就会不停地找下一个符号。不考虑初始化和结束动作，只要调用yylex();Parse();就是解析的全部了。\n\nlemon内部也有while循环，其目的是收到新的符号后，可能会反复的shift或reduce。直到出现错误或者栈溢出结束循环。\n\nlemon在计算规则时会计算shift、reduce和shiftreduce的范围。shift的最小值是0，只定义最大值，另外两个既有最大也有最小值。\n\n解析函数根据计算的act的区间范围，调用shift(shiftreduce也算shift)或reduce。因为Parse内有循环，只要正常一定会reduce到accept状态，都不属于只能是错误。\n\nlemon在解析y文件时，有22种分支，包括自动机状态，出错和特殊符号的处理。\n\nlemon不允许开始符出现在规则右侧，因此一定要为开始符定义一条专门的规则，从生成的代码可以看到，开始符的规则在default分支，是最特殊的，这条规则通常什么也不会做。如果一条产生式有多种写法，不需要写`|`，把不同的产生式分开写出来，lemon会负责合并这些规则。因为每个语句最终都对应到一个case，这样考虑的话分开写反而更自然。\n\n`token_type`标识lex的终结符，而`type`标识lemon内的非终结符。\n\n除了用指令，有3个宏可以控制lemon的Parser结构。分别是水位警示、错误回退和栈增长控制。reduce需要用栈暂存数据，bison默认深度是200，lemon是100，但是可以定义宏为负值做到自增长，如果不定义宏，到100就报错退出了。产生式的每个符号，以最右边为0，向左依次-1并在栈上可以找到。\n\n!! lemon阅读\n\nlemon生成后的代码大多数是表驱动，虽然大的结构能看懂，但怎么得到表却要看本体才能明白。\n\n程序有几个结构要关注，除了最大的lemon，就是rule、action、symbol最为重要。从入口来看，先确定终结符的最大个数，然后构造First集和Follow集。lemon的目的是得到一个语法分析器，但它自身又必须有词法分析，否则y文件都不能解析。\n\n整个流程是如下几个步骤\n\n# 计算First集\n# 计算LR(0)状态机，次复杂\n# 计算Follow集（包含一个前置的FindLinks 不知道该怎么翻译）\n# 计算并压缩Action表，其中压缩可以通过命令行选项控制。此步已经是LALR\n# 生成LALR分析器，最复杂\n\n计算First集要考虑空规则","modified":"20180510121530000","tags":"lang"},
{"created":"20160728121530000","title":"使用CVS管理版本","text":"\n!! 历史\n\n我所知最早的版本管理工具sccs诞生于1972年，说明代码的差分和比较需求一直是存在的，diff和patch干的就是这个。diff看着简单，其背后的理论延伸非常庞大，输出格式也有多种，除了默认的normal输出，unified也很多，而ed输出，估计现在都找不到ed软件了吧。虽然现在已经不会再独立使用这两个程序，但版本比较工具在底层还依赖它。第一个diff成熟版本在1974年随着版本5的Unix一起发布。10年后，Larry Wall发布了patch（之后的1985年，他发布了perl）。\n\ncvs是对rcs工具的改进并加入了网络功能，因此它内部的管理单位是文件，而不是整个目录的快照。这一点和svn/git的理念差异是很大的。\n\n!! 基础用法\n\n用cvs创建新项目，不一定要先import才能check out。可以在REPO的目录下，直接新建一个目录，比如foo。就可以cvs co foo来导出这个项目了。对于个人使用记录历史，这个方式简单明了，不需要记忆复杂的cvs import语法。叉开说一句，因为cvs的配置不记录提交者信息，或者就是用USER环境变量，因此在import项目时，提供vendor就很重要了，否则这个项目的owner就没有了。\n\n中心REPO下的目录，在cvs的术语里叫module，有了module概念对很多rlog、rtag命令就好理解了。r系列命令可以不用check out一个项目，甚至在A项目中，也能对B项目进行tag或log操作。\n\ncvs log命令能看到有个state标记，一般不改动默认是Exp。如果做了cvs remove操作，还会记录dead这种特殊的state。log命令可以查看指定state的日志，如果指定错，就只显示等同于log -h的head日志。使用cvs admin -sXXX可以修改。cvs的手册建议使用Exp(试验)、Stab(稳定)、Rel(发布)这3种。其实-s后面可以输入任何值都允许，为了社区交流方便，还是按惯例使用比较好。由于开分支后还是能看到主干或其它分支的日志，我想到的做法是在开发支后，用admin指令把state状态也一起修改，以后查日志时用log -s XXX就可以得到这个分支的日志。\n\n!! 分支管理\n\n!!! 查看分支\n\n当你还没有接触tag命令时，肯定已经发现每次check in，cvs会有个自动递增的数字，1.1 -> 1.2这种。这个自动递增的数字称为Revision。就像通常写程序的人会用ID一样，这个数字更多地是用于区分不同时间的唯一性，却很难记忆，因此到了程序发布版本时，项目经理会阶段性地打个标签，这时就需要用tag命令，给当前版本取个好记的名字了。\n\ncvs st命令显示的Sticky Tag: newtry(branch: 1.4.2)括号内如果是branch:就表示该个文件处在哪个分支（再次强调，cvs是管理到文件粒度，所以工作区的文件可能分属不同分支），st -v会在最后多出一段全部分支/里程碑的列表。\n\u003Cpre>\nExisting Tags:\n  tr4     (revision:  1.4)\n  newtry  (branch:  1.4.2)\n\u003C/pre>\n可以看到共有两个创建过的tag。括号里revision表示固化标签，表示发布版。而branch，就是基于tr4建立的分支。\n\n分支涉及revision/tag/branch这三个比较像的概念，这也是cvs较难理解的部分。revision是cvs自动管理的类似1.3、1.5.2.4这样的数字；tag(包括rtag)/branch(tag的-b选项)这些高级的操作，必须依附于revision。之间的关系有点像IP和域名体系，便于人的记忆、使用。\n\n!!! 创建分支\n\n通过cvs tag -b name来建立分支，cvs会自动分配revision用于内部维护。-b表示基于当前的状态开分支，可能是HEAD上开出的分支，也可能是分支的分支，因为每次做了分支，版本号就会多出两个数字，因此基于分支的分支就会有至少6个数字，看起来会很冗长。附带说一句，不指定文件名的话，默认把当前版本控制的全部文件标记为分支了。如果指定了文件名，反而在cvs up -r newtry切换分支时，只会保留标记过的文件，整个工程可能会编译不了。\n\n使用tag -b操作后，本地CVS目录的Repository文件会用Txxx的方式记录了每个文件所用的tag。用cvs up -A后，文件回到Head状态(但不Sticky)，同时Tag文件会消失。用tag -d只能删除revision类型的tag，而branch类型的tag因为可以生长，默认不能删，必须用-dB branch隐藏命令才能删，尽量不要删除branch。\n\n为什么分支命令是tag的一个选项？可能cvs的开发者认为，branch是tag的一种特殊实现，因此并没有给branch一个独立的子命令，但是如果先熟悉了git再去用cvs，就会觉得难上手。一个教训是，要不要复用，得看概念是否有差别，如果仅因为实现上的类似就去复用，对使用者其实并不友好。\n\n!!! 切换分支\n\n使用cvs up -r brname切换到具名分支，用cvs up -A回到主干（按帮助的说法是把sticky标签去掉，隐藏名HEAD）。通过up -r HEAD也可以进入主干，但是这样会让版本变为sticky，不能check in，感觉HEAD没什么用，难怪做成了隐藏。如果只是想回到过去并重新来过，需要用-p -r rev的方式来避免sticky。\n\n结合cvs保存文件的方式，就会比较好理解分支管理。REPO下保存每个文件带`,v`后缀的文件，这里记录了各种分支的所有版本号。用cvs up -r xxx时相当于遍历REPO下的每个文件，如果这个文件有对应的tag，就进行签出，没有对应tag就不会有这个文件，就实现了版本切换。因此默认打tag时就不要带文件名了，除非切分支的时候故意不想要某几个文件，只是这样操作起来实在太啰嗦，估计也没人愿意这么做。\n\n!!! 创建里程碑\n\ncvs一旦打上标签比如alpha，不论是通过指定名称还是程序自动赋予的1.4这种，后期通过cvs up -r alpha回到这个版本，在这种标签上做的任意改动，是不能check in的(后面会提避开的方式)，CVS称这种特性为Sticky，tag相当于milestone，在cvs的概念里，并不希望去修改它。一个不能提交的tag是没有意义的，要修改就需要branch。\n\n如果想要基于过去的某个tag做bugfix，使用cvs tag -b -r alpha alpha-patch命令，这个命令不太直观，-r 和alpha联用，指明基于alpha这个tag，开一个称为alpha-patch的新分支号。这个alpha-patch分支(或者说带了-b选项的tag)可以check in。1.1、1.2这个版本号类似主干，用up -r 1.x回到主干的某个历史是不能提交的，因为这时revision再加1会冲突。此时必须基于这个版本创建branch，并用up -r alpha-patch的方式切换到这个分支上，基于此才能继续提交。\n\ntag会记录在CVS总仓库的module中；而branch除了记录在module外，还会记录在cvs总仓库的CVSROOT/val-tags。\n\n!!! 社区用法\n\n用cvs实现OpenBSD的版本发布方式，我觉得还是比较困难的。以下纯为假设，操作会失败。先设定一个revision比如1.5作为tag基，在这个tag上开branch，在此branch上提交代码。到一定时候，把branch的末端merge回1.5的tag，这时的tag不能直接提交，只能在commit时指定新的revision如1.6来提交。后续在1.6上再重复刚才流程，定tag、开branch，开发合并最后提交新的1.7revision。就我个人操作而言，只用branch，不用revision的方式至少可以做到随意切换。以后真遇到需求了，再来研究revision的用法吧。\n\n!! 远程仓库\n\nC/S模式是从本地访问基础上加上用户认证实现的。支持密码(:pserver:)、GSSAPI(:gserver:)、Kerberos(:kserver:)这3种认证，如果cvs pserver能正常执行，说明支持密码认证，其它两种同理。一般不由cvs监听，交给xinetd监听，收到请求后调用cvs来执行客户端的命令。\n\n在仓库目录下的CVSROOT/passwd配置用户名和密码，最简单的配置就一行`user:`，无密码且同名映射到系统用户。据说有潜在的安全隐患，最好用独立的cvs内的passwd认证。cvs登时的用户名可以和系统的用户名不同，但最终还是要用别名方式映射到系统用户，因为登陆之后的操作仍然是本地操作，需要有用户身份。cvs用户和系统不同可以实现复杂的权限管理，简单项目可以不用这个特性。\n\n除了passwd文件，还有readers和writers文件控制读写权限，这3个文件在cvs init之后不会生成。\n\n在debian/jessie上开远程仓库却遇到无权限问题，寻找良久无果。kali版本的xinetd默认只使用IPv6模式，所以要手动指定IPv4，否则报无法连接\n\n配置文件/etc/xinetd.d/cvspserver内容如下\n\n```\nservice cvspserver\n{\nport = 2401\nsocket_type = stream\nprotocol = tcp\nflags = IPv4\nwait = no\nuser = root\npassenv = PATH\nserver = /usr/bin/cvs\nserver_args = -f --allow-root=/home/android/CVSREPO pserver\n}\n```\n\n客户端配置`CVSROOT=:pserver:username@ip:/xxx/repo`\n。如果设置了密码又不想每次输入，用cvs login命令操作一次，密码会保存在~/.cvspass文件，如果不想保存，cvs logout会清除。\n\n!! 管理员功能\n\nadmin是很强大的功能，管理员可以改变提交记录(-m)甚至能删除历史(-o outdate)。用`admin -o 1.1:1.3 xxx`这条命令，就能把1.1到1.3的历史都删除。这是直接向CVSROOT这个总仓库进行作业，但是不允许把历史全删掉，至少要保留一条记录。又比如用`admin -m 1.4:modify xxx`就可以在提交后发现问题时做补救(或者掩饰)。\n\ncvs没有锁的概念，好像类似的是watch/edit/unedit。使用了watch后在仓库的目录中会产生CVS目录，这个目录内会有个fileattr，没有做过watch可不会有哦。被watch后的文件，check out后便是只读，必须用edit来编辑，这个和svn的lock file特性似乎是一样的。但是我只在本地操作，脱离了用户和权限，watch特性就发挥不出来了。\n\n!! 缺陷\n\n回车符以CRLF保存，改为LF无法diff也无法提交，只能ci -f强制提交，但是导出后依然是CRLF。\n","modified":"20160728121530000","tags":"tool"},
{"created":"20180101121530000","title":"使用DroidScript开发安卓程序","text":"\n本来是想用ionic在手机上做些开发，但不知什么原因安装失败，发现一个叫DroidScript的安卓程序，可以在PC端浏览器连接手机，并在浏览器上进行编码调试。支持HTML和App两种开发模式，从通用性来说肯定是HTML好，App支持的插件丰富一些。\n\nHTML模式本质上是原生程序中内嵌了web页面，布局在四边稍有些空白，可以访问完整的window对象。虽然具备XMLHttpRequest，但可能是受限于跨域，另外提供了HttpRequest方法进行网络通信，可以向任意地址请求，HTTP头也没有Origin字段。至少支持get/post/put/delete方式(其它几乎没有使用，不测了)。参数只能以URL Encode方式编码，也就不能像jQuery那样写成json并由jQuery去转换，略有些不便。更坑的是分隔符居然用`|`而不是标准的`&`，如果用`&`程序会强行转码导致PHP上无法从`$_POST`找到希望的key。使用get或delete时，参数只能通过url方式携带，而post或put则一定在request body中。\n\n比如发起这样一个请求`httpAjax(\"delete\", \"/index.php?t=3\", \"id=1|name=jojo\", handleParam);`，抓包可以看到变成了`index.php?t=3?id=1&name=jojo`，强行把url和参数用?符号连接起来，导致后台如果用PHP解析，把`3?id=1`当作t的值。\n\n多字节字符支持得很差，界面上无法输入中文，甚至复制中文后就不能再输入了，只能尽量用英文。导致一个更不方便的问题，写的中文日记无法提交，只能先将中文用JS的encodeURI转码再附到提交数据上，但这样和PC端Web上提交的内容不同。比如**看**字，PC端抓包是`%E7%9C%8B`；而经过encodeURI转码后的看字，抓包则是`%25E7%259C%258B`，两者比较前者9字节后者15字节。重复的部分就是`%`后面的字符要怎么解释，encodeURI相当于%要转译两次，因此负载密度很低。通过base64解决这个问题，但base64的结果会有=，因此用encodeURIComponent方法把=也进行转码。建议用带Component的方法，因为encodeURI不对+=等特殊字符转码。\n\n支持很多特性，但Reference没有写只能从Demo去看。写好的程序可以打包成apk，Img目录如果有和工程同名的png文件，则该文件会作为apk的图标。支持debug和release签名。如果是release方式需要先生成私有的keystore文件，以后输入密码就可以打包了。\n\n!! WebServer\n\n支持创建服务端，并能上传和下载文件，但是上传功能并不明显，通过自带demo发现，当在CreateWebServer的option指定Upload，就能以POST方式发起upload请求，形如` curl -F \"DB=@a.db\" -F \"DB1=@b.db\" ip:port/upload`，其中-F后面的字段可以随意指定，会自动创建同名文件夹。","modified":"20180101121530000","tags":"web"},
{"created":"20230112121530000","title":"使用fossil管理版本","text":"\ngit建服务端有些限制，而fossil自带服务和用户管理，包括设置密码和权限，虽然不支持公钥，但个人使用足够。\n\n初看命令和git有些类似，但语义不同。比如add只要做一次，后面只要被管理的文件有改动，commit就会提交。又比如仓库如果是同步远程的话，如果远程连不上，本地都无法提交。从这个角度看，git确实是完全的分布式版本管理。也难怪fossil的作者自己都说是大教堂模式。\n\n再比如mv指令只能修改fossil管理的文件名，导致既要执行fossil mv又要执行mv，非常分裂而且不便。\n\n默认clone时未指定用户，导致推送也没指定用户名，总是失败。解决办法用`remote-url add http://$USER@ip`，接着输入密码，就能指定向远端push的用户。\n\n由于已经搭建好git仓库，fossil的体验至此阶段性结束，还是那句话，多用主流工具。","modified":"20230112121530000","tags":"tool"},
{"created":"20160218121530000","title":"使用Lazy-Stream方式实现Fibnacci数列","text":"\n起因是看到一篇讲stackless方式coroutine的文章，给的例子是用js写的。用Lua重写了一遍，感觉有些思路上以前没有想到过，做点纪录。\n\n要实现Lazy，假设采用function fibNext()的形式，每一次调用fibNext()，都会返回下一个数，且可以无限调用。显然这个函数要return一个数字，那么要怎么实现状态的更新从而在下一次调用时得到下一个数据呢？如果用OO的方式，很简单把状态和方法绑定到一个对象上就可以了，那么函数式中对应的就是闭包，在Lua中的名字就是upvalue。\n\n首先函数的基本形态应该是这样的：function fibNetx() return ?, fibresult  end。?处肯定只能是一个function（因为限定了不用OO方式）。传入的function会替换掉fibNext，因此需要在fibNext外面做一个wrap\n\n\u003Cpre>\nwrapNext function()\n  local i, j, next = 0, 1\n  local yld = function(k, i)\n  next = k\n  return i\nend\n\n next = function() yld(function()\n   local tmp = i; i = j; j = temp + j\n  j) end\n\n  return next()\nend\n\u003C/pre>","modified":"20160218121530000","tags":"lang"},
{"created":"20170707121530000","title":"使用xapian和scws进行全文检索","text":"\n中文的全文检索最难的是分词，暂时只有scws结合xapian能跑起来。scws是个分词库，用在生成倒排索引阶段，建立索引和查询还是要利用xapian才能完成。\n\n生成索引是查询是两个相反的过程，输入一个或多个document的描述到index，生成B-tree或其它格式的数据库，输出一个关键字给search，search从索引数据库把document还原出来。\n\nxapian的索引和查询命令分别是simpleindex和simplesearch，索引生成的数据库是个目录，内部的文件比较多，simplesearch指定到数据库目录，再输入关键字，会按匹配程度从高到低排列出来。","modified":"20170707121530000","tags":"data"},
{"created":"20181028121530000","title":"视频的封装格式","text":"\nES（Elementary Stream）流是基本码流，包含音频、视频、数据的连续码流。编码器输出的都是这种类型。\n\nPES（Packet Elementary Stream）流是打包的基本码流，是将ES根据需要打包成长度不等的数据包并加上包头就形成了打包的基本码流PES。\n\nTS（Transport Stream）流，也叫传输流。是由固定长度的188字节的包组成。含有独立是一个或者多个program,一个program又可以包含多个视频，音频和文字信息的ES流。每个ES流会有不同的PID标示。为了分析这些ES流，TS有些固定的PID来间隔发送Program和ES信息表格：PAT表和PMT表。\n\n(在MPEG-2系统中,由视频, 音频的ES流和辅助数据复接生成的用于实际传输的标准信息流称为MPEG-2传送流)\n\n封装 : 就是捆绑打包, 将画面视频文件和音轨文件打包在一起, 并按照一定规则建立排序和索引, 便于播放器或播放软件来索引播放. 包括AVI / PS(Program Stream)/ TS（Transport Stream）/ MKV（Matroska）等.\n\nPS是节目流编码器出来的是TS流，传输接口为asi口，编码器整个作用过程是把模拟信号变成ES，再打包成PES，再打包成TS流输出。\n复用器是把多路单节目或多节目TS流合称1路多节目TS流，再给调制器。\n数字卫星接收机出来的是TS流，也是asi接口，可能包含一路或多路节目，有的还同时有一路模拟信号视音频输出。\n模拟卫星接收机出来的是模拟视音频信号。，PS流与TS流的区别在于，PS流的包结构是可变长度的，而TS流的包结构是固定长度的.\n\nTS流的解码过程-ES-PES-DTS-PTS-PCR\n\nTS 流解码过程:\n\n# 获取TS中的PAT\n\n# 获取TS中的PMT\n\n# 根据PMT可以知道当前网络中传输的视频（音频）类型（H264），相应的PID，PCR的PID等信息。\n\n# 设置demux 模块的视频Filter 为相应视频的PID和stream type等。\n\n# 从视频Demux Filter 后得到的TS数据包中的payload 数据就是 one piece of PES，在TS header中有一些关于此 payload属于哪个 PES的 第多少个数据包。 因此软件中应该将此payload中的数据copy到PES的buffer中，用于拼接一个PES包。\n\n# 拼接好的PES包的包头会有 PTS，DTS信息，去掉PES的header就是 ES。\n\n# 直接将 被拔掉 PES包头的ES包送给decoder就可以进行解码。解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与PES中的PTS关联一下，以便进行视音频同步。\n\n# I，B，B，P 信息是在ES中的。\n\nES 是直接从编码器出来的数据流，可以是编码过的视频数据流，音频数据流，或其他编码数据流的统称。 ES 流经过 PES 打包器之后，被转换成 PES 包。 PES 包由包头和 payload 组成.\n\n在 PES 层，主要是在 PES 包头信息中加入 PTS( 显示时间标签 ) 和 DTS （解码时间标签）用于视频、音频同步。 其实， Mpeg-2 用于视音频同步以及系统时钟恢复的时间标签分别在 ES ， PES 和 TS 这 3 个层次中。在 ES 层，与同步有关的主要是视频缓冲验证 VBV （ Video Buffer Verifier ），用以防止解码器的缓冲器出现上溢或下溢；在 PES 层，主要是在 PES 头信息里出现的显示时间标签 PTS （ Presentation Time Stamp ）和解码时间标签 DTS （ Decoding Time Stamp ）；在 TS 层中， TS 头信息包含了节目时钟参考 PCR （ Program Clock Reference ），用于恢复出与编码端一致的系统时序时钟 STC （ System Time Clock ）。\n\n基本流程如下：首先 MPEG-2 压缩编码得到的 ES 基本流，这个数据流很大，并且只是 I ， P ， B 的这些视频帧或音频取样信息，然后加入一些同步信息，打包成长度可变长度的数据包 PES ，原来是流的格式，现在成了数据包的分割形式。同时要注意的是， ES 是只包含一种内容的数据流，如只含视频，或只含音频等，打包之后的 PES 也是只含一种性质的 ES, 如只含视频 ES 的 PES, 只含音频 ES 的 PES 等。可以知道， ES 是编码视频数据流或音频数据流，每个 ES 都由若干个存取单元（ AU ）组成，每个视频 AU 或音频 AU 都是由头部和编码数据两部分组成， 1 个 AU 相当于编码的 1 幅视频图像或 1 个音频帧，也可以说，每个 AU 实际上是编码数据流的显示单元，即相当于解码的 1 幅视频图像或 1 个音频帧的取样。 MPEG-2 对视频的压缩产生 I 帧、 P 帧、 B 帧。把帧顺序 I1,P4,B2,B3,P7,B5,B6 帧的编码 ES ，通过打包并在每个帧中插入 PTS/DTS 标志，变成 PES 。在插入 PTS/DTS 标志时，由于在 B 帧 PTS 和 DTS 相等，所以无须在 B 帧多插入 DTS 。而对于 I 帧 和 P 帧，由于经过复用后数据包的顺序会发生变化，显示前一定要存储于视频解码器的重新排序缓存器中，经过从新排序后再显示，所以一定要同时插入 PTS 和 DTS 作为重新排序的依据。\n\n其中，有否 PTS/DTS 标志，是解决视音频同步显示、防止解码器输入缓存器上溢或下溢的关键所在。 PTS 表明显示单元出现在系统目标解码器（ STD- System Target Decoder ）的时间 , DTS 表明将存取单元全部字节从 STD 的 ES 解码缓存器移走的时刻。 视频编码图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 的 ES ，加入 PTS/DTS 后，打包成一个个视频 PES 包。每个 PES 包都有一个包头，用于定义 PES 内的数据内容，提供定时资料。每个 I 、 P 、 B帧的包头都有一个 PTS 和 DTS ，但 PTS 与 DTS 对 B 帧都是一样的，无须标出 B 帧的 DTS 。对 I 帧和 P 帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，一定要分别标明 PTS 和 DTS 。例如，解码器输入的图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 ，依解码器输出的帧次序，应该 P4 比 B2 、 B3 在先，但显示时 P4 一定要比 B2 、 B3 在后，即 P4 要在提前插入数据流中的时间标志指引下，经过缓存器重新排序，以重建编码前视频帧次序 I1,B2,B3,P4,B5,B6,P7,B8,B9,I10 。显然， PTS/DTS 标志表明对确定事件或确定信息解码的专用时标的存在，依靠专用时标解码器，可知道该确定事件或确定信息开始解码或显示的时刻。例如， PTS/DTS 标志可用于确定编码、多路复用、解码、重建的时间。\n\nPCR\n\nPCR 是 TS 里面的，即 TS packet 的 header 里面可能会有，他用来指定所期望的该 ts packet 到达 decoder 的时间，他的作用于 SCR 类似。\n\nDTS, PTS\n\n对于一个 ES 来说，比如视频，他有许多 I,P,B 帧，而 P, B 帧都是以 I ， P 帧作为参考。由于 B 帧是前向后向参考，因此要对 B 帧作 decode 的话，就必须先 decode 该 B 帧后面的 帧（ P, 或者 I 帧），于是， decode 的时间与帧的真正的 present 的时间就不一致了，按照 DTS 一次对各个帧进行 decode ，然后再按照 PTS 对各个帧进行展现。\n\n有时候 PES 包头里面也会有 DTS ， PTS ，对于 PTS 来说，他代表了这个 PES 包得 payload 里面的第一个完整地 audio access unit 或者 video access unit 的 PTS 时间（并不是每个 audio/video access unit 都带有 PTS/DTS ，因此，你可以在 PES 里面指定一个，作为开始）。\n\nPES 包头的 DTS 也是这个原理，需要注意的是：对于 video 来说他的 DTS 和 PTS 是可以不一样的，因为 B 帧的存在使其顺序可以倒置。而对于 audio 来说， audio 没有双向的预测，他的 DTS 和 PTS 可以看成是一个顺序的，因此可一直采用一个，即只用 PTS。","modified":"20181028121530000","tags":"protocol"},
{"created":"20190110121530000","title":"视频取流协议","text":"\n!! RTSP\n\nRTSP支持RTP/AVP, RTP/AVP/TCP两种传输模式的，前者也可以写作RTP/AVP/UDP，这种模式因为是UDP传输，客户端会携带自己的端口，通常是两个，音频和视频。而TCP是RTP over RTSP over TCP方式，复用连接并不需要传递端口。\n\nVLC向StreamApp请求，发送SETUP时指定RTP/AVP。由于库本身的问题，只能支持TCP，回复455表示不支持，于是VLC发起OPTION尝试，但响应中又携带了SETUP，于是VLC就不知道该如何执行下去。\n\n看起来似乎RTSP缺少一种更灵活的协商机制，但是考虑到TCP和UPD特性对视频的影响，如果协商变成由服务端来决定，显然并不符合客户的本意，这个SSL的协商在业务领域是不同的。虽说也可以做成SETUP时交换能力，在PLAY时指定方式，似乎和SDP的阶段又有冲突，也许是它的不足吧。\n\n!! 浏览器无插件视频播放\n\n看了IPC的浏览器播放，速度很快体验很好，抓包看实现，网络协议用 RTSP over WebSocket，用HTTP的upgrade部分切换，要注意的是必须先F12打开开发工具，再进入视频页面，这样才能在Network页签看到网络数据。\n\n可以看H265视频，组合了多种技术\n\n首先解码部分单独跑在worker里，音频和视频各一个，解码部分用了FFMpeg，这块估计是用了WebAssembly实现的，但不能实证。既然播放H265那就肯定不是用video标签，用的是canvas呈现，将视频解码并转成图片画上去的。虽然能播放H265，但是码流太高还是非常卡，实测在3M码流时已经掉帧严重，几秒后自动切入辅码流模式。\n\n!! HLS\n\nHLS是HTTP Streaming传输视频的一种，由Apple提出，另外3GPP，微软和Adobe也有类似的技术，由于iPhone太强势，使得HLS几乎无人不知。\n\nURL对应的索引文件，就是M3U8，8代表UTF8。格式像这样\n\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-MEDIA-SEQUENCE:0\n#EXT-X-TARGETDURATION:1\n#EXTINF:0.998, no desc\nhttp://media.com/seg1.ts\n#EXT-X-ENDLIST\n```\n\nhtml5的video标签本来只支持3种封装格式，mp4/ogg/webm，这几种格式似乎都偏向点播。而Apple在safari的实现中额外支持了ts，为什么要用 TS 而不是 MP4，这是因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，播放器连续播放两个 MP4 文件会出现破音和画面间断，影响用户体验。这就是Living的意思。最简单的方式是video.src","modified":"20190110121530000","tags":"protocol"},
{"created":"20181022121530000","title":"视频云的域和组织","text":"\n域有两个含义完全不同的英文单词\n\n* domain 指SaaS层的一组服务集，通常指一个下级平台\n* region 指PaaS层包括但不限于设备接入，存储，流转发等服务集\n\n一个domain包含若干个region，目前受实现限制，两者只能一一对应。domain包含若干个设备，同时能提供各种视频和结构化数据，但这些设备要交给region管理。\n\n通常来说，一个平台就是一个domain，也代表一个地理上的区划。要把从县到市再到省的平台组成一个大的整体，就依赖于domain的级联。在网络上，级联的两个domain直接联接，但在业务展示上，要经组织关联到一起。\n\n一个domain内可能会有很多层的组织树，而这个domain又挂到一个更大组织的某一层节点。\n\n看到一棵组织树，除了根节点是在本级平台，各子节点都可能是从下级获取的，而且平级的组织可能和下级组织平级，因此组织必须有一个字段记录属于哪个domain。","modified":"20181022121530000","tags":"design"},
{"created":"20210404121530000","title":"数据库的执行优化","text":"\n现代数据库都基于成本做CBO优化，CBO的难点在评估不同规则组合的期望时间，这里就会有组合爆炸的问题，为此就有了两种模型：Volcano模型和Cascades模型。其中Calcite使用的是Volcano模型，而Orca使用的是Cascades模型。这两种模型的思想都基于成本最优假设，即局部最优化后即达到整体最优化，不同点在于Cascades模型并不是先Explore、后Build，而是边Explore边Build，从而进一步裁剪掉一些执行计划。\n\nVolcano模型是一种经典的基于行的流式迭代模型(Row-BasedStreaming Iterator Model)，主流的关系数据库Oracle，SQL Server, MySQL等都采用了这种模型。在Volcano模型中，所有的代数运算符(operator)都被看成是一个迭代器，它们都提供一组简单的接口：open() -> next() -> close()，查询计划树由一个个这样的关系运算符组成，每一次的next()调用，运算符就返回一行(Row)，每一个运算符的next()都有自己的流控逻辑，数据通过运算符自上而下的next()嵌套调用而被动的进行拉取。\n\n和Volcano的相对应，推送模型最早在一些流媒体计算中被使用，随着大数据时代的来临，在一些基于内存设计的OLAP数据库也被大量使用起来，例如HyPer、LegoBase等。\n\n![sql-pull-push](./img/sql-pull-push.jpg)","modified":"20210404121530000","tags":"data"},
{"created":"20190801121530000","title":"数据库和数仓的历史","text":"\n数据库是计算机最早的应用系统，阿波罗计划时就有了数据库原型，这便是1968年的IBM ICS系统，69年改名为IMS/360（层次型数据库）。70年，IBM的研究员Codd提出了关系型模型，虽然关系型理论是IBM提出的，但出于产品惯性IBM没有及时跟进，反而是1983年Oracle率先向市场推广，虽然同年稍晚IBM也发布了DB2产品，但在市场上显然是Oracle胜了。\n\n和数据库相关但又有区别的数据仓库（Data Warehouse），概念早在1970年代就有探讨，Inmon在Kimball分别在1992和1996年出版关于数仓的专著，可以认为数仓正式成型。Inmon定义数仓是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。或者说就是建立围绕主题，并最终要挖掘出主题间关系的库。落地到具体行业，一定要对行业关心的主题建立好模型。支持构建完整数仓的技术有：清洗、集成、OLAP。\n\n* OLTP: 联机事务处理， 关系型数据库(Oracle、MySQL)多属于此类，擅长记录发生的业务内容，多小批量写入，要保证事务性。设计时强调三范式，表结构紧凑，避免冗余\n* OLAP: 联机分析处理，随着OLTP的数据越来越多，如何快速地分析这些数据就变得重要起来，这个概念是Codd在1993年提出的，在设计上和OLTP不同，往往把多张表JOIN成宽表，保留一定的冗余，来提升分析和处理速度，并不在意事务能力。分析使用的技术，多为统计学或机器学习方法。\n\n数据仓库的来源分为非结构化和结构化数据。非结构化数据要先经NLP提取变为结构化，结构化数据可以用机器学习的方式做分类、聚类，又或者按统计学的方式进行提取。\n\n数仓的建模方式有多种，国内主流的是阿里推崇的维度建模(kimball)，有星形模型(一个事实表和多个维表，没有二级维表)和雪花模型(在星形基础上允许二级甚至更多级维表)。\n\n!! MPP与SQL on Hadoop\n\n支撑数仓的软件有很多，其中一个大类统称MPP，比较商业的产品是金融领域的TeraData，但价格太贵，多见的是GreenPlum，是基于Postgre开发的主从式分布数据库，master负责调度segment负责执行。引申一句GP最初是EMC开发的，买存储送GP，配合EMC的存储和售后，在银行领域很有竞争力。\n\nMPP的代表产品有：Vertica/Redshift(Paracel，被Amazon买下了源码的license后变成Redshift)/Greenplum。仔细观察不难发现，这三者其实有非常很多相同点：\n\n# 全部基于PostgreSQL\n# 都是基于列的存储(Columnar Storage)\n# 操作都是以Scan为基础，依赖Compression来提供性能的优化\n\nMPP为了速度，需要将数据导入做一定处理，整理成优化的格式以便加速。这样做的后果就是，它们的存储类似一个黑盒，数据进去之后很难被别的系统直接读取。\n\n还有另一类统称SQL on Hadoop，实现有Impala，Hive，SparkSQL，Presto等。这类方案不负责存储，或者说是存算分离，计算基于MapReduce/RDD机制，水平扩展性很强。但是这种方案是多种系统共用一个HDFS存储空间，不可能做非常彻底的优化时优化，典型的就是CBO优化程度会弱一些。\n\nSQL-on-Hadoop架构可以分为两类：\n\n# SQL over Processing Framework：例如SparkSQL，Drill/Datameer，Presto，Impala\n# OLAP over Hadoop：例如Kylin，Druid，AtScale，Kyvos\n\nSQL over Processing Framework系统的共同特点是“Hadoop通用计算框架+SQL解析引擎”，存储层、执行引擎层、SQL解析层三者分离，可以方便替换执行引擎，对使用者而言，同一份数据可以采用不同并行执行引擎来分析。优点是灵活性高，支持细粒度容错，集群扩展性好，缺点是效率无法保证。\n\nOLAP over Hadoop系统的共同特点是预计算，即数据都以时间序列的方式进入系统并经过数据预聚合和建立索引，因为是预计算，所以应对多维查询时速度非常快（计算时间复杂度O(1)）且稳定，支持高并发，支持集群扩展。缺点是灵活性较差。\n\nMPP原理朴素上说就是分治思想，均分task。\n然后每个worker/segment上做的都是同样的sub-task，pipeline方式执行，理想情况下性能是非常优异的。\n但是很容易受到慢worker（它是最长路径）和interconnect的影响，所以scalability不佳，集群规模在十几个节点后就没有性能提升了（甚至还可能下降）。\n\nHADOOP原理更类似batch processing，更细粒度切分task，worker能者多劳（每个worker上执行的任务可以是不平均，不一致的）。\n单独worker看，性能不及MPP，但是胜在scalability优异，几百个节点是没问题的，在集群性上远胜MPP。\n\nMPP和SQL on Hadoop的最大区别在于，MPP架构是Full-SQL compatiable的，实现不局限于将Query分解为一连串的job去执行。并且由于每一列的数据类型进行了特定的压缩和编码(比如run-length/delta/bytecoding)，能做的优化要比单纯的MapReduce多很多，效率自然也要高不少。相较于SQL on Hadoop，MPP更适合做interactive ad-hoc analysis，前者则更适用于对于海量数据做批处理或者需要使用UDF(自定义函数)的场景。","modified":"20190801121530000","tags":"data"},
{"created":"20200327121530000","title":"数据库计算理论笔记","text":"\n!! 事务和隔离级别\n\nJim Gray于1970最早提出事务的ACID特性，虽然它们并列为四大特性，但重要程度并不同。\n\n* A 原子性，单机版已经很好地解决了这个问题，但分布式环境似乎仍然无解\n* C 一致性，只描述了最终的效果，过于宏大也没有提出具体的措施，因此更像是个衍生结论\n* I 隔离性，事务中最复杂的特性，分了多个隔离级别，较低的级别其实是在正确性上做了妥协，将异常结果抛给应用层解决，从而获得更好的性能\n* D 持久性，它的核心思想是应对系统故障，由此衍生出诸如WAL日志、日志同步/半同步、共享等多种具体技术\n\n可以说事务模型的发展过程就是隔离性和性能之间平衡的历史，甚至可以说隔离性是事务核心。\n\nSQL92定义了4种隔离层级，不久后Jim Gray于1995年发表了经典论文《A Critique of ANSI SQL Isolation Levels》，正式提出了快照隔离的概念。同年Oracle很快就做出了回应，但它的First Update Win方案却不同于《批评》的First Commit Win方案。顺便说句PostgreSQL也和Oracle一样用了FUW方案。早期的MySQL存储引擎并不支持事务，InnoDB出现的时候，计划基于IBM的Aries算法做出MV2PL（多版本两阶段锁），但有学者在2009年基于此改造实现了快照隔离和串行快照隔离SSI，虽然如此但MySQL官方并不支持SI，只是做了可重复读RR。反倒是PG吸收了学界的成果，把SI和SSI合并到产品中。\n\nSQL92之所以不提快照隔离并不是想不到，而是因为当时的实现主要基于锁并发，而快照隔离的基础是MVCC。当然到了现代，MVCC已经成了一种底层技术，用来高效实现乐观或悲观并发控制。乐观和悲观的区别就如字面意义，通过两段简单的代码来展示区别\n\n乐观控制\n\n```\nselect * from goods where id = 1   -- 不加锁读\nbegin; -- 读之后开始事务\nupdate goods set stock = stock - 1 where id = 1 and stock = cur_stock;  -- 更新时要注意 where 条件 “stock = cur_stock”，只有程序中获取到的库存量与数据库中的库存量相等才执行更新\ncommit;\n```\n\n悲观控制\n\n```\nbegin;  -- 先打开事务\nselect * from goods where id = 1 for update;  -- 读时用for update对数据加锁\nupdate goods set stock = stock - 1 where id = 1;  -- 写时不再校验\ncommit;\n```\n\n可能是单机数据库的历史原因，也可能是应用层为了快速开发，占据主流还是悲观控制。\n\n!! 一致性协议\n\n数据在多节点间的同步，应用较广的有这几种协议\n\n* 两阶段提交，即prepare和commit，要求所有节点都一致，高可用性不足\n* paxos/raft，中心化广播协议，前者是论文的提法，后者则是后来另一篇论文给出的几乎完整实现。可以看作是复制协议的一种，属于多数共识算法，大部分节点可用即通过\n* gossip协议，适用于P2P网络的同步协议，在节点非常多的时候，paxos负担会很重，这种场景用gossip更好\n\n!! 分布式\n\nCAP三者只能选其二，也可以只求一个达到最大化，没有见过实际例子。\n\n* 取CA，又名强一致性 ACID，但是分布式系统必然要求P，所以可以把ACID和传统单机的数据库等同\n* 取AP，又名弱一致性 BASE，从命名中也能看出舍弃了C，在不追求严格准确（或者说始终最新）的场景有一定应用\n* 取CP，用得最广，似乎没有专门的一致性定义\n\nCAP和ACID的C，中文都叫一致性，但两者含义稍有不同。CAP的C指多副本、单操作的一致性，而ACID的C，在最初的论文定义中是指单副本、多操作的事务一致性。\n\n!! 数据分片\n\n分片是单机分区机制在多副本的一种扩展，有两种\n\n* Hash分片，为做到适应扩容，都会用一致性Hash算法。这种做法平衡性好，但业务不敏感，扫描时必须全副本都执行，归纳起来就是写性能出众，但读性能较差\n* Range分片，原生的分布式数据库多采用这种方案，多个分片间使用raft协议组成Group组，每个Group是最小的高可靠单元\n\nSort和Shuffle是MapReduce上最核心的操作，由于MR每一步都会写磁盘，因此任意节点都能恢复，同样的，只要做足checkpoint也能非常健壮。","modified":"20200327121530000","tags":"data"},
{"created":"20231027033135083","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'data' sort[title]>>\n\u003C/div>","tags":"目录","title":"数据库技术","modified":"20231027033146680"},
{"created":"20200321121530000","title":"数据库SQL优化原理","text":"\n粗略地说关系型数据库都是这几步，具体前后顺序根据不同dbms不同配置下略有小差\n\n# 应用程序与数据库服务器建立链接\n# sql发送到数据库，数据库验证是否有执行的权限\n# 进入语法解析器，进行词法与语法分析\n# 进入优化器生成执行计划，部分dbms会检查是否有可重用的执行计划\n# 根据执行计划依次扫描相关表中的行，不在数据缓冲区的走io\n# 同时对于被扫描的行可能加锁，同时也可能会被其他sql阻塞\n# 扫描的行足够放入查询缓存则开始运算或直接返回，不够则生成临时表，可能消耗io\n# 对sql结果进行计算（可能）\n# 将计算完成的结果全部写入网络io（可能）\n# 如果事务完成则同步事务日志并释放锁，具体方式取决于dbms和当前配置\n# 关闭连接（可选）\n\n这么多步骤，每一步都有优化策略\n\n# 应用程序与数据库服务器建立链接，引入数据库连接池，避免每次都与数据库建立连接，提高效率\n# sql发送到数据库，数据库验证是否有执行的权限。没撒好说的\n# 进入语法解析器，进行词法与语法分析。也没撒好说的，想要数据库在这里少用点资源就把sql写的简单点，但是差别不大\n# 进入优化器生成执行计划，部分dbms会检查是否有可重用的执行计划。最复杂的部分来了，任何数据库如何生成执行计划都可以写一本几百页的书。\n\n关系型数据库选择走什么执行计划都是基于消耗最小化的思路来的，简单来说就是走什么索引，按什么顺序走表，被扫到的数据行最少。如果你的表结构很复杂，有各种混搭的索引，你的join很多，那执行计划分析的时间就会拉长。所以sql对应的表索引简单，join或子查询少就快，复杂了优化器也会得选择困难症。\n\n# 根据执行计划依次扫描相关表中的行，不在数据缓冲区的走io，存储引擎扫描表的性能消耗参考下面的list，消耗从大到小\n\n> 全表扫描>全索引扫描>部分索引扫描>索引查找>唯一索引/主键查找>常量/null\n\n要走索引对于sql语句也有要求，不能在谓词上作任何运算，扫描行数一般不能超过表的17%左右，这对你数据分布又有要求，比如你查select xxx from human where sex ='man'，五五开，还是走扫描。推荐一本书《Relational Database Index Design and the Optimizers》\n\n# 同时对于被扫描的行可能加锁，同时也可能会被其他sql阻塞。如果扫描的行多，sql执行的时间长，被阻塞的概率就高，阻塞别人的概率也高，然后大家一起等，数据库就hung住了\n# 扫描的行足够放入查询缓存则开始运算或直接返回，不够则生成临时表，可能消耗io。一次取的尽量少，这不单指返回服务端的行数，应该从嵌套最深的一个子查询开始算\n# 对sql结果进行计算（可能）少用各种复杂的函数啊，count啊，order by啊等等\n# 将计算完成的结果全部写入网络io（可能），请尽量少返回一点数据，如果不行请多次分批\n# 如果事务完成则同步事务日志并释放锁，具体方式取决于dbms和当前配置。这里举两个代表性栗子:\n\nsql渣：\n\n```\nfor i in (1-1000):\nstart transaction;\ninsert into table values (1);\ncommit;\nend for\n```\n\nsql赞：\n\n```\nstart transaction;\nfor i in (1-1000):\ninsert into table values (1);\nend for\ncommit;\n```\n\nsql赞爆：\n\n`insert into table values (1)()...()(1000);`\n\n首先，sql语法是我临时自创的，这个不是关键，关键在sql渣先生是1000个事务插1000行，日志flush1000次。sql赞先生是一个事务插1000行，事务日志flush1次。sql赞爆最nice。这个例子我想表达的意思是如果你要用sql做一件事，那就要尽量让这件事占用的事务总时间最少。\n\n第二个例子\nsql渣：\n\n`update table where id > 0 and id \u003C 1000000;`\n\nsql赞:\n\n```\nupdate table where id > 0 and id \u003C 1000;\nupdate table where id >= 1000 and id \u003C 2000;\nupdate table where id >＝ 2000 and id \u003C 3000;\n```\n\n这个例子我想表达的意思是如果你要用sql做一件很大的事，那就尽量让大事化成很多小事。两个例子好好体会下，一点不矛盾哦。补充一下，这里每个update都是单独事务\n\n# 关闭连接（可选）。同1，别每次都关，关了也许还要重连。不关的话记得commit就好了，千万要记得commit啊！","modified":"20200321121530000","tags":"data"},
{"created":"20190827121530000","title":"数据挖掘、机器学习和深度学习","text":"\n数据挖掘不是一个学科门类，更多是商业或业务上的叫法。利用的技术主要是机器学习或深度学习，都是分析数据，提取公式或模型，并最终用于预测数据，解决问题。\n\n机器学习并不是全新的学科，和更早的数据拟合或最优化计算有千丝万缕的关系，和统计学关系尤为密切，都是实现分类聚类预测关联。相对来说，得到的结果具备可解释性，也可以根据数据原理调优。\n\n机器学习的分类有几种维度\n\n* 监督学习：分类和回归，比如KNN，SVM，决策树与随机森林\n* 无监督学习：聚类，如K-Means，Apriori，主成份分析PCA\n* 半监督学习：\n* 强化学习：应用较少，多为游戏领域如AlphaGoZero\n* 集成学习：bagging，boosting，stacking\n\n深度学习则基于**神经网络**，属于监督学习。喂以海量数据，经多层的前馈和反馈自演化训练出一套行为。由于网络层数很多，人很难分析其具体行为，调优也靠撞。另一方面喂了海量数据但终究只能处理同类型的数据，并不具备理解和推导上的延伸能力。","modified":"20190827121530000","tags":"data"},
{"created":"20140313121530000","title":"数字的精确与不精确","text":"\n很久不写Scheme，写了个判断质数的函数却永远返回成功，看代码逻辑看不出问题，于是只能一个个函数去试验，好在Scheme交互式写法很容易就能逐个函数地检查问题。终于发现问题出在数字运算的精度上。\n\n简单的质数判断逻辑是从2开始，直到这个数的平方根为止挨个去试，如果有一个能被整除，就不是质数；反之就是。但取余是个整数运算，而平方根的结果就算做了取整依然是浮点数，于是用浮点数对整数取余的结果，哪怕它实际上是0，但反应在浮点数里却可能是37e-52这种结果，而这和0是不相等的，导致每次计算的判断都为假，最后这个数就被作为一个质数报上来了。原因找到后，只要在开平方取整后，再做个inexact->exact的操作就可以把浮点变成等值的整数。计算结果也就正常了。\n\n出这个错的原因，一方面因为Scheme是弱类型语言，而在强类型语言里浮点和整形计算是要做区分的，像C会报类型不匹配警告，而ML则干脆就区分了整形和浮点数的运算符，但Scheme是在运行时悄悄地执行，也不报错。难怪历史上总有弱类型语言容易出错的报怨，大家也都是一路吃着苦头过来的。另一方面在RnRS里有一个完整的章节就用来描述数字的概念及相应的操作，以前看的时候不明白为什么要花费这么多笔墨描述数字的概念，以及那一族奇怪的exact?,inexact?inexact->exact，这回算是彻底明白了。正因为Scheme弱类型的特点，需要人为地判定并做显示的数字类型转换，才能得出正确的计算结果。\n\n说个C语言的浮点数处理，float/double是可以memset的，结果就是0.000000。估计也是为了兼容吧。","modified":"20140313121530000","tags":"lang"},
{"created":"20170730121530000","title":"思考、笔记与记忆","text":"\n学会正确地思考，不被欺骗(不被收智商税)，就一定要提升自己的认知能力。光说正确的思考方式比较抽象，就和读书的时候看教科书往往很难学到东西，只有做错了题目才能更进一步掌握，这是因为我们的思维对比较差异是很高效的。\n\n本文试图探讨如何将碎片时间的点滴，积累成完整的内容；如何更好的记忆和复习；如何将内容分类并形成体系。\n\n!! 1. 记忆与间隔重复\n\n** 解决问题的公式=知识+逻辑 **\n\n知识需要记忆，如何才能达到高效的记忆？间隔重复SRS(Spaced Repetition Scheduler)，是对艾宾浩斯的更精确的量化方式。比较公认的是SuperMemo作者 Piotr Wozniak 提出的DSR(Dificulty-Stability-Retrievability)模型。Difficulty 难度，越大越难，Stability 稳定性指的是记忆的存储强度，越高，记忆遗忘得越慢。量化方式是回忆概率从 100% 下降到 90% 所需的天数，Retrievability 可提取性指的是记忆的检索强度，越低，记忆遗忘的概率越高。估计今天复习回忆成功的概率。\n\n这3个参数中S最难计算，也是核心。基于以下记忆规律来设计SRS的公式：\n\n* 记忆材料越难，记忆稳定性增长越慢\n* 记忆稳定性越高，记忆稳定性增长越慢（又称为记忆稳定化衰减）\n* 记忆可提取性越低，记忆稳定性增长越快（又称为记忆稳定化曲线）\n\n换成算法表述，对于一堆要复习的素材，就是以时间T为衰减项，根据难度D和稳定性S这两个系数值，更新召回率R。当R低于阈值后就进入复习序列，难度和稳定性影响召回率的下降速度。每次复习后的反馈会修正难度和稳定性（不是替换老的值，而是加权修正），进而影响召回率的更新速度。\n\n参考FSRS并简化后的计算公式如下\n\n* R = 1 / (pow(1+dT/S, -1) * D) # dT: 过去的天数\n* D = D - d(Grade-1) - e(1-R) # Grade: 0-遗忘 1-一般 2-简单  d/e: 默认1\n* S(成功) = S(1 + a * pow(D, -b) * pow(S, -c) * (exp(1-R)-1)) #\n* S(失败) = pow(S, f * L) # L: 遗忘次数\n\n!! 2.思考方式与思维误区\n\n传统的逻辑学分类是演绎和归纳两种。\n\n演绎的基本是我们所熟知的三段论，如果再细分的话，有直言三段论、假言三段论和析取三段论，这几种都是古典逻辑，现代逻辑的符号学或者更复杂的形式，我还不了解。演绎的推导是必然和确定的，但是这里存在一个弱点就是最初的出发点，要如何如证真？为了提炼出最初的前提，就会用到归纳法。\n\n归纳通常来自我们对外在世界的观察，并以类比的方式总结出一些结论，这也是经验主义者(如大卫休谟)所推崇的。归纳不像演绎，它是或然的(probable)。但不能因为这个就不否认归纳法，而是要用大量的事实来尽可能提高结论的适用性。但如果真的出现归纳前提不成立，也不见得是坏事，这时世界已经对你展现了另一面从未见识的地方，理应感到高兴才对。\n\n经常会有误区认为：做好了开发，就能做好架构。其实前者重在逻辑推理，算法构建，而后者更多是种权衡与取舍，甚至对人心的把握。做好了架构，不一定做得好技术白皮书，因为面向的是市场，又是完全不同的内容，对素材的要求也不一样。\n\n不同阶段不同人群，都是不一样的打法，可能其中有些粗看相同，但细看却差别很大。需要厘清概念分而解之。只有将思维误区必须和思考方式互为参照，才真正能提高。\n\n!! 3. 实践与写作\n\n卡片笔记是一种思考方式，把它作为过程的外化和具象化。记录+链接的wiki未必是最好的载体。卢曼卡片有两个阶段，第1阶段是一种按目录组织的知识体系，第2阶段会给卡片标上类似3125分类，每位数字代表一个领域，逐级细化。\n\n还有一种是链接，尤其是双链。因为分类天然是深度优先，只有用链接重新跳出来，才会触发更多的灵感。双向链接有4种子分类，主题索引，前后逻辑，文本内容，卡片编码链接。主题用来确定大的类目，前后逻辑表示卡片的引用关系，文本内容则是更具体的内容详情展开，卡片编码似乎也是分类。链接的同时也是一个思考的过程。\n\n写作之难，在于把网状的思考，做成树状的结构，用线性的语言表达出来。三种结构，时序、逻辑、情绪。挑选一种作为推动故事发展的内核。文章运用修辞，如李笑来就是比喻和排比。手法上长短镜头结合。\n\n!! 4.目标与积累 up at 23年1月\n\n我相信人都是有路径依赖，哪怕转型，过去也是财富。盯紧目标，有近的和远的，阶段性有几个具体的专项去做，更难的是要不时地去确认和修正远景目标。正因为远景定得宏大，所以走偏或发现不对十分正常，但又因为不是日常内容，如果不周期性核对，就会忘记导致忙碌一整年却没有沉淀。\n\n做的过程经常笔记，但更要时时地对内容做分类、合并，分类是为了建立知识体系，合并是因为新的总会修正旧的，而这个过程也是进一步夯实技能。\n\n分类会存在模糊或错误，曾经的分类，随着能力圈的扩大，会变成子分类，说明是好事。","modified":"20170730121530000","tags":"think"},
{"created":"20231027033506875","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'think' sort[title]>>\n\u003C/div>","tags":"目录","title":"所思所想","modified":"20231027033521504"},
{"created":"20161112121530000","title":"通过限制来降低沟通成本","text":"\n看了王垠的[对Rust语言的分析](http://www.yinwang.org/blog-cn/2016/09/18/rust)，\n其中提到一点，少用类型推导而用明确的类型声明，大概这种大逆不道的话，也只有王垠敢说吧。\n但是他的原因我是深以为然的，代码写出来是给人阅读和交流的，\n甚至更多的时候只有你会读你的代码，所以更具备更读性，也是对自己好的一种方式。\n\n想起工作中的一件事，公司的接口和协议使用Json有5、6年了，协议使用Json没什么大问题，\n但是如果头文件也直接用Json，然后在注释段直接来一句：参见XX文档，就很有问题。\n现在做产品的，都提倡不要让用户想，不要增加用户的获取成本，\n如果把程序员也当成设计人员的用户，那么这条准则依然适用。\n因为有可能，程序员根本不知道所谓的XX文档是什么，也不知道去哪里获取，\n即使有了文档，还是会不确定。比如我在昨天遇到的一个例子，当时文档上很清楚地标明了，\nJson格式是这个样子的：\n\u003Cpre>\n{\n\"content\" : {},\n\"alarm\" : 1\n}\n\u003C/pre>\n但是他还是不确定alarm和content是否平级，并为此还特意拉了几个人，在群里确认了一遍。\n虽然这样的例子不多，但是随着组织的扩大，人员平均水平的下滑(这几乎是一定的)。\n这就造成了非常大的重复沟通浪费和注意力分散。\n\n我一直提倡在头文件中，用struct来替代Json。能做到自解释，也能明确的规定类型，\n规定类型是一种限制，可是这种限制带来的确定性，在一个组织变得庞大后，\n更多的仍是明确含义，减少沟通的益处。组织庞大及随之而来的低效，往往是沟通不畅造成的，\n在程序员这一级，我们有很好的技术手段来简化这种沟通成本，为什么不用呢？\n","modified":"20161112121530000","tags":"design"},
{"created":"20231027033300058","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'protocol' sort[title]>>\n\u003C/div>","tags":"目录","title":"通信协议","modified":"20231027033316704"},
{"created":"20190103121530000","title":"网络层的交换与路由","text":"\n!! 网段定义\n\n对于私网地址的规范，在RFC 1918 - Address Allocation for Private Internets里有完整的规范定义。其中A类，B类，C类网段各取了一部分：\n\n* 10.0.0.0/8 (255.0.0.0)\n* 172.16.0.0/12 (255.240.0.0)\n* 192.168.0.0/16 (255.255.0.0)\n\n192的私有网段只能放下255^2即6万多台主机，家庭当然够用，但大企业可能就不够。所以大公司内网会用10或172网段。\n\n可能最早的路由是用192.168.0.1，从最小的0开始合理，后来随着小区有了网络，为了避免和外级网络冲突，用了192.168.1.1，好比现在的无线网络用192.168.2.1，原理是类似的。\n\n最后一位不能用0。原理大概是这样，0和255都是广播地址，**关于0到底是广播还是主机号，此处存疑，但不用肯定没错**。0不能被主机使用，255可以。但如果用255会被用作广播的收端，尽量避免。有些特殊会用254，所以也有路由器用253地址。\n\n倒数第二位用0虽然理论上很正确，在早期的路由器中，0段子网在没有子网掩码的情况下会与它的网络号相同而产生路由上的混乱，古老的路由协议RIP在路由时就不考虑子网掩码的问题，所以在cisco的设备上才有 ip subnet-zero这个命令来打开对 0段子网的支持。可能出于规避目的，用192.168.1.1。当然现代的路由器应该不需要考虑这些问题了。\n\n!! 交换和路由的区别\n\n简单的说，同一个网段内叫交换（二层），不同网段之间叫路由（三层）。现实中也有三层交换，属于特例。\n\n早于IP网络的电话交换机，可以理解为一层交换。对电话来说独占一条物理电线，不存在IP分包的概念，直接对物理介质做交换控制，所以是一层。\n\n路由路径在二层和三层的路径是不同的。二层用ARP协议，从IP反查MAC直接物理层就找过去了。三层就全是IP寻路，通过网关出去，并由网关往后一级的网关传递，最终找到目的地。\n\n有两个常被忽略的属性，dev和scope。dev相对于对gateway的一个更小的约束。同样起到约束作用的还有scope。Scope是一个更小程度的约束，指明了该路由在什么场景下才有效。也是用于约束目的地址的。例如不指定网关的二层路由，通常对应的scope类型是scope link。scope link的意义就是说明在同一个二层。这个意义与网关不指定的效果是呼应的。\n\n四种scope\n\n# global是在任何的场景下都有效，link是在链路上才有效，这个链路是指同一个端口，也就是说接收和发送都是走的同一个端口的时候，这条路由才会生效（也就是说在同一个二层）。Global则可以转发，例如从一个端口收到的包，可以查询global的路由条目，如果目的地址在另外一个网卡，那么该路由条目可以匹配转发的要求，进行路由转发。\n# link的scope路由条目是不会转发任何匹配的数据包到其他的硬件网口的。\n# host表示这是一条本地路由，典型的是回环端口，loopback设备使用这种路由条目，该路由条目比link类型的还要严格，约定了都是本机内部的转发，不可能转发到外部。\n# site是ipv6专用的路由scope。\n\n!! route命令\n\nWindows和Linux的参数不完全一样，网上找文章时要注意。route命令除了添加了删除，还能屏蔽某种路由路径。route命令除了支持inet协议，还能支持ax25、ipx、netrom等数种二层协议，不过由于/proc/net/下没有对应的文件，所以没有使用。\n\n!! 路由协议和preference\n\n到某主机有多条路可选，会挑选优先级高的。比较方式先匹配掩码长度，再比较管理距离(比如metric)。掩码长的高于掩码短的，所以3种路由顺序如下\n\n# 主机路由，直接指明某台主机，/etc/hosts\n# 网络路由，指明某类网络怎么走\n# 默认路由，也叫默认网关，一般是目标地址为0.0.0.0的那条\n\n路由器往往支持多路由协议，这就有一个多种路由的选择和配合问题。为了解决这个问题，在路由的参数中引入了优先级（preference）的概念。各路由协议一般来说都定一个固定的preference值，preference值越小，协议对应的路由的优先级越高。以下是业务标准的路由协议：\n\n* 直接路由  0\n* OSPF路由  10\n* IS-IS的level 1的路由  15\n* IS-IS的level 2的路由  18\n* RIP路由（Berkeley）  100\n* BGP路由 170\n* EGP路由（已被BGP淘汰） 200\n\nRIP是最简单的协议，只告诉近邻，距离目标有几跳，且当目标之间距离变长后，并不会更新，因此网络收敛非常慢。RIP协议规定跳数上限是16，因此17可以认为是目标不可达。\n\nOSPF/ISIS比RIP高明的地方，RIP只知道邻居选择告诉自己的消息。OSPF/ISIS邻居不会隐瞒任何消息，会毫不保留地将消息传递给整个参与OSPF/ISIS网络里的任何一台路由器。因为信息同步是OSPF/ISIS能够正常工作的前提。如果不同步，OSPF/ISIS有网络环路的可能。OSPF内划分一个或多个Area，规模小的话只要一个Area0就行。由于OSPF/ISIS分享的信息过多，只适合运行在一个AS（Autonomous system 自治系统）内部，自治系统可以是一个公司，或一个校园网，也可以是一家运营商。每个AS会有个独立编号，公安网内部号段6xxxx和7xxxx。\n\nRIP、OSFP都属于内网路由，但规模不能太大，如果是非常大的AS，或者AS之间，就要引入BGP协议。\n\nBGP路由最复杂，主要用作不同AS间的边界网关，也是互联网惟一的协议。可以配置路由的颗粒度。颗粒度是由路由前缀的长短决定的，比如17.0.0.0/8的颗粒度很粗，17.1.0.0/16就会稍细，当然17.1.1.0/24颗粒度会更细。但是颗粒度太细，又会造成路由表的臃肿不堪。当前对颗粒度的要求是，路由前缀的长度，要≤21。\n\nBGP是唯一使用TCP作为传输层的路由协议（端口179），其他的路由协议可能都还到不了传输层。TCP连接的窗口是65K字节，也就是说TCP连接允许在没有确认包的情况下，连续发送65K的数据。而其他的路由协议，例如EIGRP和OSPF的窗口只有一个数据包，也就是说前一个数据包收到确认包之后，才会发送下一个数据包。当网络规模巨大时，需要传输的数据也相应变大，这样效率是非常低的。这也是它们不适合大规模网络的原因。而正是由于TCP可以可靠的传输大量数据，使得BGP适合大规模网络环境。\n\nBGP不同算法对收敛速度影响不同，比较快的有BFD，FRR算法。\n\n!! 路由metric的含义\n\n需要区别的是路由开销（metric）和路由优先级（preference）这两个概念。metric是针对同一种路由协议而言，对不同的协议，由于代表的含义不同，比较不同协议的metric是无意义的，所以要在两条不同协议的同信宿路由中作出选择，只能比较路由的优先级。相反，preference是针对不同协议而言，同协议的路由的优先级是一般情况下一样的，metric这时是在两条同信宿路由中作出选择的标准。","modified":"20190103121530000","tags":"net"},
{"created":"20210120121530000","title":"网络代理概念与区别","text":"\n!! 模式\n\n* 全局模式 所有连接全从指定的端口转发出去，简单却不灵活\n* PAC模式，全称代理自动配置，由网景公司在1996年在2.0版本的navigator上开发，是一段JS脚本。根据目的端地址选择不同的出口。在火狐浏览器上与全局模式是二选一关系，谷歌可以装插件单独设置PAC，但应该也是屏蔽全局模式\n\n!! 类型\n\n* 正向代理: 比如内网通过网关访问互联网，在客户端侧显式设置\n* 反向代理: 在集群最外侧做负载均衡，在服务端侧显式设置\n\n往往公司的正向代理会做行为管理，客户端感知不到它的存在。有几种模式，透明代理/匿名代理和中间人模式。透明代理是做包转发，而中间人模式取自中间人攻击，代理会和客户端先建立https连接，再由代理和目的端建立连接，没有隐秘性。\n\n!! 代理协议\n\n连接到代理服务器也需要指定协议\n\n* http 对代理转发端来说最方便，但隐蔽性不够，即使用https也会因为代理多出一条CONNECT从而暴露目的，多用于企业或学校内网\n* socks 专为代理设计的协议，定义足够简洁且历史悠久，支持的软件也很多\n* shadow_sock 为解决socks加密和隐蔽性不够而开发的新协议，有变体，应用较多\n* 各类VPN 这个工作在IP层，比以上的传输层代理更通用\n\n!! socks应用\n\nsocks协议非常简单，有4，4a，5共3个版本。socks4只支持TCP，版本5增加了UDP，也成了当今代理界的事实标准。ssh的-D隧道就是在客户端启动的socks5代理。\n\n整个流程包含认证和确定目标两个阶段，最简单不作认证的情况下，两次交互以后的数据就是纯转发了。因为协议是明文且特征明显，很容易被识别出真正的目的地址，要用socks5穿墙是不可能的，往往是用在本地程序和本地加密代理间。\n\nshadowsocks的本地端就以socks5方式接受数据，之后把数据混淆后转给ss服务器，回复的数据最终以socks5方式给到应用程序。\n\nIE浏览器支持socks代理，但似乎只支持4，但要注意不能填http/ftp，只能填写socket那栏，socks代理才能生效。但是4不能承载dns协议，如果目的端是域名而不是IP，代理无法生效，此时用代理插件而不是系统代理就能解决。\n\n!! 实现一个最简单的HTTP代理\n\n最简单的代理，得到HTML的主体内容并回复给请求者，以PHP为例，最简单的做法是用curl取得数据。要注意的是对于HTTPS，要关闭验证否则会得不到数据。另一种做法是用`file_get_contents`，在某些环境要配置签发CA的根证书，没有无法获取，且只能得到HTTP的body，header描述信息会丢失。\n\n不管是curl和file函数，获取到的网页主体HTML内容是一致的。但网页的复杂性在于HTML还包含了CSS和JS代码，需要额外下载。如果是绝对地址可能到不可达；相对地址在展开时，浏览器看到的是代理地址，所以会补全成代理的地址，这时显然就不能获取到资源文件了。所以代理的难点，就在于尽可能穷举各种URL的形式，并替换成指向源端的地址。","modified":"20210120121530000","tags":"net"},
{"created":"20190429121530000","title":"网络文件系统机制","text":"\n几种常见的NAS协议，FTP无法挂载到路径，AFS只有Apple用，几乎遇不到，说说Samba(smb又叫CIFS)和nfs方式\n\n!! Samba\n\n有1和2两个版本，在win10上比较方便，但win7怎么都试不出来。win10要用smb版本2，需要注意。\n命令是sudo mount -t cifs -o username=\"administrator\",password=\"1\" //winip/code/ /mnt/win -o vers=2.0\n\n!! nfs\n\n有1~4版本，前3个版本是Sun设计，而4是IETF主导，机制上改动很大。目前多见的是3和4版本，v3监听UDP的111端口，但真正RPC通信端口是后续协商出来的，而v4则只监听TCP/UDP的2049，配置防火墙更简单。\n\nwindow作为服务端，linux作客户端时，高版本windows带了v4版本，或者用第三方hane nfs server开启服务，配置 `D:\\code -public`就可以共享指定目录了。linux端下载nfs-utils。用 showmount -e ip 查看开放的共享目录，用 sudo mount -t nfs ip:/d/code /mnt/win 就可以挂载目录了。默认用UDP可能不太稳定，可以在mount加上 -o proto=tcp -o nolock。如果用v4版，mount命令改为-t nfs4。\n\n如果linux作服务端，步骤稍多一些，必须root身份\n\n# 安装nfs-utils和rpcbind（也叫portmap）\n# 编辑/etc/exports文件，exportfs -r 把目录写入内核\n# 启动rpcbind，也叫portmapper服务，在cent上的包叫rpcbind\n# 启动rpc.mountd和rpc.nfsd服务\n\nv3和v4版本都要用 exportfs 命令设置 NFS 导出目录。exportfs 有两种操作模式：\n\n# 读取 /etc/exports 以及 /etc/exports.d/\\*\n# 从命令行参数获得导出目录设置\n\n两种模式下，exportfs 都会通过 /proc/net/rpc/nfsd.export/channel 往 Linux 内核写一份（很像 Plan 9），并且更新 /var/lib/nfs/etab 文件。\n\nnfs采用了 C/S 架构，但是NFS的Client/Server只负责和文件系统交互，而不提供任何 TCP/IP 数据传输功能，需要配合RPC服务器才能实现数据传输（其实也好理解，Sun利用RPC开发了很多服务，NFS只是其中的一个应用，从分层角度看，自然不会包含网络协议）。因此nfs的v3版共有4个服务才能完成完整的功能\n\n# rpcbind服务(portmapper)，监听111端口，有点像 DNS server，它把 PROGRAM ID 翻译成服务真正的 IP 和 PORT(不知道 IP 是否可以是其它机器），每个 RPC service 启动时都要向  注册自己的 PROGRAM ID。可以用rpcinfo -p ip来查看注册了哪些服务。注意这个命令是查注册命令，不一定运行，所以netstat可能看不到这些端口\n# rpc.mountd服务，监听20048端口，应该是负责文件系统交互的服务\n# rpc.statd服务，有IN和OUT端口要监听\n# rpc.nfsd服务，监听2049端口，如果没启动，客户端在mount时会提示RPC程序未注册\n\nv4版简化了上述流程，只需要nfsd监听2049就可以了，简化了防火墙的配置难度，但需要额外向/proc/fs/写内容。","modified":"20190429121530000","tags":"os"},
{"created":"20170525121530000","title":"网络相关头文件所属目录的关系","text":"\nunix下的网络文件分布的目录比较多，初看会觉得很乱且难记，试着整理一下。\n\n本着unix下一切皆文件，所有的网络操作都通过抽象的socket操作，即socket是这些网络的承载者，不同的网络主机有各自的socket，并处在不同地址上。socket的头文件是sys/socket.h，比较直观也很好记。\n\n对网络来说，不同的网络不能直接通信，所以socket首先要和地址绑定，不同的网络方式地址格式不同，要确定地址就要先确定网络方式，这里引入第一个概念`AF_XXX`宏，AF指Address Family，除了常见的IP网络(有`AF_INET/AF_INET6`两种)，还有像Bluetooth、AppleTalk、IPX(Novell)等不常见格式。OpenBSD支持36种，而Linux支持40种。从数量来看好像差不多，但两个系统间互相之间的交集并不多。Linux支持的NFC/CAN格式在BSD下不存在，同样BSD也有很多Linux没有的，不过总的来看BSD的网络协议更冷门一点，也许和它历史更久，用得也少有关系。\n\n因为不同的地址族使用不同的协议，所以还定义了一套`PF_XXX`的宏，PF指Protocol Family，除了前缀不同，其它和AF宏完全一样。既然有三十多种地址，地址的格式必然不会相同，struct sockaddr解决的就是这个问题，这是个变长的结构，否则无法支持未来的网络协议族，因此这个结构最重要的就是长度和family字段，定义方式和TLV的思想是一致的。sockaddr相当于父类，具体每种协议族有各自的表示，像`sockaddr_in`是IP网络地址，而appletalk就是`sockaddr_at`，命名风格非常统一。不过并不是每个协议族都有专用地址，net80211/就没有。\n\n虽然socket.h文件比较长，但和操作相关的accept/bind/connet/listen等占比重不高，其余大量各种宏和数据结构操作的定义。比如`SOCK_STREAM/SOCK_DGRAM`，这样看起来，这两个定义适合各种网络，而不仅仅是TCP/UDP。\n\n理解了socket.h，就能知道网络的family有非常多，每种family下肯定还有很多的选项，这么多的协议族肯定要分开保存管理，所以在/usr/include/目录下有net/目录，还有形如netinet/、netmpls/、netatalk/、netax25/等等具体协议族的目录。\n\n先说net/目录，这下面的文件特点是大都`if_xxx.h`风格，主要的用途是查询(inquery)各种network interface。比如`IFF_UP/IFF_MULTICAST`操作。BSD和Linux在这里又显出很大的差别，BSD中定义了名为ifnet的结构，用于内核操作网络接口man(9)，但Linux没有。\n\nnet的作用更多在于操作网卡，具体的协议比如IP协议则定义在netinet/目录下，这里的in.h(我猜应该in是internet的简写)定义了IP协议的各种应用，如TCP/UDP/ICMP/IGMP/ESP/AH等。这些定义都以`IPPROTO_`作为前缀，是IP PROTOCOL的简写。\n\n这样一路看下来，网络头文件的规律就很清晰了。最后再说一个稍有点特殊的头文件，arpa/inet.h，这里定义了各种IP地址的数字表示和字符串表示的转换函数，为什么放在arpa目录，我猜是因为：IP网络的定义是由IEEE提出的，但第一个实现这个网络的是arpanet(1968年构想，直到1975年才有60个节点)，可能是当时开发时觉得，需要一个工具性质的地址转换函数，就放在arpa这个有点项目专用性质的目录下了，但后来随着用的人很多，所以就保留至今，没有移到netinet目录。另外arpa/目录下还有telnet.h/ftp.h/tftp.h等文件，原因是arpanet要求主机实现telnet/ftp/tftp协议，这也是一个网络最基本且必须的功能。所以arpa/目录作为历史的见证一直保留到今天。","modified":"20170525121530000","tags":"protocol"},
{"created":"20180621121530000","title":"网络协议与socket","text":"\n!! IP协议族的历史\n\nTCP/IP这套基于包交换理念的协议族最早构思于1974年5月，并在同年12月发布了如何控制传输的RFC675（这个时期还只是一个大的单体程序，没有做分层）。到1980年1月发布了层次化的RFC760标准，82年3月美国国防部钦定用于军事系统。随后在1982年用于SATNET，紧接着在1983年1月用于ARPANET。\n\nTCP和UDP只支持单一特性，出现在2000年的SCTP协议，能够同时支持严格有序传输（像TCP），部分有序传输（像per-stream）和无序传输（像UDP）。贴段说明：\n\n> 作为一个传输层协议，SCTP兼有TCP及UDP两者的特点。SCTP可以称为是TCP的改进协议，但他们之间仍然存在着较大的差别。\n> 首先SCTP和TCP之间的最大区别是SCTP的连接可以是多宿主连接的，TCP则一般是单地址连接的。\n> 在进行SCTP建立连接时，双方均可声明若干IP地址（IPv4，Ipv6或主机名）通知对方本端所有的地址。\n> 若当前连接失效，则协议可切换到另一个地址，而不需要重新建立连接。\n> 其次SCTP是基于消息流，而TCP则是基于字节流。\n> 所谓基于消息流，是指发送数据和应答数据的最小单位是消息包(chunk)。一个SCTP连接（Association）同时可以支持多个流(stream)，\n> 每个流包含一系列用户所需的消息数据(chunk)。而TCP则只能支持一个流。\n> 在网络安全方面，SCTP增加了防止恶意攻击的措施。SCTP连接采用四次握手机制，有效的防止了类似于SYN Flooding的防范拒绝服务攻击。\n> SCTP主要的贡献是对多重联外线路的支持，一个端点可以由多于一个IP地址组成，使得传输可在主机间或网卡间做到透明的网络容错备援。\n\n!! Socket的历史\n\n光有协议还不够，必须有编程接口，Berkeley socket于1983年随着BSD4.2系统发布，但直到1989年才和AT&T达成诉讼和解并真正成为众人公认的网络编程接口。\n\nsocket函数声明传入3个值，依次是domain/type/protocol。域最大，然后是类型，比如连接/无连接/原始等，最后是协议种类如TCP或UDP。经过这么多年的洗礼，历史上曾经繁多的domain类型，比如X25,IPX,AppleTalk,NetBEUI不能尽数，可对如今很多人来说，只知道IP。协议也只剩下TCP或UDP这两种了。网络之外，还有红外`AF_IRDA`、蓝牙`AF_BLUETOOTH`的socket可以使用。\n\n现在一提到连接，就是TCP，一说数据包就是UDP，一般用如下两种方式：\n\n* UDP socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n* TPC socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n如果DGRAM配合TCP或反之，函数返回-1，errno显示原因是`EPROTONOSUPPORT`，表示协议不支持。还有一种`IPPROTO_UDPLITE`类型，去掉了UDP的checksum，配合音视频流的时候，尤其VoIP效果更好。","modified":"20180621121530000","tags":"net"},
{"created":"20231027033108259","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'net' sort[title]>>\n\u003C/div>","tags":"目录","title":"网络原理","modified":"20231027033125504"},
{"created":"20190607121530000","title":"网页链接","text":"\nOCaml和SML比较\nhttp://adam.chlipala.net/mlcomp/\n\n目前还在使用中的 Standard ML 实现有4个：经典的 SML/NJ（只有32位版本）、Moscow ML、Poly/ML 和 MLton。其中 SML/NJ 的地位相当于参考实现和标准库，其他所有实现都向它看齐。Moscow ML 的性能比较差，但功能丰富；Poly/ML 性能高，主要用来编译定理证明器；MLton 性能最高但没有交互界面。 ​​​\n\nPython字节码\nhttp://knuth.luther.edu/~leekent/CoCo/\n\nLispMachineManual\nhttp://hanshuebner.github.io/lmman/frontpage.html\n\n从错误提示学Rust\nhttps://rust-unofficial.github.io/too-many-lists/index.html\n\n编译器课程\nhttps://www.cis.upenn.edu/~cis341/current/\n\nhttp://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/\n\n!! 收藏夹\n\n[vim教程](https://github.com/vim-china/hello-vim)\n\nhttp://tushare.org/\n\nhttps://plfa.github.io/\n\nhttps://coq-zh.github.io/SF-zh/plf-current/toc.html\n\nhttps://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/\n\n2017学区 https://www.19lou.com/forum-263-thread-6631457491565752-1-1.html\n\n初中学区 https://www.19lou.com/forum-15-thread-7011427707348977-1-1.html\n\nhttp://weakyon.com/","modified":"20190607121530000","tags":"tool"},
{"created":"20190408121530000","title":"网站项目教训","text":"\n!! MySQL\n\n用service 启动MySQL后，会发现进程有两个，mysqld_save和mysqld，save是个shell脚本，做些资源守护。记得开binlog，\n\n遇到启动不了updating without PID的情况，居然简单地mv /etc/my.cnf /etc/my.cnf.old就解决了。原因是支持无配置文件的启动，用mysqld --verbose --help |grep -A 1 'Default options'察看读取的配置文件。\n\n本地无法连接，先改配置skip-grant-tables并重启，update mysql.user  set authentication_string=password('newpasswd') where user='root'更新密码。事后发现是密码置空所以登陆不进。\n\n远程无法连接，可能是限制了root的来源，use mysql; select host from user;看是否为localhost，并改为%。改完如果不想重启mysql，执行 flush privileges;相当于刷新权限表。\n\n!! nginx\n\n命令行参数很简洁，修改配置后用-t验证，重启用-s，而启动前可以用-p, -c, -g指定预加载路径、配置名称和额外的全局变量。\n\n重定位原理，如果是root配合index指令，浏览器的请求一定要以/结尾，这样才能配合index指令找到文件。可以理解为访问站页，用的就是`/`路径，返回index.html。\n\n`location ~* /js/.*/\\.js`\n\n* 以 = 开头，表示精确匹配；如只匹配根目录结尾的请求，后面不能带任何字符串。\n* 以^~ 开头，表示uri以某个常规字符串开头，不是正则匹配\n* 以~ 开头，表示区分大小写的正则匹配;\n* 以~* 开头，表示不区分大小写的正则匹配\n* 以/ 开头，通用匹配, 如果没有其它匹配,任何请求都会匹配到\n\nlocation和proxy_pass配合有个奇怪的特性，路径如果最后带/与否对结果影响很大，比如location /openeco，请求/openeco/user的话，转发后会剥掉匹配部分，实体只会收到/user请求，而location /openeco/，转发就会收到完整的/openeco/user。\n\n再举个例子，想达到访问首页跳转到某个子文件夹，利用rewrite指令，这条指令的格式是这样\n\n* rewrite  capture-regex  dst-path  flag;  flag可选，但我试了不填效果不确定，建议填上\n\n对flag的选择不同会有少许区别。一种是用redirect或permanent返回给浏览器新地址，由浏览器重新请求，另一种用last或break由nginx在内部完成地址重写。前者适合网站域名迁移，通过HTTP 301/302通知搜索引擎进行域名更新。如果只是网站内的地址重写，最好还是用last或break。要理解这两者的区别，要明白地址重写后，并不会立刻进入下一阶段，而是把重写后的地址，作为源，继续匹配别的location，直到没有可以匹配的时候，才进入下一阶段。break的作用，就是提前终止并立刻进入下一阶段，而last会继续匹配location。感觉last这个叫法不够直观。\n\n如果是首页重定向，匹配式必须写成`^/$`，完整匹配根路径，这样下次重新匹配时才不会又匹配上。\n\n访问限制\n\n使用allow和deny指令，要注意的是如果只想限制某些IP可以访问，用allow列举了所有可以访问的IP后，要加一句deny all;才行。另外deny all;和allow all;都加上的话，生效的还是deny。","modified":"20190408121530000","tags":"web"},
{"created":"20190413121530000","title":"网站性能测试","text":"\n14年5月我用PHP做了个公司网页，查询协议文档。今天用ab测了性能简直掉了下巴。\n\nlinux配置4核4G，Xeon E5-2680v3 2.5G。windows配置4核4G，i5-6500 3.2G。\n\n* 首页\n\n| 命令 | linux-qps | windows-qps |\n| ---- | ---- | ---- |\n|ab -n500 -c5 | 1340 | 194 |\n|ab -n500 -c1 | 381 | 111 |\n\n* 单表查询一条关键字\n\n| 命令 | linux-qps | windows-qps |\n| ---- | ---- | ---- |\n|ab -n500 -c5| 802 | 69 |\n|ab -n500 -c1| 155 | 46 |\n\n* 多表查询一条关键字\n\n| 命令 | linux-qps | windows-qps |\n| ---- | ---- | ---- |\n|ab -n500 -c5| 117 | 15 |\n|ab -n500 -c1| 31 | 14 |\n\n从上表数据看，先不谈语言或OS，讨论qps如果不说并发数是不严谨的。不过即使再上量，对这台linux的极限无法超过1500。","modified":"20190413121530000","tags":"web"},
{"created":"20190410121530000","title":"微服务的理解和实践","text":"\n大型系统由于业务复杂，理论上通过合理的约定，一个服务没问题，就像linux至今仍是宏内核。但大部分的团队没有自制力，只好强制拆分，使每个功能变小，互相之间通过消息传递，不再也无法知道其它服务的细节。\n\n在做两个网站项目，虽然规模不大，还是借公司项目尝试拆分，想以下原则\n\n# 变动和不变分离，比如第三方依赖库和包装类单独建一个工程，部署后要能做到lib/不改动。更新只替换jar\n# 同类型业务不拆分，打包进一个jar。如果要读写分离应该是一个服务内两个数据库连接来分离。具体一个jar放多少个业务，视情况而定\n# 服务间通过网络交互，不要共享数据库。原因依赖接口而不是依赖实现。服务间的地址通过独立服务共享，现阶段可以用nginx实现","modified":"20190410121530000","tags":"design"},
{"created":"20170914121530000","title":"为什么C语言的long类型长度不确定","text":"\nC语言的规范没有规定long必须是多长，只要求不小于int就可以。从我看到的情况int都是4字节，但long就有32/64两种长度。典型的像VC把long当成32字节，而Linux的GCC则把long当成64字节。\n\n造成这个差异的根本原因其实并不是编译器，因为今天意外地发现GCC在windows平台上是把long当成32字节，说明long长度不仅仅和编译器相关，那么为什么windows的long会是32字节呢？\n\n恰好昨天提交一个头文件，修改结构体定义BITMAPINFOHEADER中四个long类型为uint32，我查了下BITMAP的要求，明确说MUST BE 40bytes。但是这个结构体有10个字段，6个INT和4个LONG，而这个定义又是抄自windows.h的定义，说明当时在微软定义头文件的这个哥们就是把LONG当成UINT来用。没有看过所有头文件，也许那时所有人都认为32位已经足够用了。然而时至今日出现了64位，如果这时把LONG定义成64位，BITMAP头文件就不能和真实的文件匹配上了，必须让LONG保留32位，而且不仅微软自家编译器，是所有跑在windows平台的编译器都必须按32位来对待long。在Linux平台没有和文件格式强绑定的头文件定义，因此GCC就把long当成64位来处理了。\n\n由此可见头文件的定义，一旦落了地影响就无比深远，远到当初定下这个结构的人，都不曾预料到会演变成今天的情景。","modified":"20170914121530000","tags":"lang"},
{"created":"20160515121530000","title":"我对两种同步异步的认识","text":"\n网络编程中经常会遇到如上四个概念，网上也有很多讲解，我想讲一个\n至少是没有看到过的提法。\n\n先给我的认识：\n\n* 同步异步：针对的是函数调用者，即caller而言\n* 阻塞非阻塞：针对的是函数实现者，即callee而言\n\n先说阻塞非阻塞，落实到代码就一句话，文件句柄有没有设置过`NONBLOCK`。\n一旦设置了`NONBLOCK`，则耗时的网络操作就不会等待，立即返回。\n因此函数就不会**阻塞**在网络IO上。由于默认的文件句柄都是BLOCK，\n所以对这概念需要一点时间来理解。\n\n同步异步说的是业务层的一种逻辑做法，它的前提就是函数区分了阻塞和非阻塞。\n由于函数的实现有了阻塞和非阻塞的区分，一旦调用非阻塞函数，\n看起来函数是返回了，但结果却还在网络的另一端，此时有两种做法：\n\n# 等着消息返回，不停地查询IO结果，等结果出来了流程再继续走下去\n# 先做别的事，等消息返回了再回过头来处理这个非阻塞的消息\n\n1的做法，是同步，而2的做法，则是异步。\n\n从上面可以看出，由于调用阻塞函数只能等待，因此一定是同步调用。\n只有非阻塞函数才会出现同步和异步两种情况。虽然理论上非阻塞函数\n可以按同步的方法做逻辑，但这样一来就与调用阻塞函数没有区别，\n体现不出非阻塞函数的优点，因此实际运用时，\n非阻塞函数通常都是按异步模式来处理。\n\n异步模式最明显的风格就是设置回调函数，原因很明显：因为不知道什么时候\n非阻塞函数会返回，所以只能把一个callback函数往下设，由下层来回调这个函数。\n由于这种写法不符合普通人的逻辑，因此异步的逻辑很不好写。\n也有人会将非阻塞函数按同步的逻辑来写，就是常说的异步转同步，\n其实我倒觉得更严谨的说法，是同步地调用非阻塞函数，更准确。\n\n另外针对回调函数不直观的做法，业界也有诸如coroutine，promise等方案，\n可以做到看上去像同步的写法，但实质上并不会导致CPU空转的做法，\n这块还没研究透，就先不铺开了。\n\n再说说同步回调和异步回调\n\n程序中经常会遇到钩子函数和回调，这里就引申出回调函数何时执行的问题。一个函数最终都会在确定的线程中执行，先考虑触发形式的回调，执行触发逻辑的线程，和回调函数执行线程是否在同一个线程，就分为了同步回调和异步回调两种类型。\n\n同步回调方式，比如外部触发一个notify，所有注册的回调函数就会在notify的内部依次执行，所有都执行结束notify才会返回。坏处是notify可能会等待很久，但是逻辑非常清楚，调用者可以很确定地知道注册的回调业务执行完毕，在notify之后可以放心地做其它工作。\n\n与之相对应的是异步回调，这时触发notify可以很快返回，然后另一个线程就会被唤醒，但因为另一个线程什么时候开始执行，更重要的是什么时候结束是完全无法预测的，导致notify之后业务状态不确定，很多的复杂逻辑是无法开展的。\n\n这两种回调，在公司代码中都有体现，其中异步回调是网络框架的Close和`handle_close`，这也是一个初学者经常犯错误的地方，由于Close之后什么时候执行`handle_close`未知，也就不能在Close之后对NetHandler做任何操作，一旦赋值或delete就很容易招来死机。同步回调则是上层的事件中心notify，触发事件后，把所有注册函数执行完才返回，从调用者来看，notify之后，至少业务是完了状态，不过回调函数的成功或失败状态无法返回，不过到底要不要返回，似乎也无必要。\n\n至于定时回调，比较多的是有个独立线程进行异步回调。但也有单线程模式下在同一个线程内回调，如果业务执行得比较久，定时器的精度会比较成问题。","modified":"20160515121530000","tags":"design"},
{"created":"20171023121530000","title":"我国省份行政编码规则","text":"\n每个人身份证的前两位(企业则是社会信用代码)表示省份，比如上海是31，北京是11。省、地、市县这三级行政区划代码，从1982年到2007年，有专门的国标2260定义，期间修订10个版本，后来可能觉得修订太频繁，由标准改为民政部每年发布一份文件。省份的编码其实很有规律，试着发掘一下。\n\n省份是按区域大致划分的，从首都为中心按顺时针排布。北京作为首都自然排在首位，代码11，然后就是天津河北山西内蒙，这些省有个很熟悉的名字：晋察冀，至于内蒙大约和河北地缘较近，也被归类到中心区。\n\n中心区顺时针开始第一个片区是东三省，辽吉黑从21到23，耳熟能详了。接下来是华东六省一市，上海31领衔，后跟江苏浙江安徽福建江西山东，后面几个省的顺序比较杂乱，也没有明白排列顺序是什么。\n\n时针走到下方，则是湖广地块，包括湖北湖南广东广西海南，河南也归在这个片区，可能实在不好归类只能放在湖广区了，不过可能是作为弥补给了河南41的代号。湖广再往西就来到了云贵，包括重庆四川贵州云南西藏，藏民有很多住在四川，归入这个区很自然，这个区有点特殊的是重庆的代号是50，其它区第一个都是1，只有重庆是0，原因也很简单因为重庆成立直辖市晚于省份代号制定年份，又是直辖市，只好放在原来51的四川前面。\n\n最后来到以6开头的西北，陕西甘肃青海宁夏新疆，陕西和甘肃古有陕甘道，且李唐的关陇集团就是以陕西为中心，陕西和山西虽然听着近，但中间隔着太行山潼关，陕西自战国时代就秦朝的属地，所以还是划入西北片区。\n\n民政部官网上可以查到每个自然年的到市县的行政区划代码，省地市每级2位数字，共6位。同时也会把变动的乡镇街道编码公布出来，但不会公布全部的乡镇街道编码。乡镇街道会按类型划分，比如街道是0，镇是1，乡是2，还有些林场、开发区、农场也属于这一级。再往下的村和社区没有找到网上有可查的地方，乡镇和村社每级是3位数字，所以完整的到编码共12位。","modified":"20171023121530000","tags":"think"},
{"created":"20160621121530000","title":"我理解的面向对象设计原则","text":"\n面向对象的程序设计和面向对象的程序语言，两者并不完全一样。\n面向对象的程序设计是一系列原则，是指导思想；而面向对象的语言，则是把这些原则和思想，用一些规范化的语法给规定下来。\n\n初学面向对象时，教科书都会提三大概念：封装、继承、多态。\n但是我的理解，这里面只有多态才是面向对象的核心观念，继承分接口继承和实现继承，接口继承勉强算是，实现继承则不算。\n而封装更是和面向对象关系不大。\n\n!! 面向对象设计的几条重要设计原则\n\n* 开闭原则(Open-Close-Principle)\n* 里氏替换原则(Liskov Substitution Principle)\n* 依赖倒置原则(Dependence Inversion Principle)\n\n除了这三条还有许多，但我觉得这些就够了。这其中最原则性的，就是开闭原则。即**软件要对扩展开放，对修改封闭**。我对这句话的解读是：**当你修改了代码并替换后，其它的使用者是感知不到的。**\n上面这个例子中的开放，就是对代码做修改；而封闭，就是使用者感知不到。在《松本行弘的程序世界》和陈天的《谈谈编程思想》中，也都认为OCP是最根本、最基础的原则。\n\n从刚才的说明来看，就是在交互的双方之间，要保持接口的一致性。好的接口不是泛泛而谈功能，\n不是任意地扩展参数，而是在屏蔽细节的基础上，完成具体而明确的行为。比如接口是阻塞或是非阻塞的，出现错误时是返回错误码还是抛异常，这些都是要明确的，而接口的大O值是O(N)或O(logN)，则是偏重实现层面。\n其它的里氏替换原则说的是怎么界定基类和子类，依赖倒置则是说细节要依赖于抽象，抽象不应依赖于细节。相比之下都是更具体的操作手法。\n\n因此只要能实现OCP原则的语言，就完成了最核心的功能，都可以称之为OO语言。\nC++实现OCP的机制是多态，但多态从语法层面是强依赖于继承的，而C++的继承又只有实现继承，\n因此多数人会自然地关注类的特性，偏偏C++的类有public、protected、private关键字，且非常直观易懂，导致很多人在入门的时候\n把认知的重心放在封装上。加上对象二字又和现实世界中的具体的实体对应，\n这又强化了面向对象即封装的认识。其实很多动态语言，根本没有提供封装的语法关键字，但不妨碍很优雅地实现OCP。\n\n很多教科书在讲授面向对象时，都用鸟能飞，于是继承自鸟的子类大雁也能飞，但一碰到企鹅就傻眼了。\n我反倒奇怪，为什么很少有教科书拿Duck Typing作例子，如果一种东西能飞，\n那它就是一只抽象的鸟，即便它其实是飞机，又有什么关系呢，反正它满足了我们对于飞的期望，而且比鸟飞得更好。\n\n以上讲了面向对象中最核心的概念是开闭原则，接下来结合我的经历说说这个原则的具体应用。\n\n先说句题外话，在面向对象思想发展之前，讨论更多的是结构化编程思想。\n今天已经很少有人提了，但是并不代表结构化编程思想过时，而是两者的出现时代，要解决的问题不同。\n结构化编程的年代，代码规模还很小，也没有什么代码规范，更多的时候都是用汇编甚至机器码写程序，因此怎么抽象机器，\n怎么规范化地表达程序，是当时重点要解决的问题。而随着结构化思想被众人接受，程序规范化提高，\n给大规模编程提供了基础设施，使得多人合作完成程序成为可能。这时怎样更好地配合，怎样使软件更稳定，成为了那个时代的痛点(今天依然是)。当人们为解决这些问题时，才催生了面向对象思想。\n\n因为多人配合，互相之间不会去关注对方的实现细节，这时接口就成了联系的纽带。要让这个纽带好用，就要满足开闭原则所说的对扩展开放，对修改封闭。\n\n比如一开始有这样一个接口：`int getVersion(void* ver);`。\n这个接口被定下来的时候，ver指针指向的真实内容是`char*`，\n一段类似\"2.1.11.3.R\"这样的字符串。为什么要用`void*`而不是`char*`呢？\n据说是制定的时候为了扩展性，因为`void*`可以转换成任何类型嘛。\n\n果然没过多久，需求就来了，原始版本只能表示软件版本号，\n可现在需求要SVN版本号，怎么办，扩展呗。把参数改成\n\n```\nstruct Version{\n  const char* softVer;\n  uint32_t svnVer;\n};\n```\n\n因为结构体的第一个字段也是`char*`，所以不影响即有代码。而且能通过`void*`强制转换得到想要的结果。看，当初使用`void*`多么明智啊。\n\n可是这样真的对吗，是不是还漏考虑了另一种情况，即使用者已经按struct来使用了，可是因为一些原因，\n提供实现的人也许漏实现了或者提供错了版本，这时svnVer尽管也能取到值，可是这个值所指向的内存，根本不是期望的内容啊。\n更正确的做法，是一开始就把接口定义成`int getVersion(struct Version * ver);`结构体的定义类似\n\n```\nstruct Version{\n  const char* softVer;\n  int resv[3];\n};\n```\n\n则使用者在扩展后，即使库没有更新，因为取到的内存值就是0。而0显然是个非法的SVN版本号，使用者可以因此做到区分。\n\n那么是不是增加保留位就可以了呢？不够，如何正确地扩展保留位，也是有技巧的。考虑这样一个场景：原来的产品都有NAT穿透功能，\n因为产品细分做CostDown，为了做到市场区分，部分产品从软件层面屏蔽了该功能。可是界面需要根据是否有NAT来配置界面啊，那就继续扩展吧。\n增加一个`int8_t hasNAT`？可是这样就不对了。因为原来的产品其实是有NAT的，按hasNAT的意思，原有产品都得修改代码这样，这就增加了无谓的工作量，\n所以正确的扩展应该是noNAT，这样才是对修改关闭的。说来简单的一个小技巧，可从我的经历来看，却很少有人注意到。\n\n在我刚工作不久的时候，我的主管和我说：在做大型项目的时候，一定要有面向对象思想。\n那时我的对面向对象还停留在类、封装这些概念上，并没有体会出面向对象在大型项目里有什么应用，今天想来，也许就是想说在大型项目中接口的重要程度吧。","modified":"20160621121530000","tags":"design"},
{"created":"20180710121530000","title":"我司组件化的优劣","text":"\n!! 类型剖析\n\n组件化在不同的领域有不同的含义，应用在远程管理相机这个领域，最大的优点是两条，生命周期管理和RPC访问。相对较弱的还有弱链接，但这更多的是实现后的副产物，可能不是一开始的设计初衷。\n\n组件化的入口是用getComponentInstance方法得到组件对象，从这里开始介绍吧。这个函数返回一个TComPtr的泛型指针，刚才提到要管理生命周期，因此TComPtr一定要具备智能指针功能，另外还要支持RPC，要持有一个代表远程连接的标识。看TComPtr的内部，确实是一个泛型的`T*`和一个`IClient*`成员。先说智能指针，最简单的方式是引用计数，从刚才的叙述来看，没有保存int变量，但是实现又有AddRef之类的操作，其实是要求`T*`能支持计数。也就说明T不能是普通的类型，必须是IUnknown类型。\n\nIUnknown定义了destroy虚接口，内部持有计数变量，和其它是否instance、cid等，先不管它。TComPtr控制这个变量并在计数到0时进行回收，但是计数的智能指针应该是在一体的，却被生生地分开，我觉得是第一个违反直觉的地方。\n\n再来看IClient管理远程连接，在RPC上，继承了IUnknown的具体的业务指针只处理参数和协议间的转换，并没有接触到相机，协议要通过IClient发送给相机。因此业务类必须要持有IClient的指针。从层级上，这三者应该是TComPtr`>`IUnknown`>`IClient关系，实际却是后两者成平级关系。\n\n!! 客户端使用者角度\n\n使用一个远程组件，有三个要素，做什么，怎么做，向谁做。做什么又叫iid，在定义类型的时候强制实现了。怎么做叫clsid，每个继承IUnknown的类一定要实现，且不能相同，否则就会互相覆盖。向谁做取决于ServerInfo或者uid，会保存在IClient里。ServerInfo通常是第一次连接一台设备，一旦连接成功并构造出IClient后，就能从这个IClient得到uid，以后再用uid就能得到同一个IClient对象。使用者可以从代表一个功能的TComPtr取到连接，并构造同一连接上的不同功能TComPtr。\n\n!! 客户端实现者角度\n\n分两个方向考虑，继承IClient的代码，负责登陆。继承IUnknown的业务代码（多种多样），负责将参数转成协议或反之。这两者只有在取组件的那一刻，getComponentInstance才会带来ServerInfo或uid，业务代码必须要利用此机会，在构造中保存uid（最好映射成IClient句柄）。\n\n!! 服务端实现者角度\n\n服务端可以认为没有使用者。也不关心IClient，无非是继承业务定义的I接口，并实现它。所以对大多数只负责实现嵌入式设备功能的开发而言，上面提的几乎不会去接触。","modified":"20180710121530000","tags":"design"},
{"created":"20170305121530000","title":"系统性能分析的理解","text":"\n曾经以为性能分析一定要用看起来很高深的工具，实际上重点还是在于对系统各个方面的理解。对《性能之巅》观测指标做个分类，分为软件和硬件，软件类包含操作系统、文件系统和进程，而硬件包含CPU、内存、磁盘和网络。\n\n!! 进程状态\n\nps会显示多种状态\n\n* S 可中断睡眠，可以被外部信号或内核唤醒，比如网络等待\n* D 不可中断睡眠，只能被内核唤醒，比如读写磁盘，虽然不占CPU但占着其它硬件，且必须一直拿着这个硬件，否则会导致硬件损坏\n* T或Z 停止或僵尸\n\n另有几种文档说BSD状态，但好像也会显示\n\n* \u003C和N 高低优先级\n* s session leader\n* l 多线程\n* \\+ 前台进程组，不理解，似乎不重要\n\n!! CPU\n\n最粗略的观察通过uptime和top，看变化趋势和整体分布，要注意的是load和usage是不是维度的度量，两者甚至可能出现很大的偏差。因为load统计可以大体等同于R和D状态的进程总数，表示运行中的进程数，但是D状态不会占用usage，所以如果出现有大量读磁盘的进程时，load会明显高于usage；理论上猜测（没有遇到过），当进程数较少，但某些进程使用多核计算，会出现usage高于load的情况。\n\nCPU的计时分了很多状态:  usr, sys, nic,  idle,  io(wa),   irq(hi),   sirq(si)\n\nusr、sys和nic是某个进程的耗时，nic是低优先级(1~19)进程的用户态耗时，而io、irq计算整个系统的耗时，类似于公摊，不计入进程耗时。进程还要观察上下文切换，也会导致CPU过高。\n\n!! 内存\n\n内存首先分为物理内存和虚拟内存（swap分区）。\n\n内存有cache和buffer。buffer对应block device，比如文件系统的MetaData，量并不大，知道就好不用太关注。\n\ncache比较重要，它表示程序曾经往Disk写入的数据，除非系统判断内存不足，不会去清理cache，所以经常看起来很大，但不必担心。\n\nps有个-o选项，可以输出非常多的信息，说说内存。\n\n* rss，resident set size，表示常驻物理内存的大小。这里有个要注意的，在计算so共享库的时候，会全部计算进去，实际上so的多存往往是多个进程共用，对系统的占用并没有表面上来得严重。累计了CODE段和DATA段的总大小。用pss做总和才是正确的值，p表示比例，共享的内存按比例均分。\n* sz，比rss大\n* vsz，虚拟内存，最大。等于swap和rss总和。\n\n另有pss(proportional set size)是将so内存按比例统计，对每个进程来说更准确。uss则完全不计入so内存。\n\npmap可以给出更细的检测报告，每个so库的每种段，堆和栈占用多少内存全部统计分明。\n\n内存在系统中有4种状态\n\n# 未载入(不用关心)\n# 已载入，但未映射\n# 已载入，且已映射\n# 已载入，但被换到虚拟内存\n\n通过工具看到最多的，3代表常驻内存RSS，2,3,4合起来又名VSS\n\n监测可以针对系统级进程。监测的原理分为计数器和跟踪，另外profile也有，但使用面会窄些。\n\n* 计数器方式：由于内核本就维护各种统计数据，因此计数方式的采集可以认为是零开销。基于计数器方式有sysstat工具包，涵盖了一系列专项的工具，如pidstat/mpstat/iostat等。另外sar是system active report的简写，虽然没有stat但也是sysstat的一员。其它各自针对不同资源进行监测。还有一个procps-ng包，包括了vmstat/free/ps/top等经常会用到的工具，形成两大派别。netstat是早已有之，不在这两个派别内。\n* 跟踪方式：又叫事件，系统级典型如perf/systemtap，进程级有strace/gdb，基于系统事件方式的采样。找到哪个环节出问题，针对性的采集数据。Perf是Linux内核自带的性能监测工具，自2.6.31版开始引入所以发行版都会带这个功能。它配合内核的`perf_events_open`接口(也是perf惟一的接口)使用。而systemtap更像是CentOS专门的工具，默认不带要另外安装。\n\n!! 计数器方式\n\n计数器方式可以很快地看出系统的负载，最复杂的命令是sar，用sar -A可以看到所有数据，底层有sadc(采集数据)和sadf(输出格式化数据)支持。再说几个工具的特性。\n\niostat可以监视IO(-d)和CPU(-c)，类似的top命令观测CPU时也有iowait指标，也体现了IO的度量，IO不仅受磁盘影响，也会影响CPU的使用率。\n\npidstat从名字可以看出，用于找出问题出在哪个进程，指标包括IO，内存缺页，栈的使用大小。\n\n!! 跟踪方式\n\n2.5版本内核支持了ftrace特性，并以tracefs文件系统方式展现给用户。如果打开了该特性，可以在/proc/mounts查找tracefs的挂载点，并切换到root（sudo不行！）进入该目录（一般是/sys/kernel/debug/tracing/）。既然是类文件系统，通过修改文件来打开跟踪和观察。这种方式操作不友好，trace-cmd包可以简化一些。ftrace的实现依赖于内核在gcc编译阶段留的桩，编译内核的参数缺省会用\"-pg -mfentry -mrecord-mcount\"，前两个参数给每个函数开头插入5个字节的callq指令，而最后一个参数则在vmlinuz的`mcount_loc`段记录了所有内核函数的地址。但是所有函数都留桩显然开销太大（下降13%），所以ftrace在内核启动时会callq指令替换成nop指令。当用户对特定函数开启了追踪，用callq替换nop，将追踪信息写入ring buffer输出给用户。\n\n2.6版本出现了perf，因为ftrace只管抓trace数据并没有分析，perf在trace数据分析方面做出了很多成果。在trace数据采集方面，perf复用了ftrace的所有插桩点，并且加入了采样法(硬件PMU)。PMU是一种非常重要的数据采集方法，因为它大部分是硬件的，所以可以做到一些软件做不到的事情，获取到一些底层硬件的信息。\n\n> PMU是什么：像L1 cache失效、分支预测失败等几种处理器特性对软件的性能有很大的影响，然而依赖时钟进行定期采样的 profiler 模式无法揭示程序对这些处理器硬件特性的使用情况。处理器厂商针对这种情况，在硬件中加入了 PMU 单元，即 performance monitor unit。PMU 允许软件针对某种硬件事件设置 counter，此后处理器便开始统计该事件的发生次数，当发生的次数超过 counter 内设置的值后，便产生中断。比如 cache miss 达到某个值后，PMU 便能产生相应的中断。捕获这些中断，便可以考察程序对这些硬件特性的利用效率了。\n\nBPF源于1992年的Berkeley Packet Filter论文，触发Linux社区在97年也跟进并实现了Linux Socket Filter机制，但长久以来只有tcpdump这个应用。BPF原理如下图。经网卡驱动层的报文在上报给协议栈的同时会多出一路来传送给BPF，再经后者过滤后最终拷贝给用户态的应用。除开tcpdump，当时的 RARP 协议也可以利用 BPF 工作(Linux 2.2  起，内核开始提供 rarp 功能，因此如今的 RARP 已经不再需要 BPF 了)\n\n![bpf-germ](/img/bpf-germ.jpg)\n\n其中的filter是类似汇编码的指令，为了防止注入，对BPF的指令做了很多数量和长度的限制。由于内核态开销大，3.x时代出现了JIT for BPF，2013年对BPF做了彻底重写，命名为eBPF，最终在3.17时代进化出全新的eBPF，并持续发展了seccomp、XDP、traffic control等机制。","modified":"20170305121530000","tags":"os"},
{"created":"20210211121530000","title":"线程模型与调度","text":"\n共有3种线程模型，以x:y命名，即x个用户线程对应y个内核调度实体(Kernel Scheduling Entity，这个是内核分配CPU的对象单位)。\n\n# 多对一(M:1)的用户级线程模型。似乎没有实现，缺点在于：多线程并发执行，如果一个线程执行阻塞的IO操作，内核接管这个操作，用户态的其他线程都会被阻塞，因为这些线程都对应同一个内核调度实体。这时内核不知道用户态有多线程，无法把它们调度到其他处理器，也无法通过优先级来调度。这种模型只在单核处理器上有一定意义。\n# 一对一(1:1)的内核级线程模型。典型的是POSIX的pthread，每个用户线程都对应各自的内核调度实体。由内核来调度的结果就是：线程的每次操作会在用户态和内核态切换，影响速度。另外如果出现大量线程，会在内核分配同等数量的线程调度实体，影响系统性能。\n# 多对多(M:N)的两级线程模型。典型的是golang的协程调度，结合了1：1和M：1的优点，每个线程可以拥有多个调度实体，也可以多个线程对应一个调度实体。但这种模型的线程调度，必须由内核态和用户态一起来实现，典型如go语言在1.2版本后内嵌支持了（1.1时代是1：1模型）。因为当多个对象操作一个资源时，肯定要有同步机制，用户态和内核态的分工合作导致实现该模型非常复杂。Linux的第二代模型NGPT用了多对多模型，但性能上仍输给了使用一对一模型的第三代NPTL。（其实NPTL曾经也想使用M:N，但因为太复杂，且要对内核进行大范围改动，最终还是用了一对一）。\n\n!! golang调度\n\nGo的调度器内部有三个重要的结构：M，P，G\n\n* M是对内核级线程的封装，数量对应真实的CPU数，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息\n* P全称是Processor，它处理的是协程与队列，用于执行goroutine的。每个Processor对象都拥有一个LRQ（Local Run Queue），未分配的Goroutine对象保存在GRQ（Global Run Queue ）中，等待分配给某一个P的LRQ中，每个LRQ里面包含若干个用户创建的Goroutine对象。\n* G代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。\n\nGolang采用M:N线程模型，对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。\n\n这张图是正在运行中的状态，有2个物理线程M，每一个M被一个处理器P管理，每一个P也都有一个正在运行的goroutine（蓝色），灰色的那些goroutine并没有运行，而是处于等待被调度的ready就绪态。P维护着这个队列（称之为runqueue）。\n\n![go-runtime-state](img/gorun1.jpg)\n\nP的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出一个goroutine执行。\n\n当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。\n\n![go-runtime-block](img/gorun2.jpg)\n\n当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。\n\n另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很闲，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里拿任务的话，会拿run queue的一半，这就确保了每个OS线程都能充分的使用，如下图：\n\n![go-runtime-schedule](img/gorun3.jpg)\n\n!! MPG相关QA\n\n# M和P的数量如何确定？何时会创建M和P？\n\n    a) P的数量由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定（默认是1）。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。\n\n    b) M的数量受go语言本身的限制，go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。\nruntime/debug中的SetMaxThreads函数，设置M的最大数量。一个M阻塞了，会创建新的M。\n\n    c) M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。\n\n    d) P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。\n\n    e) M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。\n\n# M选择哪一个P关联？什么时候会切换P与M的关联关系？\n\n    M会关联到创建了这个M的那个P。当M因系统调用而阻塞时（M上运行的G进入了系统调用的时候），M与P会分开，如果此时P的就绪队列中还有任务，P就会去关联一个空闲的M，或者创建一个M进行关联。（也就是说go不是像libtask一样处理IO阻塞的？不确定。）\n\n# 就绪的G如何选择进入哪个P的就绪队列？\n\n    默认情况下：P的数量是1（M不一定是1），所以如果我们不改变GOMAXPROCS，无论我们在程序中用go语句创建多少个goroutine，它们都只会被塞入同一个P的就绪队列中。\n\n    有多个P的情况下：如果修改了GOMAXPROCS或者调用了runtime.GOMAXPROCS，运行时系统会把所有的G均匀的分布在各个P的就绪队列中。\n\n# 如何保证每个P的就绪队列中都会有G\n\n    如果一个P的就绪队列所有任务都执行完了，那么P会尝试从其他P的就绪队列中取出一部分到自己的就绪队列中，保证每个P都有任务可以执行。\n\n!! Erlang的调度\n\nBEAM的调度模式在2006从单线程切换到多线程（最早在1998年由一个硕士着手研究），有点类似go的MG模型，没有P。相比go的原生调度，由于BEAM是虚拟机形态，调度灵活程度更高。\n\n在BEAM中，除了process之外，还有3种调度单位：端口（ports）、链入式驱动（linkd-in drivers）和系统级活动（system level activities）。这三种特殊的任务形式主要用来进行IO操作和执行其他语言的代码等功能。\n\n!! Go和Erlang的比较\n\ngo是协作式调度，除非进入内核阻塞态，协程一直运行，这和它native的实现有一定关系。而erlang是轮转调度，分了4个优先级，基于VM机制可以抢占。","modified":"20210211121530000","tags":"os"},
{"created":"20180819121530000","title":"消息队列理解","text":"\n为了实现观察者模式提供的一种中间件，串接起生产者和消费者两端。不同的场景要选择合适的实现。RabbitMQ有6种工作模式，也有Exchange,Binding,Queue,RouteKey等很多概念，适用于业务复杂场景。Kafka只有topic和partition，因此吞吐量大，但业务就需要使用者手动处理。\n\n!! RabbitMQ的模式\n\n6种模式分别为Hello world、Work queues（工作队列）、Publish/Subscribe（发布订阅）、Routing（路由）、Topics（主题）、RPC（远程调用）。除了RPC模式外，其余的模式都是从简单的使用到更为灵活的使用。\n\nHello world和Work queues比较简。消费者声明一个队列（Queue）才能收消息，增加队列一方面可以把多个消费者合并，另外能多些特性，比如消息要不要持久化，要不要做排它性。\n\n最简单的投递，有了Queue消息就能贯通了。这种模式的Q和设备侧的事件定义很像，生产者指明要发给这个Q，不关心谁来收，需要这个Q的消费者去响应并做逻辑就行。\n\nPublish/Subscribe、Routing、Topics这几个模式都依赖Exchange，源于RabbitMQ遵循的AMQP规范不允许直接向Q投递，而引入的概念。Exchange有3种类型fanout,direct,topic,header，很像UDP的广播，单播，组播。\n\n* Publish/Subscribe模式: 对应fanout型exchange。最粗暴，全发送\n* Routing模式: 对应direct型exchange，必须严格匹配，简单的分类器\n* Topics模式: 对应topic型exchange，可以用通配符模糊地表示关联关系\n\n前两种直接发给Q的模式，用了名字是空串\"\"的一个特殊Exchange，后三种则必须指定Exchange名字。\n\nBinding是很简单的，虽然存在但很无脑。只有通配匹配，绑定的算法才变得重要起来。绑定是Exchange给消费者的提示，生产者需要给出RouteKey。所以即使同一个Exchange，投递的消费者可以千差万别，它的数量级也是最少的。\n\n!! RabbitMQ使用\n\n默认启动会有epmd监听4369端口和beam的25672。启用web插件后，只能用guest用户，再添加admin后，就能用15672端口进入web控制台。\n\n```\nrabbitmq-plugins enable rabbitmq_management\nrabbitmq-server\nrabbitmqctl add_user admin admin\nrabbitmqctl set_user_tags admin administrator\nrabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\nrabbitmqctl shutdown\n```\n\n!! RabbitMQ和Kafka的比较\n\nRabbitMQ的劣势\n\n# 在消息投递时必须由客户端指明IP，这就给无感横向扩展带来不便。\n# 默认没有分区机制，虽然官方有个sharding插件，但似乎用得不多\n# 只有主备，类似副本机制\n\nKafka的劣势\n\n# 由于Kafka每条消息都会写磁盘，当topic数量变多后，并发多进程的随机写入会导致性能会急剧下降，RabbitMQ大多数情况把消息保存在内存，不会有此问题\n\n为了从MQ迁移到kafka，在MQ协议中引入了分区概念。\n","modified":"20180819121530000","tags":"tool"},
{"created":"20180129121530000","title":"小鲜4刷机反思","text":"\n上周买了一个安卓机，事先查好各种资料确定可以刷机才下的订单。然后到手后足足用了5天才线刷成功。\n\n第一天徒劳无功地反复操作软件、装驱动各种瞎折腾没有任何收获，虽然当天快12点换了win10系统，但仍然不成功。但大概知道原因出在数字驱动签名。\n\n第二天查阅数字驱动的关闭方法，按照网上最多的说明通过重启方式进入，但因为系统原因找不到这个菜单，仍然是换win10可以，即使这样也没有进展。倒是知道还能通过组策略gpedit方式关闭，不过并没有任何帮助。这一天至少刷机时MTK的红色刷机条能走完，查看了资料知道是一个叫Download Agent的程序写入CPU的RAM，但是数据还是无法写入Flash。\n\n连续两天折腾下来也比较心累了，估摸着换win7会好一点，第三天没有刷。\n\n第四天找到一台win7电脑，装驱动的时候确实提示无视数字签名，感觉离成功近了一点，但最后仍然提示驱动安装失败，仍然无果。\n\n第五天，既然三个系统都试过，只好静下心来反思每个步骤，在安装驱动的最后失败界面，系统提示文件无法找到。以前从来不在意这个提示，走投无路之下用这个作为关键字搜索，竟有意外收获，网上有一篇很详细的介绍，还附带了两个安装包。其中一个显示是win7用，安装失败，但另一个成功了，结果到了最后一步还是提示缺少inf文件。介绍文章也用的是win8，和我的一样，有些气馁。但想想都走到这一步了，不妨再试试win10，竟然非常顺利地插上线就开始写Flash了！问题找到就是驱动不对。5分钟后刷机成功，系统得到root权限。\n\n反思这个问题，如果第二天结束的时候能仔细留心提示的错误信息，用搜索引擎显然是能找到正确的解法的，只怪当时没有沉下心来找原因，只想着换系统，直到山穷水尽才发现其实路早已在那里。不过可惜的是主力机win8一直都不能成功，可能和系统文件有缺失有一定关系，刷机已结束，教训也有了，就不再尝试了。\n\n4月补记，拿到一台xplay3s，root过程也不平坦。\n\n先用教程一的方式，用PC端工具写入recovery，再导入root.apk包，这个包含有su和授权管理程序。但不知道是fastboot未解锁或其它原因，recovery没有写入，可想而知用官方recovery写入root.apk遇到签名失败问题，此路不通。\n\n教程二提供了adb的命令行方式写入recovery方式，但执行过程遇到无法找到su错误。再看教程介绍，要先用一键root工具。结果工具root不成，反而装上了kingroot和另一个垃圾软件，而且这两个垃圾软件还不能卸载！说明安卓一定有机制允许未root设备向只读分区写文件，又有一种可能就是su被暂时写入tmp分区，从而实现apk写入只读分区。其实当时我并没有想到这个问题，只是抱着试一试的心态又点击了一次adb写recovery。重新进入recovery模式后，发现居然已经烧写成功了，而且大量的垃圾软件已删除一空，包括kingroot也没有了，但另一个附带的垃圾软件还驻留着。\n\n到这一步毕竟比出厂情况要好太多，接下来就是下载第三方已经集成好root的安装包，重新完整写入就获得干净的系统了。","modified":"20180129121530000","tags":"os"},
{"created":"20190817121530000","title":"协程剖析","text":"\n协程的历史很早，随着非阻塞(NonBlock)操作的日渐普遍，每一次非阻塞指令都配套回调，代码可读性很差，于是协程就重新被人捡起。\n\n分为有栈协程和无栈协程俩种，区别在于是否有自己的调用栈来进行函数调用等操作。\n\n!! 有栈协程\n\n有栈协程这里的做法比较好理解, 一般来说有俩种做法:\n\n# 采用操作系统提供的api 类似 ucontext 或者 setjump longjump\n# 用汇编操控寄存器保存状态\n\n!! 无栈协程\n\n从上面例子看出，用了OS自带函数做所有寄存器(EIP)和栈上变量的保存恢复，故名有栈协议。 下面给一个C语言实现的模拟操作\n\n```\nvoid coro_func(int& step) {\n  switch (step) {\n    case -1:\n      if (step) {\n      terminate_coroutine:\n        step = -1;\n        goto bail_out_of_coroutine;\n      bail_out_of_coroutine:\n        break;\n      }\n      else\n    case 0:\n      worker(1);\n      for (step = 1; ;) {\n        if (step == 0) {\n    case 1:\n      break;\n        }\n        goto bail_out_of_coroutine;\n      }\n      worker(2);\n      for (step = 2; ;) {\n        if (step == 0) {\n    case 2:\n      break;\n        }\n        goto bail_out_of_coroutine;\n      }\n  }\n}\n```\n\n可以看出，把阻塞操作拆成两步，在执行完NonBlock后更新步进值并退出，下次自然就能回到上次的点继续。不依赖系统调用。\n\n以下是其他人用Python实现的无栈协程\n\n无栈协程的实现, 要几个条件:\n\n# 栈帧内保存的不是状态而是指向状态的指针\n# 所有帧的状态保存在堆上\n\n为什么说第二点比较重要, 因为理解了第二点就发现, 其实根本不需要上下文切换, 因为全局的上下文就没变过, 改变他们的调用关系就行(栈)\n\n!! 区别\n\n有栈协程可以随意的切换, 因为他所有状态都在他协程内部, 并且可以并行 , 存在中间状态比如寄存器的计算结果啥的, 切换要很小心, 但是粒度更细。无栈协程只能手动切换, 不过效率要高, 不用管复杂的寄存器状态, 切换的控制权也在用户手中\n\n!! 对称和非对称\n\n用yield/resume风格实现流程切换，叫非对称协程。在让出运行权后并不知道接下来是谁运行。\n\n还有一种对称协程，类似 `f() { core.transfer(g) }`，在函数f运行过程中直接切换到函数g上，但是这种方式写出的代码破坏了模块性，要关心外部的运行流程很难维护。因此目前能见到的协程实现都是非对称。","modified":"20190817121530000","tags":"os"},
{"created":"20160815121530000","title":"协议工作该如何演进","text":"\n协议岗位作为职能部门，工作本身不容易出彩。出了问题会被追责，做得好无非就是不出问题，但不出问题这个标准在组织内部是没有意义的。\n\n曾经有比较理想化的言论，协议就像法律，但事实上迫于现场的压力或者设备以出货等名义，妥协是难以避免的。除此之外日常工作中的扯皮、认识不对等造成的心力损耗更是难以承受。\n\n首先要尽可能地团结友方的力量，协议分为服务器端和Web及NetSDK两个客户端，Web隶属产品线且经常被界面牵着鼻子走，通常很难想到一起，但服务端和NetSDK作为同在一个楼层的兄弟团队，想法利益往往一致。两种客户端因为服务对象不同，协议风格会产生差异。\n\n目前的想法还是要区分Web协议和NetSDK协议，往往Web先定义一套协议，到NetSDK实现时，视情况做一层桥接，不把Web协议直接暴露给NetSDK，而是由服务端调整成更纯粹的协议，实现上可以迁就Web。因此必须要有一支能调动肯拼搏的服务端实现团队作为支撑，否则难以落地。","modified":"20160815121530000","tags":"protocol"},
{"created":"20170424121530000","title":"协议是什么，要定义什么","text":"\n!! 定义和期望\n\n每一个软件只要不是像HelloWorld那样纯入门性质的软件，它一定承载了某种功能，想让它完成某种功能就要有固定的格式，这种格式便是接口，如果网络化了又可以称之为协议。Unix时代的软件多是单机执行，也存在着格式的要求，比如grep就要求第一个参数是搜索关键词，第二个及以后是要搜索的文件名，缺少或者乱了都不行，到了网络时代因为传输的复杂性，接口的要求也愈加复杂，但本质都是对输入的一种约定。有了输入，则软件会按预设的行为给出结果，同样拿grep为例，它会将文件拆分成以行为单位，并将每行和给定关键词进行匹配，一旦匹配成功则输出这行的内容。至于正则表达式如何被编译，又如果匹配，使用者无需关心。\n\n同样的对于业务层协议，要定义一种业务的输入格式及反应行为的期望结果，至于背后的实现逻辑不需要也不应该在协议定义，当然如果我们对这块业务很熟悉，看到接口大致能推断出背后的逻辑是什么样的，当然这不是必须。\n\n比如大华的configManager.deleteFile协议，历史原因它是没有入参的，自然也无法知道到底删除什么文件，相应地就我们需要严格定义它的行为，比如让设备回到出厂状态，只要删除的文件让设备看起来是恢复出厂，这个协议目标就达到了。更进一步最好要规定出厂状态的指标，在做测试时更有依据。\n\n再比如有个需求要实现抽帧播放，可以保留I帧后的若干个P帧，也可以若干个I帧只保留1个。如果只是这样定义，似乎也没有问题。但是考虑到H264规范有一种特殊的P帧，比一般的P帧大且只依赖于I帧，这时按照若干个I帧回放1个的定义，对这种视频就应该是若干个I帧加重定位P帧中抽取一个。随着视频格式的不同，协议竟然要跟着变化，说明这样的定义没有触及更根本的东西。更好的定义就是以最少几秒看到一个视频切面来定义能观察到的行为，这种方式不依赖实现细节，协议才能稳定。\n\n!! 协议的层次\n\n对于分层OSI给出了七层模型，通常业务协议不需要如此复杂，传输层(TCP/UDP)\\+标识层\\+载荷就够了。通常TCP占主流，UDP更多的用在实时的音视频流或NAT中，标识层衔接了传输层和载荷，作用是指示分包、加密、校验和等功能，这一层要考虑不同客户端的便利性。载荷层负责描述业务内容，多为消息封装格式，常见的有XML或JSON，如果觉得文本格式浪费体积也有Protobuff或MsgPack这类Binary的消息封装。对于秒级的消息通信业务而言，消息大小、解析时间并不是瓶颈，我认为简单易懂且普及(JS天生支持使得在Web领域更是加分)的JSON是够用了。像Protobuff则是到了毫秒级的通信场景下才能发挥更大的作用。\n\n!! 协议设计的关联性原则\n\n比如登陆和是否支持静态/动态多连接在同一个交互里，现在看来就属于过耦合。因为登陆不意味着要取流，但由于多连接的存在，导致登陆的处理代码非常复杂。比如静态要建立所有的连接，如果是动态则必须把状态内化，以期在真正拉流时能确定设备的调性，可是这就把这个特性的周期延长了，理想的设计特性是用完即丢，从概念上尽量做到stateless为好。比如在真正开始取视频流时，在应答中告知客户端接下来的连接特性，客户端依此做反应，这个状态的周期就被约束在真正的取流过程。\n\n视频流协议的业界标准RTSP就是这样，先发请求信令并根据回复的地址/端口建立子连接，而公司的私有协议是先请求建立连接，再创建子连接，最后再发信令。虽然看起来建立连接必不可少，但发信令比起来显然更重要一些，既然更重要，就应该更放在前面，也许后一个看起来也很重要的操作，就可以省掉了。比如大华的P2P网络，实际的连接只有一个，创建一个子连接反而是一种累赘。所以尽量不要额外地假设一些条件，只要保证更高优先级的操作被更早更完整地处理掉。那些额外的假设条件最好要明确地写出来，以便让以后的人知道当环境改变时，可以毫不犹豫地对协议进行调整。\n\n!! 协议体系的自洽\n\n曾经和夏杰聊过，协议要能自圆其说。如果从更哲学的角度来理解，尼采有句描述：这个世界没有事实，只有诠释。即所有的现象都是诠释/解释，解释的方式可以有很多种，但是只有最具有说服力的解释，才能占得主流地位。大华协议也是对监控领域这个小世界的诠释，因此只有具备最好的解释性的协议，才能生存到最后。一个好的解释体系，根基有两件事，定义(或概念)和逻辑推演。没有体系内明确的定义(只要明确，不过度追求“正确”)，逻辑推演就是无本之木容易陷入诡辩和循环认证，没有正确的推演，衍生的结果往往会冲突。\n\n!! QA(17年6月初)\n\n# 协议的本质是什么，好的衡量标准(金线)是什么？\n* 协议是被网络化的接口，接口的本质是契约。即在什么样的规定前提下，通过什么样给定的输入，最终达成怎样的输出。衡量标准就是契约的定义，越详细越无歧义越好。至于扩展性的权重，是第二位甚至更靠后，大不了重新订一份新的契约就好了。\n# 大华协议有4千多条，粒度是什么或者说应该依据什么来制定协议？(此处是两个原始问题)\n* 有4千多条，就说明有4千多个应用场景，分别有不同的输入，有不同的期望输出。考虑到大华是个OEM导向的公司，光IPC一年软件版本能达到1万多个，4千并不多。至于粒度，对超过90%的定制协议，满足定制客户的使用场景就是好的协议。如果一定要说粒度，两件事，如果以普通消费者能够区分的差异度来区分协议。但也不要把从软件上可以归并的行为硬生生归在一起。我想到微信的例子，把小视频和拍照合并到一起后，我的母亲就再也不会用小视频了。(因为那个按键短按是拍照，长按是视频，母亲不会用长按这种操作方法)\n# 协议要包含哪些元素？\n* 同问题1，界定什么场景下用，输入和输出，这些要素是第一性的。至于其它request-ID，session-ID，就好比是合同中的签名，如果再有时间戳，相当于合同的有效期，就更好了。\n# RPC要定义哪些方法，如何让调用者更简单？比如做到RESTful风格。\n* 简单的定义要从理解角度看，如果用户懂业务背景，或者需求就是用户定制的，那么和定制需求完全契合的协议，就是最简单的。说实话RESTful风格未必就是简单，把一切都认为是资源的行为，然后基于资源的操作，这种思想适用于互联网，或者反过来说，正是基于互联网的基础设施，提出了RESTful。但不同的领域，未必都要按RESTful方式设计。让使用者最自然的使用方式，就是简单。这方面有很多理论，最少知识/最少惊奇原则。","modified":"20170424121530000","tags":"protocol"},
{"created":"20170329121530000","title":"协议为什么要分包","text":"\nTCP是流式传输协议，每次在传输就要告知对端一个这次数据的长度，否则在流上无从断句。像HTTP就有Content-Length字段用于标识包长度。但是公司的协议除了总长度，还有分包长度，比如数据超过32K后，每次只发送32K，这个特性有什么意义呢？\n\n这个特性和数据发送模型有关，公司协议是一条连接上可以并发地发送多条请求，即第一条请求的应答还没到，就可以发出第二个请求。HTTP则没有这个特性，HTTP的多请求利用同时创建多个TCP连接来实现。但是如果在一个连接上有多组请求应答，假设第一个应答有100K,第二个应答只有10字节，但是如果把第一个100K直接写入socket，再写入第二个10字节，则后面的10字节必须要等待100K发送完成才会继续发送，这对简单应答就很不利，所以强制将数据拆散32K,只要发送中途线程被调度到，就有机会把这10字节发出去，如此一来就可以尽早收到简短的回复包了。","modified":"20170329121530000","tags":"protocol"},
{"created":"20180612121530000","title":"写文件的一些特性","text":"\n先创建一个分区，方式如下\n\n* `dd if=/dev/zero of=./dummy count=204800` 创建一个普通文件，用file看类型是data\n* `mkfs.ext4 ./dummy` 会提示不是个block special device，是否要继续。选Y继续。将普通文件用ext4的方式格式化，进而可以挂载。block大小1K，每个inode管理约4个block。预留5%的block给root用户，journal占4096block。文件变成了filesystem data类型\n* `mount ./dummy /tmp/` 将block文件挂到指定目录\n\n磁盘满有空间满和inode用完两种情况。inode用完主要是小文件过多导致，此时空间是还有剩余的。一般跑服务器程序不会有这么多小文件，重点关注磁盘剩余空间。\n\n分别用fwrite和write测试连续256次写入一些数据。\n\n* 4K粒度，每次用3到9us，隔20次左右会突然有次达到30us，最大44us。\n* 8K粒度，每次用5到9us，但隔10次左右就会耗时增加，大约20略大us，最大78us。\n* 16K粒度，开始5us，到最后几次达到20us，突变时约30us，但有一次特别大，达到25ms。\n* 32K粒度，每次最少20us，后来到达150us。突变峰值32ms。\n\n当空间快占满时，写4K的速度几乎没有变化，10us左右，波动仍是30us。当写完后，每次写的时间仍然差不多，但100多次才出现2、3倍的小波动。\n\n用df看磁盘空间，当avail显示是0时，root仍然能继续写入一定量的数据，普通用户如果是0那就真不能写了。写空间从有到没有的一瞬间，会出现写入耗时的峰值，约是10us到10ms放大1000倍，在那之后写入速度基本就是个2到3us的恒定值。\n\n!! df和du查看磁盘区别\n\n这两个命令都能统计分区大小，原理不一样。df读磁盘的superblock分析空间和文件系统属性，而du是用stat系统调用遍历每个文件或目录，最后得到总和。因此速度要慢很多。","modified":"20180612121530000","tags":"os"},
{"created":"20170325121530000","title":"辛弃疾的青玉案赏析","text":"\n\u003Cpre>\n东风夜放花千树，更吹落，星如雨。\n宝马雕车香满路。\n凤萧声动，玉壶光转，一夜鱼龙舞。\n\n蛾儿雪柳黄金缕，笑语盈盈暗香去。\n众里寻他千百度。\n蓦然回首，那人却在，灯火阑珊处。\n\u003C/pre>\n这首词最为人熟知的是最后一句，但整首词其实非常有讲究。从后往前解读，最后一句不消多说，为了衬托寻找的那个她，先来个铺垫，于是有蛾儿雪柳黄金缕，这三个词都是女性饰物，泛指元宵节时街道上来来往往的女子，而且这些女子笑语盈盈而去，但作者却偏偏要寻找那个她，这里便是强烈的反差的对最后找到伊人的烘托。\n\n既然下半阙写人，上半阙便是写景。东风夜放花千树的**放**字用得极好，因风吹过而绽放的花便活灵活现起来，从更吹落星如雨到宝马雕车香满地，镜头从天下拉到地下，再经过凤萧声动，玉壶光转，一夜鱼龙舞的描写，开始将景向人的活动迁移，从而引出后面对人的描写。这样看下来，整首词的逻辑、顺序简直无可挑剔，在这么小的篇幅里把内容都写到，且过渡自然，不愧是名篇。","modified":"20170325121530000","tags":"think"},
{"created":"20150725121530000","title":"信息的价值与一篇机器学习文章读后感","text":"\n当媒体说互联网带来了知识的普及，这句话并没有全部说对。我一直就疑惑，\n虽然互联网上看似能搜索到很多东西，但是有两个问题：\n\n# 信息是谁放上去的，他出于什么样的利益放到网上？\n# 谁让你看到这些放上去的信息，你又怎么知道你看到的信息，就是全部的信息？\n\n先说1，在互联网出现以前，我们获取知识的途径可以买书，也可以去图书馆，\n但是不管怎么样，一定要有人来出版书。互联网的出现，\n简化的只是出版一篇文章的成本（注意是文章，而不是书）。\n你可能会问，为什么我能从网上搜索到这么多资料？早期借着互联网的东风，\n很多人无偿地贡献着各种次数，或者有人在blog上发表文章。这些行为的背后，\n一定是有背后的利益驱动。对于真正有价值的内容，往往由于利益无法匹配，\n不可能出现在网络上。也就是你能看到的内容，往往是他人不在意的内容。\n\n再说2，回忆一下你是怎么找到内容的？最常见的就是通过搜索引擎，\n但是搜索引擎的算法不是使用者能够控制的，这也正是百度的信用日下，\n而内容无法保证的原因。\n\ntinyfool的一篇文章，提到机器学习就是对人脑的一种模仿，那么反过来这种模仿也是对我们理解大脑的一种方式。\n\n机器学习最常见的理论是：模型+数据，看书看报，好一点的是可以拿到新的、有价值的数据，而更好的则是了解一种新的模型。 数据要经过梳理，并和模型结合，才真正被机器所用，我们也一样。好比学英语，背单词只是数据，只有结合语法语境，才不会出现一篇文章，所有单词都认识，但就是看不懂的情况。\n\n编程亦然，我学lua快9年了，却一直没有输入高质量的数据，没有看过好的代码，manual看了一遍又一遍，却总感觉雾里看花。最近因为想把一个web服务从apache+php切到异步模型，找到了alilua这个项目，突然觉得以前没有接触过的方面好多，甚至连lua_thread都刚看到该怎么用。如果我只看手册，再学10年我也不会明白coroutine的价值。 同样的，看异步网络编程的书，提到2.6.28内核开始提供的accept4调用，只有当我结合代码和实际的需求，我才真正理解它的价值。\n\n学习的意义，在于把接触到的例子，总结成共性并正交化的点。共性后的规律，再应用到新问题，反过来完善规律，正交则是使点的数量达到最小，从而减少记忆负担。\n\n输入和输出间的变换，可以叫函数，也叫模型。输入是训练集，之所以这么叫，是为了将函数打磨得更通用和简洁。\n\n思维导图的用法，核心是连接，又叫索引。建立一个点，是不是中心没关系，只要这个点推演生长，中心最终会被发现。把所知的概念融汇在名词性的点或动词性的线上，让你的知识精炼，连结并产生新的知识。","modified":"20150725121530000","tags":"think"},
{"created":"20180305121530000","title":"行人卡口事件的思考","text":"\n!! 问题是什么\n\n收到智能交通产品线增加行人卡口的需求，此前协议中已经有名为HumanTrait的事件，表示视频画面中出现了人。第一感觉就是行人卡口记录的也是人的出现这一事实，和HumanTrait有没有差异？\n\n!! 思考的角度\n\n能否复用就要仔细地比较两者的异同。先分析HumanTrait事件，当视频画面中出现了多个人，会以每个人为单位，进行一次这个人的事件上报，并尽可能地带上脸部照片和一些分析信息。而行人卡口要求记录一个人不同时间的画面，比如走过斑马线前后的画面。虽然描述的都是人，但是HumanTrait是从同一个时间进行切入，描述在这个特定时间点某个空间内人的状态；而行人卡口描述的是同一个人，在不同时间点构造的一个序列。*HumanTrait是多人合照，行人卡口是个人短视频*。\n\n!! 反思与推广\n\n做协议经常会遇到到底能不能，要不要复用的问题。如果要复用，要看这个复用协议描述的粒度。但是在定义第一版协议时，因为没有比较，描述往往不精确，会隐含了很多外部信息，直到遇到新需求，才会发现原来还可以从另一个维度看。\n\n像上面提到的过人事件为例，第一次看到这个需求时，的确没想到可以从时间序列去记录一个人。其实第一次分析不完整问题也不大，只要后面遇到新需求时，回过头来比较、细化已经定义好的协议也是来得及的。\n\n另一个悖论是倘若粒度真的太小，非常地场景特化，能被复用的可能性自然就少了。","modified":"20180305121530000","tags":"protocol"},
{"created":"20190618121530000","title":"性能监测工具选项备忘","text":"\n!! top\n\n默认显示Task数量，用 top -H 切换到线程模式，显示Thread的数量。也可以 top -H -p xxx 仅显示某进程的线程。top -a按内存使用排序。\n\n!! ps\n\n-T或-L 看到线程，又叫 lwp 或 spid 或 tid。默认不建议启用，只在确定某个进程有问题，且存在多个线程时，再打开线程观察，要注意的是打开线程时，内存占用是一样的（因为共享），CPU占用要加总。默认查看/proc目录时，用getdents(2)，并不显示线程。 -o %cpu= 只看cpu占用\n\n!! pstree\n\n-p才显示进程号，似乎内容也会变多\n\n!! strace\n\nstrace的原理是先给目标进程发暂停信号，attach上去后再发SIGCONT信号，所以开始时会显示 `restart_syscall(\u003C resuming interrupted nanosleep >)`\n\n系统级别的进程用strace观察多线程的始末是个很好的方式，trace内容定向到stderr，大概是不想影响被观察程序的正常输出吧。多线程的主线程join的系统调用对应的是futex，这个动作会提示unfinished，直到所有子线程退出，退出时子线程会调用futex(FUTEX_WAKE_PRIVATE)，主线程的futex才会resume。\n\nLinux x86_64的ABI要求系统调用至多只能接受6个参数，strace跟踪的参数列表是有限的。\n\n同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，如果没有竞争发生，则只修改futex,而不用再执行系统调用了。如果futex变量告诉进程有竞争发生，则执行系统调用去完成相应的处理(wait 或者 wake up)。\n\n所有逻辑结束后，主线程会close 012三个默认句柄，munmap内存，最终exit_group退出进程组结束整个程序。\n\n常用选项\n\n* -c : 以统计形式(理解为Group By)显示哪个系统调用耗时，一般用于排查一次性任务，还可以和-S配合结果显示时的顺序\n* -s 128 : 默认打印输出字符串的前32个字符（文件名不属于字符串），此选项打印更多字符\n* -vT : v打印环境变量和结构体等更多信息，T打印syscall的耗时\n* -f : 默认只跟踪进程，此选项追踪线程\n* -t : 显示每条调用的发生时刻，可以tt甚至ttt，提升精度\n* -e expr : -e trace=!file,process,network,signal,ipc,memory 只跟踪某类系统调用，反向时记得用backslash修饰!\n\n!! ltrace\n\n跟踪动态库调用，默认输出很少，可以用-S打印系统调用，不过速度比strace慢\n\n!! pidstat\n\n* -u显示的%wait表示 得不到运行的时长/期望运行的时长。比如2核机器运行8个任务，等待率是75%\n* -w显示上下文切换，包括自愿和非自愿。说明内存或CPU存在瓶颈\n\n!! time\n\n既有bash内建也有独立命令，一般用bash内建的time -p输出POSIX格式时间。real包括CPU和IO的所有耗时，等于秒表计时时间，而user和sys都只代表CPU时间且多核会一并计入，所以对多核优化得好的程序，会出现`real\u003Cuser+sys`的情况。在`/proc/\u003Cpid>/stat`文件的14和15列分别表示进程运行在用户态和内核态的tick周期数，tick代表多少时间不是固定，大多数是10ms，可以用以下程序测出来。\n\n```\n#include \u003Csignal.h>\n#include \u003Cunistd.h>\n#include \u003Cstdio.h>\n#include \u003Cstdlib.h>\n#include \u003Cstring.h>\n#include \u003Csys/time.h>\n\n#define USECREQ 100000\n#define LOOPS 3\n\nchar cmd[64];\n\nvoid event_handler(int signum)\n{\n    static unsigned long cnt = 0;\n    cnt++;\n    if (cnt >= LOOPS)\n    {\n        system(cmd);\n        exit(0);\n    }\n}\n\nint main(int argc, char **argv)\n{\n    struct sigaction sa;\n    struct itimerval timer;\n    int pid;\n    pid = getpid();\n    sprintf(cmd, \"cat /proc/%d/stat\", pid);\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = &event_handler;\n    sigaction(SIGVTALRM, &sa, NULL);//SIGALRM\n    timer.it_value.tv_sec = 0;\n    timer.it_value.tv_usec = USECREQ;  // timer can't precise to 1us, let it be normal\n    timer.it_interval.tv_sec = 0;\n    timer.it_interval.tv_usec = USECREQ;\n    setitimer(ITIMER_VIRTUAL , &timer, NULL);//REAL\n    while (1) ;\n}\n```\n\n原理就是利用while(1)让进程跑满用户态，同时再用setitimer机制让程序在固定时间后退出，计算用户态运行时间除以tick，就能得出tick代表的真实值。但是有一点要注意，定时周期似乎不能小于tick本身，否则程序运行时间会比期望时间长，可能是itimer定时器的精度问题，计算得到的tick值误差也会更大，但大体还是准的。\n","modified":"20190618121530000","tags":"os"},
{"created":"20221123121530000","title":"修复操作系统问题记录","text":"\n磁盘挂载失败\n----\n起因是服务器磁盘被拔，导致系统进入emergency模式，即使进入所有服务也未启动。\n\n原因出在盘被拔，但/etc/fstab却没有修改，系统认为缺少盘所以进了应急模式。每块磁盘会有个UUID，fstab也是通过这个来找盘。用blkid命令可以看到所有盘的UUID。两相对比去掉不存在的盘就行。\n\n修改后不用重启，mount -a就能挂载。这时又出现新问题，报UUID重复错误，用mkfs.xfs -f /dev/sdx格式化硬盘，再挂载就没问题了。\n\nlsblk命令查看分区和挂载目录的关系，其实mount也能看，但因为装过容器，mount看不清楚。\n\n要注意的是，blkid只会列出分区，比如/dev/sda被分成了sda1和sda2，用blkid看不到sda，只能看到sda1和sda2，行为和df命令一样。而lsblk既能看到设备也能看到分区。\n\n忘记root密码\n----\n只适用于centos，在选择内核列表时，按e进入编辑模式，在linux16命令的参数中加入init=/bin/sh进入单用户模式，执行mount remount后，用passwd可以重置，最后用exec /sbin/init重启。","modified":"20221123121530000","tags":"os"},
{"created":"20171204121530000","title":"修改能力协议的思考","text":"\n对一个视频通道获取智能能力的协议，原来的协议只有一条能力，这种描述不足在于能力有当前能力和潜在能力，嵌入式设备的能力不是孤立的，会受制于其它资源，因此协议上要有两个能力。如果只到这里为止，协议就结束了，但接下来的实现就相当地狗血。\n\n因为用了RPC方式，每个协议和接口对接，接口中只定义了一个caps参数，无法把协议的full节点映射到头文件。通常这种时候再增加一个接口，用来获取full能力，并在RPCServer中调用两次把能力返回也是可行的。此时第二个坑出现了，所有的接口定义在类当中，而类的接口数量是有上限的！此时这个类的32个接口都用完了。当然这种情况也遇到过，换一个类增加接口就是了。但偏偏这个类不是管理类，协议调用这个方法是通过工厂方法的instance，并传递通道号来获取类实例指针方式，比如当前的智能类名字是DevVideoAnalyse，客户端会先指定通道2获取对应的实例token，接下来通过token去访问getCaps方法，到了getCaps的实现只有token，无法映射到DevVideoAnalyse2这个实例(因为无法直接得到通道号)！变通的作法是建立token和两个类实例的绑定关系，这样一来又要多费很多周折，且为这一个方法也没有必要。\n\n最后的解决办法是在getCaps的请求中增加一个channel，通过channel重新获取DevVideoAnalyse2的类实例并调用方法获取full能力。当然这样做协议就显得很冗余，也是协议被实现绑架的一个例子。\n\n我一直对先获取资源指针并操作这种模式很反感，协议不应该暴露资源，如果不是这种模式，虽然类有32个接口数量限制，实现上并不会很丑陋。","modified":"20171204121530000","tags":"protocol"},
{"created":"20190722121530000","title":"学Scheme经历的误区","text":"\n从SICP上手的人往往觉得一个list类型包打天下，以致于看到R5RS中特别定义vector都很惊讶。其实就像其它成熟语言一样，容器有很多分类\n\n> Sequence，顺序容器的统称\n>>\n>> List，特点是长度可变，访问耗时O(n)。含aList和pList子型\n>>\n>> Array，特点是长度固定，在CL中支持多维，访问耗时O(1)。含vector和string\n>\n> HashMap，无序容器\n>\n> Struct，关联数据\n\ncar的返回，更倾向于scalar的值，而cdr通常是list。\n\nmapcar遍历Sequence容器，而maphash遍历Hash容器。scheme原版没有hash，所以mapcar被简化为map，但并不代表这样真的对。\n\n**绑定let和赋值setq的区别**\n\n每个let块会创建新的scope和新的storage place保存值，如果和外层变量同名，以栈的方式实现遮蔽，块结束后弹出从而恢复前一个值。setq复用storage place，实现也简单得多。\n\n从知乎上看到，scheme的意义，觉得写得非常精彩。\n\n在R7RS 88页的篇幅里，塞进了相同尺寸规格的语言无法企及的复杂性。从文法层面的directive, datum label, external representation 与read的联动，到 语义层面的numeric tower, region, proper tail recursion, macro, continuation, environment, evaluation 与eval的联动。Scheme以一种偏执的近乎反实用主义的态度展现了作者的脑洞，回答了这样一个问题：如果有这么一门语言，不用考虑机器实现的便利，不用考虑用户的使用感受，不用考虑设计的可扩展性，尽可能小的篇幅内尽可能多地展现符号操纵的概念，方法，行为和联系。它该是什么样的？","modified":"20190722121530000","tags":"lang"},
{"created":"20220201121530000","title":"压缩技术浅谈","text":"\n凡涉及存储和传输，就一定会涉及压缩，不同领域的需求和特点也各不同\n\n!! 文本\n\n目前我们日常使用的各种压缩软件，追根溯源都是LZ77算法的衍生。看名字就知道它是Lempel和Ziv在1977年发明的算法。它是基于字典编码理论的一种实现，细分静态词典和动态词典，静态编码指编码器事先准备好词典，如果文本中的词不在词典中，则不进行压缩；动态词典则基于对文本的统计，LZ77是动态词典的开创者，同时也是当今各种泛用形文本压缩算法的原型。\n\nLZ77算法有滑动窗口和前向缓冲（Lookahead Buffer）两个概念，先读入的会放入滑动窗口，并作为动态词典的样本，同时对后续的文本尝试匹配，匹配成功则进行替换，不成功则进入滑动窗口用于后续替换，如此迭代直到整个文本被处理完。后来的研究者基于LZ77的理念，在实现细节上做了很多优化，也形成了如今种类繁多的改进算法。\n\n基于LZ77的理念，就比较好理解为什么许多软件会有多个最快压缩和最大压缩的级别可选，核心就是通过控制滑动窗口的大小和匹配的阈值来调节计算过程。比如大数据领域的Snappy算法就是控制匹配长度的下限为4来提升压缩速度，另外它还设置了每个压缩块长度32k，块之间互相独立，因此只用2个字节就能表示块中的偏移，滑动窗口每次移动4字节而不是LZ77的1字节，种种优化措施下来，Snappy的压缩速度非常可观。另一种用于互联网的Brotli算法，加入预定义字典的方式（有点动静结合的意思），提升压缩率。\n\n!! 声音和图像\n\n由于人类自身感官的限制，声音和图像在压缩过程中是允许丢失一定精度（其实在数字化采样的时候，原始精度就已经丢失了），就有了无损与有损的划分。加之采样又有整数采样和浮点采样，所以音视频的压缩算法比文本要丰富得多。\n\n以音频采样为例，无损领域有两个非常有名的编码格式APE和FLAC，后者就只使用整数采样，又因为音频播放器往往都会用DSP解码，只使用整形对DSP来说无疑极大降低了硬件的要求，这也是FLAC现在比APE更主流的一个小因素。\n\n!! zip文件头\n\nzip作为压缩格式虽然不是压缩比最高，但由于其诞生年代早没有专利保护，受到了操作系统和各种开源社区的广泛支持。有次遇到被7z压缩的文件用zip解压，报错PK版本过低，原来是magichead后面会有两个字节表示所需要解压软件的最低版本。而PK正是zip的发明者Phil Katz的首字母。","modified":"20220201121530000","tags":"tool"},
{"created":"20170109121530000","title":"业务分离和厘清概念","text":"\n所有服务端的程序，都离不开3A(Authentication Authorization and Accounting)。\n其中又以前两个最容易混淆。一般把鉴权称为A1，授权称为A2。在Apache中的简称则是authN和authZ。\n我们的程序在校验权限时，一般是长连接，所以A1交给登陆认证模块，\n后续不再考虑，加上没有计费，所以只有A2。校验权限的回调接口是这样的：\n\n    bool cbCheckAuth(const char*, void*, char*);\n\n第1个入参是请求的方法名，第2个入参是对应的参数，第3个出参是对应的权限名称。\n返回值为true表示找到权限，而false表示不关心，采用默认策略。\n这时有个新需求，某些敏感操作比如重置系统即使用admin登陆，还需要再次确认用户身份。\n显然现有的接口无法满足需求，我本来想通过返回false，并且用第3个参数表示错误码的形式来做，\n但是这个想法不被认同。于是仔细查了3A的概念，既然身份确认属于A1，\n放在A2的阶段确实不合适。有了理论依据接下来就简单了，在检查A2前增加一个A1的检查函数。\n\n平时做很多业务，都没有把业务划细。虽然平时经常说分层，但对于怎么分层并没有标准，\n我的理解就是只要能把业务里的每个概念、差异点给明确了，把不相同的概念隔离开，\n层次自然就出来了。否则只能是拍脑袋凭感觉，是无法让其他人信服的。","modified":"20170109121530000","tags":"design"},
{"created":"20161023121530000","title":"一次安卓刷机失败的修复过程","text":"\n手头有个华为手机，自带的EMUI实在太难用，偶然在华为论坛找到一个flyme的链接，大喜过望马上准备刷机。那篇帖子提供了两个链接，并且告诫说，\n如果其中一个ROM导致黑屏，可以刷另一个ROM。本来这个时候，应该把两个ROM都下载后再开始刷机，但因为下载速度实在太慢，加之自己的大意，下载完一个ROM就急切地开始刷机了。果然悲剧发生了，刷完之后一进入系统就黑屏了。\n\n在这个状态下，电脑不能识别手机，也就无法把新的ROM再拷贝进去，本想试着把新的ROM拷贝到TF卡，让Recovery从TF卡升级，\n但进到Recovery，可能是Recovery的缺陷，一旦执行mount TF卡，就失去响应了。这时我已经有点着急了，难道只能线刷？网上线刷包倒不难找，\n但是一来下载要花时间，二来线刷包和卡刷包的区别在哪里？既然有卡刷包，也能进到Recovery，非要线刷不可吗？\n\n又在Recovery的菜单里找起来，惊喜地看到有个sideload的选项，说明写着通过adb sideload命令，可以把文件导入到手机。\n看来可以在电脑上把卡刷包给写到flash上，但是操作之后却提示无法找到设备。猜想很可能是没有驱动，去哪里找驱动是个麻烦的问题。好在现在有各种方便的刷机工具，靠它来装上驱动，还是挺方便的。于是随便找了个下载安装，\n再输入adb devices命令，果然手机被识别出来了。接下来手机侧点击sideload，有了驱动后再一次电脑上输入sideload命令，把卡刷包写入手机。经过漫长的等待，手机总算活过来了。\n\n手机修复后，重新去思考修复过程，发现只要Recovery能用，且和卡刷包的版本是配对的，就能救回来。因为遇到过问题，从Android4.4系统，下载的5.0的卡刷包，升级后就不能引导进应用系统了。接下来就仔细缕缕这其中的关系：\n\n先从系统结构说起：比如一个跑在x86上的linux，启动流程是先进入BIOS，然后引导kernel，最后执行init程序，就能进入shell或GUI了。那么对应手机，分别有如下这几个阶段：\n\n* fastboot 也叫bootloader 对应BIOS，一般是u-boot来实现，功能比较简陋，无法交互，目的是引导到下一个阶段，比如Meta,factorymode,recovery,normal这几种模式。这种模式下的刷机，俗称线刷。\n* recovery 这个就包含了kernel和定制的init的程序。这种模式下的刷机，俗称卡刷。\n* normal 就是我们平时打开手机的flyme或MIUI系统，当然有kernel和init。\n\nrecovery和normal都带有kernel，可以分别独立启动，通常按电源键，会直接运行normal模式，只有同时按下音量键（具体取决于手机厂设置），才会选择recovery模式。只要这两个中任何一个正常，就能看到开机画面了。所以上文提到的就是recovery可用时的刷机策略。\n\n但是如果Recovery坏了，或者Recovery和想升级的rom包不匹配，就需要更新Recovery了。更新Recovery有两种方式：\n\n# fastboot工具。如果Recovery有问题，这时选择进入手机的bootloader模式，(比如我这个华为手机，音量+和电源键是进入Recovery，音量-和电源是进入fastboot/bootloader)。\nbootloader模式和adb是不同的，驱动也不一样，会出现adb能识别而fastboot识别不了的情况。要用fastboot flash recovery filename命令，\n来写入第三方的Recovery。bootloader比Recovery的阶段早，所以这个阶段可以写Recovery，fastboot模式由于不具备交互界面，只能在电脑上操作，\n# 使用厂商提供的专用工具，还需要刷机包有分区表(通常卡刷包是不会有的)，\n从分区表可以看到第一个和最后一个分区名为pgpt(primary gpt)和sgpt(secodary gpt)，\n说明是按GUID Partition Table而不是MBR方式管理分区的。我手头的手机Recovery分区是16M，有了这个基础，下一步就是卡刷了。\n\n很多厂商不希望玩家刷机，就故意把Recovery的功能做得很简陋，或者限制刷入包的签名，同时又在bootloader上做限制，不允许更新Recovery。\n这就需要先解除bootloader的限制，即俗称的unlock。经过这一步，手机便失去了保修，换来的是可以自由地写入Recovery，然后各种Rom就可以烧入手机了。\n\n前文还提到Recovery和Rom会不匹配，这就涉及另一个概念：底包。\n经常在刷机论坛能看到底包说法，打开底包可以看到非常多的文件，\n包括上文提到过的recovery，system.img,boot.img,userdata.img等文件，\n还有些像moden_ltg.img,trustzone.bin,logo.bin等文件，\n还有在操作中惟一可以由用户选择的文件——分区表。\n\n不管卡刷也好，fastboot重写recovery，如果没有正确的分区表，也是不可能的。\n从这里可以看出，如果要把系统写到一块完全空白的flash，确实需要线刷底包，\n但是一般说的黑屏啊救砖什么的，通常分区表不至于损坏，只要下载到版本合适的Rom或Recovery，\n就一定能救砖成功。\n\n底包含有基带moden，还有用于DRM版权及支付的trustzone.bin文件，\n这些文件都是厂商不愿意开放出来，且ROM的作者也不会去修改的地方。\n可以认为卡刷包是把底包中和应用相关部分给替换的部分。\n\n底包中往往有完整的分区表，比如MTK6752有24个分区，有ext4和RAW两种格式。\n但是并不是每个分区都会写文件进去，像NVRAM分区保存的是IMEI串号，\n就只定义了分区大小为5M，但不管哪种刷机方式都不会去改写它。\n从这里也能看出：分区表绝对不能破坏，否则IMEI一旦丢失就没有任何方式能挽回，\n除非保存过NVRAM的内容，否则只能返厂重写。\n\n手机变砖后能和线刷工具通信，说明内部有一块固化的代码，MTK平台称为Bootrom，\n代码固化在NOR flash上，同时还有一小块SRAM，执行DA程序，DA是Download\nAgent的简称，用于接收线刷工具发到手机的数据。\n所以至少MTK平台的启动第一步，并不是uboot，而是这块Bootrom。\n这部分是无法访问的，如果被破坏，只能返厂维修了。\n\n最后附一个MTK6752的分区实录，总计有24个分区，列出部分。\n\u003Cpre>\npreloader 256K\npgpt(first) 512K\nproinfo  3M\nnvram(IMEI) 5M\nboot      20M\nrecovery  20M\nlogo      8M\ntee1(trustzone)  5M\ntee2(trustzone)  5M\nsystem    1.5G\ncache     320M\nuserdata  1180M\nsgpt(last)    512K\n\u003C/pre>\n","modified":"20161023121530000","tags":"os"},
{"created":"20180829121530000","title":"一次反汇编的崩溃定位","text":"\n将设备搜索功能从子节点迁移到管理节点，虽然程序没有变动，但会出现启动就崩溃问题，重启后不会崩溃。\n\nGDB跟踪发现是死在第三方的so库，直观的解释是free的内存被破坏。可是重启后没问题，开始就没往这方面去想。第二天，同事说怀疑是否网卡数量过多引起，原来子节点没有很多网卡，重启是因为主备切换导致虚网卡消失，所以就不会重启了。加上这个第三方库做设备搜索工作，确实很有可能在绑定网卡时出了什么问题。\n\n于是开始研究反汇编代码，发现存在一个大循环，跳转前有`addw 0x01, -2(%rbp);cmpq 0x00 -10(%rbp);`。后一句cmpq还原成代码，是`p==NULL`，前一句则是计数，等循环结束就能知道一共有多少张网卡。看来很可能是由于没有控制好网卡上限，导致内存溢出。\n\n再回到函数开头，查阅了x64的汇编调用规则，第一个参数在rdi，第二个参数在rsi，第三个参数rdx（展开说一下，这个规则随着位数、编译器不同，VC用的寄存器就不同，而32位默认全放在堆栈，除非开启fastcall模式才会用寄存器传参）。可以看到rdi被放了一段内存。之后又高了另一个so的库也分配了内存，去掉malloc在分配前的16字节cookie（取决于实现），发现刚好是挨着的。在最后执行free的时候，cookie部分被前面所写坏，导致free时abort退出。最后又找到了进入函数前的hardcode的分配0x75C内存的new操作，基本可以定论不换so的情况下，只能依赖限制网卡数来规避问题了。\n\n限于汇编能力不足，具体是哪一行写坏内存仍不可考，但利用这些点，算是把问题给交代了。","modified":"20180829121530000","tags":"tool"},
{"created":"20171201121530000","title":"一个加密协议定义不仔细的教训","text":"\n前天下午NetSDK组反馈在AES加密时数据，客户端和服务端对正文的padding采用了不一样的加密方式，导致无法解密。当时就觉得很蹊跷明明已经调试通过的功能，为什么这么久了还报问题。昨天下午花了两个半小时才把问题解决，现在想来都觉得是我接手协议以来遇到最屈辱的一次遭遇。\n\nAES加密是一种块加密，当数据不足一个块时需要填充，和RSA不一样的是，填充内容都常不在算法实现，而是由构造加密数据的人来填充。换句话说AES的API并不体现padding参数，而RSA是明确地预留了padding参数并给出了5种宏定义，这也是当初定协议时遗漏的诱因。\n\n于是想当然地，AES加密时不足部分就填了0x00。可是服务端在实现时从安全产品线得到一份文档，要求采用PKCS7方式填充，但并没有同步给其他团队。为什么需要PKCS7这种方式呢？要从填0x00有什么缺陷来考虑。AES块加密的特性决定了加密后的内容长度一定是16的整数倍，但源数据往往不是16的整数倍，因此接收方得到数据并解密后，需要把最后的padding数据排除掉。如果源数据是字符串，使用0x00来padding没什么关系，都能正确地解析，但如果源数据是二进制数，还用0x00做padding就没法界定源数据的边界。解决的思路就让padding数据自表示哪些是无效的，比如在所有数据的最后一个字节，表示有多少是被padding出来的。举例来说，明文数据是120字节，加密后变成128，多了8字节，加密前就在在明文数据后补上8个字节的0x08（或者补上7个0x00和1个0x08），解密后根据最后的0x08就能丢弃无用的padding字段。\n\n说完原因再说问题，服务端按PKCS7方式处理数据，而客户端根据0x00填充，在源数据长度不是16整数倍的情况下，填充若干个0，而服务端又根据数据最后一个字节向前回退0个字节的偏移（这里处理不严谨，按PKCS7的定义不允许出现尾字节是0的情况，一定是0x01到0x10之间的某个数），由于是0相当于把整段数据交给上层应用。目前协议是用json传输，多几个0没有关系。但当原始数据是16的整数倍时，没有做padding，但是由于json库实现的一些瑕疵，会在最后的'}'后带上'\\n'即0x10，在这种情况下服务端把数据回退10，导致上层得到的json数据缺失无法解析。数据长度恰好是16整数倍是个随机概率，测试时也很难发现，导致事情过了3个月才暴露。\n\n整个事故反思下来，教训有三条\n\n# 制定加密协议时遗留了细节，导致出现流程上的盲点，还是需要自己加强知识学习\n# 多部门间未同步到位，致使关键信息没有同步\n# 服务端实现时未考虑异常情况，不是根据收到数据包来解析数据，而是预设条件导致错误解析","modified":"20171201121530000","tags":"security"},
{"created":"20161104121530000","title":"一个GDB和GCC版本不同引起的定位问题","text":"\n有同事问起调试过程中，触发了SIGFPE除0错误，但是通过core的bt命令，\n却发现出在pthread_create函数上，非常不可思议。今天找了部门对汇编最熟悉的大师，\n原来问题是出在编译使用的是GCC5.2版本，但是调试用的GDB因为使用的libc和GCC不匹配，\n导致符号表错误，而GDB是通过偏移量并从符号表中读取符号，\n一旦版本不匹配，读到的符号也是错误的。\n\n解决方案是通过GDB的set sysroot命令来重新定位到GCC的库中，强制确保libc库的正确性。\n怎么知道正确的sysroot路径呢？就从编译的信息来，通过ld的-t选项，能得到libc的路径。\n比如写一个gcc hello.c -Wl,-t的方式，就知道从哪个目录下引用了哪些库。\n把这个目录再通过set sysroot在GDB环境中设置一遍。\n但是仅有sysroot还不够，因为出问题的往往是自己写的库，因此还要用\nsolib-search的方式把自己编写的库，导入GDB的搜索路径下，\n经过这样一遍的尝试，再用bt命令就能定位到正确的函数了。\n\n顺便再说说用GDB查看栈帧的理解：\n\n程序被加载到内存后，以windows为例，程序数据如main，func这些函数的汇编语言代码，用disas main来观察，保存在0x00401300左右的内存空间，而栈空间在0x0028ff00左右位置。用i reg仔细看eip,ebp,esp这三个寄存器，eip始终在代码区徘徊，而ebp和esp沿着栈空间一直向下生长（值不停地变小）。\n\n每次汇编的call一执行，会把当前的ebp、eip、函数参数(如果有的话)依次保存在栈上，所以入参从0x8(%ebp)开始算，而eip的值通过反汇编可以看到，是call的下一条指令位置。从而在leave指令可以用上次的栈和pc值回到上层函数的call之后继续执行。也可以用disas eip的值，看eip要执行的汇编代码是什么。\n\n所以递归的时候，每一次的函数入参和返回地址eip，用x/50x ebp address命令能看得很清楚。这就是bt能打印函数执行地址的原因，那些值其实都沿着栈内存写着，bt只是帮人翻译出来罢了。","modified":"20161104121530000","tags":"lang"},
{"created":"20180902121530000","title":"伊斯兰国家的传承","text":"\n世说穆罕默德雄才伟略，不得观。但死后四大哈里发不得善终者二，并不稳固。按时间线共有3个大的王朝分别是：\n\n# 倭马亚王朝，白衣大食，逊尼派，661-750。\n# 阿拔斯王朝，黑衣大食，750-1258。都巴格达。\n# 奥斯曼帝国，1299-1922。都伊斯坦布尔\n\n另有两个支线王朝：\n\n# 法蒂玛王朝，绿衣大食，什叶派，909-1171。都开罗\n# 阿尤布王朝，1171-1250。都开罗\n\n倭马亚立足叙利亚享国近百年，却幅员辽阔。有名的普瓦捷之战便在此朝，此战后扩张也被终止了。由于朝内反对势力太盛，终被被阿拔斯朝取代，地处伊朗，官僚集团大量波斯化。稍晚一点有法蒂玛王朝，但只是一方割据，未能占据正朔。至元朝阿拔斯为旭烈兀(拖雷子)所灭，稍后就进入了最强盛的奥斯曼帝国。\n\n从蒙古灭亡阿拔斯王朝后，传统上的阿拉伯帝国就不复存在了。奥斯曼和其它几个阿拉伯帝国不同，它是消灭了东罗马帝国后，定都于君士坦丁堡，且以东罗马帝国的继承人自居。随后突厥人更是在文件上融合了伊斯兰教，但仍以教徒自居。","modified":"20180902121530000","tags":"think"},
{"created":"20211016121530000","title":"以太和IP网之外的一些网络","text":"\n对网络来说，第一层物理层的种类相对较少，就我所知无非是光纤、双绞线、单芯线，受限于物理介质不会有太多花样。但在这些介质上传输信号，就必然要定义信号的标准和传输方式，所以链路层（二层）的协议可谓数不胜数，不过大浪淘沙，现在几乎只剩下802协议，但是回顾曾经丰富多彩的链路协议也能看出通信发展与演化。\n\n!! 802.x\n\n以太网、令牌环以及无线网络都是这个家族的一个子类别，之所以是同一个家族，是因为共同遵守802.2的LLC链路控制协议，MAC地址也是这套规范定义的。\n\n以太帧除了承载IP包，还能承载ARP、VLan等。\n\n!! ATM\n\n现在估计知道ATM网的人不多了，它采用的信元交换理念（cell switch），和电路交换和包交换都不一样。ATM网协议比TCP/IP协议复杂，也完善的多，基于电信思维制定的ATM网明显比基于计算机专家搞的TCP/IP协议完美太多。论技术，ATM协议绝对更适合通信未来发展，采用虚链路的连接方式，QOS有保障，带宽有保障，传输利用率也更高更稳定，整个网络的流量管理更强大，网络可控性高太多，对现在的流媒体等应用绝对更友好，基于ATM网的上层应用应该就简单很多，而不用像面对TCP/IP协议一样需要自己考虑网络稳定性，而且更强的网络控制和流量管理能力，可以大幅度降低大流量下的网络并发难度，减少现在因为突发流量导致网络崩溃。\n\nATM网络虽复杂，但是应用层绝对简单，面对用户应该比TCP/IP协议友好很多。其实TCP/IP协议表面看很简单，然而如果真正自己部署，要运营维护好难度相当高，因为自主性太强，灵活度太高，用户需要自己面对很多灵活的规划部署，这其实相当有挑战性。用TCP/IP协议构建一个小网可能很简单，然而网络复杂一点，就相当有难度。至于成本问题，我一直认为ATM设备贵只是因为他没机会像TCP/IP网一样得到大规模推广，没有规模应用，成本是无法降低的，如果当年率先得到推广的是ATM网而不是TCP/IP网，那ATM设备绝对可以降低成本，而且以电信思维制定的电信网络，往往都是网络端功能强大而复杂，但是接入终端则易总简单且成本低廉，就像我们曾经的固定电话一样，复杂而昂贵的电信局端设备干了基本绝大多数工作，用户客户端其实简单而廉价，所以ATM网当年倘若可以得到大规模应用，其整体成本不见得真就高昂，而且现在云计算的大规模应用，更是把这种将复杂工作放在后端，以简化终端的思想，其实挺适合ATM的技术思想。\n\nATM输就输在时间上，ITU-T基于电信网思维经验制定出一个庞大复杂的ATM协议花费了巨大精力和时间，然而计算机领域的专家，根本就不考虑那么多，只求简单快捷，有问题后面再迭代修补，结果标准还没定产品已经跑前面去了，以实战替代标准，所以随着TCP/IP协议的一统江湖，却越来越显示出IP协议在面对流媒体，语音，视频电话等应用时的力不从心，通过在IP协议上修修补补，以求弥补TCP/IP协议的不足，然而本质问题解决不了，只能尽力优化，所以导致为了适应新应用需求，整个TCP/IP协议其实越来越复杂，越来越庞大，虽然光传输的兴起极大的解决了带宽问题和部分QOS问题，然而现实中传输带宽用不是无线的，QOS问题不可能全寄托于传输链路没问题。今天各种应用大爆发，全网融合以IP协议一统天下，然而当年那个天赋异禀却时运不济的ATM只能叹息生不逢时。","modified":"20211016121530000","tags":"net"},
{"created":"20171222121530000","title":"音频与声道的一些基本概念","text":"\n起因从一个对讲的bug说起。客户端在语音对讲时，一直发送的是双声道的音频文件，设备管理也按双声道解码，结果最近一款设备却实现成了只能解码单声道，最后非得客户端兼容才算把问题解决。\n\n所谓声道就是一个独立的可以播放的声音，对应的硬件可以简单的认为是个普通的民用麦克，采集人的声音并进行编码，这就是一个声道。虽然人只有一张嘴，却有两只耳朵，如果通过耳机播放一个声道的声音，就会出现仅单边有声单边静音的违和感，为了让听起来来自然，就把这个从麦克采集到的单声道声音复制一份，并按LRLR顺序按帧排列发送到对方，听起来就是两边有声音了。经过这样处理的声音就是双声道，尽管这两个声音是完全一样的。前文提到的那款设备，在解码时没有进行声道的处理，把每帧音频都送给同一个播放单元输出，因此造成了设备端回放声音的混乱。\n\n如果说对讲因为比较简单所以可以复制声道，音乐就不能这样做了，尤其是大型交响乐，舞台左右的乐器是不一样的，为了形成声音的方位感，在录制的时候会在舞台的多个点采集声音，并经过后期的调整叠加最终混合成左右两路声道，这两个声道的声音是同一首曲子，但不同的乐器会在响度和方位上的差异，给听者带来的感受就是能区分开各种乐器的方位，听起来声音就有了立体感，因此一般双声道的音乐又被称为立体声。\n\n家庭中常见的尤其是PC配备的2.1音箱和2声道又是什么关系呢？这个.1指的是低音单元，声音是有高中低频的(其实是连续的频谱)，一个音箱由于物理上的限制，无法完全地还原各个频段的声音，于是就有人想出把低频的声音通过低音单元放送，中高音则通过两个音箱播放。但是这就引出一个问题，音箱有3个，声道是2个还是3个？对民用产品来说，2.1音箱上播放的还是2声道声音，只是软件在播放前会把两个声道中低频部分通过低通滤波器过滤并送到低音炮播放，中高音部分送两个音箱播放，只是这种分离的做法有点生硬，所以讲究点的音乐爱好者会选择2.0的音箱，宁可牺牲低音效果，也要听到未被分离的声音。\n\n除了2.1，影院级的5.1或更高端的7.1就不再使用低通滤波器硬生生分离出来的声道，而是在采集的时候就额外采集一路单独的低音声道，这时就有6声道或8声道，这样播放的声音还原度、立体感也更强。","modified":"20171222121530000","tags":"protocol"},
{"created":"20181120121530000","title":"音视频解码器的特性","text":"\n音频解码有指标\n\n* 比特率范围\n* 输入通道\n\n比特率范围，典型如MP3是8k到320k，FLAC会有1到2^31全覆盖。\n\n通道数大抵越低端，用于通信的越少，音乐则多。AMRNB, G711是1个，MP3是2，AAC是6可以5.1声道，Vorbis是8可以7.1声道。FLAC某实现是30(但另一个实现编码只有2通道)。\n\n视频解码指标\n\n* 帧速率\n* 比特率范围\n* 对齐宽高\n* 支持宽高\n\n帧速率大多是1到240全覆盖，也有mpeg4只有12到60。VP8和9是0到960。\n\n对齐宽高不论编解绝大多都是2，H263是解4(编码是16)\n\n别名3gpp的音频是AMRNB，视频是H263。mp3是mpeg，mpeg4是mp4v-es，aac是mp4a-latm。","modified":"20181120121530000","tags":"tool"},
{"created":"20170802121530000","title":"英语的谓语、表语和动词","text":"\n英语五大基本句型和人类历史发展史是完全一样的\n\n* 主谓就是一个男人和一个女人；\n* 主谓宾就是一个男人和一个女人生个孩子；\n* 一个孩子太寂寞再生一个就是主谓双宾；\n* 孩子长大找自己的另一半那就是主谓宾宾补；\n* 男人没一个好东西总是要变心的，于是找了一个新的媳妇叫做系，生了一个新的孩子叫做表；\n\n所以宾语和表语是同父异母的兄弟：\n\n* 主谓宾\n* 主系表\n\n如果从词法角度来看，主谓是不及物动词，主谓宾是及物动词，而主系表则是系动词。\n这三者在词法上都归在Verb大类下，但细分下来，还是会成为不同的句法。\n还有个巧合，谓语predicate和表语predicative竟然如此得相像。表语补足语则是\npredicative complement。\n\n谓语和动词并不等价，动词共有4类\n\n* 实义动词：run/walk有真实动作的词\n* 系动词：is/am/are，作为联系词，不单独使用后面一定带词\n* 情态动词：can/should/have to，不能单独使用，只表示态度\n* 助动词：do/be/have，不单独使用，使整句话的语气由陈述句变为疑问/强调等","modified":"20170802121530000","tags":"think"},
{"created":"20200105121530000","title":"硬盘操作和文件系统散记","text":"\n!! 硬盘操作\n\n首先要明确个概念，每块硬盘都有设备和分区这层概念，一块硬盘当然对应一个设备，但会有一到多个分区，util-linux包提供了多个操作硬盘的程序。\n\n* fdisk: 应该是最有名的程序了，fdisk -l显示当前总线上已经识别出的设备\n* lsblk: 显示块设备、dev的major/minor号、挂载点等。关于lsblk命令查看分区和挂载目录的关系，其实mount也能看，但如果装过容器，mount会看不清楚，这时用lsblk就很方便\n* blkid: 只会列出分区，但可以识别文件系统。比如/dev/sda被分成了sda1和sda2，用blkid看不到sda，只能看到sda1和sda2，行为和df命令一样。而lsblk既能看到设备也能看到分区\n* hdparm: 只知道，不太会用\n\n以上这些命令都是针对硬盘，所以就算没有挂载，也可以看到硬盘。\n\nfile命令的-s选项可以查看块设备的特性，比如`file -s /dev/sda`能看到这块盘是GRUB启动程序，接着又是若干个分区。而直接`file -s /dev/sda1`就只显示分区信息，可见/dev/下面分开显示sda和sda1并不是无意义的。\n\n!!! 磁盘挂载失败记录\n\n服务器磁盘被拔，导致系统进入emergency模式，即使login所有服务也未启动。原因出在盘被拔，但/etc/fstab却没有修改，系统认为缺少盘所以进了应急模式。每块磁盘会有个UUID，fstab也是通过这个来找盘。用blkid命令可以看到所有盘的UUID。两相对比去掉不存在的盘就行。\n\n修改后不用重启，mount -a就能挂载。这时又出现新问题，报UUID重复错误，用mkfs.xfs -f /dev/sdx格式化硬盘，再挂载就没问题了。\n\n磁盘写入有两种模式\n\n* write through: 直写式，数据不做校验直接写入磁盘，写完后再读出来后写校验值。性能差，可靠性高？\n* write back: 写回式，数据先写到cache，再用cache计算校验值，然后数据和校验一起定入磁盘，如果cache足够大且性能强，可以一直写入。有些RAID卡要开启这种模式，除了有cache，还要有电池，保证掉电后cache数据也能写入磁盘。\n\n!! 文件系统\n\n安卓有`protect_f`和`protect_s`分区，s是f的备份，专门用来保存SIM ME LOCK数据，运营商专用机就是修改这份数据达到的。原来是保存在/data分区，为保证恢复出厂时不用重新生成，干脆做成独立分区。\n\n文件系统单个分区上限取决于单个簇大小和簇个数，比如ext3的簇个数是uint32，取常见的簇大小4K来算，分区上限就是16TB。（似乎ext3簇大小不可改，NTFS可以改成单簇64K使上限达到256T）\n\nZFS的默认簇是128K，在和PG数据库配合时，其默认记录大小是8K，如果数据库用于零散查询较多的场景，最好用`zfs set recordsize=8k zp1/data`也调整到8K效率更高。","modified":"20200105121530000","tags":"os"},
{"created":"20180910121530000","title":"用数组实现链表","text":"\n为每个链表元素分配一次空间对有洁癖的我来说太过累赘，更倾向用数组的连续性来得到这个特性。\n\n直到看到s9的实现，才明白该其中决窍，引入一个和真实元素等长的标记可用数组，我称之为canuse，下标表示当前数组已使用或分配了多少个，再用一个整型值记录当前used个数。多出的canuse数组，类型选项uin8的话，可以将空间占用压到最少，代价就是每个块只有255，如果不够换uint16绰绰有余了。\n\n初始化用canuse[i]=i。每次增加元素，只要used没到上限，自增后从对应canuse位置取得真正可用块。释放则反过来，把分配块的下标，放在canuse[used]位置，再将used减1，不需要释放内存。\n\n上面的释放过程结束后，canuse数组元素内容从初始的顺序变乱序，但元素不会重复。这也要求决不允许同一个元素释放两次，目前没有做内部保护，要在外面清理。\n\n另一点稍微不方便的是，分配出去的块，必须要记住在数组的什么位置，否则归还时无法建立正确的映射。","modified":"20180910121530000","tags":"design"},
{"created":"20190520121530000","title":"域名和DNS的事","text":"\n自从2016年5月注册免费的DDNS域名，一直用却从未深究过其中原理。网上提供免费域名的服务商不少，几个知名的直接在路由器内嵌支持，如果不支持，通常服务商会提供客户端程序和DDNS服务器通信来达到解析效果，客户端有些从C语言编译，有些就是一行脚本。如果有一台低功率主机，也方便。\n\n以公云3322.org为例，不充钱的账号只能开通一个账号。而且登陆管理员的账号密码和域名保活的密码并不相同，一定要分开。\n\n域名的完整名称是Fully Qualified Domain Name,(FQDN)，由hostname+domain name组合而成。域名服务器并不限制FQDN，有些局域网只输入hostname也能找到服务器，这个hostname又称Partially qualified domain name。域名只能包含数字，字母和连字符(减号)。域名有顶级域名和壳域名，顶级域名有组织管理，个人要用必须要购买，而免费域名一定是壳域名，通常是公司买下顶级域名，并开放了其二级域名吸引用户去用，所以才会免费。如果有域名和静态IP，可以用dnspod.cn配置绑定。\n\nDNS是1985年出现的，在那之前ARPANET就有了host.txt方式记录IP和名字的对应关系，随着主机数量日渐增多，文本方式成为辅助，但仍在操作系统中存在。\n\n!! 域名解析\n\n查域名函数是gethostbyname，无论是宿主机或是k8s集群，DNS解析会依赖 /etc/host.conf 、 /etc/hosts 和 /etc/resolv.conf 这三个文件，查询顺序通过/etc/nsswtich.conf控制，由solaris发明，被linux继承，以libnss库的形式存在。简单讲解一下/etc/resolv.conf配置，每行都会以一个关键字开头，然后跟配置参数。在k8s集群中主要用到的关键词有3个。\n\n* nameserver   #定义 DNS 服务器的 IP 地址\n* search       #定义域名的搜索列表，当查询的域名中包含的 . 的数量少于 options.ndots 的值时，会依次匹配列表中的每个值\n* options      #定义域名查找时的配置信息\n\n!! DNS记录\n\n称为Resource Record(RR)，有如下几种类型\n\n* NS记录：Name Server，表示这个域名由谁来解析，通常买域名的厂商就是NS，当然也可以改成dnspod或cloudflare之类。\n* A记录： 域名到IP的映射关系，A表示Address。如果要映射到IPv6，称为AAAA记录\n* CNAME： 域名到域名的映射\n* MX记录：邮件交换记录，邮件服务器会用到\n* PTR：和A记录相反，从IP获取域名\n\nDNS是一棵庞大无比的树，具体实现时某一段子树往往归为一个DNS Zone。\n\n一个域名可以对应多条A记录，使用场景一是IP的负载均衡，二是不同运营商间智能匹配最佳线路。不过DNS不会检测IP存活，需要额外的检测和更新机制配合。\n\n!! CNAME绑定\n\n比如阿里云的域名指定了CNAME到3322，就行了。但想转到github pages却不能成功，必须在pages的repo增加CNAME文件，里面写上阿里云的域名，才能实现域名跳转。\n\n上述虽然要双向配置，但毕竟能在浏览器直接打开。而冰雪提供的绑定CNAME只能用于绑定，直接打开显示的永远是同一个首页。可能是虚机的缘故，靠入口域名做映射，这种情况显然单向绑定是不够的。\n\n!! WHOIS和IANA\n\n通过whois可以查到域名在哪个分销商注册的。全球的域名分销商都会向IANA机构注册，并被分配一个IANA数字编号，见过292-1479范围的。每个分销商通常会有多个域名解析服务器地址，数量在2-8个不等。\n\nWHOIS只能查到一级分销商，看不到个人或企业的详细信息。","modified":"20190520121530000","tags":"net"},
{"created":"20190524121530000","title":"远程文件传输说明","text":"\n由于安全性的关系，很多新系统默认不提供FTP功能，要交互文件就需要别的方式，好在SSH整合了SFTP子系统。不用额外启动守护，只要`sshd_config`配置中增加一项`Subsystem  sftp  /bin/sftp-server`，就能使用了。要注意的是，有些发行版把sshd和sftp分成两个包，如果出现校验密码成功但连接被断开的错误，很可能要单独安装sftp。\n\nsftp利用SSH加密通道进行文件传输，它借用了FTP的指令，但基础是SSH加密，严格地说并不算FTP协议。\n\n另一种叫FTPS，类似HTTPS，本质是FTP over TLS的方式，使用的指令和FTP完全相同，不过支持的软件（服务端和客户端）都比较少。\n\n除了FTP模式，用scp传输文件更通用，出现过winscp用FTP和SFTP始终无法连接上，但用scp模式成功的情况。scp本身不常驻后台，监听的还是sshd，但是当外部连接到来后，sshd会调用scp完成文件传输，所以当SFTP不可用但ssh可以连上时，不妨用scp来传文件。\n\nscp和ssh同属一个包，但scp是基于rcp程序改写的，因此选项风格很不一样。比如指定远程端口，ssh是-p而scp是-P(大小写是反的)。指定远程用户，ssh用-l，而scp却是username@hostname:fileposition这种格式。另外scp不仅要求本机有scp，对端也必须有scp才能完成传输，否则在验证结束后，会报`sh: scp: not found`错误，之后连接就断开了(lost connection)。\n\n如果没有装scp，winscp可以浏览文件夹但不能复制，说明scp没有浏览命令，必须和ssh配合使用，从复制文件的角度看，scp更纯粹，当然功能也更弱，不支持断点续传。而sftp是完整的文件传输方案。有独立的浏览命令，支持断点续传。openssh实现的scp，从8.8版本开始，默认使用sftp协议，但是如果服务端不支持，也可以用`scp -O`回退到scp协议复制文件。\n\n如果连scp也没有，rsync -e \"ssh -l user\"能达到相同效果(未验证)。\n\n!! rsync使用说明\n\n作为远程同步工具，支持ssh和rsync两种协议，如果是rsync协议，客户端使用`rsync -av ip::archive/img/ img`，值得一说的是`::archive`这段，::表示使用rsync协议，archive则指代服务端的一个module，可以用`rsync ip::`查看远端所有的module列表，如果有module，使用`rsync ip::modname`查看，并可递归查看mod下的文件夹。服务端先配置好/etc/rsyncd.conf后，再rsync --daemon会监听873端口。配置rsyncd.conf的module时，除了path外，如果遇到无权限问题，再加上uid=0和gid=0就可以解决。\n\n如果对端机器不是默认22端口的话，同步时候要加上 -e \"ssh -p port\"，rsync -avzP -s \"ssh -p 22\" /tmp/ itv@ip:/home/itv/","modified":"20190524121530000","tags":"tool"},
{"created":"20170621121530000","title":"云升级项目的反思","text":"\n这个项目大概是我在大华经历最失败的项目了，因为不确定最初的需求到底是什么，我自己的理解应该只是客户无法下载升级包，如果是这样提供工具可以\n下载升级，而不是执着于必须由设备主动从云下载。\n\n嵌入式设备的升级包包含的分区非常多，比如一个典型的NVR升级包，去掉签名包还有6个分区，分别是uBoot、kernel、rootfs、web、custom、logo。前三个是执行所不可少的，web一般来说也是必须的，custom和logo则和公司的商业模式有关，因为有些大的OEM商不会修改功能，只要把logo换掉，最多把web界面的配色换了就可以，所以这两个分区独立是有价值的，custom分区则给一些小的定制功能使用，通过配置来打开/关闭某些功能。uboot和kernel不需多说，rootfs包括了执行程序，和busybox等接触最多的程序。\n\n正是因为多个分区具有独立升级的需求，导致需求分散极难实现。\n\n因为云升级项目考虑到法务上的风险(不明白为什么会有这样的顾虑？)，在初始化的阶段又加入一个云升级自动检测的开关，最初在做初始化需求的时候并没有考虑会有多个步骤，认为只要账号初始化整个过程就完成了。结果多了一个步骤后，导致原来一个原子化的操作有了状态。一旦有了状态，就必然要考虑中间的异常情况，另外还涉及到多个库间的兼容性问题，变得非常难处理。\n\n经过一个星期的理解，突然意识到云升级自动检测、云接入并不是必须的，和账号初始化的重要性不同，云升级只是个可选项，并不影响设备的使用，因此就不应该和初始化使用同一个状态机。把云接入总结为开机向导的概念，和初始化分离开。所以协议最重视的，就是概念或定义一定要清晰，市场或需求包会统称为初始化，但在程序实施时必须要把不同的概念分开处理。\n\n考虑到云升级可能会没有网络(神设定啊！)又在NVR上增加一层代理设计。代理本身是个专门的领域也有专门的SOCK5协议，但由于时间关系显然不可能集成SOCK5的情况下，领导安排手动实现一个代理，且最好两端都能做到无感知。可是显然是不可能的，因为作为代理方，必须要知道下一跳去哪里，或者说请求发必须要知道代理的存在，这个下一跳的存在就不可能作到和直连完全等价，因此一定有一方需要做出区分。但是总有人妄图用一套接口实现两个流程，可惜当时没能把下一跳这个关键点亮出来，花了很多唇舌才说服众人保持方案不变。","modified":"20170621121530000","tags":"design"},
{"created":"20150719121530000","title":"在CentOS和FreeBSD上安装OpenResty的一些记录","text":"\n花了两个周末的时间，分别在CentOS6.6和FreeBSD10.1上安装并跑起了OpenResty，虽说没什么技术难度，但有些遇到的问题还是记录一下，方便以后查找。\n\n一开始我是想在cygwin上编译，但是卡在MAP_BIT32宏上过不去，想想cygwin毕竟只够练手，真正的编译还得用正牌的系统，就装上了VMWare9，上真正的OS。\n\n先说CentOS，这个问题比较少，因为我的硬盘和内存都不足，所以下的是CentOS6.6的minimal版，默认的安装包非常少，像GCC、Perl、OpenSSL都没有，好在yum非常成熟，这些很快就装好了。但有两个问题要说一下：\n\n1.安装完系统，没有eth网卡，通过ifconfig只能看到lo，不知道为什么采用这么谨慎的策略。简单地话通过ifup eth0就行了，但关机就不行了，还是得改/etc/sysconfig/network-script/ifcfg-eth0，把ONBOOT=yes写上，这样从windows才能访问虚拟机。\n\n2.编译和安装其实问题都不大，一把直接过，但nginx启动后，windows下却怎么也连不上，始终报超时。netstat看到端口是开放的，ssh也能用啊。这个问题想了一个多小时，改nginx配置不少于10次始终无果，最后终于有网上文章说是防火墙作祟，最后chkconfig iptables off一把，问题解决。今天再看，发现CentOS默认是打开SELinux的，也许这就是原因吧，SELinux还没细研究，总之能用就算OK了。\n\n再说FreeBSD，这个问题就麻烦多了，由于文档少，国内用得人不多，理解它的ports系统就花了很久。我以10这个版本说说：\n\nports是以源代码编译为导向的软件包机制，又名ports collection，这是BSD家族的正牌安装方式，默认安装时如果没有装，需要通过portsnap工具先生成目录结构。原理就是在/usr/ports/下生成一个巨大的目录树，其中的顶级的Makefile和README等文件，各种软件又按类别放在子目录下，比如devel/、www/等等。因为顶级有Makefile，所以可以在/usr/ports目录下通过make执行查找，（其实用whereis命令更简单）。要安装时，再进到具体的目录，通过make install方式就自动编译装好了，在这个目录的Makefile会记录源代码的下载地址、编译选项等等。默认不需要configure，这点比较方便。ports也是需要更新的repository，更新工具就是portsnap fetch命令。第一次要执行portsnap extract，但这个操作非常耗时，执行一次以后就不要再执行了。下载后的repository保存在/var/db/portsnap/目录下，都是分散的文件，我目前的版本有大概2万5千个文件。\n\n但每次都要自己编译未免太费时间，于是就有了直接下载编译好的文件方式，这就是pkg。在版本10以前，是pkg_***工具集，到10之后，统一成pkg一个命令。所以官方对pkg的命名是pkgng以示区别。在执行之间一样要先下载repository，使用pkg update命令。但默认的repository用的美西服务器，速度太慢，始终只有10k，导致update一直无法完成，好像是FreeBSD不同意其它网站同步源，国内源很少，也许根本没有。只能在pkg.freebsd.org上找，最后尝试了pkg0.ydx.freebsd.org后，速度终于上到20～30k，总算完成了pkg update。和ports不一样，pkg方式是保存在/var/db/pkg/repo.sqlite文件里，就是个sqlite3的文件，里面记录了2万5千个软件的地址、描述信息等。除了ydx源，2017年6月又发现了几个新源：\n\n* pkg0.bme.freebsd.org\n* pkg0.nyi.freebsd.org\n* pkg0.isc.freebsd.org\n* pkg1.chinafreebsd.cn\n\nupdate完成后，后面的安装软件就顺利了，把OpenResty依赖的包装上，需要注意的是，OpenResty是用gmake编译的，在Linux下，就等同于make，但FreeBSD的make却不同于gmake，所以还要另外再安装gmake。我自己也手欠，装了个gmake-lite，真搞不懂make这么个小玩意还有lite版。结果还是报错，于是又对gmake-lite做了个软链接生成gmake，接下来的编译都很顺利了。编译并安装后，从windows访问也没有问题。\n\n不管CentOS和FreeBSD，编译都不是问题，说明OpenResty的软件包做得很好，主要还是对系统的配置等外围工作花费时间。","modified":"20150719121530000","tags":"os"},
{"created":"20180920121530000","title":"指针的三种面貌","text":"\n起因是同事发了一段C语言的汇编代码，理解不透，代码如下\n\n```\nifAddrSt = ifAddrSt->ifa_next;\n\n0x00000000004006a5 \u003C+221>:  mov  -0x10(%rbp),%rax\n0x00000000004006a9 \u003C+225>:  mov  (%rax),%rax\n0x00000000004006ac \u003C+228>:  mov  %rax,-0x10(%rbp)\n```\n\n能看出把rbp-10位置上的值做了一通操作后赋值回自身，但是为什么是两次取地址非常迷惑。\n\n在分析汇编之前，先想明白指针的几种表示和对应的汇编形式。先说普通的变量，比如最简单的`int i=1;`这条语句，i就有两种形式，i和&i。&i是i这个变量的地址，对应rbp加减一定的偏移量。实际代码中很少会用到&i，大多数时候都是用i，也就是&i地址存放的值，这个值对应的汇编就是(%rbp)。\n\n说完普通变量，再看指针。指针除了上述两种形式，还多了提领`*`操作。因此对于`char* p;`，rbp就对应&p，(rbp)才是p。`p->next`的操作可以等价为`*p.next`，因此才有了刚才汇编中的前两句，对rbp做了两次取址操作就好理解了。\n\n# 第一句(%rbp)将ifAddrSt放到%rax寄存器\n# 第二句等效的C语言是`*ifAddrSt->offset 0`，所以(%rax)就够了，不需要偏移\n# 第三句将值重新写回ifAddrSt，此时不用提领%rax，值写入(%rbp)。","modified":"20180920121530000","tags":"lang"},
{"created":"20170814121530000","title":"重新认识Makefile","text":"\n不要片面地把Makefile理解成程序编译工具，更广义地说是个基于文件依赖关系的管理工具。可以通过make制定规则、调用shell命令，也可以在Makefile中定义变量、条件和函数调用实现复杂的功能。\n\nMakefile包含五种块，显式规则、隐式规则、变量定义、指令和注释。最核心概念是规则rule。显式或隐式规则格式类似：\n\n```\nTARGET ... : PREREQUISITES ...\n        RECIPE1\n        RECIPE2\n```\n\nTARGET可以表示一个文件名或动作名(Phony Target)，PREREQUISITES是文件列表，并作为TARGET的输入。隐式规则的区别是有且只有一个`%`，用于匹配文件名，通常是文件类型的替换。\n\n先说TARGET，因为含有两个意思，如果指定的目标名恰好有个同名文件，文件名会优先于动作名。常见的all/clean规则一般表示的是动作名，如果Makefile所在的目录中恰好有文件名是all，那你就等着看all is update to date吧。要避免这种错误，就必须显式地声明Phony Target，告诉make不要管那个同名文件，使用的语法是`.Phony : all clean`。\n\n之所以有时候不指定phony，执行make clean也能成功，是因为make按文件名先去找clean文件，找不到才去执行该规则的动作，而该动作通常无论如何都不会生成一个clean文件，因此不写phony也没有问题。\n\n但以上说的是clean这种没有依赖的目标，如果有依赖，情况又不一样了：\n\n假设目录中有个clean文件，按说执行make clean是不会有动作的。但当我们把目标写成 clean : *.o的时候，执行clean目标需要先找到.o文件，这时make就不理会有没有clean文件，而是去查找.o的隐式规则，找到后去生成.o文件，如果clean的recipe又恰好是删除操作，又会把关联的.o再删除一遍，很无厘头吧。做这个测试也只是为了理解make的运行规则。\n\n其实理顺了make的规则也就那么几点，无非就是显式/隐式规则的目标查找和一些内建函数的用法以及一些奇怪的变量名，好在我看来常用的特殊变量就三个，也有点规律。像$^就是显示规则中:后面依赖项，另外$\u003C和$@则是隐式规则的源和目标，\u003C表示源，@表示目标，基本上勉强能算上字面意思吧。\n\n原始的Makefile的变量定义比较简单，只有`=`一种定义，`=`在使用时会递归地查找右边变量的定义，有时会引起不希望的副作用，GNU make引入了`:=`避免递归问题。另外还定义`?=`和`+=`两种赋值符，分别表示不存在才赋值和追加赋值。\n\n除了变量，还支持很多函数功能进而实现很方便的操作。比如要找到所有含有jpg图片的目录，就可以这样：\n\n```\nSUBDIRS = $(sort $(dir $(wildcard */*.jpg */*.jpeg)))\nprint:\n        @echo $(SUBDIRS)\n```\n\n函数调用语句和变量引用是类似的，先用wildcard尝试通配jpg或jpeg的文件名，剩下的dir和sort是因为不关心图片内容，只要文件夹名。sort带去重功能，可有可无。\n\n命令前带@表示不打印命令本身，还有个更有用的前缀-，表示即使这行命令出错，也继续执行。比如-include，如果找不到要包含的文件，不会停下来，make会提示Error 1(ignored)且继续运行。直到遇到TARGET无法达成才报错，并显示`***`，也可以显示调用$(error your prompot)来提示错误。-可能是GNU扩展，如果要通用化，最好用sinclude代替。\n\n!! automake\n\n1994年9月第一次提交，依赖于1992年开发的autoconf和更基础的m4。automake和autoconf的版本号演进各自独立，似乎不是一个团队开发。其做法从最初就没有大变化，从`*.am`文件生成`*.in`文件，只是规模从最初的500行代码发展到如今几万行规模。","modified":"20170814121530000","tags":"tool"},
{"created":"20170207121530000","title":"仔细打磨写过的程序","text":"\n从去年12月到最近，把公司内的AppWiki网站还有这个博客网站的代码，重新进行了调整，颇多感触。\n\n比如代码中早期很多地方因为求快都是HardCode，最典型的比如AppWiki\n的更新日期居然都是每天手动修改PHP，直到昨天才忽然想到可以利用\nstat函数取出数据库文件的mtime来自动更新，把依赖降到数据库文件本身。\n同样如博客的首页，原来是手写的2016、2017年，过了一年还要手动创建目录，改成每页固定显示10篇，\n用下部的页号签来自动导引。凡此种种都是让整个网站环环相扣，互相关联，自然就能有牵一发而动全身。\n\n还有就是AppWiki的解析代码，因为发现Win7的cmd用chcp65001转成UTF-8的显示效果比XP好了很多，就切过来了。但是原来的代码由于用\nls来判断文件是否被更新，就依赖于终端的编码环境，造成移植的困难，\n加之需要批处理、VBScript和Lua三种语言共同使用，\n在Windows下速度慢不说，还屡次因不熟悉VBScript而苦恼，\n后来发现核心的VBS就三行代码，用luacom实现也不难，中途还顺手编译了luaiconv\n解决GBK到UTF-8的问题。整个切换完用一种语言实现，不仅速度快了，\n代码文件和中间文件也变少了。(因为不同语言只能靠中间文件来交互，导致目录下非常凌乱而难看)\n\n新的段落式解析代码，也一直有bug，多个文件只能解析第一个文件，\n当时不愿意解决，就用批处理的方式分次处理，后来为了提高自动化程度，\n把批处理也改用Lua来实现，就必须解决这个bug，直到早上通过打印才发现原来是解析完第一个文件后，协程状态就变成dead了。\n原因是协程代码在结束时用了return，必然会导致dead。\n这是我第一次用协程，对语义不熟悉造成的。\n一个dead的协程无法resume，而我整个程序始终用这个协程变量处理文件，\n所以超过一个文件就失败了。找到这个问题后，顺带发现原来的协程变量还是全局的，坏味道。把协程变量的范围缩小到函数内，并增加了协程状态判断，\n保证每个新的文件解析开始创建一个新协程，解决问题。\n然后也按照三代协议解析代码重构的思路，用lua实现了比较文件时间，生成HTML和SQL并写数据库等配套环节。重构后的流程非常清晰，\n增加一份文档只要三步：\n\n# 在man.old里添加源Word名称、更新时间和输出HTML名(这里必须用GBK，没办法)\n# 在解析代码增加一个入口，并确定文件的归类(我用了生物学上的Tribe)和层级，\n这个环节必须要人工干预\n# SQL脚本里加一项.read xxx.sql\n\n三个步骤分别对应Word->HTML->SQL->DB，任何人接手都能很简单地增加文档了。\n3月份的时候又做了一次合并，把1和2的内容都记入man.old，再通过中间得到的差分结果来生成SQL脚本，\n因此需要个性的就只有一个文件，是目前能想到的极限了。\n写代码是个不断打磨自己思路的过程，让流程更自然，环节更严密。","modified":"20170207121530000","tags":"design"},
{"created":"20181103121530000","title":"字符编码与字体映射","text":"\n早期计算机的字符编码基本上都是6位。所以早期计算机的整形的字长一般是6的倍数，如18位、24位、36位等。1963年公布的ASCII码是第一个得到广泛采用的7位字符编码。这时的通信领域的协议采用了第8位做校验纠错用途。但是对于计算机内存来说，校验纠错变得不是必要。因此8位字符编码逐渐出现，用来表示比ASCII码更多的字符。为此，1971年公布的ECMA-35标准，用来规定各种7位或8位字符编码应当遵从的共同规则。随后ECMA-35被采纳为ISO 2022。\n\n\n字符编码追求的是\n\n# 表示的字符足够多\n# 表示常用意思时占用内存足够小\n\n汉字有GB2312和Unicode编码，字符编码是字符的数字表示，一套字符集相当于一个命名空间，空间里的每一个元素代表一个唯一的字符。不同字符编码方式对应同一个字符的字面值不同。区位码的「区位」即「row-cell」，日语称「区点」\n\nGB2312釆用94x94的区位码，顺带一句日语的JIS0208也是94x94。符合ISO2022定义的用7位双字节编码（共128*128），为了避开ASCII编码中的控制字符（0~31和127DEL）以及空格符（32），最后只剩下94位可用。至于0x9A~0xFF这些空间是国标码变形后得来的。设计时采用的是区位码，有了区位码才会在编码空间上作映射。区位定义：\n\n* 01-09区为特殊符号。\n* 16-55区为一级汉字，按拼音排序。\n* 56-87区为二级汉字，按部首/笔画排序。\n* 10-15区及88-94区则未有编码。\n\n共计72区的汉字，在区码为215，位码为250-254之间共五个编码没有汉字编码，所以一共72x94-5=6763个汉字。\n\n不管选哪种，最终用黑体字比如simhei.ttf都能正确渲染，原理如下。\n\n首先字体内部是有一个自己的编码号的，用于索引图元（Glyph），但是外界不会知道它。字体内部的各种数据比如 GSUB 和 GPOS 都是用这个索引号编的。\n\n将图元和文字关联起来的东西是 cmap 表，这表的格式十分多，用来支持不同的外部编码：最常用的 UCS-2 外部编码（FontForge 里面称 UnicodeBMP）使用 Format 4，UCS-4 外部编码（FontForge 称 UnicodeFull）使用 Format 8、Format 12 等。\n\n然后是绘图的时候，WINAPI 或者其他的 API 会对文字编码进行转换。Windows 是默认把其他编码转换成 UTF16LE ，兼容早前版本API用的UCS2格式。","modified":"20181103121530000","tags":"design"},
{"created":"20180923121530000","title":"自制编程语言的历程","text":"\n尽管还存在缺陷，即便如此从9月16号开始重新启程，已经比过往强得太多。大约从2009年便有实现一门语言的想法，如今看到希望，虽然很简陋，却也算原型完备，令心结解开，不再纠结于要不要学习新的语言。\n\n词法和语法都是工具生成，不在此文罗列，主要从归约出生成语法后的事。\n\n!! 转译到字节码\n\n除了从源码执行，还可以从字节码执行，而源码又能输出成字节码（反之也可以，但那更多是破解用）。字节码通常不能无脑序列化，会有个非常简单的重组过程，三者构成如下关系。\n\n```\nSource-----|\n         VM(IR)---Run\nSerial-----|\n```\n\n最初是雄心勃勃想按二进制定长方式指令，但发现融合常量池的实现周期太长，为了验证可行性，还是全部用可打印字符，便于调试。格式很简洁，一字节指令加上用逗号分割的指令数，最后用分号结尾。如果是顺序指令，将每条连在一起就构成完整指令。\n\n顺序其实不值一提，函数、分支、循环才是三个最难的部分。理论上循环可以由分支和尾调用替代，从字节码实现看，确有相似性。\n\n先说函数，这是十年前最让我头疼的难关，甚至在想明白用字节码做为间接层后，仍为返回值该放哪里思考良久。函数必不可少的成分有二，指令和环境。指令永远不变而环境可链表，递归处理时要做好保护和复原。指令可以持久化而环境不需要，这两个阶段用不同的结构会更好，而在传递中指令最好能做到所有权转移。\n\n环境除了保存局部变量，还要保存入参。每次调用相当于两个环境间的数据复制。我现在的做法，得到指令码还捆绑一个环境的做法是错误的。\n\n!! 转译到另一种语言\n\n业界对此有专门的叫法transpiler，比较难的点是对嵌套结构的处理，自然地统一用cons/car/cdr方式来表达，在实现时为求简单，把值也保存在cons。cons看似简单，其实可以表示树和链表结构（不使用car就是单链表）。\n\nC语言在表示链表移动时，要分配内存和链表移动放一起，否则很容易引起内存分配了，但链表没有指向新分配的内存。","modified":"20180923121530000","tags":"lang"},
{"created":"20191101121530000","title":"子进程执行和信号","text":"\nsystem(2)调用子进程非常方便，返回类型int，但不是脚本真正的返回值，对待这个返回值，要先用WIFEXITED是否非0，非0表示成功，再用WEXITSTATUS取返回值。从命名上看，表示只有EXIT了，才能取STATUS。从数值角度看，返回值由低8位和高24位构成。我只见过低8位全0的情况，不知道什么情况下低8位不是0。\n\n有个类似的函数族execve，也是执行命令，但它会放弃当前进程空间数据，切换到待执行的进程，因此exec必须在fork出的子进程执行，好处就是不会阻塞，这也是shell下执行命令的机制。\n\n要想让执行中的进程停止，可以用信号量，kill如果不带参数，发的是TERM信号，不是KILL。TERM可以通过TRAP或函数方式捕捉，进而在被信号触发后做一些保存工作再退出，而KILL不能被捕捉，一旦收到必须退出，因此在关进程时，优先用kill，迫不得已再用kill -9。\n\n并不是所有信号都会使进程退出，像SIGSTOP和SIGCONT则是使进程暂停和继续，在STOP状态的进程只是暂停，不算异常，因此system还有个判断状态函数WIFSIGNALED表示非EXITED且非STOP才是被信号了。也可以用trap命令修改信号对应的行为（再强调一次，不能捕获KILL）。\n\n而termux有个bug，SEGV不一定能捕捉到，有时要第二或第三次才会退出。\n\nHUP信号，所有网上教程都说后台进程在终端退出时会被杀掉，所以要加nohup命令。实际测试并不是这样，不管是exit/logout或者直接断掉终端并不会使后台退出，只有手动kill掉这个会话的sshd进程，才会导致后台退出。实际中几乎没有人会刻意地找出这个sshd的pid，所以只进后台不用nohup在绝大部分场景下都没有问题。用`&`进入后台的进程，TTY编号会变成和前台不同但仍会绑定一个，exit的后台进程才会显示`?`。\n\n要解释这个问题，要从基本概念说起\n\n* terminal，简称tty，DEV号5,0。包裹着shell提供输入输出，可以有多个，类似电视的遥控器。有个系统函数`char* ttyname(int fd)`，会返回句柄所绑定的tty，实测0, 1, 2这几个标准句柄对应的tty是相同的（不确定是否有方式修改）。\n* console，DEV号5,1。最早的主机在启动完成前不能接入terminal，在启动和关闭阶段的日志会在console上显示，可以是一些灯或磁碟机，至多一个，类似电视的面板按钮\n* pty，虚拟终端，ssh就是网络化的pty。之所以会有这个概念，是因为terminal会在设备驱动和系统读写函数间，有一个内部的转换层，但网络化缺少了这层。为了保持一致性，将网络源也抽象为终端，像串口的波特率概念还保留，比如我测试结果输入输出的波特率都是38400。pty映射到软件上的实体是pts，unix特性，linux内核的2.1.93版正式支持该特性。对应devpts文件系统，一般挂在/dev/pts下。是个主从结构，主只有1个，名字固定为/dev/ptmx，DEV号5,2。从的名字从主获取，`df=open(\"/dev/ptmx\") or getpt();ptsname(df);`。从的名字格式是/dev/pts/xx，每增加一个虚拟终端就增加一个。\n\nhangup的原意是挂断电传打字tty，引申后就是pts即ssh，所以用exit只是退出shell，并没有关闭外覆的sshd，不触发HUP信号的原因就在于此。\n\n在安卓6上遇到ssh登陆后提示`PTY allocation request failed on channel 0`错误，可能是关闭了ptmx所致。这就会出现ssh连接成功后，只有bash内置命令(pwd)能显示出来，其它即便执行也看不到结果。\n\n!! 容器化的应对\n\n容器鼓励只有1个进程，而普通的shell进程并不能转发信号，有两种做法\n\n# 用exec把作为entrypoint的shell进程替换为真正的程序，适合redis/mysql用途单一的容器\n# 用dumb-init或tini等专有的容器化1号进程作为启动，代替系统级的1号进程init\n","modified":"20191101121530000","tags":"os"},
{"created":"20170530121530000","title":"组件化与线程模型及缺陷","text":"\n今天夏杰和我看了他的PPT，讲到组件化在实现过程中留下的缺点，很值得反思。\n\n组件化以类为单位，并提供接口给外部操作。这种开发模式更像是提供一堆的工具类，而不是程序的框架。因此在开发时，必须要另外提供线程模型来执行这些组件，对设备而言，线程就在各个接入协议里自顾自地跑起来了。这样带来两个问题\n\n# 随着接入协议变多，线程池和线程数量肯定会越来越多。\n# 对组件实现者而言，由于不确实组件的执行环境，为了确保多线程安全，最简单粗暴的做法就是大量的加锁，所以代码中经常可见不知有用还是无用的锁。\n\n原因就是程序是静态的代码组织和动态的代码执行两部分组成的，组件化解决了面条代码的问题，但在大华的执行期上却处理得很糟糕，虽然有RPCFramework这一理论上可用的公用业务线程池，比如Onvif也可以把请求转交到这里执行，但想用RPCFramework却强依赖继承的方式，侵入性太高，且接口又过度地和大华私有业务绑定，导致三方接入库不愿意用。\n\n分析下来，也不能全怪组件化，只是它缺少一个好的动态运行框架，才导致组件层面实现沉重无比。下一步就是要想办法提出一个好的动态运行模型，和组件化一起承担完整的业务模型。\n\n通过给NetSDK培训了协议和组件化的课件，也让我自己梳理出如果从协议角度看组件化，最核心的概念就是反射。根据字符串消息，找到类和方法进而执行。\n公司的组件化从接口层看就是带了工厂的类，但从全局的角度看其实是更大粒度的模块。一个组件的接口可以由很多个类来分担实现，每个实现类可以具备自己的public接口，但并不是所有实现类的public接口都需要暴露给组件层面。\n组件更多的是用于外部网络或者不同库之间的协作，包含的功能会更大一些。既然组件是不同库之间的契约，因此参数就更需要明确，不能使用Json式的灵活接口。\n\n6月份7日追记：\n\n由于组件化又和RPC协议联合使用，而RPC方式即意味着一个请求到来变成了对另一个模块的调用，这种模式对测试很不友好，只能打桩测或者整体测试了。如果整体测，出了问题无法确定出在哪个模块，而打桩测又必须对接口有很严格的定义，而大华接口定义的不严谨根本无法支撑打桩所需要的提前。\n\n软件作为一个新兴行业，只要验证和测试这关难过，就无法成为一个成熟的行业。硬件由于物理的限制，一个特性呈现出的行为是固定的，而软件因为完全由人实现，几乎可以达到无限的自由度，因此对接口的定义一定要严格，否则可测试性也就无从谈起。","modified":"20170530121530000","tags":"design"},
{"created":"20151006121530000","title":"Andoird上用kbox模拟linux环境","text":"\n随着这几年安卓机的军备竞赛，一拨拨的性能“落后”的旧手机被淘汰下来闲置在家，却又不能发挥作用。手头就有一个13年的老机，A8单核，1G内存放在角落蒙灰已经一年多了，想想自己好歹算个程序员，这个设备不利用起来甚是可惜，这些年也不爱折腾设备了，这次国庆闲来有空，就想着把安卓装个linux，多少也能跑个apache搭个服务器，多少也算物尽其用。\n\n由于是老机，root挺顺利的，顺便熟悉了下adb和fastboot的一些命令。安装好busybox，按说明busybox是自带httpd的，但是只有httpd没有PHP或其它脚本，这服务器也是没什么实际价值，还好集成PHP的APK非常丰富，比如anmpp这个项目，在android上部署nginx、mysql、php和postgre，可以实现一个完整的服务器功能。要注意apk只是个UI，毕竟体积摆那儿，还需要另外下载anmpp.zip包才行，第一次不知为何下载下来的二进制包不正确，解压后无法运行，又重新下了一次，运行后用浏览器打开，熟悉的phpinfo界面弹出，这算是基本可用了。有了服务器，再配上路由自带的花生壳域名绑定，这样随便在哪里，都可以访问自己的网页了，不用花一分钱，而且因为是手机还特别省电，非常好。\n\n!! kbox\n\n到2019年2月，kbox共4个版本，kbox1已经不维护，kbox2在ls时总有些小问题，\n加上busybox带的工具似乎-h选项总是没用，kbox4安装不成功，只能用kbox3。按作者自己的介绍，\nkbox3是为Android5适配的，但我刷了Andoird5.1再安装kbox3总是报dlopen not found，\n一度只能在Android4.4下使用kbox3。直到有一天偶然在stackoverflow上看到有人提和我一样的问题，\n才在这个页面的2015年6月30日日志下看到月个fix版的libfakechroot.so可以下载，\n将这个重命名成libfakechroot.so并替换原来/lib/下的文件，Android5下也可以用kbox3了。\nkbox用deb的包格式，所说是busybox支持，所以工作量可以少一点。\n\nkbox3配备的GCC版本是4.9，但默认安装后，哪怕编译最简单的文件，也会报cannot create temporary file in /tmp/:错误，我按这个关键字，\n都说是TMPDIR环境变量设置有问题，可我看脚本写的TMPDIR=/tmp却看不出错误，\n换成/home，就报类似的/home/:错误，导致我一直以为是多了后面的:引起的路径非法。\n因为手头还有一部Andoird4.4上跑的是GCC4.7没有问题，再看GCC4.7的写法，\n是TMPDIR=$KBOX/tmp，再看KBOX=/data/data/jackpal.androidterm，并按这个方式改写了GCC4.9，\n终于成功运行，虽然还会报unused DT type 0x1d in libmpc.so之类，\n在另一篇文章中看到，通过readelf -d libmpc.so可以看到0x1d段类型是RUNPATH的信息段，即使丢弃也没有影响，这才放心。\n\n那么为什么GCC在kbox下一定要写成TMPDIR=$KBOX/tmp这种完整写法，其它软件却没有这个问题呢？\n联想到上面提到的libfakechroot问题，查了些资料，大概是这样的：\n因为kbox旨在未root的手机上安装类linux环境，但显然安卓的app是被安装到/data/data目录下各自的目录，\n因此就需要伪造一个根目录环境，这也是fake这个名字的由来。\nfakechroot的原理，就是改写环境变量LD_PRELOAD=/data/data/.../lib/fakechroot.so，\n让linker先行加载这个动态库，并在这个库中提供open/chroot/dlopen等一系列接口，\n让程序以为自己是在/目录下。但是也许是GCC没有用到linker动态加载（似乎说得通），\n所以当TMPDIR目录直接写成/tmp，找到的是安卓设备真正的/tmp，显然kbox无法向这个目录写入数据，因此一直不能正常运行。\n可惜kbox的作者在GCC4.7版本中并未注释TMPDIR必须是完整路径，可能在了解的人看来，这不值一提吧。\n\ngit也有点小问题，连接https域名会报ssl证书不对，解决方法是git config --global http.sslVerify false去掉校验即可。\n\n另外Andoird5.1上的dropbear无法使用，提示不是position independent execution。\n难道作者自己都没有测试过吗？还好有utelnet程序，这个程序虽然能跑，\n却每次在putty上输入用户名就结束，看帮助文档才发现需要utelnetd -l /bin/bash指定程序才可以。\n作者给dropbear作了一个sshd_daemon.sh的wrap脚本，参数很多，其中-A,-U,-G,-N,-C这5个，\n都是为了解决Android系统去掉了用户概念导致程序不兼容。\ntelnet也可以作个类似的wrap脚本。用telnet连上后速度好像比ssh稍快，shell下显示也正常，\n但vim打开文件，显示的行数只有20行，似乎是哪个TERM的参数没有设置对，这个问题暂时还没有解决掉，留待以后。\n\nroot与非root安装linux的区别是这样的：没有root的设备最麻烦的就是权限问题，虽然是你的手机，可是程序却不能随意地写和执行，如果是root过的手机，就可以很明显地在/data/data目录下看到，每个程序的用户名都是不一样的，类似app12这样带了数字(当然会有些预装app的用户名是system，这种会有多个)，由于每个程序只能在自己的目录下为所欲为(这样也防止了程序往SD卡乱写)，因此kbox的安装包必须要放在这个jackpal目录下。所以我通过电脑把安装包放到SD卡，在terminal看来却是root用户，好在SD卡可读，于是通过cat命令把安装包移到jackpal目录下(原生可能没有mv)，然后在jackpal下运行。kbox的网站提供了一些deb包，像coreutils、dropbear、gcc等，下载到本机用dpkg安装，因为只是个人作品，没有仓库也没有apt。建议先装dropbear，是个轻量级的ssh server，有了这个就可以通过电脑来远程执行手机上的命令了。由于安卓的单用户特性，dropbear提供了6个专门的选项，好在作者提供了`ssh_daemon.sh`可供学习。kbox上提供的最重量级的是gcc，拿lua试编译了一次，问题多多，列举如下\n\nlocale.h里的localeconv()->decimal_point[0]这个函数是个假实现，原因是bionic C库把它阉割了，导致编译不过，好在这个地方直接写死返回'.'就行，然后没有ranlib命令，更坑的是ar好像也不支持s选项，其实原因是默认的ar是指向busybox的软链接，功能不完整。只要找到gcc所在的真实目录，在PATH路径下做个软链接或写个shell脚本，再删除原来指向busybox的ar以可以用解决了。最后在链接时又报没有log2，看了源代码这个是属于C89后加入的函数，看来bionic把这个也给阉割了，唉，还好luaconf.h已经预料到这种情况，打开C89宏，总算编译成功了。\n\n看了kbox3，也是对android的C库各种吐槽，包括奇怪的权限设置、服务缺失、乱用UID、奇葩的API等等问题，连lua这么简单的程序都被编译得如此恶心，想来那些大神们只会遇到更奇怪的问题吧。\n\n折腾半个下午加晚上，以后配上一个键盘，至少出门在外可以简单地用手机做点事情了，前提是最好有个大点的屏幕。等有空再试试kbox3，或者GNURoot Wheezy等类似的非Root版linux，手机也要发挥工作机的作用才行。\n\nkbox只能算半截的工程，它不是完整的apk程序，而是依赖能提供shell环境的apk，并利用这个环境内可写可执行(/sdcard只能写，不能执行也不能创建软链接)，构造一个属于kbox的环境。而Termux，相当于把kbox做的事情和apk整合到一起。","modified":"20151006121530000","tags":"os"},
{"created":"20190215121530000","title":"Android安装Linux环境","text":"\n15年时试用过kbox，毕竟是个半成品，到2019年2月，安卓跑终端已经很成熟了。和Linux比，安卓的模拟环境是单用户且用户名已预置，在4.2以前，用户名就是个序号，4.2之后扩充形成类似`u0_a99`的命名方式，但本质还是单用户，且没有密码。home目录下不会再有子目录，自然不能创建新用户。\n\n已经root可以用linux deploy。这个软件会在/dev/block/loop0（或loop1）块设备上创建rootfs，并安装完整操作系统，因此，从体验上最接近完整系统。\n\n没有root的机器，根据安卓不同版本，选择不同的软件。\n\n* 安卓5.0及以上，用Termux或UbuntuForAndroid\n* 安卓4.4及以下，用GNURoot\n\n!! Termux\n\n由于文件系统无法遵循FHS规范，加上依赖的C库是bionic，所以不能直接拿其它发行版的二进制程序来用，需要单独编译。除了基础的库依赖/system/lib/下的libc.so、libm.so、libdl.so之外，其它动态库都在Termux的lib目录内，因此也可以说不是个自完备的系统。相比bionic的libc.so，glibc则命名为lib-2.32.so，再用libc.so.6软链接过去。\n\n包管理器是dpkg和apt，又用shell封装了简单的pkg前端。初始化安装后有大约65个包，ca-certificates包只有一个文件，记录了可信任的CA，提供者是curl的作者，可见CA的基础性。在一次升级过程中遇到依赖的libandroid-support无法升级，甚至用`-o APT::Force-LoopBreak=yes install libxxx` 命令还导致所有程序全部被清空的惨剧。据说是用了改版的apt，使升级策略变成了滚动升级。重装之后提示仓库版本和本地不同，我选择D看差异却导致再也无法继续，只能再次重装时只敢选N(保留我的配置)，折腾3次才重新装上。\n\n如果更换源，要先执行`apt-get update`更新缓存才能执行进一步操作。\n\n默认bash，用chsh可以换sh，原理是把默认shell写入$HOME/.termux/shell。login不能作为默认shell。bash有700多K，而dash仅130K。bash提供了很多交互上方便的特性，典型的像通过改变PS1变量更换提示符，还有个内建钩子函数`command_not_found_handle`，当执行一个不存在的命令，会用一个外部程序给出更好的提示，比如用pkg安装某个对应包。\n\n用atilo可以安装完整的linux，原理是先启动基于proot打了patch后的termux-chroot构造假的root环境，从lxc-images下载基础镜像，再以proot方式启动。包括取消LD\\_PRELOAD环境变量，用`env -i`加载空的环境，设置PROOT_NO_SECCOMP=1关闭可信计算。同时也说明这类镜像只依赖内核的syscall，辅以合适的根目录，就能运行。\n\n在termux上编译软件要注意，因为默认的/usr/local路径不可用，必须用 ./configure --prefix=$PREFIX/stow/xx-1.0 方式显示指定安装路径。安装后，进入stow目录，执行stow xx-1.0就能用了，执行stow -D xx-1.0则删除该软件。\n\n!! UbuntuForAndroid\n\n自带ssh，装上就能用。源比debian要少太多，先安装software-properties-common再用add-apt-repository ppa:添加相应的源才能安装。在换国内源时遇到若干问题\n\n# 先确保安装了*ca-certificates*\n# 网上换源的文章都只适用于x86系，如果是arm的话，要把url的ubuntu换成ubuntu-ports\n# apt-get update会提示签名不通过，改成`deb [trusted=yes] http:...`。注意如果没有装第1步提到的包，即使加了trusted也没用\n\n!! GNURoot\n\n可以安装debian jessie，理论上可以换源逐步升级到最新版本。不过在5.0不让装。\n\n又试了Gentoo，依然遇到sshd问题。首先是没有公私钥对，用`ssh-keygen -t rsa -f ssh_host_rsa_key`生成，还是会断开，通过修改配置项`UsePrivilegeSeparation no`后能登陆。这个选项在7.5版本后废弃，强制yes，但在安卓系统下，可能是exec机制不同，必须no才能连接。如果sshd不管怎么配置都不能用，可以换dropbear，因为只用一个进程，免去了exec的麻烦。默认没有公钥的话，用dropbearkey -t rsa  -f dropbear_rsa_host_key。由于Gentoo的portage机制导致小文过多，同步后直接把inode用完（至少13万个），导致系统无法使用。这可能也和手机版本4.2，默认只有19万inode，而另一台6.0上的inode有64万多，可惜无法尝试了。\n\n由于ebuild不能用，只能源码编译，没有自带解压zip的软件，网上找到的unzip源码竟然是2010年最后更新的6.0版本，看起来也不会再更新了。支持非常多的操作系统，以致于根目录下没有Makefile，看了帮助才知道要自己从相应的目录复制Makefile，在那个操作系统百花齐放年代的软件，风格和如今大为不同。可能是太常用也太古老的关系，busybox也整合了unzip功能，倒不一定非得使用原始的unzip。顺便说下unzip和zip分属两个包，版本号也完全不同，有点难以想象。\n\n应用市场能下载和GNURoot配套的镜像都比较旧，可用lxc制作的发行包(https://images.linuxcontainers.org/images/), arch或alpine也有独立发布的arm包(选armhf，不支持aarch64)。下载发行包后，按以下顺序操作\n\n# 进入/host-rootfs/data/data/champion.gnuroot/app_install目录，有roots/support/versions 共3个文件夹。versions不用管，在roots和support下创建同名文件，名字随便取以后会显示在下拉框。roots包含的是发行版的rootfs，support是proot和busybox。由此看出GNURoot的流程大概就是busybox内用proot加载rootfs，达到模拟操作系统的目的。\n# 创建host-rootfs目录，如果没有/etc/resolv.conf也复制一份。\n\n做完以上两步，再打开GNURoot的下拉框，就可以看到刚安装的发行版了。\n\n* 不成功案例1: 先安装GNURoot的aboriginal包，然后不另建目录，直接把发行版的rootfs覆盖上去，再次打开会退出，可见必须另建新目录。在覆盖时遇到一个有趣的问题，原有的bin/目录是指向usr/bin/的软链接，这时一定要用`rm -rf bin`，不可以在bin后面加/，否则会把指向的目录删掉。因为软链接是文件，不加末尾的/，rm只删除这个软链，而加了/的话，会被作为目录删除导致悲剧。\n* 不成功案例2: 在安卓5上可以安装GNURoot，但安装dropbear后，ssh输入密码成功后，提示`client_loop: send disconnect: Broken pipe`，然后断开。可见终究还是不能用。\n\n!! GNURoot Debian Jessie\n\n可以逐个版本地滚动升级上来\n\n```\napt-get update\napt-get upgrade\napt-get dist-upgrade\nsed -i 's/jessie/stretch/g' /etc/apt/sources.list\n```\n\n之后再重复以上3升级步骤，此时要多一条\n\n```\napt-get autoremove\n```\n\n这样就彻底向上跳了一个版本，后续版本的更新类似。不过在一台未root的手机上操作，最终却因为libc无法更新停在了half-install状态，此时尝试装file，会提示需要libc >= 1.20，但是jessie的版本是1.19，只有stretch是1.24，无法安装新的软件，导致这个版本等于是废了。","modified":"20190215121530000","tags":"os"},
{"created":"20180316121530000","title":"AndroLua记录","text":"\n一个在Android用lua开发程序的应用，利用了JNI技术。JNI的交互是在java中定义若干个native方式的接口，通过javah导出头文件。在C函数中实现这些导出头文件对应的函数。这是java调用C的流程。想从C调用java，就要借助传给C语言JNIEnv变量并保存下来，后续用这个变量找class和method，并通过JNIEnv来调用。利用lua、C、Java三者之间两两互通，最终实现lua和java的互操作。\n\n最初的想法来自Lua的Kepler项目中luajava这个子项目。代码分为C和Java两部分，先看C语言部分。\n\n1.1版本就luajava.c一个文件。前半部分定义了5个lua操作java对象的函数，new/newInstance/bindClass/createProxy/loadLib。4.0版本又增加了多个函数，为简化起见先学习这5个。\n\n这5个函数肯定放入lua的table，并以字符串和C函数的关系绑定。这个L保存在CPtr.java定义的private long peer;成员变量。\n\nlua中会以newuserdata方式创建JNIEnv类型变量，并命名为`__JNIEnv`保存到`LUA_REGISTRYINDEX`里。每当这个userdata被触发gc时，会找JNIEnv并用DeleteGlobalRef方式对jobject的引用计数减1。\n\nluajava.c的后半部分定义了107个JNI的C实现，注册5个函数是在LuaState.java中定义为native方式的名为`luajava_open`的函数，由于javah的转换,到了C语言中函数名会稍有不同，但还是能看出来。C语言中实现了5大函数的注册。而在java的LuaState构造函数中，实现了`luajava_open`的调用。\n\n如果是通过java的console方式，会在Console.java的main函数构造LuaState，实现5大函数在lua的注册，接下来就可以在lua中调用java了。\n\n每次在abstract的JavaFunction调用LuaState.pushJavaFunction，就会在lua中创建新的userdata，再创建一个table，并设置`__call`域，执行函数调用int execute()签名函数。所有的入参在lua栈上，出参会压入栈上，返回的int就表示出参个数。\n\n!! 开发安卓程序\n\n利用布局器交互式地添加几个简单的控件，.aly文件会依次出现这些控件，然后加上id=\"xx\"之后，就可以在代码中操作这些控件。布局器只要一个LuaWebView，剩下的就是web开发和打包。","modified":"20180316121530000","tags":"lang"},
{"created":"20161125121530000","text":"\n前文有提到过PHP是怎么和Apache和Nginx整合的，作为最流行的两大Web服务器，从配置文件来看看这二者对Web业务的理解。\n\n还是先从和外部程序(如PHP)的结合性说起，Web服务器要想实现动态网页效果，最早是CGI方式，\n另外还有Python定义的WSGI(包括衍生出的uwsgi)，以及不太常见的SCGI。Nginx支持这三种方式都是比较松的耦合，\n通过`fastcgi_pass`把HTTP请求转给CGI服务器处理。另外一个很像的指令是`proxy_pass`，\n二者的差异是`proxy_pass`是纯透传，即Back-to-back。而`fastcgi_pass`要做的工作则多得多，\n不仅要构造一堆的CGI变量定义，还要在这些定义之前增加符合FastCGI规范的协议头。\n另外php的cli方式不支持，一定要使用php-cgi -b port方式才支持fastcgi协议的请求。\n用`uwsgi_pass`则是转成uwsgi协议给对应的程序处理。所以Nginx只做协议转换，不会调用外部进程。\n\n正是因为Nginx支持各种非HTTP协议的适配和转换，又不集成外部程序，它被普遍地认为是反向代理的模板。\n\n!! Apache\n\n支持转发，通过加载`mod_proxy`插件和相应的配置，把HTTP请求转给独立的外部进程。除些之外，Apache和PHP还有一种结合更紧密的方式，即通过`AddHandler fcgid-script .php`这条指令，把路径名是.php结尾的请求，识别成fcigd方式，进而通过FcgidWrapper指令声明的执行程序，直接运行PHP程序了。\n虽然这种方式也是调用php-cgi.exe程序，但不是-b监听的方式。因此在我的win8.1系统上出现一个很奇怪的故障，即Apache的`mod_fcgid`可以运行，Nginx却死活跑不起来。OpenResty深度整合了lua(主要还是程序小)，达到像Apache的效果。\n\nApache和Nginx在Web功能的配置上还是很像的，比如统一定向到错误页面\n\n* Apache方式:  ErrorDocument 404 /missing.html\n* Nginx方式:  error_page  404              /404.html;\n\n这里有个初学者很容易误解的坑，用PHP返回的错误码，服务器是不理会的。原理是Web服务器只认自身产生的错误码，对外部程序返回的HTTP头内的错误码不做识别。Nginx还好一点，可以用`fastcgi_intercept_errors on;`这条指令强制打开，进而达到错误码重定向的功能，Apache就比较惨了，如果是Proxy的返回，还能用ProxyErrorOverride来识别，但对FastCGI方式没有直接支持，只能以WorkAroud方式绕过，具体怎么绕，还没搞明白。\n\n!! nginx和tomcat协作\n\ntomcat是符合servlet规范的一个实作，规范定义了web.xml，包含servlet类名，很多MIME项，所以很大，一般不用看。\n\n业务配置在conf/server.xml中，最多可配6层结构。最外层定义惟一的server，是整个tomcat大的业务入口，这层要监听一个关闭端口，默认是8005。server下可以有多个service，其中可以定义多个connector和惟一的engine，每个connector负责一种protocol和端口，支持的protocol有ajp/1.3和http/1.1。ajp是Apache JServ Protocol，似乎只有httpd支持，如果要和nginx配合，要依赖http的connector才行。engine下层是若干个host元素，每个host通过appBase属性规定了war包的位置。context中指定url路由对应的servlet，不过这套做法已经近乎绝迹，最里还有Logger等就不提了。\n\n之所以会有这么多层，也是需求使然。服务要拆分，每个服务监听不同端口，就要在service层实现。对虚机运营商来说，监听端口惟一，但想尽量多卖主机，于是Host就有存在的价值。service和engine是一对一绑定，我觉得可以合一，而context也没有存在的必要。但最起码，service和host是无法被简化的。\n\n由上可知tomcat自身是可以做web服务器的，类似PHP支持http和cgi两种协议。但真正部署时，还是用动态处理能力。\n\nnginx可以配置upstream，层级在http之下和server平级。比如upstream tomcat，在location定义`proxy_pass http://tomcat;`一句就能反向代理过去了。其实直接在`proxy_pass`后面写ip和port应该也可以。\n\n从命令行启动tomcat的入口是catalina.bat，使用了cmd的一个语法`start title dosth`，即start特殊命令，从而可以打开一个名为title的新cmd窗口，并执行dosth命令。否则就在窗口下直接执行。\n\n!!! nginx打印变量\n\n# `add_header X-debug \"$var\" always;`指令，客户端就能看到某个变量。如果不加always，只有成功的响应才会添加头，不过这个参数在1.7.5以上版本才支持。\n# `add_header Content-Type text/plain;return 200 \"$var1 $var2\";`，直接在内容上显示变量，没有header内容会变成下载，不利于调试。\n\n[[nginx工作流与模块]]\n\n!! 在小米路由的使用\n\n小米路由器使用Nginx监听80端口，配置文件在/tmp/sysapihttpdconf/目录下，\n首页目录在/www下，这个目录没有什么内容，index.htm中最主要的就是这句：\n`\u003Cmeta http-equiv=\"refresh\" content=\"0; url=/cgi-bin/luci/web\">`。\n这个标签含有浏览器刷新和重定向两种功能，最终被重定向到了url所指向的地方。\n在Nginx的配置脚本中，有`set $script_name /cgi-bin/luci`\n在/www目录下，有cgi-bin/目录，其中又有luci这个文件，\n\nluci只是个入口，这其中会require相当多的文件，比如sgi.cgi，dispatcher等等。","title":"Apache和Nginx配置的理解","modified":"20231026060138468","tags":"web"},
{"created":"20170318121530000","title":"ARQ可靠传输协议","text":"\nTCP是可靠传输协议，但并不是惟一的，甚至在无线环境下都不是最好的选择。可靠传输有三种算法模型:\n\n# Stop-and-wait ARQ\n# Go-Back-N ARQ\n# Selective Repeat ARQ / Selective Reject\n\nTCP是Go-Back-N的一个变种。已经有非常多的文章提及TCP的特性并不适合无线网络。另外有种KCP协议，两种协议的设计初衷不同：\nTCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。为什么TCP会选择方式，我猜想大约是和LAN的碰撞特性相关，LAN是基于碰撞检测模型，如果每个节点都频繁地向网络发送消息，网络很容易堵塞，为了充分利用带宽，设计TCP的时候就以必须配合LAN的特性。但到了无线通信时代，如果发送数据不是基于碰撞检测，这个模式就未必是最优的模型。\n\nKCP可以跑在UDP上实现可靠传输，如果客户端服务端都是自己的，可以利用这种模式来做业务优化。\n\nTCP的拥塞控制算法的简要状态机，加性增窗和乘性减窗。TCP会一直尝试动态调整窗口，如果增大成功，则线性地以常量方式增加滑窗，一旦发送失败，减少一半滑窗。这种机制是非常克制的，在多个节点共同组成网络时，可以尽最大可能利用网络但又不会堵塞。4.9内核引入了google的BBR算法，对计算策略做了优化，发送失败会等待10个周期才减窗，且幅度只有3/4，防止线路噪音造成的意外衰减。","modified":"20170318121530000","tags":"net"},
{"created":"20170829121530000","title":"Bitcoin中三种哈希的区别与关联","text":"\n区块链的不可篡改性是基于哈希函数的特性，Bitcoin中有3个地方用到了哈希的特性(都是SHA256)，分别是区块的哈希、区块的merkler树的哈希、每个交易的哈希。\n\n比特币实现区块链的数组结构比较简单，区块构成单向链表，区块结构的整体概貌：\n\u003Cpre>\nstruct Block {\n  uint32 blockSize;\n  struct BlockMeta; //80 bytes\n  varint transactionCount;\n  struct Transaction* transaction;\n};\n\u003C/pre>\n每个区块含有一到N个交易，是个可变长结构，但不能无限增大，目前代码中人为地把区块大小限制在1M(分叉的BCC是8M)。这里还看不出哈希，接下来看看BlockMeta，这里面包含了两个Hash。\n\n\u003Cpre>\nstruct BlockMeta {\n  uint32 version;  // 最初是1，12年11月更新到2，最晚在17年已更新到0x20000002(隔离见证BIP141)，还有些0x20000012(BIP141和BIP91)。\n  uint256 parentHash;// 指向前一个区块，以0x000000开头(至少八个0，工作量证明)，Genesis块这个位置全为0。\n  uint256 merklerRoot;// 该块中所有交易通过构造merkler树生成的计算和，DoubleSHA256。\n  uint32 timestamp;\n  uint32 difficulty;//每2016块重新计算一次，早期都是1，直到第16个更新周期，即高度32256时第一次变化到1.18，后面一直在增加\n  uint32 nonce;\n};\n\u003C/pre>\nparentHash是把区块形成区块链的关键字段，计算这个Hash值异常困难，需要数亿次(甚至更多)地变换nonce值，进而使算出的Hash值小于difficulty。这也构成了Bitcoin共识机制PoW的基础，谁能算出这个值，网络上所有节点就承认TA挖到了这个块，从而获得了coinbase的奖励。但是区块并不保存自身的Hash值，因为一旦尝试出了nonce使得本区块符合链的条件，只要向全网广播这个刚算出的区块，其它所有看到这个广播的矿工都会保存这个区块的哈希。\n\nmerklerRoot也是SHA256，不过这个计算就没区块哈希这么变态了。区块只是个容器，重要的还是其中的交易，merkler树就是记录所有交易生成的摘要，使得不论多少笔交易，都只需要很少且恒定的数据，就能证明交易的存在。它也是SPV的验证基础，这部分内容还没看明白，以后再补充。如果区块只包含一笔交易(即coinbase交易)，merklerRoot就等于这个coinbase交易的ID(哈希)，如果有两笔以上交易ID，则两两作字符串拼接，并通过Double SHA256反复循环直到算出根值。\n\n每笔交易都是可变长结构，包含的输入和输入数量至少为1，无上限。\n\u003Cpre>\nstruct Transaction {\n  uint32 version;\n  varint tx_in;\n  void* in;\n  varint tx_out;\n  void* out;\n  uint32 locktime;  // 0指立即执行，1~5亿指到这个区块高度为止，5亿以上指时间戳(但4字节能表示的时间范围有限，难道不是问题吗？)\n};\n\u003C/pre>\n\n交易结构并不包含哈希，只有输入才包含哈希。\n\u003Cpre>\nstruct tx_in {\n    uint256 pre_txhash;   //指向前一个交易的哈希\n    uint32 pre_txout_index;// 定位到该交易的第几个output，必须是UTXO，否则会因余额不足而校验失败。\n    varint scriptLen;\n    void* script;    // 解锁脚本,signature+pubkey\n    uint32 sequence;\n};\n\nstruct tx_out{\n    uint64 value;\n    varint scriptLen;\n    void* script;  // 锁定脚本\n};\n\u003C/pre>\n由于Bitcoin没有账户的概念，只有UTXO，可以理解成一张支票吧。如果想交易，即证明有合法的input，就要向前找到一个或多个可用(未花费)的output，输入的哈希就用于寻找这个output。但交易可能不止一个output，所以还需要index来标识是第几个output，有了这两个值，就能惟一确定到UTXO，各节点也能验证余额是否足够。\n\n上面说了Bitcoin的结构，接下来对比下Bitshares的区块结构。Bitshares只有区块摘要的哈希算法用了SHA256，而区块ID、交易ID和MerklerRoot用的都是RIPEMD160。计算Merkler时的策略也有细微不同，Bitcoin在计算奇数个叶子节点时，会把最后一个节点复制一份，且每两个叶节点在向上计算上一级摘要用的是Double SHA256；而BitShares是直接把最后一个孤立节点放到下一轮计算，只用了Single SHA256，少了一半计算量。","modified":"20170829121530000","tags":"protocol"},
{"created":"20161213121530000","title":"BW博客系统简探","text":"\n从index.php开始看，先用`include_once`手动导入system.php，这里有个逻辑很有意思：\n检查conf这个目录下有没有info.php文件，如果没有则使用header的Location重定向到install向导。\n然后定义了`spl_autoload_register`，把类文件的目录确认到inc目录。\n\n准备工作之后，index.php自动加载Canonicalization类，在构造Canonicalization时会读取一个全局的'M'变量，根据M的值会决定一个mode目录下的文件，这个M的值通过loader方法返回作为`include_once`的参数，触发了mode目录下对应的文件。\n\n首页没定义M，默认值是index，经switch的计算变成cate.mod.php。mode目录下都是php文件，且不是定义，都是执行流程。\n先读取数据，创造View类，这是BW自己写的模板引擎，\n其思路是把页面拆成若干部分，每次在输出前选择需要的部分，\n选取后调用View->setWorkFlow保存，支持preg替换实现了load/loop/if三种语法结构。\n替换后的结果送给浏览器渲染。\n\n在代码层面，具体的mode代码只管调用View的finalize。会调用generateOutput，这里引入components.php并把一个$parts的变量赋值。\n设置theme成员变量。比如default，\n进而把theme/default设为文件的读入源。通过`ob_start`方式把文件载入，最终输出。\n\n路由用的是`$_SERVER['PHP_SELF']`。这个变量和`$_SERVER[\"REQUEST_URI\"]`相比，\n少了`QUERY_STRING`部分，比`$_SERVER['SCRIPT_NAME']`会多一些脚本后的值。\n至于`__FILE__`和`$_SERVER['SCRIPT_FILENAME']`这两个是一样的，不过使用场景不一样，\n因为表示的是本地的路径(即Windows是D:\\这种风格，当然这在nginx.conf还是有大用的)。\n\nbw甚至还有一套插件系统，会把注册的手册写入SQLite的extensions表，在启动时读入，\n然后去根目录的extension目录找同名文件夹，然后加上`ext_`前缀构造类，\n并调用类的init方法。网页的插件大约就是这个模样。","modified":"20161213121530000","tags":"web"},
{"created":"20180413121530000","title":"C++类的访问控制符与引用","text":"\n`C++`类的public/private是范围式的，从一个声明符直到下一个声明符之间的所有变量、函数的可访问性是一样的。而Java是针对每个函数需要显式写出访问控制符。初看之下似乎两者没有大的区别，甚至`C++`的范围式控制还可以少打几个字，直到最近我才意识到`C++`的控制方式在隐藏信息上存在的缺陷。\n\n比如声明一个接口类，通常来说最先思考的肯定是类的对外可以提供的功能，即public区域的函数。定义好这些函数后，就开始着手实现。但是在实现的过程中，如果公开函数的语义包含的操作较多，肯定会进行拆分，这些被拆分出的函数当然是private级的。但是当你在cpp文件进行函数拆分后，却会遇到代码无法编译通过的问题，原因就是在类声明中没有定义这个private函数，于是一方面，你要切换到.h去声明这个仅仅为了可读性而提炼出来的函数，而且可能因为函数命名比较随意，直接暴露出去又不是本意。\n\n为什么在编译器层面，不能省略声明呢？还是由class的特性引起的。由于对OO特性的理解：封装、继承、多态，这3大特性被语言级别地支持了。封装就体现在public/private上。如果一个函数没有声明就直接实现函数体，编译器不能也不敢随意地给这个函数确定可访问性，于是这个问题被抛回给了代码编写者。因此类的每一个细节就必须在头文件中暴露出来。这也是为什么`Effective C++`这么推崇pImpl法则的原因。\n\n所以`C++`的访问控制只是阻止了人为的调用，但无法阻止人看到内部函数。要想完全地隐藏细节，必须先声明一个只有public的函数，然后在实现时，继承这个类，把私有函数在继承类中声明，这个继承类不公开，如此才能做到细节的隐藏。\n\n反观Java，由于访问性是函数级别，完全可以在实现时直接把这个被拆分的子函数声明为private。话说Java好像也没有头文件和实现分离这回事。\n\n!! 引用\n\n「引用」是被 operator overload 逼出来的。在 operator overload 出现之前，Bjarne Stroustrup 从来，从来没有想过要引入「引用」。因为引用的所有用途都可以被指针代替。\n\n而且 Bjarne 是最烦增加新元素的。像 C++14 里那个「= delete」我以前都没想到这辈子能在 C++ 里出现。因为 Bjarne 当年死认为把 constructor 放到 private 就行了。\n\n「引用」也不能防止空指针。大型代码动辄传递指针引用好几层，其中完全可以有一层是空的。具体代码我就不放了。\n\n自从 Bjarne 铁了心要做 operator overload 之后，一个问题就是像 「=」，「+=」这样的自修改操作怎么传参。你要不要写成：\n\nA a;\n&a += 1;\n这哪行？（上面这种代码是 Bjarne 论证引用的必要性的时候自己在书里写的。）\n\n所以就有了引用。\n\n至于其它用法都是废物利用吧。","modified":"20180413121530000","tags":"lang"},
{"created":"20160412121530000","title":"C++模板引起的一个二进制兼容问题","text":"\n问题来源是这样的，公司的基础库里，用于实现Observer模式的Signal库是模板写的。模板嘛实现代码都在.h头文件里，在之前的一个版本里，因为要解决一个bug，对Signal模板类增加了两个成员变量，在提交时内部几个人评审，都觉得模板既然是在各自的cpp内实例化，且不涉及对象的传递，即使改变了类大小，也不会引起问题。然而最终集成的时候，就是挂在Signal类里。\n\n一度我以为是应用的使用者在两个不同的库之间（这两个库编译时引用不同版本的头文件），传递了Signal的实例引起，但后来经同事提醒，加上回忆起之前做的一个实验，发现确实是增加类变量引起的不兼容问题。原因如下：\n\n模板类在编译时，的确是在每个编译单元即cpp生成的.o中实例化出来的，但是这个实例化出来的函数（或类）的链接属性是Weak。通过readelf -s命令可以查看。正常如果不是手写attribute((weak))属性，编译出的要么是Global要么是Local。由于是Weak属性，如果实例化时的参数类型一样，生成的函数名也一样，而在不同模块生成的.o中的模板代码尽管不同，但因为名字相同，在最终的链接环节，会因为Weak的原因随机挑一个进入最终的可执行程序。而挑选哪一个是由链接器决定的，无法预测。因此当A库用了size更大的模板类，而B库用了原始版本，链接时如果恰巧选择了A库实例化的Signal类最终进入可执行程序，则会破坏B库中紧跟在Signal类后的变量。反过来，如果链接时选择了B的类进入可执行程序，则A在执行时还是用的原始库，不会破坏数据，但修改Signal的bug的期望也落空了。\n\n怎么在A、B库不同步更新头文件的情况下，解决这个问题呢？目前能想到的只是保证不崩溃，但做不到百分百修复bug。方法就是模板类也用pImpl方式实现，即模板类的成员变量仅使用一个void* internal指针，具体的数据在这个指针所指向的堆上扩展。这样不论链接器选择哪个版本的模板类，大小始终是一样的。如果用的不是模板类，也一样要遵守这个原则，只是非模板类因为是Global，所以可以控制最终链接进的版本，而使用模板就没这么幸运了。换句话说，如果要用C++的类作为接口，不论是普通类或模板类，为了扩展并保证二进制兼容，一定要遵守pImpl守则。","modified":"20160412121530000","tags":"lang"},
{"created":"20170308121530000","title":"C与和ua的交互问题记录","text":"\n!! 环境变量\n\n用Lua写一个库，在单元测试和正常业务上需要导出不同的符号，但是require机制不支持，偶然想到通过环境变量的方式传递，可是lua原生只能getenv却不能设置。这时有三种解决思路\n\n# 在lua调用外层做个shell，在shell中设置环境变量\n# 用C做host，由C语言作为UT的执行入口，设置环境变量\n# 用C写个Lua的扩展，在Lua里就能调用setenv了\n\n第一条最简单代码都不用写，因为在同一进程空间内执行没问题。\n第二条，因为windows下没有setenv，所以换用putenv实现，在C语言中能getenv到结果，偏偏lua的虚拟机内就是获取不到，既然没有fork为什么会失败，可能的疑点是windows下执行lua是dll载入方式，会不会dll引起的空间不同，环境变量没有迁移过去造成？\n第三条实现也不麻烦，putenv就一个入参数，返回整数代表成功与否，整个扩展写下来15行，大量都是wrap代码，第一次实测没有问题，但奇怪的过一段时间再测的时候，在主程序还是无法读到这个环境变量。\n\n从以上二、三条的实践来看，不同的dll有各自的环境变量，比如在lua扩展里设置环境变量，但在lua主程序因为是另一个dll，所以直接用os.getenv是得不到的。解决的办法就是第三条策略，扩展里再实现一个和putenv配对使用的getenv，而不是自带的os.getenv。在主程序里调用扩展的getenv，这样就可以读到扩展dll里设置的环境变量了。\n\n之所以非要用C语言而不是shell，是希望后续能做三语言开发，以C作为胶水，把Lua作为工具再用scheme作为上层调度，强化自己的技术栈，另外也提醒自己不要荒废了C这个老本行。\n\n!! lua嵌入C程序\n\n写了段lua的脚本，想整体打包成可执行程序，总是失败，定位1小时才找到原因。\n\n首先把dofile换成loadfile和pcall，发现是pcall环节出错返回值是2，表示遇到运行时异常，通常来说大概率是某个变量为nil未捕获。C语言调用，简单的做法把最后参数置为0，错误消息会留在栈的顶上，打印错误值得知是main函数的入参arg为nil，导致索引下标1触发异常，导致程序根本没能运行。\n\n再看代码原来arg参数是lua.c创建的，如果集成库的方式，显然不会有arg参数，所以能在命令行调用，却无法集成到C语言，换句话说也可以通过根据arg是否为nil来判断是否从命令行触发。\n\n以前写的混合程序，都是lua中定义好函数，从C语言调用，所以从未遇到arg问题，经此问题也算是有更深刻的理解。总之必须重视错误消息提示，代码中注意捕获并显示异常返回，不要遇到问题乱试一气。","modified":"20170308121530000","tags":"lang"},
{"created":"20181116121530000","title":"C语言的HTTP请求","text":"\n在windows上写HTTP请求，遇到问题很多。\n\n头文件要用winsock2.h，且必须调用WSAStartup，另外还要链接`ws2_32`库。\n\nPHP Server会分两次发送头和payload。\n\n收到的数据，win7似乎是1013，大于这个数量，puts或printf的输入就会被截断。但win10至少在2200左右无问题。更大未知。\n\n发送的接口要把数据拆成3块，否则很难灵活组合。\n\n遇到过对端不断连接，导致流程下不去，变通办法是对recv加超时参数。奇怪的是用`SO_RCVTIMEO`在某些情况下导致程序异常中止，命令行无法打印，GUI直接崩溃。\n\n换用select，返回有3种情况，>0表示事件发生，0表示超时，\u003C0是select函数本身有问题。这3种状态即使在跨平台上也依然适用。\n\n读写集`fd_set`在win10配64位gcc的大小是520字节。第一个字节，所有的手册都说是最大的fd+1，看到一种说法是OS要给监听fd分配连续的内存，最小的fd是0，为了容纳从0到最大fd的范围，因此填值是fd+1。而windows上这个参数是无意义的，因为windows的fd并不是从3开始，而且连续两个fd的差也不是1，所以最大值+1规则不适用。当fd数量过多，超过`FD_SETSIZE`，其实就是超过`fd_set`容纳的范围时，就不能再用select。换句话说select不能应对海量连接。\n\nreadset表示可读，或者说read操作不会堵塞，这时进行recv一定有数据或者EOF，对于socekt就是连接被断开。\n\n超时虽然有秒和微秒两个值，但实测windows下必须在秒以上，少于1秒的值会破坏堆栈导致崩溃。\n\n使用HTTP/1.0短连接，关闭联接时又遇到语义不一致的坑，由于是服务端主动断开，主动断开方会变成`TIME_WAIT`。这个socket在windows客户端用close会被置成`CLOSE_WAIT`状态。说明windows的close函数只是释放句柄，不处理TCP协议，必须先调用shutdown或换成closesocket(对TCP/UDP都适用)才行。除非要半关闭，通常用closesocket就行。\n\n语义不一致的原因，猜测大概是由于，fd的维护和socket状态是分开的，windows没有把这二者绑定。\n\nTCP状态机有5个标识过渡到CLOSED的中间状态，超过所有状况的一半。要仔细理解。\n\nhttp库和国标网关调试时，会遇上登陆流程卡住不往下走的问题，才分析出原因。\n\n代码中用recv收数据，之前遇到过和某些服务器请求，对端会在1分钟后才关连接，所以recv就会阻塞1分钟，所以把请求改为HTTP/1.0且显式声明是close，期待对端来关闭连接。但是国标网关的程序并不理会close指示，不会断开连接，所以就一直停在recv不往下走。查询手册知道用setsockopt设置fd的超时时间，recv就不会永远等待，先这样规避该问题。\n\nuv的多线程。只提供了4个线程接口，没有cancel这种语义复杂的接口，对我来说够用。多线程同时从tty读入，是否会抢占？从实验来看，两个线程如果都调用scanf，先被触发的会锁住tty，直到输入完成才会放开tty，让另一个线程去读，因此是安全的。但是在读的过程中，似乎可以输出。","modified":"20181116121530000","tags":"net"},
{"created":"20140518121530000","title":"C语言如何获取Lua中的内容","text":"\nC语言要与Lua交互并获取其中定义的函数，网上有些入门教程会用lua_getglobal，如果只是写demo这样是没有问题的，但显然用全局变量不够严肃。前一篇里我分析了Lua的require机制，C语言与Lua交互也是类似的思路。\n\n写好一个Lua的扩展模块，在C中通过`luaL_dofile`的方式把这个函数加载进来。注意如果只是用`luaL_loadfile`，只是预编译，并没有运行，也就没有获取到Lua中的数据。C里没法把require到的包赋值给指定变量，那dofile获取到的数据在哪里呢？其实这个返回值就被压入`lua_State`了。假如是在全新的`lua_State`中做了dofile操作，则index为1的值就是从包中获取的表，再通过`lua_getfield`(L, 1, \"foo\")就能得到包中名为foo的变量了。\n\n在前一篇中说到require只能返回一个变量的限制，但是如果还是返回了多个，在`lua_State`栈上也会保存多个值，只是除了第一个之外，后面的全是nil。其实这个nil在package.loaded中也是能找到的。\n\nrequire包之后，就可以通过`lua_gettable`或`lua_getfield`来得到包中的函数/变量，再通过`lua_pcall`就能利用Lua的扩展包了。`lua_getfield`是`lua_gettable`的一个方便的封装，省去了手动`lua_pushstring`的动作，写代码更方便一点。\n","modified":"20140518121530000","tags":"lang"},
{"created":"20230601121530000","title":"CDN的来源与应用","text":"\n万维网自1990年推出以来，已从简单的客户端服务器模型演变为复杂的分布式体系结构，在演化过程中，CDN是其中很重要的基础设施。最早的CDN公司Akamai诞生于1998年，虽然经历了二十多年的发展，但是至今没有形成完整的范，各家的具体实现也不一样。CDN的核心点有两个，一个是缓存，一个是回源。\n\n* 缓存：就是把资源复制一份到CDN服务器上的过程，缓存的管理需要协议，主要有ICP、HTCP、CARP。\n* 回源：当CDN发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。\n\n!! CDN协议\n\nICP(internet cache protocol)：最初的缓存控制协议，参考RFC2186。基于UDP协议实现的轻量级的缓存内部通信协议，被用于在Cache服务器之间相互查询web资源信息，以确定当前被请求的资源是否在其他服务器上。一个缓存服务器发送ICP请求给它的邻居，邻居会用ICP消息响应，如果有的话就是HIT无就是MISS。\n\nHTCP(hypertext caching protocol)：RFC2756，管理一组http cache服务器并监控相关的缓存活动。该协议机制与ICP类似，都是通过向邻居服务器发送查询请求并获得应答来反映web对象在集群中的缓存情况。但设计ICP协议时考虑的是HTTP/0.9协议，查询资源是否存在时只允许缓存发送URL。HTTP版本1.0和1.1引入了很多新的请求首部，这些首部可以和URL一起用来确定文件是否匹配。只在请求中发送URL可能无法得到精确的响应，而HTCP允许兄弟缓存之间通过URL和所有的请求及响应首部来相互查询文档是否存在，以降低错误命中的可能。另外HTCP还允许兄弟缓存监视或请求在对方的缓存中添加或删除所选中的文档，并修改对方已缓存文档的缓存策略。\n\nCARP(cache array routinig protocol)：CARP是ICP的一个替代品，通过建立HASH函数用于划分cache服务器集群的URL空间，通过HASH算法将用户对URL的请求准确路由到服务器阵列中的任一成员上，消除了阵列中重复缓存数据，实现了对cache资源的高效定位。CARP和ICP都允许管理者通过使用多个代理服务器来提高性能。优势：\n\n# 无需资源查询和应答的过程，降低网络传输开销\n# 消除了重复缓存数据，每份url保存一份，节约空间\n# 具有更好的扩展性，可以灵活的增删服务器节点\n\n额外说一句，CARP也是共享地址冗余协议的缩写（Common Address Redundancy Protocol），是一种能让多台网上主机共享同一个IP地址的协议。它的设计目标在于为故障移转（failover）提供冗余的主机作为备援。\n","modified":"20230601121530000","tags":"net"},
{"created":"20161204121530000","title":"CGI与FASTCGI规范的理解","text":"\n!! CGI语义以及基于Busybox使用\n\n作为最早的Web交互规范，由于足够简单甚至连busybox都能支持，只要做到以下两点就可以\n\n# 在网站根目录下创建cgi-bin目录（必须是这个名字，否则作为普通的目录，只会读取文本不会执行）\n# 在cgi-bin目录下创建文件，子目录也可以，并具有执行权限，但文件名不要和系统自带命令同名，我就遇到过命名为env后，程序一直执行不会退出\n\n然后在浏览器端，只要访问/cgi-bin/xxx，就可以触发执行CGI程序。RFC规范定义了以下环境变量给脚本读取使用：\n\n* REQUEST_METHOD: GET/POST等HTTP方法，busybox只实现了GET/POST，其它方法会报错501 Not Implemented\n* REQUEST_URI: 请求的完整路径\n* QUERY_STRING: 把URI的?之后部分提取出来，保存到这个变量\n* SCRIPT_NAME: 被执行脚本的相对路径，Web根目录为/\n* PATH_INFO: 额外的路径信息，由客户端给出的。换句话说，脚本可以由他们的虚拟路径名来访问，在这个路径的末尾附带额外的信息。这个额外信息被作为`PATH_INFO`发送。这个信息如果在传递给CGI脚本之前来自URL就可以由服务器来解码。如果请求http://example.com/test/test.php/a/b?k=v，则PATH_INFO的值为/a/b。\n* PATH_TRANSLATED: 服务器提供的PATH_INFO的转换版本，它需要路径并且为它做虚拟到物理的映射。busybox不支持。\n* SERVER_PROTOCOL/GATEWAY_INTERFACE/SERVER_SOFTWARE: 值类似HTTP/1.0、CGI/1.1，告知服务器运行版本\n* stdout: 这并不是环境变量，对于POST请求的内容来说，URI之外的数据，需要脚本从stdout来读取，所以也提一下\n\n!! FastCGI协议\n\nCGI规范了传输数据的环境变量命名（以及stdin/stdout用法），但只适用父子进程。FastCGI是网络化的，可以跨进程甚至节点使用，协议为8字节对齐，头是个8字节的标志位：\n\n```\ntypedef struct _fcgi_header {\n    unsigned char version;\n    unsigned char type;\n    unsigned char requestIdB1;\n    unsigned char requestIdB0;\n    unsigned char contentLengthB1;\n    unsigned char contentLengthB0;\n    unsigned char paddingLength;\n    unsigned char reserved;\n} fcgi_header;\n```\n\n这个格式缺少协议头标志(MagicFlag)，大概那个时代都是如此吧。版本好像只有1，type是消息类型共有10种：\n\n```\ntypedef enum _fcgi_request_type {\n    FCGI_BEGIN_REQUEST      =  1, /* [in]                              */\n    FCGI_ABORT_REQUEST      =  2, /* [in]  (not supported)             */\n    FCGI_END_REQUEST        =  3, /* [out]                             */\n    FCGI_PARAMS             =  4, /* [in]  environment variables       */\n    FCGI_STDIN              =  5, /* [in]  post data                   */\n    FCGI_STDOUT             =  6, /* [out] response                    */\n    FCGI_STDERR             =  7, /* [out] errors                      */\n    FCGI_DATA               =  8, /* [in]  filter data (not supported) */\n    FCGI_GET_VALUES         =  9, /* [in]                              */\n    FCGI_GET_VALUES_RESULT  = 10  /* [out]                             */\n} fcgi_request_type;\n```\n\n比较常见的有`BEGIN_REQUEST`/`END_REQUEST`(网络化后标识请求应答状态用)，PARAMS(代替环境变量)，STDIN/STDOUT(名字和CGI一样，含义则作了泛化)。\n\nBEGIN/END的payload部分是定长的，BEGIN定义\n\n```\ntypedef struct _fcgi_begin_request {\n    unsigned char roleB1;\n    unsigned char roleB0;\n    unsigned char flags;\n    unsigned char reserved[5];\n} fcgi_begin_request;\n```\n\nrole表示Web服务器期望应用扮演的角色。分为三个角色\n\n```\ntypedef enum _fcgi_role {\n    FCGI_RESPONDER  = 1,\n    FCGI_AUTHORIZER = 2,\n    FCGI_FILTER = 3\n} fcgi_role;\n```\n\nflags包含一个控制线路关闭的位：FCGI_KEEP_CONN：\n\n* 0，则应用在对本次请求响应后关闭线路。\n* 非0，应用在对本次请求响应后不会关闭线路。一般都是非0，减少连接开销。\n\nEND定义：\n\u003Cpre>\ntypedef struct _fcgi_end_request {\n    unsigned char appStatusB3;\n    unsigned char appStatusB2;\n    unsigned char appStatusB1;\n    unsigned char appStatusB0;\n    unsigned char protocolStatus;\n    unsigned char reserved[3];\n} fcgi_end_request;\n\u003C/pre>\nappStatus是应用级别的状态码。protocolStatus组件是协议级别的状态码；\nprotocolStatus的值可能是：\n\n* `FCGI_REQUEST_COMPLETE`：请求的正常结束。\n* `FCGI_CANT_MPX_CONN`：拒绝新请求。这发生在Web服务器通过一条线路向应用发送并发的请求时，后者被设计为每条线路每次处理一个请求。\n* `FCGI_OVERLOADED`：拒绝新请求。这发生在应用用完某些资源时，例如数据库连接。\n* `FCGI_UNKNOWN_ROLE`：拒绝新请求。这发生在Web服务器指定了一个应用不能识别的角色时。\n\n另外PARAMS、STDIN/STDOUT由于受协议单次数量64K的限制，如果要分包，\n则采用最后带一个长度为0的请求表示结束。有点类似HTTP的CHUNK传输方式。\n\n详细说下chunked方式，回复的HTTP包头如果标识是chunked方式，包头结束后(即单独的一个空行`\\r\\n`)，接下来就是若干个chunk，格式遵循这个格式：该chunk的字节长度加上回车，然后是正文数据加上一个回车结束。\n\n比如发送abcd四个字节，这个chunk是`34 0d 0a 61 62 63 64 0d 0a`，34和回车表示这个块有4字节，正文数据的长度匹配后再跟一个回车，当所有带内容的chunk都结束后，要再发送一个结束包`30 0d 0a 0d 0a`，30和回车表示块有0个字节，这个不存在的正文后再跟一个回车，内容结束。长度按16进制表示，比如一个附件是44307字节，抓包是`61 64 31 33 0d 0a`，表示ad13，转成十进制正好是44307。\n\n!! FastCGI在nginx和PHP的应用\n\nFastCGI作为解决CGI协议的后继者，已深得人心，在Nginx和PHP中都默认支持。比如php-cgi虽然名字是cgi，但是-b模式开启的其实是FastCGI模式。再配合上Nginx的`fastcgi_pass`指令，动态网页的环境就完成了。\n\n从Nginx的配置语句也可以看出点端倪，fastcgi部分一共支持两个预置变量\n\n* $`fastcgi_script_name`\n* $`fastcgi_path_info`\n\n从命名看出和CGI规范也是符合的，那么这两个变量怎么赋值呢？\n\n答案就是通过`fastcgi_split_path_info`这个命令字。这个命令的参数是捕获两个变量的正则表达式，捕获对象是$uri，前一个赋值给`script_name`，\n后一个赋值给`path_info`。`PATH_TRANSLATED`这个变量好像没什么用，没有在nginx内赋值程序也能正常执行。\n\n看一段PHP代码时，发现URL映射很不寻常，用了/index.php/article/?s=a这种格式。印象里.php这个SCRIPT_NAME在末尾，最多就是再跟个`QUERY_STRING`。查了CGI规范，允许这种写法，且后面的/article/还有标准名字，叫`PATH_INFO`。\n\nPHP对`PATH_TRANSLATED`的支持有点问题，以前是和`SCRIPT_FILENAME`一样，但这不符合CGI规范，现在默认已修正，但还有个cgi.fix_pathinfo=1选项能倒退回以前的行为。归根结底CGI就是先定位到一个文件，在这个文件基础上附带参数。参数分两段，`/`之后(含/)的`PATH_INFO`和`？`之后的`QUERY_STRING`。在Apache或PHP -S选项下，只能写成/index.php/article，而nginx由于用了更灵活的正则匹配方式，写成/index.php-article也可以识别并正确引导。\n\n`parse_url`函数会拆解成5个部分，scheme, host, path, query, fragment。在这套定义中`script_name`是path的一部分，不是独立元素。","modified":"20161204121530000","tags":"web"},
{"created":"20150904121530000","title":"Chomsky的4型文法与BNF","text":"\n按序有4种文法，从强到弱排列如下\n\nType-0：也称短语文法，产生式为A-〉B，A和B均包含terminal和nonterminal，表达力最强，等价与图灵机\n\nType-1：也称为上下文相关文法，CSG。是0型的特例，要求|A|\u003C=|B|。与0型的差异暂时还不明白。\n\nType-2：也称为上下文无关文法，CFG。是1型的特例，要求A只能是一个nonterminal，由于只有一个，因此也就没有上下文，故而当然是上下文无关了。对应下推自动机Push Down Automaton，是带一个栈的有限状态机扩展，比图灵机的双栈要弱。下推自动机也分确定型和非确定型，两者的能力不相等，其中非确定型等价于CFG。\n\nType-3：也称正则文法，是2型的特例，由于2型已经限定了左侧，故3型的限制在于右侧至多有两个符号，且只能是两种形式，A->a，或者A->aB。a是terminal，A->a很好理解，状态已经推导确定，A->aB我的理解是3型文法具备cleene闭包特性，可以无限推导，但由于不带栈，故不能记忆状态。而A->Ba这种文法，必须要先把B压栈，再lookahead一次，才能确定是否符合文法规则，因此不属于文法3类型。3型对应的自动机是有限状态机。\n\n前面说的是语言学的纯理论部分，接下来看BNF方法记述\n\nBackus Naur Form定义于1960年代，是一种格式化的语法记法。\n所谓格式化是可以严格推导、能用数字证明的方法。\n\n原始的BNF格式能表达Context Free Grammar。只是由于语法偏少，\n所以后人又做了扩充。扩充有两大流派\n\n* EBNF Extended BNF，是PASCAL的作者wirth做的扩展，后来也被ISO标准化定案\n* ABNF Augmented BNF，有IETF的RFC标准定义的扩展格式\n\n与我最初想像的不同，有RFC背书的ABNF并不是最广泛使用的格式，\n还是EBNF用得更多一些。比如Lua5.1的EBNF定义，使用了22条规则就把所有语法规则定义完了。\n两套表示法以及BNF的表达能力是一样的，只是书写时的简便程度不同。\n似乎并不是所有的语言都能用EBNF来表达，不过语言最好还是要设计得符合简洁才好。\n\nBNF只是一种记述法，对应编译的语法分析阶段，像YACC的语法就和BNF很类似，\n但不完全一致，典型的比如`::=`这个符号就直接简写成`=`了。\n好在没有特别大的差异，基本都是一眼就能看得懂的转义。","modified":"20150904121530000","tags":"lang"},
{"created":"20221119121530000","title":"continuation的理解","text":"\nScheme 和SmallTalk并不采用堆栈来保存上下文，而是将这些信息保存在continuation记录中。这些continuation记录和堆栈的Frame的区别在于，它不采用后入先出的线性方式，所有continuation记录被组成一棵树（或者图），从一个函数调用另一个函数就等于给当前节点生成一个子节点，然后把系统寄存器移动到这个子节点。一个函数的退出等于从当前节点退回到父节点。这些节点的空间回收是由垃圾回收器(garbage collection)来管理。如果没有引用这个continuation记录，则它就是可以被删除的。这样的调用方式和堆栈方式相比，它可以在一个函数内的任何位置储存自己的上下文信息，然后，在以后某个适当的时刻，从其它的任何一个函数里面返回到自己现在的位置。\n\n由于每次延续被恢复的位置不同，可以理解为函数拥有了多个不同的入口点，\n\nPython的yield教程都说是生成器，思考其实质，函数的上下文被保护，从而可以被多次调用，精神层面和continuation是一脉相承，而且加入了send和throw函数，也更方便易用。","modified":"20221119121530000","tags":"lang"},
{"created":"20170203121530000","text":"\n!! 写在前面\n\nHTML是SGML/XML的一种特殊应用或者说DSL，标准的网页写法是`\u003C!DOCTYPE html>`，与之对照的DocBook的首行写法是`\u003C!DOCTYPE article>`，而SVG图像的写法是`\u003C!DOCTYPE svg PUBLIC >`。\n(`\u003C!DOCTYPE>`是SGML的语法，和注释语法`\u003C!-- -->`参照就好理解了)。\n凡是符合XML定义的文档都必须通过DOCTYPE指定DTD，而浏览器天生就为显示HTML，即使不指定DTD，只要开头有`\u003Chtml>`标签就默认当作网页来解析了。\n既然是SGML系，整体风格都是树状。原生如h1,p,table等标签就属于CSS1范围的选择器，浏览器内建了各种HTML标签的CSS基础样式，因此最简单的网页，哪怕不定义任何CSS也具备一定可读性。当然除了原生的选择器，还有类选择器、ID选择器以及伪类等高级用法(当然对应CSS的级别也更高)，这时就必须由用户指定样式，浏览器只负责渲染。\n\nCSS作为大HTML的一部分往往会被浏览器缓存，虽然在HTML层面可以用一些方法控制缓存策略(比如PHP的setheader或者在HTML用\u003Cmeta HTTP-EQUIV>>标签强制修改缓存策略为no-cache，但CSS作为外链的附加属性就没这么幸运了。通常的作法是在引入CSS文件的末尾加上?v=1标志，当CSS内容有更改时，则改变v的值，由于CSS文件链接在HTML中，HTML可以控制不用缓存，浏览器读取到新的v值就会重新获取CSS文件。否则只能用Ctrl-F5的方式强制更新，界面才会用上新样式。\n\n!! 视口\n\n手机版页面的文字非常小，且经常要来回地拖动。几经查找看到viewport概念，是Apple的mobile safari首先提出，后来各个移动浏览器厂商都跟进了。具体地说在html的head部分加这这样一句，网页效果会如你所预期那样：\n\n```\n\u003Cmeta name=\"viewport\" content=\"width=device-width,height=device-height,inital-scale=1.0,maximum-scale=1.0,user-scalable=no;\" />\n```\n\n这里面最重要的莫过于width=device-width和inital-scale=1.0两句，由于不同设备的宽度不同，有了device-width指定可以大致做到不同页面如预期，但如果没有inital-scale，至少在这个博客上会非常难看，正文栏所占的宽度很窄，加上之后所有的内容就正常了。再说一句user-scalable，如果没有这句，每次焦点到输入框，页面会稍稍扩大一点，有种跳变感。再者对手机网页来说一旦可以缩放，反而会来回拖动体验未必就好，不如一开始就把布局字体设置妥当，之后就不必调整了。\n\n!! CSS五大主题 up 18年3月24日\n\n第一次学以为CSS就是布局，随着看文章变多，才知道范围庞杂，至少包括\n\n* 样式: 范围最广，包括但不限于颜色/字体\n* 数字/单位/函数\n* 布局: 盒模型\n* 层叠和继承\n* 选择器: 很难记忆，但它是理解CSS的关键 [[论为什么CSS难学]]\n\n!!! 样式\n\n这可能是相对比较好理解的主题，也是最早就有的内容。HTML5丰富了b/i等各种样式元素，使HTML更专注于语义层面。\n\nvalue是元素的属性值，比如form控件当前的值。而innerText和innerHTML是元素开始和结束标签之间的值，可能不能编辑，比如div元素。\n\n!!! 数字/单位/函数\n\n这块内容比较繁琐，也很难记，加上还要考虑各种不同屏幕的差异，细节非常多。\n\n* px/em/rem: 默认字体大小16px，对应1em\n* vw/vh: 相对宽高，1表示1%的总宽度/高度\n* fr: grid布局的单位\n\n关于px单位，引用hax的解释\n\n>    CSS规定，浏览器应该对像素值进行缩放调节，以保持阅读体验的大体一致。也就是要保持一定像素的长度在不同设备输出上看上去的大小总是差不多。 因此CSS提出了“参考像素”（reference pixel）概念。规范使用视角来定义“参考像素”，1参考像素即为从一臂之遥看解析度为96DPI的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。 请注意这个差别——CSS规范定义的参考像素并不是1/96英寸，而是1/96英寸在一臂之遥的看起来的视角。通常认为常人臂长为28英寸，所以其视角可以计算出来是0.0213度，即(1/96)in / (28in * 2 * PI / 360deg)。\n\n可以看到px和物理分辨率并不等价，对PC而言，由于人眼和显示器的距离与CSS定义基本一致，二者近似划等号；而手机的分辨率虽然高于PC，但仍然要符合规范，因此手机屏幕宽度px值会比分辨率小很多，具体多少px由每个厂商各自定义。从而保证了16px字号在不同显示设备上看起来的视觉效果是接近的。\n\n函数这个特性让我比较惊讶的，比如counter/calc的确可以进行数值计算，url则可以进行外部资源的导入。不过应该只有预定义函数，还不至于添加自定义函数。\n\n!!! 布局\n\n盒模型包括margin, border, padding, conntent 四个部分。差别是对高宽的范围定义。\n\nCSS最初并没有定位在布局功能，只是意外地发现BOX模型配合float可以实现布局效果，但用float方式不仅需要很多hack手法，还破坏元素间关系，所以增加了flex和grid作为更专门的布局手段。\n\n作为最早被广泛使用的盒模型，还是要理解。规范定义的盒模型只有block和inline两大类，block的原始语义是一个元素占有一行，主要有div/list-item/table这几种（题外话：由于table的历史比CSS更早，所以CSS用在table时，会有特殊的地方）。block能内嵌block/inline，而inline只能内嵌inline。再提下CSS与HTML历史的兼容性，由于CSS出现得比HTML晚，因此它一定要把HTML中所有的元素的特性纳入到自身的体系结构中。比如HTML的head标签不会显示，对应盒模型的属性就是display:none，不会影响布局，而body就是display:block，作为顶层的BOX容器呈现。任何新生事物都要能包容已有系统的能力，才是可被推广的系统。\n\nCSS定位又是重中之重。共有三种定位方式：正常流动、浮动和绝对。相应的三个关键字的优先顺序为display(不为none)>float(不为none)>position。\n在一个父div内顺序放置多个div，每个div都设置成float，宽度未满时从左向右排列，如果宽度达到父div的上限，另起一行排列。举例来说，如果父div的宽度是90%，第一个子div是50%，第二个子div是40%，这两个就在同一行，如果第二个也是50%，就会被挤到下一行。\n\n归根结底本来每个div单独占据一行，如果想让多个div在同一行，就要破坏div的block特性，让想处在同一行的多个div“漂浮”即float起来，注意必须都float才行。一旦这样块之间就再不是固定的排列关系，而要取决于div宽度总和，如果宽度够就被放在一行了。如果超出了，还是排列到下一行。排到下一行后，可以用left或right来决定对齐方式。\n\ninline-block这种方式更玄乎，比如有3个顺序的div，如果1和3都是inline-block且总宽度和小于父block，直接把1和3排列到一行里，如果这一行的剩余宽度还能放下第2个div，就放在同一行，否则在下一行排列。但是如果第二个div是float:left，会放在第一个div前面。\n\n!!! 层叠和继承\n\n两个相近但不同的概念，先说层叠，CSS的C代表层叠，也是CSS与其它布局方式最大的不同。CSS的所有变量定义是全局的，因此必然存在冲突，解决的办法就是层叠的规则。样式来源有5个\n\n* `\u003Ca style=\"\">`  属性样式，又称内联样式\n* `\u003Cstyle >`  内部样式表\n* `\u003Clink>` 外部样式表，又名外部样式表\n* 浏览器用户自定义样式\n* 浏览器默认样式\n\nCSS权重规则的特殊性可以用4个整数来表示，例如1，0，2，0这样一个4元数表示，计算规则从高到低排列如下：\n\n# 对于内联规则，权重值表示为1，0，0，0\n# 对于规则中的每个ID选择符，权重值表示为0，1，0，0\n# 对于规则中每个类选择符和属性选择符以及伪类，权重值表示为0，0，1，0\n# 对于规则中的每个元素名或者伪元素，权重值表示为0，0，0，1\n# 对于通配符，权重值表示为0，0，0，0.\n\n最终得到结果就是这个规则的权重。两个权重值的比较类似字符串大小的比较，是从左往右依次比较，第一个数字大的规则的权重高。\n\n还有一种层叠，`\u003Cp class=\"A B C\">`，这时ABC三种样式会层叠后作用在p元素上，ABC属性的层叠原则，和class属性中的排列顺序无关，而是取决于怎么定义，其中规则非常复杂，这里就提最简单的一种，所有都是单独定义（没有父子、兄弟或important时），最后的定义覆盖早先的定义。如果A最后被定义，层叠的结果就是A。\n\n继承这个特性是由HTML的结构化特性导入的。像color、font-size、font-family、text-align这些属性，会在给父元素设定后传递到子元素甚至孙元素的样式中，这些子元素/孙元素会得到样式的渲染，就是CSS的继承机制。不是所有属性都会继承，像margin/float等都不会继承\n\n!!! 选择器\n\n由于HTML的树状结构，对元素渲染时一定会遇到对某种具有父子或兄弟的元素采用特殊属性的场景，选择器提供了丰富的语法来支持如何选中树结构的某类元素\n\n!! HTML转PDF的技巧\n\nCSS的@media print可以单独控制打印稿的样式，格式\n\n```\n\u003Cstyle>\n@font-face {font-family:\"MyF\";src:url(\"file:///C:/Windows/Fonts/lucon.ttf\");}\n@media print {\np.xx_font { font-family:\"MyF\"; !important}\n}\n\u003C/style>\n```\n\n用wkhtmltopdf一定要加上--print-media-type才生效。-s 指定页大小，格式化的有 A0-A9, B0-B10，另外还有数种Letter, Ledger, Folio, Tabloid格式。要控制页边距，则用 -B -T -L -R 后面跟实际的物理单位控制。一台5.5寸手机大约在B7和B8之间。\n\n指定字体更复杂一些，首先通过font-face定义一个字体名，并用绝对路径方式定位到字体，因为是src:url导入的外部ttf文件，所以必须通过css类关联到元素才能改变字体。\n","title":"CSS的一些理解","modified":"20231029060717033","tags":"web"},
{"created":"20170610121530000","title":"dmesg和BSD初期版本的故事","text":"\ndmesg最早出现在3BSD时代。\n\n1975年Ken Thompson请了一年休假并来到Berkeley担任客座教授，Ken在Berkeley安装了Version 6的Unix，并实现Pascal编译器。这时Bill Joy因为优化这个编译器而出现在历史舞台上。因为其它学校对这个系统也很感兴趣，Joy在77年着手完成系统的拷贝并最终在1978年3月发布了称为1BSD的版本，共卖出30份。接着1979年5月发布了2BSD版本，这个版本有两个程序至今还在用，就是vi和csh，共卖了75份。\n\n头两个版本是Joy初试牛刀，同期发生的重要事件是1978年Berkeley买了VAX机，当时贝尔实验室也为VAX做了适配并命名为UNIX/32V（基于Version 7 Unix）。但这个系统并没有优化好VAX的虚拟内存特性，于是Berkeley的学生大幅重写了内核并把2BSD的程序也移植到了VAX机，最终在1979年底发布了3BSD。从这个版本起，BSD便不再是UNIX的clone了。\n\ndmesg在OpenBSD的实现并不复杂，利用sysctl接口的`CTL_KERN`和`KERN_MSGBUFSIZE`命令字获取信息的长度。再用`KERN_MSGBUF`获取真正的内容。不过这两个枚举在FreeBSD上没有定义，OpenBSD中定义的KERN操作枚举值要比FreeBSD来得多，大概也是两套系统在逐渐演化过程中发生的差异吧。\n\n内核文件是名为bsd的大约10M的文件，不像Linux的vmlinuz文件，bsd就是个普通的ELF执行文件，内核文件不止一个，比如bsd.mp用于多核系统，还有bsd.rd是类似光盘镜像的文件，如果用syspatch升级内核，还会产生一个bsd.syspatch61的备份文件。根目录下还有boot文件，类似于grub，启动顺序也是BIOS->boot->bsd这个顺序。\n\n安装包使用`pkg_xxx`系列，应该是和FreeBSD类似，使用tar包方式，tar包其实有多种格式，GNU的tar用的默认格式是gnu，但OpenBSD用的是ustar，是1988年的posix版本，另外有2001版posix标准的tar，GNU宣称未来也会切换到这种方式。安装包的地址从/etc/installurl获取，目前我只找到清华的repo是\nhttps://ftp.openbsd.org/pub/OpenBSD和https://mirrors.tuna.tsinghua.edu.cn/OpenBSD。\n\nOpenBSD的代码是用cvs管理的，看来落伍但社区觉得已经足够。先说说分支管理：风格很固定，每个版本有`OPENBSD_6_1_BASE`和`OPENBSD_6_1`两个标签(symbolic name)，其中BASE是revision，也就是Milestone，一般是决定开发新版本时，创建一个后续不再更新；而`OPENBSD_6_1`则是基于这个revision的branch，是真正的发行代码。\n","modified":"20170610121530000","tags":"os"},
{"created":"20191105121530000","title":"docker和OCI规范","text":"\n容器技术最初由Docker这个产品为大众所了解，Docker这个词是公司名，容器技术和工程化的混合。工程化上一个app一个容器是最大的创新，容器化技术最初被linus嘲笑50行脚本就能完成。随着使用日渐广泛，2015年6月，Docker、CoreOS等公司制定了OCI（Open Container Initiative）开放容器计划来规范标准。\n\n还有一个概念CRI和OCI很接近，这个概念源于k8s，因为调度系统最直接打交道的就是容器，所以必然也会对容器有约束，所以在2016年12月发布CRI规范，但从使用角度来看，可以认为两者是相同的。\n\n!! 规范与层级\n\n* 镜像image: 一般是写dockerfile后制作得到，以文件形式存储在硬盘上，包含应用软件及依赖的运行时，做得好应该尽量小。从沙盒角度看，对java有一定替代性，且从最小依赖上说，C/Go语言才能保证镜像不引入无用的依赖。\n\n* 运行时container: 是镜像的运行实例，实例好比是类，容器则是对象。在做镜像的dockerfile里不会限制CPU、内存、网络等条件，在运行期指定外部的资源参数。运行时又分高层运行时和低层运行时。\n\n高层运行时包括我们熟知的Docker外，还有Containerd和CRI-O，随着k8s的1.24版本正式删除dockershim层，可以预见Containerd将会在未来成为主流的高层运行时。\n\n低层实现的参考实现是runC，是由Docker用Go实现并捐给社区的，其实在Docker之前，Linux社区是有lxc方案的，但因种种原因没有流行起来。runC从2016年的1.0-rc1版，直到2021年才发布1.0正式版，期间主要的特性是增加了cgroup v2的支持，并修复了多个CVE严重漏洞。\n\nDocker的本质是设置了namespace和cgroup参数的进程。是沙盒概念在linux上的具体实现，安卓上运行的每个app都是类似于Docker（底座换成dalvik）的实例。Docker公司将containerd和runc捐出后，剩下的只是命令行工具的使用接口。随后开始了从沙盒技术向hyper-v虚拟化转变。\n\n不同的docker子命令适用于不同的层级，要区分。rmi是删除image，而rm则是删除container。\n\n!! 工具与运行\n\n采用C/S架构，dockerd是后台守护，docker负责向后台发命令，包括管理镜像，打新包，提交。守护进程会依次拉起多个程序，dockerd -> dockerd-current -> docker-containerd-current -> docker-containerd-shim。运行容器则依靠docker-runc。\n\n配置文件在/etc/docker/，采用json格式保存，大约和开发者比较新有关系。\n\n!! 核心概念\n\n# repo 仓库。为了分发的方便，在hub大市场里存放了很多仓库，每个仓库有多个tag版本，提供相同功能。不同tag间有区别和演进\n# image 镜像。仓库的某个具化的tag就是镜像，对应到磁盘上的一套文件结构，是静态概念\n# container 容器。镜像作为进程的底座被运行起来，此时整个进程就称为容器，是动态概念\n\n!!! 命令行操作\n\n* pull : docker pull xyz -> docker pull repo.addr/library/xyz:latest # 仓库域名不能有http://前缀，域名后面跟固定的library\n* run : docker run -it 。创建并执行容器。pull拉下来的镜像，可能不是local，run命令会自动把远程镜像再同步到local\n* start : run -it的镜像，有时在容器中执行exit会导致进程退出。但是container ID还在，用 start containerID 就能重新拉起\n* exec : 已经start的容器不能用run，要用exec才能挂载到运行中的容器\n* stop/rm : 停止然后删除容器\n* save/export : 将镜像保存成tar文件，差别是save会带上一些元信息，而export则是纯粹的二进制文件\n* load : 将tar形式的镜像加载到docker的本地仓库，在images列表中能看到\n* commit : 将容器保存为新的镜像，不是每次操作都会产生新的层，具体原理不清楚\n* history : 按时间序从上到下显示镜像层\n* network : 查看，操作，销毁容器宿主网络\n\n!! 镜像\n\n一个save的镜像解包后是这样的（docker24.0.5），如果是export，则对应layer.tar\n\n```\nsha256_folder_layerN/          # 镜像由几层构成，目录就有几个\nsha256_folder_layerN/VERSION   # 1.0\nsha256_folder_layerN/json\nsha256_folder_layerN/layer.tar # 这一层更新/删除的二进制文件\nconfig_sha256.json\nmanifest.json\nrepositories  # 镜像、标签以及sha256_folder名，似乎只有一层镜像才有\n```\n\n如果删除某个文件，在解压开的layer层体现为内容为空的隐藏文件 `.wh.\u003Crmfile>` 记录，wh猜测是write hidden的缩写。\n\n!! 网络\n\n服务端启动后，会创建名为docker0的网桥接口，用brctl show查看这个网桥的所有interface，通常启动几个容器就有几个veth网卡，同主机之间的veth是互通的。宿主机看不到这些veth的IP4地址，要进入容器才能看。\n\n!! harbor\n\n为了存储镜像和相关产物，诞生了harbor项目。Harbor 2.0 成为符合 OCI（Open Container Initiatives）规范的开源镜像仓库，能够存储多种云原生工件（Artifacts），例如，容器镜像、Helm Chart、OPA、Singularity 等等，这些统称artifacts。\n\n!! helm\n\n为了将多个docker镜像编排成一个大的应用，产生了helm。通过 Helm3 可将 Helm Chart 推送到 Harbor。 在 Harbor 2.0 中，Helm Chart 不再存储于 ChartMuseum 中，而是与容器镜像一样存放在artifacts中。","modified":"20191105121530000","tags":"os"},
{"created":"20210614121530000","title":"erlang和其上的扩展语言","text":"\n!! 程序组成和功能\n\ncent发行版拆得比较细，最核心的erts运行时单独成包，其它lib目录下的库，像compiler,debugger,edoc,kernel,stdlib都是独立的包。\n\n* erl: 负责启动模拟器并在终端执行命令，感觉更像个REPL。启动有很多的参数，和其它程序不一样的是选项风格，有`+`和`-`两种类型。erlexec负责加载EMU（现在都是beam了），由EMU负责真正的调度\n* erlc: 负责将源码编译为beam字节码，和其它编程语言类似\n* escript: 以解释（非编译）的方式执行源码。在很多其它解释型语言里，erl和escript是同一个程序，如果参数有源文件，就解释执行，否则就进入REPL，但erlang把这两个分开，因为escript的执行要求源码必须有main/1函数，更像C语言指定入口，而不是脚本语言遇到什么语句都会执行\n* epmd: 严格说并不在PATH路径，也不需要手动启动，当调用erl带上-sname或-name xx@ip参数，会自动启动epmd。即使erl程序退出或崩溃，epmd依然在后台监听\n\n启动顺序\n\nrun_erl/to_erl（可选，准备有名管道和日志环境） -> erl -> erlexec（在erts目录） -> beam（或beam.smp，很早期是jam）\n\nerlang下载时标识的是OTP版本，这个版本也决定了不同节点的程序能否组成集群，非常重要。而运行erl会显示erts/eshell的版本，要区别这两个版本。\n\n!! 文档\n\n安装包后没有文档，从官网下载man包，并放到erlang的根目录，用`erl -man xx`查看。\n\n!! 类型分析\n\n属于扩展包，typer和dialyzer是最成功的两个包。对有标注过类型的源码进行分析，并找出潜在的错误。\n\n!! lfe的编译\n\n由于lfe是shell脚本，源码发布时就在目录中，编译的目的只是为了生成所需的beam文件，用make方式，把erl源码编译为beam，再将一个c文件编译为可执行程序。\n\n执行命令前先配置ERL_LIBS路径，参数展开为`erl -user lfe_init -extra`执行。可见执行的底座仍是beam。","modified":"20210614121530000","tags":"lang"},
{"created":"20170808121530000","title":"flex和bison的理解","text":"\n这两个工具是编译理论都会介绍的经典工具，分别用于词法和语法分析。词法比较简单，虽然有NFA和DFA的区分，但总的来说就是把原子的字符按规则合并成符号，但语法分析就有LL和LR两种差异很大的流派。从词法分析向LL演进，是比较自然的方式，但词法进到LR，中间存在一道鸿沟，这时我觉得更好的做法是先学习LR的语法分析，理解LR的思维，自然就明白为什么、何时需要词法，以及flex和bison两个工具的协作模式。\n\n为什么Bison这种通过工具生成解析代码的方式被称为LR分析器，而手写解析器一般都是LL分析法呢？这两种方式都是BNF的解析方式，而BNF属于产生式文法，指先定义文章包含段落，段落包含句子，句子再包含单词，着眼点是从最顶层的结构，逐步扩展细化，最终推演到单词环节结束的过程。\n\n不管是LL还是LR，解析词法符号都是从左向右，两者都是L，没有不同。如果将符号形成一个句子，就有了分歧。手写分析器是从左向右一旦符号成为一个合法句子，解析结束，优先从最左侧进行推导，所以称LL法。而Bison的解析思路，即使已经达到推演条件，还会继续读进符号，只有在读进的符号不能推演，才会结束，优先从最右侧进行推导，所以Bison的作法称为LR。看Bison的规则，人脑很难自然地联想出从文章细化到句子乃至单词是怎么结合上的，因此LR方式通常是用机器生成代码。\n\nLL的术语是First/Follow集，而LR则称为shift/reduce。读入符号(shift)再生成句子(reduce)，这和书写yacc的规则是逆过程，不过不用担心，工具会把正确地完成这个逆过程。既然要先shift，就一定会有栈保存符号，Bison在语法分析前，先创建200长度的数组作为栈。每条规则的执行都会改变栈的深度。默认规则动作$$=$1就是在栈保存值，有这个值后面的解析才能找回值。\n\n生成词法解析代码用flex一个二进制文件就够了，而生成语法解析代码不能只有bison二进制程序，必须配套多个m4脚本，这些文件称为skeleton（比如yacc.c或lalr.java等代码模板）和XSLT的输出模板目录，保存在/usr/share/bison。而且不同语言用到的文件也不一样。比如要实现C语言输出，至少要7个文件。\n\n!! flex\n\n调用flex不需要特别的选项，windows平台可以加一个`--nounistd`防止编译错误。\n\nlex的外部输入源有文件和字符串两种形式，但内部归约到一个统一的宏`YY_CURRENT_BUFFER`，这个buffer在lex内部以栈的形式保存，可以存在多个，也可以push/pop。\n\nbuffer可以从`extern FILE* yyin;`创建，默认读出16K的内容来生成buffer，也可以是字符串，字符串可以包含0。使用文件方式比较简单，在yylex函数中，如果判定外部没有初始化yyin，则将它赋初值为stdin。\n因此在函数入口需要申明`extern FILE* yyin;`并从希望读取的文件来给yyin赋值。\n如果不使用yyin，也可以用字符串，方法是用`yy_scan_string(C风格字符串)`或`yy_scan_bytes(二进制串)`指定字符串，再将返回的`YY_BUFFER_STATE`指针传给`yy_switch_to_buffer`，这样yylex()的输入就自动定向到字符串了。当然记得最后不要忘记调用`yy_delete_buffer`把指针给释放了。\n\nlex的第一部分，要写上%option yynowrap(似乎对版本有要求)，因为lex产生的代码会用到yywrap()这个函数，也可以把这个函数直接定义成`#define yywrap() 1`，上述这句也就是lex帮你定义这个宏。如果%option没用，变通方式直接定义yywrap()函数并返回1也可以(这也是flex库默认提供的实现，因为这个库太没用，基本都是手写这个函数)。\nlex可以更改默认的变量名前缀，不用yy。如果把lex和其它语法分析器配合使用，会有效果。另外lex支持生成可重入代码，但在和bison配合时比较别扭，关于可重入的说明，在lex和lemon的文章中介绍。\n\n!! bison\n\nbison处理文件最好加上-d和-t -r all选项，-d输出头文件，用于给flex指明终结符的定义，后面会详述。-t -r all输出详细报告，报告的内容分4部分\n\n# Grammer：从0开始编号，0也是终结态$accept，自动生成。其它都是用户自定义规则\n# Terminal：每个条目都是一个符号且定义了int值，对应lex返回的枚举或该字符的ASCII值，有两个特殊终结符，$end(0，代表YYEOF)和error(256)\n# Nonterminal：对应rule。就包括$accept，还会详细标明每条规则出现在哪条grammar的左或右，左右是语法分析很重要的特性\n# 最后是各种state,从0开始编号，会显示具体的shift或reduce动作。如果有冲突，会提示哪几个state存在歧义，大多数state会带一个default的reduce规则，当然也有不存在default的。如果default对应的是accept，这个state就是最终态了\n\n除了-t -r all选项，还可以通过-g和-x选项输出automaton的graph和xml report，报告类似分为grammar和automaton两部分\n\n* Grammar是各条BNF规则的描述\n* 接着是Terminal和Nonterminal定义,Nonterminal的第一条同样是隐式的$accept\n* automaton是多个state的合集,描述的是各个state之间的转换关系,每个state下面有itemset、action、solved-conflicts\n* action包括了transition（shift和goto状态）和reduction（和rule关联）\n\n通过yacc的规则，也生成了解析的C语言文件，但是数据(终结符，用%token定义的符号)需要从lex获取。前面提到bison -d会生成头文件，这个头文件就是给lex包含的，lex自己不需要生成头文件（因为就一个int yylex()函数原型）。除去注释，yacc生成的头文件包含4条内容\n\n# 一个enum的枚举声明，对应yylex()的返回符号类型\n# 声明YYSTYPE类型，int或union，这里的S指semantic的意思\n# 声明一个YYSTYPE类型的变量，yylval\n# 声明int yyparse()函数原型(低版本bison不会生成)\n\n除了第4条比较显而易见，说说前3条必须存在的原因\n\n先说enum枚举。lex在识别词法后，yylex()的返回值要把词的类型告知yacc，所以需要yacc在首部申明`%token ***`，token对应终结符，正好对应lex，还有一种%type，对应的是非终结符，用在yacc内部。\n这个头文件就包含了%token声明的枚举定义。%token/%type不是C语句，不需要;结尾，当然带了也没关系。\n\nyacc能支持递归，因此写规则时会出现循环引用和空规则。以下是最简化的lisp语法解析\n\n```\nsexp: /*empty-rule*/ {}\n  |   sexp one_exp {}\n\none_exp: '(' mul_em ')' {}\n  |   T_VARNAME {}\n\nmul_em: one_exp {}\n  |  mul_em one_exp {}\n```\n\n当规则引用自身时，**自己一定出现在左边**，否则会无限循环，又因为是产生式规则，右边的式子代表最新reduce的结果。规则互相引用时，也会有些微小的差别，不然又会引起循环。\n\n!! 对外函数接口\n\nlex和yacc各自对外的惟一函数分别是int yylex()和int yyparse()，两个函数都无入参且返回int。虽然是自动生成的代码，但抛开各种表的数值不谈，流程还是能看明白的。\n\nyylex()看似没有入参但其实是通过外部变量作为输入源，一方面有历史原因，而且既要接受文件句柄，又要接收字符串，一种类型较难表达，只能退而求其次用一种并不巧妙的方式。出参是识别到的终结符类型枚举（文件结束时返回0），枚举值由bison定义，标识符枚举从258开始（跳过单个字符的范围），需要int来表示。\n\nyyparse()无参但有输入，输入就来自于其内部调用的yylex()。yyparse()返回的int表示错误码，共有0/1/2三种值，0代表正确，1表示异常，2表示内存耗尽（比如shift导致栈过深）。\n\n!! 交互与变量传递\n\nyyparse()调用yylex()，涉及两种类型的数据传递\n\n# 这次的token类型是什么？\n# 这次的token要表达什么含义？\n\n第1个简单，通过yylex()返回的int来表示，第2个就相对复杂，让我们进入lex看。lex的上下文，当前识别出的原始字符串，保存在yytext里，类型是`char*`，长度保存在yyleng，它和strlen(yytext)是一样的。但是yytext是yylex函数内的变量，yyparse()不能使用，正确的处理方式：**将yytext处理并保存到yylval变量**。\n\nyylval是由bison定义的全局变量，它是yy lookahead value的简写，代表了一次识别出的终结符的具体值，调用yylex()后，yylval就可能有了数据，在yyparse()内部将yylval依次保存到yyvsa数组（通过yyvsp指针），类型和yylval一样也是YYSTYPE。在bison的上下文，用$1、$2语法来引用yyvsp数组中的对应位置，从而实现了变量传递。YYSTYPE默认是int类型，不是玩具程序的话，肯定需要更复杂类型，就用到yacc的%union{}语法来替换int类型。YYSTYPE（就是刚才定义的union）包含在头文件中，lex才能看到union的声明，识别到符号后，进而将yytext转换成相应的类型。\n\nyyparse()是双栈式推进，yyssa表示state stack，yyvsa表示value stack，状态栈记录当前shift或reduce的阶段，而语法分析并不是最终目的，还需要输出分析结果，因此每一步的中间值也要记录下来，所以就有了值栈。两个栈的初始长度都是200，如果栈满了之后可以通过自定义的栈生长函数扩容，但最大不要超过10000。yyssa的当前状态经过yypact和yytable的转换，可以计算出要从yyvsa上POP多少个元素，根据.y文件的定义对yyvsa数组进行索引定位。","modified":"20170808121530000","tags":"lang"},
{"created":"20220421121530000","title":"Flink引擎学习","text":"\n!! 数据集\n\nFlink和Spark都采用了数据集（算子）+SQL方式提供编程接口，SQL上手简单但能力受限，而数据模型则相对难学但也更强大。\n\n|  |  基础会话（构建数据集） | 表会话（可执行SQL） | 数据集类型 |\n| --- | --- | --- | --- |\n| Spark | SparkContext | SparkSession | RDD |\n| Flink | StreamExecutionEnvironment | StreamTableEnvironment | DataStream |\n\n既然是数据集，肯定就有数据来源，可以从文件或表映射，也可以从无限流的连接映射出来，一旦映射后就只能基于这个原始的映射源计算。\n\n而SQL语句都不依赖数据集，属于会话级的接口，因为SQL是在一段文本中操作多个数据源，所以显然不会被绑定到某个特定的数据集。\n\nStreamTableEnvironment能提供Table和DataStream之间的互转。同样的，基本废弃不用的BatchTableEnvironment则提供了DataSet和Table的互转能力，只是随着DataSet的逐渐消亡，可以不用管这种运行环境。\n\n从Flink 1.9开始有两种planner：old 和 blink。blink实现了流批一体，因此将批处理视为流式处理的特殊情况。所以blink不支持表和DataSet之间的转换，批处理作业将不转换为DataSet应用程序，而是跟流处理一样，转换为DataStream程序来处理。因为流批统一，Blink planner也不支持BatchTableSource，而使用有界的StreamTableSource代替。\n\nTable 总是与特定的 TableEnvironment 绑定。不能在同一条查询中使用不同 TableEnvironment 中的表，例如对它们进行 join 或 union 操作。\n\nTable API中表到DataStream有两种模式：\n\n* 追加模式（Append Mode）：用于表只会被插入（Insert）操作更改的场景。\n* 撤回模式（Retract Mode）:用于任何场景。有些类似于更新模式中Retract模式，它只有Insert和Delete两类操作。得到的数据会增加一个Boolean类型的标识位（返回的第一个字段），用它来表示到底是新增的数据（Insert），还是被删除的数据（老数据，Delete）。\n\n!! 运行时与调度\n\n采用经典的Master-Work模型，Master会创建App进程，包含了三个组件，Dispatcher、ResourceManager和JobManager。Dispatch接收客户端请求，并创建出Job。Job根据任务生成Graph并向Resource申请资源。Resource有多种实现，可以是Local，也可以借由Yarn或K8S管理资源。\n\n每个Work（TaskManager）是一个JVM进程，进程中的task将共享TCP连接和心跳消息。启动的TaskExecutor跑在空闲的TaskSlot（线程）上，一个拥有3个slot的Task，会将内存平均分成三份给每个slot，slot数量通常和CPU数相同。Executor和Slot都通过Resource来分配。\n\n由于流批一体，Flink的调度策略也适用于不同类型的计算，有三种实现：\n\n* Eager：适用于流计算，同时调度所有的task，对数据不终结的流而言，这种方式很自然\n* LazyFromSources：适用于批处理，当上游数据处理完，调度下游数据。如果不lazy的话，计算效率会差\n* PipelinedRegion：以流水线的局部为粒度进行调度\n\n!!! 数据传输\n\nRegion要解决什么问题？这就要回到适合流批作业的不同数据传输机制（shuffle）\n\n* Pipeline： 上下游Task之间直接通过Netty进行网络传输，因此需要上下游同时运行，适合流。又细分了是否有Bounded模式，区别在于是否限制网络缓冲的数量\n* Blocking： 上游Task会首先将数据进行缓存，下游Task去取数时上游作业甚至可以停掉，互相不依赖对方的存活，适合批\n\n基于这两种类型的传输，Flink将ExecutionGraph中使用Pipeline方式的Task子图叫做Region，从而将整个Graph划分为多个子图。\n\nPipeline方式也存在缓存，但又要考虑实时性，于是就有了基于信用的流量控制机制（Credit-Based），来降低延迟，工作原理：\n\n# 发送端将自己缓冲区积压的数据大小加入到发送的数据当中，一并发给接收端\n# 接收端接收到发送端发过来数据之后，根据其缓冲区积压的数据大小，生成一个信用值，并将信用值返回给发送端\n# 发送端会根据信用值所限定的范围，尽可能的多传输缓冲区数据\n\n如此，每个发送端都被授予一个信用值，如果某发送端数据积压过多，那么它所被授予的信用值，就能够使之尽量多发送数据，从而减少积压量，这种机制会在出现数据倾斜时很好的分配网络资源。\n\n除了基于信用的机制外，任务链机制更能直接减少数据传输的开销，如果上下游两个Task的并行度相同并且满足其它条件，会将这两个Task合并，直接在内存中复用数据。\n","modified":"20220421121530000","tags":"data"},
{"created":"20181117121530000","title":"FLTK编译历程","text":"\n为了跨平台，Windows用了GDI，Mac用Quartz，Unix用X11。Fl::scheme可以简单地设置风格，效果一般。\n\n要想编译后的程序没有背景的cmd窗口，编译选项要增加`-Wl,--subsystem,windows -mwindows`。\n\n> the effect of -mwindows is to\nadd -lgdi32 and -lcomdlg32 to the list of default libraries (the uwin\ntarget also adds -luser32), and to pass --subsystem windows to the linker.\n\n说明subsystem是无用的，以防万一记录在此。按带cmd方式编译出来的程序，不论是从命令行启动还是界面点击，都会有IO输出。而按windows编译，即使从命令行启动，也不会有输出。\n\n链接时，除了fltk和mwindows附带的两个库，还要额外的库`-lole32 -lcomctl32 -luuid`，所以一共是5个windows库。第一个对应dnd，第二个对应TrackMouseMove，网上很多人说user32，可惜是错的，uuid是IUnknown需要的库。\n\n窗口函数的运行一定基于事件，风格就是main函数的最后return Fl::run();锁住。实现很简单，判断如果有窗口widget，就开启无尽wait，否则直接结束。windows版实现wait时，会从`ws2_32`库找select函数并等待，具体时间还没看懂，似乎是0.5秒？一旦被唤醒，执行PeekMessageW寻找是否有窗口事件或超时发生。\n\n如果要搭配libuv，可以再启动一个线程比如叫`run_layout`，在layout线程中画出布局并Fl::run，layout线程会一直阻塞。主线程join这个layout线线程，就能结合了。\n\nGUI必然依赖回调，为避免代码太长显得混乱，套路化的做法是将布局函数layout放在main文件，结构体放在cbfunc.h，回调定义放在cbfunc.cpp。\n\n```\ncbfunc.h\nstruct stXXX {\n};\n\ncbfunc.cpp\nstatic void gf_cbdosth(Fl_Widget* fw, void* w){}\n\nmain.cpp\nstatic stXXX sv_xxx;\n在layout()中对sv_xxx赋值并作为参入传给gf_cbdosth\n```\n\n在布局创建控件后，`widget->callback(sf_dosth, &sv_xxx);`\n\n既然是图形程序，配上图标会好看得多，图标等资源的源文件后缀是rc，猜测是resource compile，再用`windres -i xx.rc -o xx.res -O coff`编译成res后缀文件，不指定COFF格式的话无法链接。最后用gcc把res和o文件一起链接成可执行程序。rc是文本文件，格式如下，因为只有一个图标，nameID这栏随便指定没关系。还可以通过rc加上版本号和其它附加信息。\n\n```\nnameID BITMAP filename\n2  ICON  xx.ico\n1  VERSIONINFO\n\tFILEVERSION     2,3,3,3\n\tPRODUCTVERSION  2,3,3,3\n\tFILEOS 0x4L\n\tBEGIN\n\tBLOCK \"StringFileInfo\"\n\tBEGIN\n\t\tBLOCK \"080404E4\"\n\t\tBEGIN\n\t\tVALUE \"CompanyName\", \"NKUCodingCat Co.Ltd\"\n\t\tVALUE \"FileDescription\", \"NKU-SSS-in-One Project General Launcher\"\n\t\tVALUE \"FileVersion\", \"1.0\"\n\t\tVALUE \"InternalName\", \"Launcher on Windows\"\n\t\tVALUE \"LegalCopyright\", \"GPLv2\"\n\t\tVALUE \"OriginalFilename\", \"小心使用，谨防水表\"\n\t\tVALUE \"ProductName\", \"NKU-SSS-in-One\"\n\t\tVALUE \"ProductVersion\", \"2.3.3 build 42\"\n\t\tVALUE \"Comments\", \"一群渣渣\"\n\t\tEND\n\tEND\n\n\tBLOCK \"VarFileInfo\"\n\tBEGIN\n\t\tVALUE \"Translation\", 0x0804, 1252\n\tEND\n\tEND\n```\n\n整体布局会用到Double Window这个类，是Window类的子类，有onscreen和offscreen两个buffer，flush的时候把offscreen copy出来。\n\n如果想更灵活地回调，就要继承widget并覆写handle方法","modified":"20181117121530000","tags":"tool"},
{"created":"20180901121530000","title":"GB28181理解","text":"\n全称由3个词组合，安全防范，视频监控，联网系统。视频监控领域的通用标准，用了信令SIP和媒体RTP/RTCP的模型。选用SIP是有多重原因\n\n# 视频监控有大量的视频数据要传输，而建立起这样一个视频会话，最现成的就是RTSP或者电话的SIP协议。\n# RTSP虽然是专为视频业务设计的协议，却基于一个前提，必须知道流源的地址。在中心化分发场景，多个客户端向一个流源请求视频是非常合适的。但是视频监控反过来，往往只有很少的客户端，却有大量潜在的摄像头，因此RTSP出局。\n# 要收集散落在各处的摄像头，需要向一个中心节点主动报备，恰巧SIP就有这个功能。\n\n综上三点，SIP就奠定了在整个体系中的基础地位。\n\n核心的SIP指令只有6条，INVITE、BYE、REGISTER、CANCEL、ACK、OPTIONS，相比H323简单很多。但SIP毕竟是用于建立电话的协议，视频监控还有很多的需求，好在有INFO和MESSAGE两个扩展，有了信令控制的基础，INFO具备改变会话的能力，典型应用是DTMF，即在电话中点击数字，所以用于回放控制是很自然的。而MESSAGE并不构成一次SIP的dialog，所以用在设备控制上，类似短连接语义。\n\n除了请求应答模型，SIP还支持SUBSCRIBE/NOTIFY/PUBLISH模型，可以推送消息，甚至还有基于SIP的IM协议。\n\n控制协议分请求和应答，请求有3种，Control, Query, Notify。应答是Response。体现在XML的最外层结构。\n\n统一编码有A和B两种规范，前者20位，后者18位。我只见过A。编码即能表示设备又能表示用户。存储设备被称为前端主设备，而相机被称为前端外围设备。\n\n目录概念解释\n\n分设备目录和文件目录。设备目录包含3种:设备，区域，系统。文件只有1种:录像。每种都用一个complexType定义对象语义。业务上经常会订阅目录，发生变化后下级推送。\n\n查录像协议很有特点，一个请求会有若干次的返回。一方面，MESSAGE请求本身就有应答，另外UDP受限于MTU无法携带大量消息，必须要分段传输。大华网关实现查目录，默认一次返回1条，可以配置一次返回5条。","modified":"20180901121530000","tags":"protocol"},
{"created":"20160109121530000","title":"GCC编译4阶段的一些理解","text":"\n起因是这样的，安装了GCC4.7和4.8两个版本，但是4.8不知什么原因输出临时目录总是出错，原因及修改方法见这里，\n所以只能用4.8配合-pipe选项先生成.o文件，再用4.7链接成可执行程序。于是想了解下这么做为什么是可行的。\n\nC语言的编译分4个步骤，第一步cpp预编译，后缀名.i，这一步因为宏的机制几乎没有新特性，且功能也不多，不会有太大的变化。这个不详细研究了。第二步cc1编译成汇编语言，这是整个编译最复杂的地方，涉及语言特性支持和优化，一般说的版本就是指cc1，C++则是cc1plus。\n由这步生成后缀.s的汇编文件。第三步as(又名gas)将汇编语言转机器码并生成对应平台的目标文件，如ELF或COFF文件，最后由ld将多个目标文件生成可执行程序或库，文件格式为ELF或PE。\n\n其中的第三、四步用的as和ld，其实并不在gcc的范畴内，其版本号是属于binutils这个项目下，\n因为as的工作在于把汇编语言转机器码，并生成对应平台的目标文件，\n生成机器码这步没什么好说的，不同指令集有各自的代码，相对比较直观。\n但要生成各种平台对应的目标文件，这就涉及到一个抽象层，而一般用得最多的，\n就是BFD库，如果输入as -v也会出现as BFD version字样，生成的目标文件经ld链接，\n而ld只是个软链接，真正的文件可能是ld.bfd，也可能是ld.gold。\n看名字就知道ld.bfd表示使用BFD库来生成平台相关文件，而ld.gold则是google研发的链接版本，\n据说速度很快，但我的机器上没有安装，也不清楚依赖的gold库到底是个什么库，\n只知道gold版只支持ELF，所以GNU必然不变采用作为默认实现，其功能应该和BFD是类似。\n\n由于是两个软件包，怎么配套并没有一个非常严格的要求，因此用gcc4.8编译，最后用4.7链接也问题不大。只是默认会链接到4.7的库目录。如果想用4.8的目录，则可用用--sysroot选项来指定。\n综上来看，编译的几个阶段，重心是不一样。而每两个阶段间都需要有一个规范。cc1和as之间采用的是AT&T规范，as和ld之间则是平台相关的目标格式。正是因为有了这些规范，4步编译才能看起来仿佛一步似地完成。\n\n!! 一些有用的编译指令\n\n`gcc -print-file-name=libc.so`获得libc.so的位置\n\n`libstdc++`是`g++`的专属库，gcc命令不能自动和C++程序使用的库联接，使用`gcc -lstdc++`就可以。\n\n静态编译带运行时，`g++ -static-libgcc -static-libstdc++`\n\n编译时设置rpath和dynamic linker（绝对路径）：gcc -Wl,-rpath='/my/lib',-dynamic-linker='/my/lib/ld-linux.so.2'\n\nrpath，全名run-time search path，是elf文件中一个字段，它指定了可执行文件执行时搜索so文件的第一优先位置，一般编译器默认将该字段设为空。elf文件中还有一个类似的字段runpath，其作用与rpath类似，但搜索优先级稍低。搜索优先级:\n\n`rpath > LD_LIBRARY_PATH > runpath > ldconfig缓存 > 默认的/lib,/usr/lib等`\n\n如果需要使用相对路径指定lib文件夹，可以使用ORIGIN变量，ld会将ORIGIN理解成可执行文件所在的路径。`gcc -Wl,-rpath='$ORIGIN/../lib'`\n\n无法编译程序时，可以通过patchelf修改rpath和interpreter。\n\n```\npatchelf --set-rpath '$ORIGIN' your_program\npatchelf --set-interpreter /my/lib/ld-linux.so.2 your_program\n```\n\n利用$ORIGIN方式把依赖so放一起，portable化。也可以使用pwd获取当前路径，使用相对路径指向本地lib。\n\n```\npatchelf --set-rpath `pwd`/../lib your_program\npatchelf --set-interpreter `pwd`/../lib/ld-linux-x86-64.so.2 ./your_program\n```","modified":"20160109121530000","tags":"lang"},
{"created":"20210729121530000","title":"git的远程访问辨析","text":"\ngit虽然是个分布式版本管理工具，但在我看来网络协议的支持是开发比较晚的，共有4种协议：\n\n# local协议，其实就是把另一个目录看成是远程仓库，非要说形式的话，可以写成file://前缀地址。如果对应的目录是NFS盘，也算是一种远程目录吧，不过file://方式比ssh方式会慢一些\n# http协议，https://为前缀的地址，又细分dumb和1.6.6版本后新增的smart方式\n# ssh协议，有两种形式，ssh://前缀，或是user@server。是3种协议中，惟一可以不带schema前缀的地址，全功能，但不支持匿名访问\n# git协议，git://为前缀的地址，没有鉴权功能，只适合做匿名仓库\n\n早期的dumb版http访问，严格说并不算一种协议，只要在Web服务端把仓库路径开放出来，客户端利用http协议去访问这个远程路径，不能差分比较和传输，权限控制也全依赖于Web服务器的实现，好处是不挑Web服务器。后来出了个smart版本，要求Web服务必须支持CGI模式，利用http为管道进行两端的协商。\n\nssh使用时，似乎都采用共用同一个账号（一般是git），每个用户提供不同的公钥方式访问。但ssh作为授权登陆协议，天然不具备匿名访问方式，作为一个开源软件，却不提供让人随意下载的能力，就显得很怪异，加上ssh方案在横向扩容上存在困难，随着http逐渐成熟，因此提供商对ssh方式热情不高，甚至github还提供了如何禁用ssh访问的说明。和ssh协议相反，git协议不支持鉴权，好处是在1.6.6版本以前，可以提供进度条，在智能http出现之前，这种方式和ssh方式形成互补，我甚至想，git协议是不是在没有开发出智能http协议前的一个临时方案，在特定历史时期有其价值。随着智能http日渐普及，git协议似乎没有用武之地，加之git协议还要监听一个非标端口，过防火墙非常困难，目前看来已彻底无用。\n\n!! HTTP Smart协议详解\n\n官方文档明确要求，服务端必须是stateless服务，一切的状态必须记录在客户端，这么做的好处当然是便于服务端扩展。有两个版本，1.6.6的版本是version1，但在大的仓库中还是比较耗时，google在2018年发布了Wire协议，标识为version2，从2.18开始支持，更加命令导向，似乎想往rpc方向发展。\n\nsmart协议要求请求的url中，queryString有且只有一个service=xxx参数（仅限v1版，v2版放开此限制），参数共有11种，其中2条POST和9条GET协议。\n\n两条POST协议对应git-upload-pack和git-receive-pack命令，九条GET协议获取的都是.git目录下的文件，用git的术语就是LooseObject、InfoPack、PackFile。\n\n* info/refs\n* HEAD\n* objects/info/\\*\n* objects/pack/\\*.pack和\\*.idx","modified":"20210729121530000","tags":"tool"},
{"created":"20190312121530000","title":"git概念理解","text":"\n和cvs/svn相比，操作粒度从文件变成了commit。而操作步骤上的变化则是多出了暂存区index的概念，每次提交都分为add(也可以用stage，同义词)和ci两个步骤。有观点提出，这是为了达到svn的多文件原子提交，但命令行不容易选文件，于是多出个中间环节，先小步多次挑选要提交的文件，用add将工作区的文件提交到index暂存区，然后ci实现原子化的从暂存区向仓库区的提交。通过日志也能看到commit前后两次index的变化，每次也会用sha1编码来表示。\n\n其实暂存区并不是必备的，创建时用git init --bare就能创建没有.git目录的仓库（原来放在.git目录下的文件在当前目录直接能看到，相当于整个目录自己就是.git目录）。这个仓库无法执行add操作，一般用来做中心仓库，多人向裸仓库推。如果不这样，冲突会很多，所以有bare特性。\n\n存储方式也不同于cvs的差分保存，每次提交都会保存一份完整的记录在objects/目录下，不仅文件，每次commit时的目录结构、日志都会保存。通过git gc打包会把这些文件压缩成idx和pack文件，如果操作过程干净，所有的独立文件都会被压缩，当遇到stash恢复冲突等特殊场景，会有少量文件无法被打包。\n\n!! 一切皆object\n\n每个object都用SHA-1表示，有4种类型：commit, tag, tree, blob。互相之间的关系是：tree和blob共同组成commit，对commit打上标记形成tag。\n\n!!! commit\n\n所有的提交形成一个commit树，每个commit号标示出树上唯一确定的点。本地或远程Branch、Tag、HEAD都是这个commit树上某个点或某根枝条的别名。\n\n* HEAD: 动态指向这棵树上当前开发最新节点。注意这个最新不一定是树的末端，而是当前开发在哪个状态，随着每次提交动作而移动\n* Tag: 静态指向commit树的某个节点，一旦确定就永远不再变化\n* Branch: 对应commit树上某一段（如果不开分支，就是整棵树）的别名，由于是枝的形状，所以不表示某个具体的提交点，但可以沿着枝来溯源\n\n!!! tag\n\n打上tag后，可以用name-rev或describe查看某个commit和tag的关系，但似乎name-rev只能找比tag时间更早的commit，而describe恰好相反，只能找比tag时间晚的commit。\n\n!! 分支\n\n仅仅init不会有分支，必须在提交后才会有第一个master。分支和暂存区之间会引入复杂的关系，如果暂存区有内容，换分支有可能被中止，提交或stash后才能继续换分支。说明只有分支是独立存在，暂存区只有一个，是多分支共享的。这也是stash存在的原因。\n\nrefs/heads/保存了所有分支。删除一个旧的分支，没问题。但如果删除的是比当前要新的分支，用-d是没用的，防止辛苦做的提交白白丢失。如果确实没用，-D还是能删的。\n\n一个本地仓库可以对应多个远程分支，不同的远程仓库间用名字区分。比如用 `git remote add origin git@github.com:synich/demo.git` 添加一个远程origin分支。master和origin都是默认名字，并没有要求必须用这个名字，一般大家都遵守这种习惯。\n\n远程分支和本地分支不一样。远程分支类似tag是一个引用，origin在本地仓库是个独立的命名空间，因此可以创建多个远程。每个远程分支都会和一个本地分支建立关联，关联之后，其它本地分支间的操作，再套上一层网络传输就可以无缝衔接了。\n\n!! 目录结构解读\n\n工作区很好理解，写代码的根目录下自己写的代码都是，但除此以外只有.git目录代表仓库，所谓的索引到底是什么，有无实体？\n\n!!! 索引文件\n\n秘密就在 `.git/index` 这个二进制文件，索引只会记录文件名和SHA-1，不记录具体内容。如果索引的文件条目特别多，可以用update-index --split-index切分。索引分了若干段，第一个是DIRC段，一般会有TREE段，至于更复杂的REUC/UNTR/FSMN段只在特定场景或配置后才会出现。\n\n!!! 仓库区\n\n.git目录除index文件外的其它，就是仓库区\n\n文件类\n\n* HEAD/ORIG_HEAD/FETCH_HEAD: 存储当前检出的引用或者提交 ID\t在远程服务器上用于展示默认分支\n* config/description: 存储库配置，存储库配置优先级高于用户配置，用户配置优先级高于系统配置\n* packed-refs: 存储库打包引用存储文件，默认不存在，运行 git pack-refs 或者 git gc 后出现\n\n目录类\n\n* objects: 存储库对象存储目录\n* refs: 存储库引用存储目录\n* logs: 似乎是日志\n* info: 存储库信息，http dumb 协议依赖，但目前 dumb 协议已经无人问津\n* hooks: Git 钩子目录，包括服务端钩子和客户端钩子，当设置了 core.hooksPath 时，则会从设置的钩子目录查找钩子\n\n这些目录中最重要的是 objects 和 refs ，只需要两个目录的数据，就可以重建存储库了。在 objects 目录下，Git 对象可能以松散对象（SHA-1的前两字母）也可能以打包对象（info+pack）的形式存储。\n\n!! 命令分类\n\n查看对象\n\n* show\n* cat-file\n\n操作远程\n\n* remote\n* ls-remote\n\n操作索引\n\n* add命令是hash-object + update-index两条命令的组合封装\n","modified":"20190312121530000","tags":"tool"},
{"created":"20170310121530000","title":"GitHub用法记录","text":"\n协作环境很重要的一点要配置自己是谁，git有三个层面的配置local(repo级), global(用户级), system(/etc级)。\n\n!! 推送到网络\n\n从概念上说推送要解决两个问题，本地和远程repo怎么建立关联，通信使用什么方式。\n\n比如clone其他人的库，再本地进行操作，这种方式自不用说。如果是本地已经有的仓库，想主动推送到远程，就要用关联，操作顺序如下\n\n# 在web上操作创建一个空的repo(github给我们建的是bare仓库)，注意不要带README.md，后面从本地推上去\n# 进入本地要关联的repo，并执行 git remote add origin https://github.com/user/repo.git\n# git push -u origin master  建立关联\n# 以后的每次操作用 git push 就行了\n\n如果push的时候失败，往往是远端内容不一样，git pull --rebase origin master后再尝试push。每次提交都要求输入用户名和密码，为减少输入，将用户名密码写入配置git config --global credential.helper store，在HOME创建.git-credentials文件(这是store默认的读取文件名)，输入https://{username}:{passwd}@github.com并保存，以后就不用再输入密码了。和store对应的还有cache，默认缓存15分钟，过期要求重新输入。一旦向远程仓库推送过，.git-credentials的内容会被替换掉，无法直接看到明文的用户名和密码，有一定的安全防护。\n\n再说联接方式\n\n用git remote -v可以看到当前的连接方式，有fetch和push两个地址。按上面示例操作后，是https方式， origin\thttps://github.com/user/repo.git (push) 。\n\n除此之外还有SSH格式，用公钥完成认证。先用ssh-keygen先生成公私钥对，ssh-keygen -t rsa -C \"your@email\"。通过网页的方式把公钥内容贴到Account -> ssh public key对话框。接着把和远程的连接设置成ssh，git remote set-url origin [url]。对github来说，ssh的格式是git@github.com:USERNAME/REPO.git。如果是自建，格式可能是user@IP/REPO.git。\n\nssh的原理是这样：git会调用ssh，根据ssh_config配置，私钥默认是~/.ssh/id_rsa文件，如果用ssh -T git@github.com会提示 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 说明github主机支持ssh协议，且都使用git用户，至于你的用户名，是git用户下的二级用户。由此猜测ssh在不同的服务商不一定相同，换一个服务可能不支持，还是https最通用。\n\n解释下参数中的origin和master\n\n本地修改后要同步到远端源用git push origin master。origin就是git在clone时默认生成的名字，表示对应的remote源，刚clone下来的项目，在.git/refs/remotes目录下只有一个origin目录，且origin又只有一个master目录，这样看刚才那条命令就很好理解了。同一份git仓库可以push到github/gitlab/oschina等很多地方，无非在remotes目录下多几个不同命名的文件夹罢了。比如用git remote add oschina your-url，就会创建一个和origin平级的oschina目录。如果开了分支就可以origin branch-name。不过像个人用户如果项目简单，最简单一条git push就能完成。\n\n如果我clone其他人的库，用我的密码推送呢大概率失败，取决于服务器的配置。","modified":"20170310121530000","tags":"tool"},
{"created":"20190705121530000","title":"Go语言学习笔记","text":"\n!! 语言特性\n\nGOROOT指定了Go的工具、库和源码的存放路径。\n\nJSON库要求struct的成员必须是大写字母开头，否则无法导出，可见性渗透到很多地方。\n\nstring和[]byte在二进制层面是一样的数据，但类型不同，原因是string被设计为不可变，保证多线程安全，而[]byte就是一块内存区域。当函数需要的参数和实际类型不匹配时，二者间要做类型转换，不可避免地会引入内存复制开销，如果想避免开销，就一定要自己保证内存安全。\n\ngo可以认为是启动了新线程（较创建原生线程开销较小），goroutine是不可控的线程操作，原生带了channel用于通信，对channel的读写是阻塞的（否则执行序不可控的多个go程就无法协作了）。而coroutine其实是严格串行执行，基于共享内存通信无妨，并不需要channel，用yield和resume显示控制。\n\n每个包可以定义init函数，会先于main执行，多个包的init顺序不可控。\n\n严格地说go的函数参数传递只有一种：**值传递**。因此对复杂struct变量，用指针方式减少复制的开销。但有一种说法，在特定的场合值会比指针开销少，原因是逃逸分析。\n\n!! 编译与构建\n\n在工程源码的根目录执行go build即可。仔细看build过程，先生成一个中间过程的importcfg.link文件，内容是用packagefile指定了若干运行相关的参数，比如cpu、字节运算方式、math/sys库，并用go的link工具加载这些参数生成可执行文件a.out，然后改名成包相同的名字。\n\nimport时指定的是目录名称，导入同时会解析目录下的包名称，所以真正调用的时候以包名称引用（目录名和包名称不强制一样，但目录内的package包必须统一）。另外包名只有一级，不支持点号，所以不管import的目录名有多长，但真正起作用的，就是最后一个目录内实际的包名，而且当包名重复时，编译也会报错。所以在命名时，可以在package名中加入下划线适当增加长度，但也不需要太过冗长。导入包重命名机制一定程度上解决命名空间只有一层的简陋。\n\ngo build -tags \"abc xyz\"会启动条件编译，只有代码首行指定了`//+build abc`的文件会被编译。似乎充斥着这种打补丁似的语法，大约是实际的需求和理想化简约之间的冲突吧。\n\nrun指令可以带多个文件列表，顺序可以任意，甚至用\\*.go，否则main函数调用的其它文件没有被引入会报错，不需要像C语言把被依赖的文件放在最前面。main包平铺拆成多个文件也是最简单的项目拆分方式，如果想形成多目录，就要用replace指令，对新手来说难度会大很多。\n\n!!! 代码目录结构的变迁（go.mod）\n\n以下仅仅是历史，了解就行\n\n>  Go的1.11版本以前，代码必须在GOPATH环境变量指定的目录，背后的原因可能是Google所有的代码在同一个repo下，微缩后变成了GOPATH。固定 bin/pkg/src 三个目录，在src下建立目录比如xyz，进入这个目录下编写代码，最后用go build就会自动编译。强行指定文件名固然可以，但并不推荐。\n\n1.11引入Module机制，可以不限制在GOPATH路径。从1.13开始module成为默认行为，不再要求在GOPATH目录编译，而是鼓励在当前或父目录添加go.mod文件使这个目录成为go的模块，同时也不再限制必须有src目录。配置 `go env -w GOPROXY=https://goproxy.cn,direct` ，下载依赖包也变得非常方便。\n\n以一个简单的go.mod示例来解释构建过程\n\n```\nmodule me.local/user/tdi\ngo 1.19\n```\n\n第二行版本限定并不是必须的，其实可以精简到只有module一行。后面的模块名必须以域名开头，不用担心域名是否存在，只要遵循规范就好。最后一段会默认作为go build的结果文件名。\n\n稍微复杂的工程肯定会导入本地目录，如果有个lib目录，import时写成me.local/user/tdi/lib（module名后跟目录名），就会在源码目录找包。\n\n以前还记了一种方法，似乎也用不上了。在go.mod中添加require xxx v0.0.0和replace xxx v0.0.0 => ./xxx，关键是用replace指向本地目录，go就不会去网上找这个包了。\n\n!!! 包和模块\n\n一个目录就是一个包package，通过这个目录下的每个源文件开头申明相同的package xx表示属于一个包。取名为main的包比较特殊，通常会定义main函数作为总的入口。同一个包内的函数和类型可以互相引用，不需要申明为大写。多个包构成一个模块，通过在顶级目录添加go.mod声明是一个module。\n\ngo get下载的包会放在GOMODCACHE环境变量指向的目录。\n\n包可以被编译成.a库。解压后虽然也是.o，但和C语言不同，是混合了字符和二进制的特定形式。不过Go提倡按源文件编译，即使提供了.a库机制，似乎用处不大。\n\n!!! GUI程序\n\nwindows平台的图形化程序，链接过程必须有.syso文件才行。可以用rsrc编译manifest，或windres编译rc（内部要有RT_MANIFEST指令）都可以。go build -ldflags=\"-H windowsgui\"就不会带命令行小窗口。\n\n!! 测试与调试\n\n单元测试要函数名以 `Test[A-Z]` 方式开头，如果是小写字母则不会运行。在GOPATH下直接运行go test package，虽然能运行用例，但正常的例子不会输出到stdout，而进到package的目录直接运行go test，会输出stdout。Example开头的函数，要增加 `//output:` 才会输出。\n\n用GDB调试，build命令可以加两个参数\n\n# 使用go build -ldflags \"-s -w\"减少生成文件的体积。-s: 去掉符号信息，-w: 去掉DWARF调试信息。\n# 传递-gcflags \"-N -l\" 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。另外-m会在编译期打印逃逸分析结果。\n","modified":"20190705121530000","tags":"lang"},
{"created":"20181025121530000","title":"Graphviz使用说明","text":"\n一个包含常用元素的dot示例，中文用UTF8编码，但不能首字母用中文，可以用空格规避。\n\n```\ndigraph abc {\n  rankdir=LR\n  graph [bgcolor=\"gray\"]\n  node [shape=box, fontname=\"simsun\"]\n  edge [color=\"darkgreen\", fontname=\"Microsoft YaHei\"];\n\n  box1 [shape=record, label=\" 中文1\", fontname=\"simhei\"]\n  box2 [shape=record, label=\"abc | def\", color=\"gold1\", fontname=\"simhei\"]\n  box3 [label=\"{json | {bson|cpkg} }\"]\n\n  box1 -> box2 [weight=10]\n  box2 -> box3 [label=eval, color=deeppink]\n\n  subgraph {}\n}\n```\n","modified":"20181025121530000","tags":"tool"},
{"created":"20170110121530000","title":"groff中间格式翻译","text":"\n使用x作为控制命令，#号后面是注释(不确定是否必须放在开头)。\n输出分为prologue和body两大部分。\n通过man的例子可以看到，最简单的骨架大概是这样的：\n\n```\nx T xxx    # device name like ps or X100\nx res x y z\nx init\npnum       # this is page\nx font 1 R # this 3 line indicate font has been chosen\nfnum\nsnum\n# text begin position\nVxx\nHxx\n# your text\ntyour's input letter\n# end\nx trailer # this is actually just ignored\nVxx\nx stop\n```\n\ngroff的中间语言为简单命令、画图命令(D族Graphics Commands)和\n控制命令(x族Device Control Commands)三大系列。\n这个例子大量使用了x这个指令族。\n\nD族中最灵活的指令是D~画B样条，另外有画arc、cicrle、line等各自形状，\n加上填充颜色。这些指令构成了pic这条扩展命令的基础。\npic能画的图形也就是上述说的这些。\n\n说完中间格式再说说字体。字体文件放在devxx目录下，分为DESC和其它两大类。\n两种文件的指令集不同。\n具体的字体文件分为两段式，先是开头的字段说明如name或spacewidth，\n接下来是kernpairs(可选)和charset(必选)。charset格式如下：\n\n    name metrics type code [entity_name] [-- comment]\n\n真实的例子像这样：\n\n    u0041_0300\t24\t0\t0x00C0\n","modified":"20170110121530000","tags":"tool"},
{"created":"20210216121530000","title":"hadoop体系理解","text":"\nhdfs师从gfs的设计理念，也是面向大数据量、高吞吐的场景设计，因此单个文件默认设置为64M。而过多的小文件也会给元数据管理带来极大的负担，甚至导致OOM。\n\nhadoop除了存储还包含了调度，在容器环境从上向下分了若干层\n\n* DataNode: 同时还执行NodeManager进程\n* ResourceManager: 对应yarn，管理service和node两个维度。node看到datanode上的节点内存和vCore数量。\n* NameNode: 存储了hdfs所有的元数据，hdfs命令也在这一层执行，同时hdfs还是很多daemon的执行入口。1.0时代存在单点问题，2.0支持主备模式，仅主节点提供读写，主备切换控制的ZKFailOver也运行在这里\n* JournalNode: 为了支撑NameNode的主备切换，需要有共享存储层，业界不同厂商提出了多套方案，最后Cloudera的QJM方案被合入trunk，就是JN层。使用EditLog机制，用2N+1个副本保存数据，允许N个节点失效。当NameNode发生主备切换时，备机要从JN上同步完数据后才能工作\n\n!! 配置文件\n\n分为core、hdfs、mapred、yarn四个核心xml配置，start-dfs和start-yarn命令可以启动服务。\n\n!! hdfs元数据管理\n\nNamenode主要维护两个元数据文件\n\n* fsimage: 保存了最新的元数据检查点，包含了整个HDFS文件系统的所有目录和文件的信息。对于文件来说包括了数据块描述信息、修改时间、访问时间等；对于目录来说包括修改时间、访问权限控制信息(目录所属用户，所在组)等。简单的说，Fsimage就是在某一时刻，整个hdfs 的快照，就是这个时刻hdfs上所有的文件块和目录，分别的状态，位于哪些个datanode，各自的权限，各自的副本个数等。注意：Block的位置信息不会保存到fsimage，Block保存在哪个DataNode（由DataNode启动时上报）。\n* editlog: 主要是在NameNode已经启动情况下对HDFS进行的各种更新操作进行记录，HDFS客户端执行所有的写操作都会被记录到editlog中。\n\n写入元数据： 在NameNode运行时会将内存中的元数据信息存储到所指定的文件，即${dfs.name.dir}/current目录下的fsimage文件，此外还会将另外一部分对NameNode更改的日志信息存储到${dfs.name.dir}/current目录下的edits文件中。fsimage文件和edits文件可以确定NameNode节点当前的状态，这样在NameNode节点由于突发原因崩溃时，可以根据这两个文件中的内容恢复到节点崩溃前的状态，所以对NameNode节点中内存元数据的每次修改都必须保存下来。如果每次都保存到fsimage，效率就特别低效，所以引入编辑日志edits，保存对元数据的修改信息，也就是fsimage文件保存NameNode节点中某一时刻内存中的元数据（即目录树），edits保存这一时刻之后的对元数据的更改信息。\n\n读取元数据： 启动NameNode节点时，从镜像和编辑日志中读取元数据。\n\n因此fsimage和editlog是互相配合，这又引申出另一个进程SecondaryNameNode，主要有两个作用，一是镜像备份（不是NN的备份，但可以做备份），二是日志与镜像的定期合并。\n\n!! Yarn\n\n前身是1.x时代的JobTrack和TaskTrack，其中JobTrack是单点而且既管资源也管任务调度，职责过多，所以演化出了二代目Yarn，不仅做了水平拓展，还对功能做了拆解，Yarn最核心的组件是ResourceManager和NodeManager，通过yarn rmadmin -getAllService看到rm1和rm2两个节点的active/standby状态，因此不会有单点故障。\n\n任务提交流程\n\n# 客户端向ResourceManager提交任务请求，如果条件具备，则返回一个JobID和临时的hdfs路径，状态NEW或NEW_SAVING\n# 客户端向hdfs路径上放好运行所需的资源，进行job正式提交，状态SUBMIT\n# RM将job请求转交给调度器，调度器确认客户端有队列权限且资源足够分配AppMaster，状态ACCEPT\n# ResourceManager在NodeManager中找一个物理节点，启动AppMaster（如spark的driver和flink的jobManager），状态RUNNING\n# AppMaster继续向RM申请资源，确保NM上可以创建任务；然后找NodeManager创建Container，并执行子节点任务\n\n注意第4步状态虽然是RUNNING，但只有AM在运行，分布式任务往往要启动更多子节点，但从YARN的角度无法知道子节点是否在运行，也因此会限制AM占用资源的上限，否则会出现AM互相等待而任务永远无法启动的窘境。\n\n因为都基于yarn执行任务的流程框架，所以spark和flink的运行过程是非常相似的。\n\n!! Hive的数据分区\n\n对关系型数据库而言，随着数量的扩大，计算会越来越困难，这时将数据按一定规则拆分，减少每块的大小，从而提升速度。分区将数据切分，每个分区都是全部数据的一部分，整体构成全部数据。\n\n对hive而言，由于不能update，所以只能每次全量更新，这就导致离线计算特性，每天全量计算一遍数据，因此hive的分区是update的一种替代，更类似时序的概念，不同的分区对应hdfs不同的目录，只表示新旧，不会将数据切分，每个分区都是全量。","modified":"20210216121530000","tags":"data"},
{"created":"20170405121530000","title":"HTTP2特性学习","text":"\nHTTP2在制定时要保证不破坏语义且要尽可能地兼容，为了平滑地从HTTP/1.1升级到HTTP/2，会用到Upgrade协议头，但这样就会消耗一整个来回做升级动作，在标准制定时Google/FireFox的人都非常反对这一点，且HTTP2的前身SPDY就是利用TLS握手阶段进行协商，还定义了一套称为NPN的协议，HTTP2也类似，最终规范要求至少要TLS1.2版本，且协商协议换成了ALPN。这两者的差异在于ALPN是服务端最终确认协议细节，而NPN则是客户端确认。\n\nHTTP1.1有个很大的限制，每次请求在应答到来之前不能发下一个请求。因为协议本身没有标识请求序号的字段，导致只有等待响应收完才能发新的请求，要么干脆建立多个连接，在每个连接上并行地发请求。但是建立连接的开销是非常大的，在HTTP2时代，终于通过在请求头，规范叫Frame里加上了一个31bit的无符号sequence id的方式把问题解决了。用31bit是考虑到跨语言，比如Java没有unsigned int，如果一定要用uint32，就必须使用int64方式，显然划不来。\n\nFrame是个9字节的二进制段，包含长度、类型、标志和请求序号四部分，非常紧凑。长度只有24bit。请求序号采用客户端奇数服务端偶数的方式配对。","modified":"20170405121530000","tags":"protocol"},
{"created":"20190526121530000","title":"HTTP的认证方式","text":"\nHTTP初衷是定义为无状态协议，但随着使用日渐广泛，认证也纳入了RFC7235的定义。客户端如果请求一个不被允许的资源，服务端返回401或407，消息头带上WWW-Authenticate，并告知认证算法和域信息。客户端再根据这些信息，计算出一个签名，填到Authorization字段，后面用一个词表示认证算法，申请新的算法要向IANA提交申请并经IETF审核，已入标准的有Basic、Digest、Bearer、HOBA约10种。也可以是私有扩展，后面必须有一个空格，然后是签名值。如此这样交互下来，服务器才会认可这次访问是合法的。\n\n示例\n\nServer\n\n```\nWWW-Authenticate: Basic Realm=XYZ\n```\n\nClient\n\n```\nAuthorization: Basic ABC=\n```\n\n上述是服务端对客户端要求的单向认证，另外还有RFC8121双向认证，使用了离散对数或椭圆曲线算法的Key Agreement Mechanism 3机制。\n\n为解决SSO问题，HTTP扩展了 Negotiation 认证，也叫SPNEGO(Simple and Protected GSSAPI Negotiation Mechanism)。 Windows 支持两种 Negotiation认证方案：NTLM和Kerberos。Linux上的实现一般不支持NTLM，只支持Kerberos。\n\n!! OAuth流程\n\n每个带统计或权限的应用系统，肯定会希望有用户体系，但现实是用户往往不愿意注册，这种场景下，就要依赖向另一个管理帐号的系统(简称U)请求认证，并依赖U的校验结果去鉴定用户。\n\n要解决的第一个问题，不能触碰用户输入密码的环节，所以U一定要提供一个完全的登陆框，但这就安全固然解决，可是登陆后要去干什么呢？所以这个登陆页的参数一定要有个callback，如果登陆成功，把cb的值用302方式回复浏览器，这时还要带一个code，表示登陆成功，这个code在一段时间内，就可以证明，用户在U系统上是存在的。\n\n到此，用户是否存在(真实性)的问题就解决了，如果还想知道到用户是谁，要做进一步动作。用code再一次向U的网页发起请求，用户在页面上选同意的话，返回token，最终用token去请求资源，也只有token换资源这一步，不会弹出网页。","modified":"20190526121530000","tags":"protocol"},
{"created":"20191020121530000","title":"HTTP协议历史与细节","text":"\n!! 来源\n\nLee在1980年时，便在CERN构建ENQUIRE系统，构建这个系统的经历，促使他在1989年3月开发了HTTP最早的版本0.9，当时还只是Lee在CERN的试验产品，直到1997年才发布了如今使用最广的1.1版本。巧合的是CGI版本也在同年正式归档RFC并发布1.1版（CGI起草于1993年，由于其目的就是解决HTTP的动态能力不足，当然晚于HTTP）。\n\n和WWW万维网有一定相似性的Gopher协议诞生于1991年，可以说和HTTP的历史相当，技术上两者区别很大：Gopher使用分层结构，而HTTP则使用链接系统。\n\nHTTP协议诞生时，也有其它协议，比如邮件、FTP、新闻组等协议，但这些协议都无法承载链接系统，因此Lee最终决定开发新的HTTP协议。正因为HTTP是小字辈，因此body内容的类型是从邮件标准抄的，形式上用/划分大小类别。历史上邮件发展要早得多，发送附件的需求也更迫切。\n\n重定向3XX至少有5个值，广泛接受的是301和302。\n\n* 301: 永久重定向，会影响爬虫，浏览器书签的行为，将域名改为新地址，节省下次访问时间\n* 302: 暂时重定向，暗示会恢复，可用于临时性关闭服务\n\nRange头可以跳过并只传输一部分，但前提是服务器首先要在响应里用Accept-Range:\nByte 表示支持。一旦开启会用206表示Range响应。\n\n语义规定在一个连接上前一个请求没完成后面的请求不会被处理，所以有了多连接，最早的RFC规定只有2个连接，但浏览器都不遵守，后来RFC只好从事实去掉了连接上限。\n\n!! HTTPS代理\n\n直连的HTTPS肯定是全部加密，但如果中间要经过代理，代理就没法转发了，有两种模式\n\n# CONNECT报文\n\n客户端发现目标网址是HTTPS且要经过代理，就会先发送CONNECT请求，并带上host和port，当对端连接上后，返回HTTP/1.1 200 Connection Established，注意不是200 OK。紧接着，代理端会尝试去连目的端，成功后代理就会建立HTTP隧道，这个隧道中流转着代理将收到的请求消息原模原样发往目的端的数据。代理除了知道目标地址外，不会获取其它内容。\n\n# SSL之SNI\n\n利用TLS/SSL握手的第一个Client Hello报文中的扩展地址SNI (Server Name Indication)来获取。这种模式不会出现CONNECT请求，隐蔽性更好。","modified":"20191020121530000","tags":"protocol"},
{"created":"20190326121530000","title":"Java程序的演变","text":"\n编译后的class类似lua的luac文件，jvm去加载并从指定的类开始跑。不过从一开始，java就支持导入和打包，尤其是打包，引申出很多内容。\n\n最早出现的jar包，把多个class集中到一起，作为库或执行程序来发布。jar包的顶层目录结构包含META-INF目录，其中有MANIFEST.mf文件，如果是可执行程序，就要指定Main-Class作为入口。后来sun出了servlet规范，类似python的WSGI，都是语言专属规范，按servlet写好的类，不用考虑底层的网络处理。当年不选择CGI，是因为它和HTTP强绑定，而Java想做通用网络规范。HttpServlet就是语言专属的特化规范。\n\n为了配合tomcat这个网络层的运行时，显然需要配置文件，类似于nginx的location语句，这些配置文件一起被打到jar包，为了体现差异，就把后缀改成war。多了一个和META-INF并列的WEB-INF目录，后来的springboot则用BOOT-INF命名目录。\n\nwar包流行了至少十多年，慢慢地微服务的概念起来，服务变小再用tomcat加载就很啰嗦，于是springboot把所有的库和资源，包括嵌入式tomcat打到一个包，拿着1个文件，随便往哪一丢，连命令行参数都不用指定就跑起来了，于是war又回归了flat jar(实质是jar in jar的二重封装)。这种包的Main-Class是org.springframework.boot.loader.JarLauncher，Start-Class才是你写的类。\n\n顺带说句tomcat实现servlet规范，比较适合阻塞式的模型，追求非阻塞的服务，网络层甚至都不再用tomcat了。\n\nflat太大，依赖的lib通常不会更新，可以瘦身。先正常编译，并把BOOT-INF/lib解压出来。修改pom.xml，在configuration、ZIP后加入\n```\n\u003Cincludes>\n    \u003Cinclude>\n          \u003CgroupId>nothing\u003C/groupId>\n          \u003CartifactId>nothing\u003C/artifactId>\n     \u003C/include>\n\u003C/includes>\n```\n就能打出没有lib的包。用java -Dloader.path=/path/to/lib -jar /path/to/springboot.jar 运行。\n\n!! bean\n\n最早为了配合IDE开发GUI出现的概念，变成了大家共同遵守的约定，随着加入越来越多的需求，变成EJB，事情过了头又被spring的bean替代，解决的问题，无非是数据的包装和生命周期管理，惟此GC才能正常工作。\n\n!! maven\n\n既然上面给了配置片断，就展开讲讲pom要怎么理解。每个project由groupId(推荐用域名)和artifactId(对应jar名)标识出来，另外vertion当然是必备的。\n\n!! 组织和标准委员会\n\n1998年成立的JCP组织，community process是运作委员会，而每个提案则以JSR，specification request经过多轮讨论，只有到final阶段才算发布。\n\n!! 使用体会\n\n以HTTP发送JSON为例子。解析和序列化是个很繁复的工作，每种JSON都必须先定义一个类，运行中由反射出来的信息，根据类的scheme进行解析，完全不是随心所欲地写节点。要用这种重器，必须先想清楚结构，才能下笔。于是登陆就拆成3个类，1个行为加2个结构类。倘若换在C里，也是如此拆分，但不可能为结构体单开一个文件。\n\n再说异常，这恐怕和C的差别就更大，似乎风气导向，出现问题抛异常并在最后统一处理，往好了说是把正常和异常代码各划各片，但新语言如go仍反对异常，只能说语言倾向和手法不同。\n\n说说编译，稍微有点功能的程序，依赖包必不可少，`-classpath .;../lib/xx.jar`非常重要。其中的点号一定要有，每个用到的jar包都要写进来，编译和运行都如是。\n\n!! 远程调试\n\n支持多种connector，不过最常用的还是socket。shmem仅局限于windiws，不看也罢。\n\n客户端用 jdb -connect com.sun.jdi.SocketAttach:hostname=192.168.101.72,port=8899\n\n服务端启动脚本：\n\nJAVA_OPTS=\"$JAVA_OPTS -agentlib:transport=dt_socket,address=127.0.0.1:8000,suspend=y,server=y\"\n如果是调试jar包，指令：\n\njava -Xdebug -Xrunjdwp:transport=dt_socket,address=127.0.0.1:8000,suspend=y -jar remoting-debug.jar","modified":"20190326121530000","tags":"lang"},
{"created":"20190921121530000","title":"JS的单线程和运行时","text":"\nJS的单线程特性(eventloop)不仅体现在浏览器上，node同样，二者的运行逻辑可能有区别。所以别的语言常见的sleep函数，都必须要用setTimeout配合Promise迂回实现。\n\n运行中遇到回调，会根据类型放到两种不同的回调队列。\n\n# 脚本主体逻辑，创建Promise，设置定时器，又叫宏任务\n# Promise回调，process.nextTick，DOM变化，又叫微任务\n\n宏队列至多执行一个任务，就去检查微队列，直到微队列空了，事件循环会判断并做UI重绘。重绘后回到宏任务继续执行一次，如此循环。node没有UI，但同样遵守微任务批量宏任务单个的原则。\n\n应用最广的是Promise/A规范，属于Promise，又隶属于CommonJS。构造Promise对象传入1个两参函数，形如 Promise(function(resolve, reject))，resolve和reject都是单参函数。构造Promise时必须要执行完executero才会返回，所以new Promise动作是阻塞的，ES7增加的await则把构造Promise对象的阻塞动作给异步化。\n\nPromise初看起来是callback的语法糖，但最本质的区别是解耦数据的生产和消费。因为callback方式，必须在发送请求时就指定要执行的动作，而Promise的构造返回的值是代理对象，这个过程中只产生数据（如发送ajax请求），怎么处理等后续挂上then或catch方法，在then或catch方法中处理。then 方法中的回调是**异步执行**的，典型的实现方式是prototype.then的实现中，用\n\n```\ntimer = setInterval(()=>{ if (this._state == 'full|reject') { clearInterval(timer) } }\n, 0)\n```\n\n的方式不停地循环检测state状态，直到改变就执行resolve或reject方法。状态只能从pending变成fullfiled或reject，一旦状态改变后，定时器就会取消，也不会再触发回调。\n\n通过async关键字，把普通函数用Promise包装起来，如果直接调用async函数，得到的当然是Promise对象，如果用await方式调用，就能得到Promise之后的值。","modified":"20190921121530000","tags":"lang"},
{"created":"20180410121530000","title":"JS和AWK语言的new和delete","text":"\n!! new\n\n在JavaScript中，使用new关键字后，意味着做了如下四件事情：\n\n# 创建一个新的对象，这个对象的类型是object；\n# 设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的；\n# 执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性；\n# 返回新创建的对象（除非构造方法中返回的是‘无原型’）。\n在创建新对象成功之后，如果调用一个新对象没有的属性的时候，JavaScript会延原型链向止逐层查找对应的内容。这类似于传统的‘类继承’。\n\n注意：在第二点中所说的有关[[prototype]]属性，只有在一个对象被创建的时候起作用，比如使用new关键字、使用Object.create、基于字面意义的（函数默认为Function.prototype，数字默认为Number.prototype等）。它只能被Object.getPrototypeOf(someObject)所读取。没有其他任何方式来设置或读取这个值。\n\nLua也是基于原型的语言，虽然它并没有自带new关键字，但可以从第三方库看到模拟。比如loop库的实现，就执行了 `setmetatable(object or {}, class)`，使用一个现有或创建新对象，并将这个对象的元表指向另一个表，关键特性和JS一样。\n\n由此可以看明显看出和基于原型和基于类的构造差异。比如C\\+\\+的new，第一步类似，开辟一段新的空间存放对象，不可能有第二步设置原型指向动作，直接把这块新的空间作为this指针执行构造函数，最后返回对象相同。\n\n!! delete\n\n带有垃圾回收的语言，很大的好处分配对象不需要手动考虑回收的问题。但JS和AWK的关联数组对象，允许用delete语法手动删除某个指定元素，GNU的AWK扩展还允许用delete obj;这种语法把obj内的所有key value对一次性全部删除。\n\n须知GC的运作要依赖对象的可达性或计数值，但不论是哪种，关联数组内的成员的生命周期都受外层变量的控制，无法单独的让GC去释放。类似的问题还出现在函数的upvalue上，只是因为upvalue是匿名的，而且和函数模拟的对象有密不可分的关系，因此只针对关联数组提供了delete语法。\n\n之所以会想到这个问题，是因为lua5.4的work1版有个很大争议的改动：table中nil到底是什么语义。到5.3版本为止nil是相当于delete语法的作用，但这就产生了另一个不一致，nil作为基本类型却无法放入table中。这种不一致让语言的作者觉得是个必须要解决的问题。\n\n比较两种语言的使用方式，这大概就是delete存在的意义吧。\n\n!! 附：AWK语言\n\n在shell中诸多工具中，AWK是相对功能最丰富的工具，只有它可以创建函数。整体代码结构由复数个awk rule和可选的函数定义组成，每个rule由pattern和action两部分构成。pattern可以省略，默认捕获整行，action就是要做的动作。最常用的pattern是匹配一行中某部分的内容；另外有两个特殊的pattern，分别是BEGIN和END。如果只有BEGIN块，AWK会跳过读文件步骤，此时相当于执行脚本自身，可以利用这个特性，执行一些略复杂的逻辑。但如果除了BEGIN外还有END块，awk会默认附加一条打印输入行的行为，执行后会停留在读stdin阶段。\n\n整个脚本会编译两次，先找出函数定义，再编译awk rule（和JS有点类似）。所以函数块可以放在任何位置，为了不遮挡主体逻辑，建议把函数块放最后。示例如下\n\n```\npattern {\n   action\n}\nfunction xxx() {\n}\n\npattern := BEGIN | END | /regex/\n```\n","modified":"20180410121530000","tags":"lang"},
{"created":"20180501121530000","title":"JS模块化历史","text":"\n在2009年1月，Mozilla的程序员Kevin Dangoor发起了名为ServerJS动议，这是最早的模块规范。同年8月更名为CommonJS。为了适应浏览器环境，慢慢发展出了异步加载的AMD规范，最初是被挂在CommonJS下面，后来因为两个环境差异实在太大，最终分道扬镳。Dojo库率先实现了这个规范。最晚到2011年10月中旬已经有多个库支持AMD规范。\n\nCommonJS定义了require和exports，而AMD定义了define。\n\n!! node\n\nnode诞生于2009年5月27日，ES6的标准化则迟至2015年6月，由于node出现在前，发展出一套自己的require加载语法，不能和ES6的语法混用。\n\n假设Y是路径，X是文件名或目录名，当 Nodejs 遇到 require(Y+X) 时，按照下面的顺序处理：\n\n# 如果 X 是核心模块（例如：require(\"http\"), path, buffer）\n\n　　a.返回该模块\n\n　　b.不再继续执行\n\n# 如果Y是以“./”、“/”或“../”开头\n\n　　a.把X当成文件，从指定路径开始，依次查找下面文件：X、X.js、X.json、X.node，只要其中一个存在，就返回该文件，不再继续执行\n\n　　b.把X当成目录，从指定路径开始，依次查找下面文件：X/package.json(main字段)、X/index.js、X/index.json、X/index.node，只要其中一个存在，就返回该文件，不再继续执行\n\n# 如果 X 不是核心模块，也没有以“./”、“/”或“../”开头，则Nodejs会从当前模块的父目录开始，尝试从它的 /node_module 目录里加载模块，如果还是没有找到，则移动到再上一层父目录，直到文件系统的根目录\n\n# 抛出“not found”\n\n通过debug/inspect模式会发现执行文件的语句，在node内部变成一个立即函数调用，像这样\n\n```\n(function (exports, require, module, __filename, __dirname) {your code}\n```\n\n这就很好理解，为什么每个脚本都会有5个预定义变量了。同一个文件直接运行和被require时，module对象被解释成不同的含义。比如test.js，运行node test.js，module.parent的值是null。而node -e \"require(./test.js)\"，module.parent的值就指向另一个module，这个module是命令运行产生的，id是`[eval]`，如果不用-e，会打印对应的文件名。\n\n!! ES6\n\n使用export(注意不是exports)和import关键字。\n\n!! 差异\n\nnode的require是动态加载，用if (x>1) else可以加载不同的模块，而ES6的import则不行。\n\nnode加载的是值，即使模块的值变化了，不会影响node中已加载的地方。而ES6是引用加载，会受模块影响。","modified":"20180501121530000","tags":"lang"},
{"created":"20170121121530000","title":"Json中的null和undefined","text":"\n由于Json是来自于JavaScript，因此讨论Json中的字段必须要回归到JS中。\nnull在JS语言定义里是一个字面量，且是基本类型。如果typeof null会返回Object。\n据说是因为想把一切变量都作为对象，所以会有这种定义。虽然这是个历史错误，组委会也曾经讨论过改成null，\n但是考虑到大量代码已经在使用，就不去改变它了。\nnull的类型是Object这点争议很大，但既然规范如此只能按这个思路去理解它。\n大概就是null不是空引用，而是一个原始值，它期望被引用成一个对象，因此null自己也是Object。\n\n而另一个undefined则不是基本类型，它是全局对象的一个属性，更像是值。\ntypeof undefined比较明确直观，还是undefined。\n\n然后回到Json，构造一个变量比如val = {a:1, b:2}，此时val.c的值是undefined。\n原因是这里本来就没有c这个属性，也并不期望c会引用另一个对象，\n所以值不能是null。另外我觉得，比如把a的值赋为null，在动态类型的角度\n这样做也无可厚非，但是静态类型是有严格的界限的，如果a应该是string，\n结果被置为null，会改变它的类型。\n\nJavaScript秘密花园称undefined更像其它语言的NULL，而js的NULL在语言内部另有它有。\n比如js的函数未定义返回值，返回undefined。在PHP中未定义函数返回的是NULL。\nLua函数未定义也是返回类似nil的效果(我理解这更像是一种编译器的优化作用，而非固有语义)。\n比如function foo(a) a=a+2 end这样一个函数，直接print(foo(1))会输出一个空行，\n而如果显示地return nil，则print会输出nil，说明Lua的VM在某种程序区分了undefined和nil，\n只是无法在Lua中表现而已。\n\n再说一个关于undefined的事，将一个JSON串序列化成对象，如果取一个不存在的值，jsoncpp库会根据取的类型赋以默认值，\n如asInt是0，asString则是\"\"。但在JS里，则直接返回undefined，如果对这个值进行parseInt，返回的也是NaN，而不是0。\n所以严格来说，jsoncpp对不存在的值进行asDouble要返回NaN，但并没有这么做。\n一方面是因为`C++`语言没有对应undefined的概念，加上又是一门强类型语言，用之前必须要指定一个值，\n所以只能拿近似的NULL并转换成对应类型的0或\"\"充数了。","modified":"20170121121530000","tags":"lang"},
{"created":"20220405121530000","title":"Kubernetes笔记","text":"\nk8s不仅是软件，它还是虚拟化软件的组织体系，它定义了运行时、网络、存储的接口，自身实现则专注于容器的调度。\n\n!! 体系标准\n\n* CRI: 包含运行时和镜像两个子集，由于k8s晚于docker，所以CRI规范和docker推出的OCI是兼容的\n* CNI: 比较有名的有flanel和calico，据说flanel最简单，calico更灵活，我只见过calico，还要继续研究\n* CSI: 不确定k8s自身的PV/PVC/StorageClass是否属于这个体系，只知道topolvm是一种实现\n\n!! 基本概念\n\nPod是k8s的最小单元，将多个容器封装在一个整体，在Pod中Linux的各种namespace以及存储卷是共享的。Pod是豆荚的意思，每个容器则是一个豆子，多个豆子共同包裏在豆荚内，形象生动。\n\nk8s有JSON和YAML两种描述格式，JSON用于API，暂时还不了解。YAML则是配管。做helm应用模板是个高层封装，由于包含了很多内容不易理解，但最基础的内容并不复杂。YAML文件包含4个部分\n\n* apiVersion: 不考虑复杂特性填v1，但其实有不少于8个可选项\n* kind: 类型非常丰富，而且当apiVersion变化后，取值范围也不一样\n* metadata: 是个复合值，不可缺少的是name属性\n* spec: 也是个复合值，属性最多的段。helm模板做的各种封装也针对spec\n\n!! kind\n\n* Pod: 似乎生产环境不会用，必须太基础，但从学习的角度，这是k8s的第一步\n* Service: 将一个或多个Pod封装，提供稳定的服务。包括Pod间负载均衡，服务级虚拟地址（但只限本机访问）\n* ReplicaSet/Depolyment: Pod难免会挂掉，这种模式就保证了始终能运行指定数量的Pod\n* StatefulSet: 相比Depolyment增加了持久化数据的能力。和Deployment是主要应用于生产环境的类型\n* ReplicationController\n* PersistentVolume/PersistentVolumeClaim: \n\nkubectl作用在整个集群上，找到某个pod在哪台物理机，就可以在那台机上用docker进入。","modified":"20220405121530000","tags":"os"},
{"created":"20170820121530000","title":"libuv代码走读","text":"\n虽然并不提供Makefile，但通过CMake的脚本很容易就把要编译的文件找到，编译宏只有两个。\n\nuv的核心是loop，加上两个父级的抽象类型，handle和request。uv支持的18种句柄都是`uv_handle_t`或其子类。句柄派生出3个层级，如果只关心网络的读写，主要看`uv_stream_t`及衍生出的tcp，pipe,tty。从tcp的定义能很清晰地看出3层关系。\n```\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n```\n\nuv库多数接口都是非阻塞的，阻塞有`uv_run`，`uv_thread_join`，`uv_sem_wait`，`uv_rwlock_wrlock`等，线程类的好理解，但是文档并没有说run要阻塞多久。自己的测试结果来看，如果没有任何操作下执行run会立刻结束，如果在run之前执行一个内网连接并发送读取数据，大约会阻塞几毫秒。\n\n看`uv_run`的代码，最核心的数据loop里包含一个`uv_handle`的最小堆，run的时候每次从堆中取出顶点并执行。这就解释了如果一开始就执行run，因为堆中没有数据就立刻返回，如果有一个handle，则等待这个处理完成，run就结束了。\n\n因为`uv_run`的这种特性，必须要在执行它之前将所有会用到的句柄注册到loop，回调并不神秘，所有的接口如果允许传入回调函数，这个回调函数都会注册到loop中，并在符合条件时被触发。以TCP客户端为例说一下：\n\n传统上socket的connect操作如果用阻塞模式，执行时间是无法预期的。uv封装后的函数是`uv_tcp_connect`，最后一个参数是函数指针`uv_connect_cb`。这个指针就会先注册到loop，再尝试发起连接，直到connect成功或失败，这个回调就被执行。但这个回调只能被执行一次，显然我们肯定希望这个tcp连接收到数据就能持续地被回调，就要在`uv_connect_cb`的实现里注册一个读回调，函数名是`uv_read_start`，最后一个参数也是回调，这个回调会常驻loop，一旦有数据就能执行回调。除非显式地调用`uv_read_stop`。这两个函数没有tcp字样，原因是uv中把tcp/pipe/tty抽象成了`uv_stream_t`类型。\n\nstream的读写包含`uv_read_start`，`uv_read_stop`，`uv_write`。既然是读写，必然涉及`uv_buf_t`。读有两个回调，第一个回调是让用户分配buf空间，分配的大小是写死的！tcp和udp是65536，tty是8192或1024，只有pipe是运行中决定。当空间创建后，再把这块buf用来recv，把读出的数据写进去后，触发第二个回调。所以这两个每个都必不可少，且回调间有严格的时序关系。\n\n做到这一步还有个问题，此时流程已经运行到`uv_run`且已经阻塞住了，没法输入数据，这时就要用上三个并列的很有用的类型，idle/prepare/check，这三个实现代码很巧妙，用宏的方式定义，并通过传参的方式复制了三遍，第一次我用常规方式搜索代码无果，才发现是用了宏展开方式来实现的。\n\n三者和具体的业务态在loop的执行顺序是idle -> prepare -> specific poll -> check。由此可知poll执行前后会被调用，作一些校验和保证，类似Effiel的前验和后验概念。这三者都是寄生形态，如果没有tcp之类的事件，单独的idle不能永续存在。\n\nuv内部两个核心也是仅有的数据结构:heap和queue。heap查找最小值(似乎只用于timer)，queue遍历(loop, threadpool, pipe会用到)。实现得简洁干净，值得一读。\n\nuv的缓存`uv_buf_t`采用了和各自平台一致的定义方式，unix下是iovec，windows下则是WSABUF。因为内部实现时，如果buf数量大于1时会调用writev来替代write，所以参照iovec/WSABUF的定义就不奇怪了。\n\n`uv_run`返回之后要用`uv_loop_close`把loop关掉。和demo上演示得不同，这个函数不一定返回成功，就是说可能释放是失败的。释放包括iocp,timer,以及前面提到的idle,prepare,check句柄。\n\n说说线程库，创建用`int uv_thread_create`，返回成功与否，参数有3个，分别是tid，cbfunc,ud。调用之后要用`uv_thread_join`，内部实现是调用WaitForSingleObject。","modified":"20170820121530000","tags":"net"},
{"created":"20210205121530000","title":"Linux的权限与sudo辨析","text":"\n!! 组\n\nid命令显示gid和groups输出，原因是每个用户只有一个初始组，但会加入多个组。当只有一个组时，这两个输出相同，加入多组就能看到区别。\n\n组也有密码，但很少用，实际中多用sudo来完成权限管控。\n\n!! 权限\n\nlinux的权限管控主要体现在两方面：\n\n1、文件权限 2、进程权限\n\n文件权限包括五种：\n\n* r：可读取文件内容或目录结构\n* w：可修改文件的内容或目录的结构（但不包括删除）\n* x：文件可被系统执行或目录可被作文工作目录\n* s：文件在执行阶段具有文件所有者的权限\n* t：使一个目录既能够让任何用户写入文档，又不让用户删除这个目录下他人的文档\n\n一个文件拥有三组权限，所有者权限、所属组权限、其他人权限\n\n进程权限\n\n进程就是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。这里介绍两个最重要的进程权限id\n\nreaal user id(ruid)：执行进程者的 user id，一般情况下就是用户登录时的 user id effective user id(euid)：决定进程是否对某个文件有操作权限，默认为ruid\n在文件权限和进程权限id里，s文件权限和euid权限id是sudo实现提升权限的根本。一个进程是否能操作某个文件，取决于进程的euid是否拥有这个文件的相应权限，而不是ruid。也就是说，如果想要让进程获得某个用户的权限，只要把进程的euid设置为该用户id就可以了。在具体一点，我们想要让进程拥有root用户的权限，我只要想办法把进程的euid设置成root的id：0就可以了。\n\nLinux提供了一个seteuid的函数，可以更改进程的euid。函数声明在头文件里。\n\nint seteuid(uid_t euid);\n但是，如果一个进程本身没有root权限，也就是说euid不是0，是无法通过调用seteuid将进程的权限提升的，调用seteuid会出现错误。 那该怎么把进程的euid该为root的id：0呢？那就是通过s权限。\n\n如果一个文件拥有x权限，表示这个文件可以被执行。shell执行命令或程序的时候，先fork一个进程，再通过exec函数族执行这个命令或程序，这样的话，执行这个文件的进程的ruid和euid就是当前登入shell的用户id。\n\n当这个文件拥有x权限和s权限时，在shell进行fork后调动exec函数族执行这个文件的时候，这个进程的euid将被系统更改为这个文件的拥有者id。\n\n比如，一个文件的拥有者为user_1，权限为rwsr-xr-x，那么你用user_2的文件执行他的时候，执行这个文件的进程的ruid为user_2的id，euid为user_1的id。\n\n创建一个main.c文件，并写入如下代码：\n\n```\n#include \u003Cstdio.h>\n#include \u003Cunistd.h>\n\nint main(int argc, char* argv[])\n{\n        printf(\"ruid: %d\\n\",getuid());\n        printf(\"euid: %d\\n\",geteuid());\n        return 0;\n}\n```\n\n运行结果如下：\n\n```\nruid: 1000\neuid: 1000\n```\n\n通过chmod和chown为文件更改拥有者和添加s权限\n\n```\nsudo chown root ./main\nsudo chmod +s ./main\nruid: 1000\neuid: 0\n```\n\n此时由于文件的s权限，euid已经变为了root的id：0\n\n将代码修改如下：\n\n```\n#include \u003Cstdio.h>\n#include \u003Cunistd.h>\n\nint maind(int argc, char* argv[])\n{\n    printf(\"ruid: %d\\n\",getuid());\n    printf(\"euid: %d\\n\",geteuid());\n\n    if(execvp(argv[1], argv+1) == -1){\n        perror(\"execvp error\");\n    };\n    return 0;\n}\n```\n\n编译后执行\n\n```\nsudo chown root ./main\nsudo chmod +s ./main\n./main apt update\n```\n\n可以看到，已经成功运行apt并进行了软件列表的更新。查看sudo的权限，就是一个拥有者为root且拥有s权限的可执行文件。\n\n-rwsr-xr-x 1 root root\n\n实际的sudo实现要比这复杂的很多，比如检查配置文件，来决定哪些用户可以使用sudo，为了安全考虑sudo还要求验证ruid的用户密码等。\n\n!! 记录用户登陆行为有3个文件\n\n* utmp: /var/run/utmp，记录当前正在登录系统的用户信息，默认由who和w记录当前登录用户的信息，uptime记录系统启动时间。u表示up\n* wtmp: /var/log/wtmp，记录当前正在登录和历史登录系统的用户信息，默认由last命令查看。w表示when\n* btmp: /var/log/btmp，记录失败的登录尝试信息，默认由lastb命令查看。b表示bad\n\n这3个命令据考证在1971年的Unix v1版本就出现了，当时文件记录在/tmp目录，所以这个有些随意的名字就一直沿用至今。文件是二进制格式，3个文件遵循相同的记录格式，解析参考/usr/include/utmp.h文件。\n\n!! 文件隐藏权限\n\nOperation not permitted，用lsattr查到有i权限，用chattr去掉后通过。也可能文件本身没有问题，但归属的目录有问题，用lsattr -a查看目录并操作。\n\n文件属于e2fsprogs包。","modified":"20210205121530000","tags":"os"},
{"created":"20190501121530000","title":"Linux的软件包管理软件说明","text":"\n不同发行版有独特的包管理软件，分为打包软件和包管理两块，相对来说打包软件定义包的格式，而包管理要解决的问题要复杂得多。\n\n# 添加软件时，要记录所有依赖的库和执行程序，且依赖项的引用计数要加1\n# 删除库时，所有依赖这个库的执行程序都要连带删除\n# 删除执行程序时，对其依赖的库的引用计数要减1，如果减到0了，要提醒用户，但并不删除，比如apt autoremove就是用于删除引用计数为0的库和执行程序\n# 更新软件时，对依赖项有变动的，要更新引用计数，并按上面提到的策略给用户以提示\n# 列举已安装软件时，apt做得很清晰。如果是被连带安装，会标注automatic，如果引用计数到0了，会提示auto-removable。对被连带安装的软件，如果手动安装一次，其auto标记会被清除，以后就不再提示auto-removable了。\n\n!! CentOS\n\n可以更新系统内核版本。\n\n* yum clean all\n* yum update\n\n时间取决于和最新版本的差距，我从7.3到7.6约用了10分钟。为了让新安装的内核成为默认启动选项，你需要如下修改 GRUB 配置,打开并编辑 /etc/default/grub 并设置 GRUB_DEFAULT=0.意思是 GRUB 初始化页面的第一个内核将作为默认内核。不过这条我没用到。\n\n升级后不同版本会遗留很多的垃圾，要清理。先找出冗余内核\n\nrpm -qa | grep kernel\n\n对不是当前在用的，复制名字并删除。\n\nyum remove xxx  yyy\n\nyum不会升级内核版本，elrepo.org 专门负责有内核升级需求的人。命令如下\n\n* rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n* rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm  //适当调整\n\n仓库启用后，你可以使用下面的命令列出可用的系统内核相关包:\n* yum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available\n\n接下来，安装最新的主线稳定内核:\n* yum --enablerepo=elrepo-kernel install kernel-ml\n\n外番：rpm的命令围绕-q, -i, -e展开，选项不能随意搭配，但顺序随意。有些只用于-q查询，有些只用于-i安装。奇怪的是-R只在man能看到，帮助没有显示。\n\n!! AlpineLinux\n\n首先编辑/etc/apk/repository，到你想要的版本号，执行\n\n* apk update   ; 更新repo的index\n* apk upgrade  ; 更新程序实体\n* sync;reboot  ; 保证落盘重启生效\n\n!! Debian\n\n版本7(wheezy)以前是apt-get和apt-cache分离，版本8(jessie)增加了统一入口apt。apt-get负责下载软件和仓库索引，而apt-cache是查询，初始干净的版本是没有仓库索引的，这时用apt-cache搜索没有结果，是正常现象，apt-get update后就能正常使用了。\n\n!! Gentoo\n\n衍生自BSD系的portage，全部由python/bash构成。和其它二进制方式管理包不同，仓库同保存的各种软件的元信息，以目录形式保存描述，倾向于源码编译。\n\n所有的命令都以e开头，核心命令是emerge，支持5种安装格式。意寓把某个软件合并到portage树，最常用的world是一个set的别名。另外还有ebuild，emaint等。\n\n由于从源码编译，有几个很独特的概念\n\n* USE: 类似编译开关，选择是否取消某些连带项，而arch就做不到，只能取决于维护者的个人喜好\n* mask: 对包做的标记，如果前提不满足，无法安装\n* EAPI: ebuild的格式版本，隔一段时间会更新，如果达不到上游的要求不能安装软件\n\n!! Arch\n\npacman的命令风格格式全部以`-[DQRSU]`开头，接下来是选项，如果是单字选项可以直接跟在命令后面。比如-Qv命令显示同步源和所有已安装的包，比如我的版本有5个文件，大小从4K到5M不等，每个文件是gz压缩的纯文本。所有已安装的包也以独立目录的形式存在，每个包的描述、文件详情都能很方便得看到。\n\npacman的包没有.deb或.rpm这样特殊的后缀，而是很朴实地用了.tar.xz名（也可以配置为.tar.gz）。包的内容通常是建立在/usr目录下的各个文件，还有.BUILDINFO, .MTREE, .PKGINFO三个元数据文件。制作包也很朴实，写好PKGBUILD文件，再用makepkg就能打包。\n\n!!! pacman在其它发行版上的尝试\n\n起因是装了Gentoo但是磁盘空间不够，第一步emerg-webrsync就失败了，无法下载软件的系统是没有意义，于是想既然Linux的内核一致，能否从别的发行版移植包管理器来用。\n\n最流行的当然是apt，但这几天刚好在用ArchLinux的pacman，而且从不足2小时的了解来看，pacman非常简明，且源码只有3M，感觉比较容易，这是我第一次尝试编译包管理系统。pacman依赖并不多，在这个2015年左右的Gentoo上，只缺少libarchive的3.0版本，另外bash版本稍低，最终决定编译pacman的5.1.3。(5.2版本要求bash版本4.4以上)。遇到`clock_gettime`函数不存在，好在代码里用宏给了另一种实现，把相关3行代码换一下手动编译过。配置通过/etc/pacman.conf就够了，可以配置repo位置、arch、哪些包不更新、使用curl/wget下载等。\n\npacman的思路，所有的软件信息保存在本地的sync和local两个目录，sync是全部软件的索引，local是已安装的软件。-S操作sync，-Q操作local。所以搜索也区分全部搜索的-Ss和本地搜索的-Qs。一旦理解其设计思路，命令就能说通了。\n\n安装和配置完成后，先尝试安装locate包(几乎没有依赖)，然后提示需要更新filesystem、glibc、tzdata等若干个包，但是下载后又提示glibc:  exists in filesystem并拒绝安装。我猜原因是这些包不在pacman的记录中，且对应位置已经有文件，为防止潜在的冲突，就停止安装。加了--overwrite \\*选项后大部分错误都屏蔽了(这个选项正常情况下尽量避免)，只有filesystem提示一些目录无法覆盖。于是我尝试把另一个版本DB Path下local目录的filesystem内容复制过来，果然骗过了pacman更新了glibc等库并装上了locate。但是悲剧的是执行ls会提示glibc相关的错误，而且ssh也连接不上。\n\n分析挂掉的原因，对每个发行版来说，最根本的rootfs一定包含基础工具(哪怕是busybox)和libc，而我只更新libc却瞒过filesystem，导致两者不能配套，最终使得整个系统挂掉。可以至少对pacman来说，由于它管理了rootfs，当安装到其它发行版时，会出现不配套问题。\n\nArch没有固定版本(但是filesystem的日期勉强可以算版本)，因此不可能有锚定的rootfs，基础库和工具一定是不停更新的，这也是和debian/cent系最大的区别。","modified":"20190501121530000","tags":"os"},
{"created":"20200427121530000","title":"Linux内核与PAM模块简记","text":"\n前因是容器中启动nfsd需要依赖内核加载ko模块，分读写记一下。\n\nlsmod命令，或查看/proc/modules看到内核当前加载的ko模块。\n\n/lib/modules/{ver}-{arch}/kernel 这里放的是所有可以加载的内核模块，以4.19为例，共有3559个，但初始启动加载的只有58个。ko文件之间有依赖关系，通过modinfo查看，查看原理也是从上述提到的内核路径中查找。\n\n所有的ko操作命令有6个，都是/bin/kmod的别名。\n\n!! PAM模块\n\n类Unix系统的一套授权管理机制，Pluggable Authentication Modules，由SUN在1995年10月提出，并由ReaHat在1996年8月首次实现。典型的效果比如接ssh失败过多时，PAM会禁止登陆，ssh自身并不提供这种机制。\n\n`pam_tally`基于用户的计数，当次数达到则触发规则，同时还配有`pam_tally2`应用程序查看和清空次数，不过在1.5版本的pam去掉了这个程序并引入`faillock`替代。\n\nLinux将PAM分为4个阶段\n\n# 用户模块，检查目标用户是否符合规则，比如用户是否过期，是否有权访问某个服务等\n# 认证模块，检查用户认证方式，也可以和keyring交互\n# 密码模块，确保密码符合规则，保证密码强度\n# 会话模块，确定此会话的边界和属性\n\n业界一直对pam不支持远程操作有争议，因为这导致了kerberos不兼容，后来又发展出SASL规范。","modified":"20200427121530000","tags":"os"},
{"created":"20190703121530000","title":"Linux上的虚拟化","text":"\n!! 容器化\n\n为了实现弹性计算和灵活迁移，把一台机器跑出尽可能多的实例，且实例间做到隔离，容器化相比虚拟机，省去了kernel的模拟，没有驱动方面的困扰，启动也更快。由于不能更换kernel，容器环境很可能没有/boot/目录(取决于chroot时有没有屏蔽)，容器环境的rootfs会额外挂载，比如在debian上启动cent的环境。\n\n容器化通过四个主要组件工作：名称空间（namespaces），控制组（cgroups），映像（images）和用户空间工具例如Docker或Podman。它们都基于内核的namespace，cgroup，unionFS机制，剩下的images和用户空间工具为了更好的封装。\n\n!! namespace\n\nnamespace有多种类型 (mnt, net, ipc, user, pid, uts, cgroup, time)，没有namespace之前，所有`task_struct`共享一些全局属性，引入namespace特性后，task结构中增加了struct nsproxy *nsproxy;指针，以下是稍早期版本的结构体，没有user和time两种类型。\n\n```\nstruct nsproxy {\n  atomic_t count;\n  struct uts_namespace *uts_ns;\n  struct ipc_namespace *ipc_ns;\n  struct mnt_namespace *mnt_ns;\n  struct pid_namespace *pid_ns_for_children;\n  struct net       *net_ns;\n  struct cgroup_namespace *cgroup_ns;\n};\n```\n\n这些变量在/proc/pid/ns/目录下都有对应的文件。\n\nuts来源于uname(2)依赖的结构体 struct utsname，而这个结构体的名字源自于\"UNIX Time-sharing System\"。似乎只影响hostname和domainname。\n\n网络namespace包括网卡，回环设备，路由表，iptables规则。\n\n总的来说，namespace的本质就是把原来所有进程全局共享的资源拆分成了很多个一组一组进程共享的资源\n\n* 当一个namespace里面的所有进程都退出时，namespace也会被销毁，所以抛开进程谈namespace没有意义\n* UTS namespace就是进程的一个属性，属性值相同的一组进程就属于同一个namespace，跟这组进程之间有没有亲戚关系无关\n* clone和unshare都有创建并加入新的namespace的功能，他们的主要区别是：\n\n> unshare是使当前进程加入新创建的namespace\n\n> clone是创建一个新的子进程，然后让子进程加入新的namespace\n\n* UTS namespace没有嵌套关系，即不存在说一个namespace是另一个namespace的父namespace\n\n!! cgroup\n\ngoogle工程师为了解决系统资源无法隔离的问题，于2006年提出此方案，并最终合并到2.6内核。\n\n物理机或虚拟机享有全部的资源，查看 /proc/[pid]/cgroup 列出的内容没有值，而容器的话会随着不同的实现方式输出不同，有kubepods/docker/machine-rkt等多种。利用这个特性，也可以检测到是否在容器环境。\n\n!! unionFS\n\n在一台宿主机上跑几十上百个容器时，这些容器镜像的基础层往往是一样的，如果使用传统的chroot方式，势必造成极大的空间浪费，因此就有了多个容器共用一些基础目录的需求。每个容器又各自有其特有的内容，这些目录要和基础目录共同构建成应用看来统一的目录结构。\n\n为实现这个目的，把不同的目录的内容，联合放到同一目录内（如果有同名文件，只会看到一个），这便是unionFS技术。严格讲不能算虚拟化技术，因为早在使用CD作为Linux发行版介质时，就有类似的需求，union mount point的理念更是在1995就出现在BSD系统。随着容器技术的发展，人们发现uinonFS非常匹配，于是这种文件系统被更多的人所知。\n\nunionFS有多种实现，Docker最初使用的AUFS是2006年基于unionFS全新开发的，RedHat觉得AUFS基于文件的机制性能不好，开发了DeviceMapper。随着这个需求越来越普遍，2010年开发并被用在OpenWRT上的OverlayFS，在经过4年的讨论后，终于被合并入Linux内核的3.18版本。OverlayFS的思路和AUFS类似且又做了很多优化，目前已成为容器文件系统的主流。\n\n!! QEMU虚拟机\n\n过程是将目标机的体系翻译成中间语言，再将中间语言翻译成宿主机的过程。主启动程序是qemu-system-xxx，支持x86、arm、mips等多种架构，不同架构有不同的执行程序。虽然都是一套软件，但支持力度却不同，X86(包括X64)最方便，只要配置好硬盘和内存参数就可以启动，而arm就要-M指定模拟的机器，-bios指定启动器（甚至还要自己上网找bios），这和arm只规定指令集，不包含外围引导也有关系。\n\nQEMU是纯软实现，不会利用硬件本身的虚拟化特性，速度非常慢。但支持-enable-kvm加速，可惜我用的是手机，无法体验kvm的效果。\n\narm版本启动后，无法进入引导，可能是bios没有选择正确。默认会开vnc，但对arm版来说，只会进入qemu的控制台，没什么用。相反x64的问题就少很多。但x64也存在只认某些ISO镜像的问题。\n\n除了虚拟机执行器本身，还有些外围程序，最常用的是qemu-image，用于创建、查看、管理虚拟机镜像。推荐用qcow2格式的镜像，支持把其它虚拟机的镜像格式转换，还能查看已有镜像的大小和其它属性。","modified":"20190703121530000","tags":"os"},
{"created":"20210613121530000","title":"lisp编程与结构化思想","text":"\n熟悉了vim的sexp模式后，再进行lisp编程，这时操作时脑中思考的就不再是一行文本，而是一整个表达式块，我要在这个表达式外再施加一层操作，又或是去掉这层表达式，而因为表达式的表述如此简洁，在纯文本编辑器中对复杂表达式的引用也能做到十分自然。整个体验完全不同于其它的编程语言。\n\n此处的结构化不是指结构化编程，而是看待代码时，不是单纯的文本，而是一块块结构，编辑、移动、添加和删除的对象，都是以结构的思维去操作。\n\n!! 操作记录\n\n* \u003Cleader>i  在光标所在的表达式之外增加一对括号，并把光标置于前面。I则置于后面\n* \u003Cleader>w 将光标所在的元素，外包一对括号，光标置于前面，W则置于后面\n* \u003Cleader>h 将光标移动到表达式开头，进入插入模式，l则光标到末尾\n* (或) 光标向外以表达式为单位移动，可带前缀数字\n* [[或]]，由于(和)到顶层表达式就停止了，[[和]]就是解决顶层表达式移动的问题\n* [e或]e，同样是移动表达式，且把表达式内容用visual模式引用起来\n\n!! asdf和quicklisp\n\nasdf类似make，发行版自带，先(require \"asdf\")再(asdf:asdf-version)查看版本。而quicklisp类似包管理器，要下载文件并用`ecl --load quick.lisp`进入，再执行命令等待。\n\nHOME/quicklisp/目录下保存了包的内容，按代码和元信息分目录保存。\n\n!! exit和quit区别\n\n仅在ECL验证过，执行错误语句会进入可恢复区（可以认为是栈深了一层），用quit回到toplevel，而exit不管处在哪一层堆栈，直接退出。","modified":"20210613121530000","tags":"lang"},
{"created":"20200305121530000","title":"lisp的3个处理阶段","text":"\n看似简单的表达式解析，其实细分为3个阶段\n\n# 读取期read time，将外部文本表示解析为语法对象syntax object，标记出宏，在下一环节处理\n# 编译期compile time，此时已全部是syntax object构成的列表形式，进行宏展开。由于没有求值，替换是在语法对象层面\n# 运行期run time，将函数和参数按顺序求值，得到最终结果\n\n大部分字符在读取期和编译期的呈现是一样的，但是如表示字符串的双引号，表示数组的#，会导致一段文本变成不同的语法对象，进而影响编译期的处理。或者反过来讲，编译期的对象，可以想象成是struct，有多个维度。而文本表示则只能是平铺的，之所以会混淆，往往是维度单一的语法对象（最常见的就是变量名）。\n\n从文本表示到语法对象的变化，由读取宏来完成（lexer阶段）。quote简写形式单引号，就是典型的读取宏，具备递归能力，比编译期宏更强大。\n\n还有一种compiler macro不是普通的宏，compiler macro是可选的对函数进行优化的提示，CL规范里甚至规定可以忽略compiler macro。","modified":"20200305121530000","tags":"lang"},
{"created":"20180714121530000","title":"Lisp的宏","text":"\n都说Lisp的宏很强大，其最大的特征仍然是字符串展开和替换，只是在替换的过程中，可以结合环境进行适合的绑定，加之程序和数据的同构，才使它异常强大。本文以s7的传统宏实现来理解宏。\n\n我最初最大的困惑，在一个宏定义的开始，要不要加\\`？以一个最简单的宏来做实验。\n\n```\n# (define-macro (print arg) (display arg))\n# (define-macro (print arg) `(display ,arg))\n# (define-macro (print arg) `(display arg))\n```\n\n* 情况1，不加\\`。在宏展开后，就进行运算，并得到最终结果。展开的结果类型是表达式的返回值。没有\\`也就不能用\\,，参数无法求值，即使是未绑定的值，只是作为一个symbol来用，未绑定的值并不会报错。比如(print ar)会输出ar，甚至ar有定义时，也只是输出ar。这种宏展开，只是最单纯的展开，没有求值替换，和C的宏能力等价。\n\n* 情况2，加\\`。宏展开的类型就固定是pair，仅仅宏展开并不求得最终值。只有把宏展开的结果，再用于eval才能得到宏最终的结果。宏变量也会成为宏展开时环境的一部分，再传入无意义的变量会报错。\n\n* 情况3，加\\`但忘记用,求值。宏展开期间参数没有用，eval时只能从当时的全局环境找绑定，不确定性很大，有点类似动态作用域的效果，不建议用。\n\n所以调用宏，相当于展开宏并把展开结果绑定到一个匿名变量，展开前会把参数作为新的frame插入环境中，如果出现求值，再用eval对这个匿名绑定求值两个步骤。有时看起来加\\`和不加效果相同，是因为不加\\`相当于宏展开后已经是个self evaluating值，再做eval看不出变化罢了。要注意：加了\\`但没有把参数用,进行求值，则这个参数就会在eval阶段引用全局的同名参数。\n\n由于scheme是strict语言，只要遇到表达式就求值(但set!的第一个参数和宏的参数在宏展开前是不求值的)。","modified":"20180714121530000","tags":"lang"},
{"created":"20180702121530000","title":"Lisp文章读后感","text":"\nRethinkDB作者的理解，从XML，C语言宏等角度作了比喻。\n\nXML是一种数据表示，但Ant中可以表示行为。如果把尖括号和属性(只是为了少打字的节点的一种简写，非必须的特性)做变换，最终呈现的就是Lisp的多重括号。\n\n用C宏和元编程做比较，日常有太多的boilerplate代码要写，宏是理所当然的选择，但如果能用host语言来无缝处理显然更好。\n\n!! Henry G Baker的实现思路\n\n把Scheme转成C用到CPS变换，常见的思路是trampline，但这种方式会慢2-3倍。提出了一种永远不return，不停地让栈生长，内存分配都实现在栈上，使栈堆合一简化分配。当栈达到极限，用Cheney的GC方法进行收集。\n\nC语言禁止嵌套函数，目的就是阻止free变量的引用。只允许toplevel函数，free变量惟一的可能只有全局变量，编译器会维护一个环境指针，可以找到这些全局变量。Pascal允许嵌套定义函数，不清楚怎么解决。\n\n!! 自己的体会\n\nsymbol是为了区分函数求值和数值表示。最初存在Mexp和Sexp两种，最后以quote的形式把Mexp给去掉了。所以只能说数据和函数同构，但不是相同。在lisp体系中完整体现了外部表示->符号->值的两次转换，没有quote符号，不过是换一种语法的lua。\n\nsymbol不仅能表示简单的变量，也能表示list，因此具备树状结构，而string只是字符线性排列。换句话说，string能看起来无缝地表示成symbol，部分symbol变成string后就大不相同了。让我们混淆的是自表示symbol，比如数字1，当eval作用在结构的symbol上，求值就变得统一了。\n\n写宏的时候，\\`把sexp标识成数据，而`,`则起到了局部eval的效果。\n\n反过来想，PHP/JSP这些语言的默认标识成数据，用了`\u003C?`就把进行求值演算。只是PHP缺少数据和程序互操作的能力，而Lisp打通了两者的边界。\n\n既然函数和字符串本质都是一段二进制值序列，只是类型不同，所以计算时对这个值的eval也不同。环境是若干个frame构成的list，闭包是带env的函数，而类不过是生成对象的函数模板（let over lambda）。所以说在静态作用域出现之后，闭包和对象的界限才被打破。\n\nR5RS中，pair和vector是两种最基本的数据结构(procedure)。hash是一种高效的实现，但本质上可以用list实现。最简单的做法是单向链表，但是红黑树一样可以用list来表示，此时就不能以car来取值，而要针对树的list结构定义专门的函数，如果要用bucket方式，则会用到vector，元素是list。\n\ncontinuation在1964年由Wijingaarden首次提出，有点ES6的Promise味道，到72年广为人知。Kamal Abdali在会议上发表论文，把Algol60转为untype lambda计算。提交第一届ACM符号被拒。他在74年完成他的毕设。他的推荐人提到，将语言转为\"pure\" lambda，比如赋值就modeled by substitution，而不是内存，地址，存取操作。\n\n推演时，把k代表的符合消去，就能看出在current时间点，要做的是什么，再把参数找到，因此要做两次推导，所以显得复杂。\n","modified":"20180702121530000","tags":"think"},
{"created":"20150405121530000","title":"lua_call的机制理解","text":"\n要执行lua函数，最后都会调用到`lua_call`族(包括pcall,pcallk等)，除去错误捕捉和coroutine相关的内容，只看最简单的流程。\n\n`lua_call`(L, nargs, nresults); 这是最基本的形式，从这个调用到最后的执行经过了7次函数调用。\n\n`lua_pcallk` (调整func位置)-> `luaD_pcall`(保护环境) -> `luaD_rawrunprotected`(设置longjmp) -> `f_call`(内部函数中转) -> `luaD_call` -> `luaD_precall`(如果是C函数，直接执行并`luaD_poscall`，将结果回填到func。在precall这个函数中，还会执行debug.sethook注册c动作引起的回调，类似的，注册r动作则hook在`luaD_poscall`中被调用) ->`luaV_execute`(视precall返回是lua函数才执行)\n\n首先来看lua栈上的参数是怎么获取的，lua_State有stack和top成员，top始终指向栈顶，是个空元素。而获取栈上元素个数，并不是直观意义上的top-stack-1这么简单，实际上是L->top - (L->ci->func + 1)，为什么要用ci->func呢？\n\n因为如果是top-stack就会把所有曾经压入栈的参数全部计算进来的，但对于当前正在执行的函数来说，外层栈的参数是无意义的，只需要知道本次栈帧的情况，而这个ci，看注释/* call info for current function */。很明确的表明就是当前的执行环境。\n\n在stack_init中，ci会指向stack，如果一直只是压入参数，得到的个数和top-stack-1是一样的。当压入的是个函数，也不会改变ci的位置，只有当明确表示需要call了，这时才会把ci->func的位置调整到top-(nargs+1)，所以执行call的时候，nargs绝对不能给错，否则函数就找不到了。\n\n由于在第一步就调整了基准栈的位置，等真正进入`lua_CFuntion`的用户自定义函数时，gettop就能得到专属于这个函数的参数了。运行完成后如果需要返回值，需要用户把值继续压入栈，这时只管按顺序压栈，在`luaD_poscall`时，会将第一个出参赋值给ci->func，然后依次往上赋值。执行完之后的函数和入参就找不到了，被出参给替换。nresults的个数比较随意，如果实际填的比nresults少了，lua自动补nil，填的多了会被限制在top之外，也无法访问，关系不大。\n\n而纯lua函数，虽然开始会走luaV_execute，但最后还是会回到C函数调用(毕竟是用C写的嘛)，lua的内建全局函数也是严格按照上述的方式来调用的。\n","modified":"20150405121530000","tags":"lang"},
{"created":"20150628121530000","title":"lua闭包和其他语言比较以及修改upvalue","text":"\n!! 闭包能力比较\n\n构建闭包的特殊性在于捕获非本地的栈上变量，如果是访问全局变量，不能称为闭包。最早明确这个特性的大约是scheme吧，lua和js也照样实现。而python则用nonlocal关键字更加显示地表明要捕获上级栈的变量，但同时又不能是global，所以看似怪异，细想倒也有几分道理。\n\n```\ndef foo():\n    conf = 555  #  newclo捕获这个变量稀松平常，都能做到\n    def newclo():\n        nonlocal conf\n        print(conf)\n\ndef main():\n    conf = 111  # 起初以为即使foo中不定义conf，lua和js能捕获这个定义，但python和scheme不行，实际是lua和js把变量提升为全局变量，能引用但已不是闭包了\n    foo()\n```\n\n!! 修改闭包自由变量\n\nlua闭包中引用的upvalue类似于面向对象中实例的私有成员，是不应该被外界修改的，或者说外界也感知不到这个存在。今天看lua的手册，debug库中存在getupvalue/setupvalue函数对，利用这两个函数可以获取/修改upvalue。这两个函数访问upvalue的方式是用一个int类型的index编号，而文档对这个编号的含义也不作保证，所以这个功能放在debug库也算合理吧。\n\n首先对闭包来说，upvalue是什么时候创建的呢？是在lparser.c中由解析过程创建的，当解析器每识别一个变量，如果这个变量在函数栈上未定义，则会逐级地往上找直到找到为止，之后就在函数的proto中增加一个upvalue。因为每个闭包都含有独立的upvalue列表，所以upvalue必然是词法定界的。\n\n虽然文档说index的含义是随意的，但通过代码还是可以知道，就是upvalue在函数中被最先引用的顺序。如果一个函数定义如下：\n\n```\nlocal function foo()\n  local b = 2\n  local a = 1\n  return function () print(a) b = b+1 end\nend\n```\n\n内部返回函数先调用了print(a)，print在栈上未定义，则它就是第一个upvalue，又因为print是定义在顶级函数的`_ENV`变量中，所以这个函数的第一个upvalue就是_ENV，第二个自然是a，第三个是b。这个a、b的定义顺序无关。另外由于`_ENV`是在lua5.2后引入的定义，在lua5.1中的话，1就指a，而2是b。也就是说这个功能是版本不兼容的。不过本来lua的兼容性就不是完美向后，且这个又是个debug函数，考虑到引入`_ENV`后的概念统一性，这个变动还是值得的。\n\n至于在其它语言中是否存在修改upvalue的机制，暂时还没有找到，等找到了再补上。\n","modified":"20150628121530000","tags":"lang"},
{"created":"20150329121530000","title":"Lua的编译期和运行期区分","text":"\n虽然是一门解释型语言，但Lua其实也分了编译期和运行期，只是通常在lua的程序里顺带把luac的功能给自动执行了。但作为一个运行效率为第一位的语言，编译期更多的意义在于把源码转译为伪字节码，不会作过多语义上的校验。比如下面这个例子。\n\nfunction a:foo()  print(\"hello\") end\n\n如果直接用lua运行，会报attempt to index global 'a'(a nil value)，但实际上在编译期，这仍然是可以通过的。\n\n如果用luac先执行，会得到两个chunk，一个是main，一个是函数定义。main中有四条语句：\n\nGETGLOBAL    CLOSURE   SETTABLE  RETURN\n\n前两句是可以顺利执行的，a虽然不存在，会默认赋值nil。但到SETTABLE时，这个nil就原型毕露了。也就对应上面运行时那句attempt to报错。\n\n也就是说luac只能做到语法层面的校验，但基于性能的考虑，不会做语义层面的判断(如果要做的话，代码量可就不止当前的2万行了)。\n\n说下MetaLua对编译的作法，在编译理论里，parse和compile是两个阶段，source经过parse只能生成AST，再把AST送compile才能生成执行码(可以是机器指令或VM指令)。YACC也好ANTLR也好，都只是parse工具。Lisp语法就直接是AST了所以不需要parse但还是要有compile。由于有两个阶段，MetaLua也提供了mlp和mlc两个工具对应。非Lisp风格的编程语言如果要扩展，多少都要在parse阶段做些处理，典型如增加关键字，就在parse阶段把新增的关键字转译成AST里的function，才能在compile后正常执行。\n\n因为MetaLua的存在，将源程序先编译成luac再执行就能看出明显的区别，compile阶段的操作可以在编译成luac时很直观地看出来，且不会带到执行期。\n\n最后补充几个Lua的语法细节\n\nLua的函数到底是传值还是传引用？这是我从王垠的\n[这篇文章](http://www.yinwang.org/blog-cn/2016/06/08/java-value-type)\n想到的。\n\n上面这篇文章的结论是Java从语义层面，只有引用类型。原生类型看起来像值类型，\n只是一种实现的优化。既然Lua也是从Lisp/Scheme系继承而来，\n就做个实验验证下，到底Lua是否符合王垠所定义的引用类型。\n\n字符串拼接如果报nil错误，假如有多个nil只会提示最后一个错误，不确定是否lua编译器按从右向左计算参数的方式？","modified":"20150329121530000","tags":"lang"},
{"created":"20141112121530000","title":"lua的表方法及self参数","text":"\n对于Lua的表定义函数方法有两种语法，点和冒号。\n\n比如一个表local t = {}，定义一个new方法有两种写法：\n\n# function  t.new()  ...  end\n# function  t:new()  ...  end\n\n前一种就是常规的定义，等同于t[\"new\"] = function() ... end，类似于C++的类静态函数定义。\n但是类静态函数只能访问静态变量，而Lua的这种函数，如果显示传入这张表，\n效果上就是个普通的成员函数了。\n第二种则等同于t[\"new\"] = function(self, ...) ... end。\n类似于C++的成员函数定义。\n\n需要注意的是，如果在表定义的内部直接写函数定义，只能采用第一种写法，\n第二种带self参数写法是行不通的。因为此时表还没有构造完全，这样写有风险。\n也就是说对这个表如果两种形式都定义，则因为key值相同，加上Lua的动态特性，\n后面被定义的会覆盖前面。而C++中如果定义的静态函数和成员函数的参数列表完全相同的话，\n是无法编译通过的。\n\n采用冒号写法的函数会多出一个隐藏参数self，这个self不属于Lua的关键字，\n但在冒号定义下会由编译器自动创建这个局部变量，如果不想用self这个名字，\n修改lua的源代码重新编译就可以了，只是这样一样，就不能用其它第三方库了。\nself的做法和C++的this指针在编译器的行为如出一辙，理解了C++对类成员函数的特殊处理，\n就能彻底理解self的用意和实现方式。\n\n试想混合两种语法的定义/调用形式，如果用了冒号无参定义，而用点号调用，\n则第一个self参数相当于置了nil，如果在定义中用了self相关的变量，则这样调用会出错，\n因为不建议这么用。但这里的self毕竟是个形参，也就是即使这么调了，也没会影响这个表本身，\n即点号调用完后，表本身内容是不会变的。如果冒号定义有一个参数，\n但点号调用也只传了一个参数，则这个参数会对应到隐含的self，导致冒号原型中的参数变成nil了。\n\n如果用了点号定义，而用冒号调用，如果是无参定义，则完全一样，如果有参数，\n则第一个参数就会变成隐含的self，如果在定义点号函数时未考虑第一个参数是table类型的话，\n冒号调用也会发生类型不匹配，因此在有参数原型的情况下也存在风险。\n\n除非是无参数调用，否则混合调用都存在一定程度的风险，本质上这就是两类不同作用域的函数。\n而C++在编译期做了检查，不会出现静态函数调用成员变量的问题。\n","modified":"20141112121530000","tags":"lang"},
{"created":"20180409121530000","title":"Lua的Continuation","text":"\n静下心来看冯东的讲解，才终于明白stackless指的是：lua语言的执行不会导致宿主语言的栈增长，同时`luaV_execute`的一次执行就会「吃掉」Lua stack 顶端所有连续的「CallInfo (Lua)」frame。`lua_State`的callinfo是Lua层面的栈帧，而VM本身的实现对应宿主C语言的栈帧，是为双栈结构。对于一个Lua VM来说，始终只有一个宿主的CRT stack。\n\n凡是函数一定有栈帧的概念，而栈帧也一定有生命周期。虽然实现上差异很大，但本质必然相同。C语言的栈指针由编译器进行增减管理，或是动态语言用堆对象模拟栈，再用GC来维护生命周期，本质是一样的，只是堆要额外地依赖GC做栈帧清理和识别closure。如果把GC看成和编译器生成的栈指针管理类似的动作，每次lua的函数执行就和C一样是个透明的栈增长过程，区别是动态语言的栈帧在内存上不连续。\n\n`luaD_rawrunprotected`有个特殊的步骤：setjmp。共有四个函数会使用这个特性，分别是\n\n# `lua_newstate`\n# `luaD_pcall`\n# `lua_resume`\n# `lua_checkstack`\n\n与之对应的longjmp对应的函数比较多，分别是\n\n# `luaG_errormsg`\n# `luaG_traceexec`\n# `luaD_growstack`\n# `luaD_call`\n# `lua_yieldk`\n# `GCTM` lgc.c内部的GC函数\n# `luaM_realloc_`\n\n在lua的main thread创建一个coroutine，并resume这个coroutine，然后在coroutine内yield，发生了如下的事情：\n\n# 在C的栈上执行`luaV_execute`\n# 遇到OP码，执行`lua_resume`，由前面介绍可知，在这里埋了点\n# 执行static的resume函数\n# 执行`luaV_execute`进入新的一个lua的CallInfo中，即从main thread切换到coroutine\n# yield会触发longjmp，于是回到第二步埋的点\n","modified":"20180409121530000","tags":"lang"},
{"created":"20140517121530000","title":"Lua的require机制及限制","text":"\nLua与C的交互利用了`lua_State`这个结构，所有的参数传递、函数的调用及表数据的获取都在这个栈中完成。网上有的教程在介绍这个栈用法时，会用`lua_getglobal`这个函数来从lua中获取全局变量，并压到Lua栈。这对预定义的那几张表，这么用是完全没有问题的，但如果是在C语言中要使用自己写的Lua扩展，用全局变量来传递肯定就不是个好的方法，要怎么做才不会污染全局的命名空间呢？这时就要祭出require函数了。\n\n比如包的名字叫pack.lua，主文件叫main.lua，在main中require(\"pack\")就会编译pack.lua的内容，如果pack.lua中定义了全局变量g，这个变量也会进入main.lua的命名空间。当然如果main中先定义了local g，因为变量查找是先本地再全局，则pack中全局的g会被遮蔽。require之后，main中的package.loaded这张table就会多出一个名为pack的变量(其它预定义的string, io, os也在这张表里)。如果pack.lua的末尾没有调用return，则package.loaded.pack的值就是true，这样require到的包是没有价值的(总不能依赖全局变量吧，那样就失去包的意义了)。因此pack中的所有变量最好都定义成local，并在最后通过return返回，这时package.loaded.pack的值就是return后面的值了。\n\n在包的最后用return返回有个很大的限制，只能返回一个值！为什么有这个限制？上面说了，在main中require之后，不论你是否在main中保存require的返回值，都会保存在main的package.loaded.pack中，而这个变量显然只能保存一个值。因此在pack中如果return多个，由于package的loaded表机制，return的第二个以后的所有参数都会被丢弃，所以在写包的时候要注意。\n\n为什么package要有个loaded表呢？这样做可以防止重复包含，解析require时，如果package.loaded中已经有同名变量，直接返回就行，不需要再做查找动作了。Lua是个崇尚简洁的语言，且作为包来说，最常规的作法也是返回一个table，因此就没有必要去解决不能return多个的限制了。又由于package是张全局表，如果main包含了pack1，pack1又包含了pack2，在main的package.loaded能同时看到pack1和pack2，这种机制也简单地避免了循环包含的问题。\n\nrequire的实现其实相当复杂，在5.3时代真正的执行动作定义在package.searchers这个table，这张表内含了4个函数。会依次把require的参数作为这4个函数的参数传递进去。第一个函数是简单的查找package.loaded表，实现最容易。第二个函数会引用package.path变量(准确地说是先找`LUA_PATH`或者`LUA_PATH_5_3`这两个环境变量)，并把这个字符串中的?替换成require的参数并进行加载。第三个函数类似，换成引用package.cpath。第4个函数则是loadall方式，至少我觉得不常用。这种把一个功能分解成4种可能，然后每种可能都配备一个函数的作法，是一种很有用的分而治之方式。\n\n说句题外话，Lua5.1时代模块机制有require和module两个函数，到了5.2作者觉得module是个过度设计。于是废弃了module，只保留了require。来看看module的实现方式：比如有个模仿类机制的库loop，会在文件开头这样声明module(\"loop.base\")。这行函数会在全局空间创造了一个名为loop.base的表，这有两个问题：1.污染全局空间 2.即使在模块文件声明个名字，别人还是找不到啊。所以假定在main.lua要加载loop/base.lua文件的流程是这样的，首先向package.loaded这张表查询，发现没有loop.base于是从package.path的各个可能里找loop/base.lua文件，找到以后开始执行，结果刚一执行，base.lua就向package.loaded写入自己，但问题是这个时候别人都找到你了，显然是个废操作啊。而且从module下一行开始，所有的代码都是在向module所创建的表中定义字段，以下的代码不能有任何的执行语句动作，只能声明，这个限制实在是不友好啊。base.lua执行到最后，会把自己这张表设置到package.loaded中，却没有显式地return自己，而是说`Finally, module sets t as the new environment of the current function and the new value of package.loaded[name], so that require returns t. `。利用了require的机制`In any case, require returns the final value of package.loaded[modname]. `把base.lua导入到main中。由于module的存在，让require的处理分支多了不少，种种弊端导致废弃module也是顺理成章的事了。\n\n说个小细节，require的时候，如果模块在目录下，用 a.b 方式导入，但是写成 a/b 这种直观的方式也可以。标准的写法是 a.b， 在 require 内部会将 \".\" 换成操作系统对应的目录分隔符再从文件系统加载，而a/b不会特殊处理，刚好能从目录中找到。从通用性角度考虑，当然是建议用 a.b 的方式。\n\n拿Scheme Gauche的module机制作个比较吧。Gauche的手册是这么定义的：\n> Gauche Module is an object that maps symbols onto bindings, and affects the resolution of global variable reference.\nHowever, Gauche's symbol doesn't have a `value' slot in it. From a given symbol, a module finds its binding that keeps a value. Different modules can associate different bindings to the same symbol, that yield different values.\n\nGauche的module有两个关键字：export和import。import和lua require功能类似，但是Gauche的module并没有限制只能展出一个的限制，它是通过export显式地标记多个符号，由于export导出的符号仍然是绑定在module上，不需要担心重名问题。换成Lua则更习惯用一个table还承载多个符号，同时控制可见性。两种语言不同表述风格，但最终的效果是一样的。","modified":"20140517121530000","tags":"lang"},
{"created":"20161011121530000","title":"Lua调试器clidebug使用说明","text":"\n用lua -lclidebug xxx.lua来启动，进入后会停在第一行。\n接下来介绍常用命令。\n\n* setb linenum [file] -- 设置指定行号的断点，默认打在当前文件\n* tb linenum [file] -- 设置临时断点，执行到该断点后，即取消断点\n* delb linenum [file] -- 删除指定行号的断点，默认打在当前文件\n* listb -- 列出所有断点\n* run/cont -- 执行程序\n* s [num] -- 单步进入，默认1步，可指定步数\n* n [num] -- 单步跳过，默认1步，可指定步数\n* fin -- 跳出函数\n* p varible -- print, but format is somewhat different\n* display varible -- 增加一个变量名到列表，以后每次单步会打印列表中的变量值\n* undisplay -- 清空display列表\n* vars [levelnum] -- 显示指定层级变量，默认1\n* what funcname -- 显示函数信息\n* exit -- stop debug\n\n最后以上这些命令可以写在执行路径下的./clidebug.cmd里，比如文件里写setb 10，就能在启动后在10行打个断点。程序启动后会读这个文件，在经常调试时会比较方便。\n\n大概说下原理，通过-lclidebug导入调试库，但这个库会先执行一个pause函数，\n在pause里创建好一个协程coro_debug，这个函数会执行yield。\n并通过debug.sethook(debug_hook, \"crl\")，\n在debug_hook函数内，又通过debug.getinfo(level, \"S\")的方式得到执行的脚本名，\n当debug_hook被回调出后，如果没有断点，则直接return，从回调返回，\n把控制权交给主函数进行，即sethook的函数，如果有断点，会resume这个coro_debug函数，\n在coro_debug里做while循环并io.read(\"*l\")，等待用户输入动作，\n只有run/step/next这三个命令，会触发yield动作，其它命名处理后，等待下一次用户输入。\n\n这个流程的关键一环，是Lua自带了sethook这个函数，因为有了它Lua会在执行的过程中，\n每次的call或单步，都会回调进hook函数。如果仅仅是这样，只能在hook函数中做一些固定的动作，\n要让debug真正可用，就要在hook中引入协程，hook先让渡执行权，由用户来输入，\n在协程中判断用户输入，如果是打印或设置断点，则执行后还在协程中，\n只有step/next/run等命令，才会让渡回hook函数，每次hook函数被回调出来，\n都会计算当前行号，如果这个行号上没有断点，hook回调结束，让主程序继续走下去。如果有断点，则resume协程。\n\n通过这种方式，从而托管了后面的脚本文件的执行。\n\n编程语言说到底还是函数的调用，调用成链必然会形成层次，debug.getlocal的第1个参数，表示的就是调用栈的层数。不同的语言可能表示法会有不同，lua用1表示当前的函数层（即调用链最末端的函数），然后以此为基准向main函数逐层递增。C语言的当前层是0，语言风格使然。恐怕不会有语言以main函数为1开始计算，这样的话很难定位到当前调用函数的层级，而出问题的往往是当前函数。","modified":"20161011121530000","tags":"lang"},
{"created":"20170204121530000","text":"\nLua与C互操作用的是Stack模式，1表示底部，-1表示顶部。除了push/pop还有`lua_insert,lua_remove,lua_replace`这三个值得一说。\n\n`lua_insert`在文档中的注释是这样：\n\n> Moves the top element into the given valid index,\n> shifting up the elements above this index to open space.\n> Cannot be called with a pseudo-index,because a pseudo-index is not an actual stack position.\n\n不能用pseudo-index比较好理解，难的是前半句和函数命名，换用exchange更适当。\n把顶部的元素放到指定的index位，剩下的元素依次移位。这个操作不改变栈内元素数量，\n仅仅把顶部元素换个位置。insert给我感觉函数原型应该是 `lua_insert(lua_State*, int index, union value)`\n\n从外部指定一个元素，插入指定位置，真正操作要分两步，先push到栈顶，再将栈顶元素挪到指定位置。因为union类型无法表示，才做成这样的。\n\n另外两个`lua_remove`和`lua_replace`都会减少一个栈上元素。不同的是remove就是单纯把index指定的元素删掉，而replace是用栈顶元素把index元素换掉，两者共同点的是index指定的元素都没有了。","title":"Lua栈操作记录","modified":"20231026124631545","tags":"lang"},
{"created":"20170312121530000","title":"Lua中引入对象风格的价值和loop的实现","text":"\n用弱类型语言写代码，函数多了以后参数具备明确含义就很重要了。就好比web开发不可能总是用原生的json包打天下，定义一个类，更多的也是对接口的一个契约，使其在函数名之外具备更详细的自解释性。至于C++面向对象三要素的封装尤其访问性封装和继承，目前我还没觉得有什么用处，对动态语言来说多态已经在语法层面失去价值，反而使接口和实现分离这个最本初的愿望更直接地体现出来了。\n\n接下来先分析loop.base的实现原理，base是基本，就做了最简单的引入类和实例概念：整段代码20行，如下\n\n```\nfunction rawnew(class, object)\n\treturn setmetatable(object or {}, class)\nend\n\nfunction new(class, ...)\n\tif class.__init then\n\t\treturn class:__init(...)\n\telse return rawnew(class, ...)\n\tend\nend\n\nfunction initclass(class)\n\tif class == nil then class = {} end\n\tif class.__index == nil then class.__index = class end\n\treturn class\nend\n\nlocal MetaClass = { __call = new }\nfunction class(yourDef)\n\treturn setmetatable(initclass(yourDef), MetaClass)\nend\n```\n\n创建类需要指定具名字段并返回一个可以call的物件，因此创建是function，返回的则是设置了metatable中`__call`字段的table。如果没有定义任何东西，库也会默认生成个{}，而接下来这句设置`__index`的作用要在new中才会体现。先来看`__call`对应的的函数new。触发这个方法时，第一个传入的参数是class这个function生成的物件，从rawnew函数可以看到这个物件被当作一个object的元表，此时object需要能访问到类中定义的成员，显然需要`__index`方法，又因为这个object不能再创建对象，所以也不会有`__call`字段定义。到此功能原型就出来了。\n\n上面说完了base类，这时还不具备继承功能，先说单继承，这是loop.simple的职责，simple要实现继承，在base基础上要再做两件事：\n\n# 要能够访问到基类的属性\n# 既然是继承类，也要能够构造实现，也就要有`__call`方法\n\n来看simple的代码\n\u003Cpre>\nlocal DerivedClass = ObjectCache {\n\tretrieve = function(self, super)\n    -- return a new class extended super with __call, so it's different from origin super\n\t\treturn base.class { __index = super, __call = new }\n\tend,\n}\nfunction class(subDef, super)\n\tif super then\n\t\treturn DerivedClass[super](initclass(subDef))\n\telse return base.class(subDef)\n\tend\nend\n\u003C/pre>\n如果class的第二个参数(父类)非空，则通过DerivedClass[super]的方式生成一个带`__call`的强化版super类，且索引也指向super。再以subDef为参数向super类上附着子类的参数，这样继承的目的就达到了。","modified":"20170312121530000","tags":"lang"},
{"created":"20170921121530000","title":"Lua中元表的理解","text":"\n从题外话说起，Lua在语言虽然没有class关键字，但不妨碍它是一门OO的语言，只是归属到object-based这个类别下(JS是这个流派中的prototype-based一脉)。可以把Lua中所有的table变量认为是object，如果仅仅是这样肯定是不够的，让Lua产生变化的就是元表。\n\n通过一个值的元表可以修改很多操作的含义，但我认为其中最有用的只有3个：`__index`(get)，`__newindex`(set)和`__call`，lua在选择关键字的时候没有太直观。一旦能覆写get/set操作，不仅仅数据得到了隐藏，还能实现delegation，使得语言看起来有了继承的特性，当然也提供了rawget/rawset来访问数据的本来面貌。call则让对象成了仿函，使函数式风格能实现。\n\n在重写这些方法时，`__index`是两个固定参数，self和keyname，`__newindex`再多一个value。而`__call`的参数个数至少有一个self外加可变的参数列表...。共同点是重写函数的第一个参数都是self。\n\n为什么一定会有self呢？因为这3个特殊索引的值都可以是函数，而且还是C风格的plain function。\n像`__index`的触发条件至少有两个参数，因此像`__index`的实现，可以写成function mt:__index(name)这种风格。\n如果朴素一点，就直接返回一个变量或新的table，绕弯一点也可以返回function，\n进而构成链式调用。执行这个function会返回一个table，这个table要先做一次setmetatable，从而使外面使用者看来，就是一个完整可用的对象了。\n\n又比如`__call`能让table当成函数来调用，如果这个table中含有的大量信息不传递到`__call`对应的函数就太可惜了，所以table就成了函数的第一个参数，这是从实用角度出发点得到的设计结果。\n\n前面提到了rawget做点补充说明，正常情况从table访问元素如果访问不到(即值为nil)，就会触发元表机制，哪怕{b=nil}这种形式，访问b时也会查找元表，因为b用pairs根本看不到，所以rawget的结果通常就是nil。\n\n再来一段例子说明元表设置时的一个小误区，看例子\n\u003Cpre>\nlocal mt = {a=\"inmeta\", __index=mt}\nlocal tbl = setmetatable({}, mt)\n\u003C/pre>\n我开始的设想，访问tbl['a']会得到inmeta，但事实是nil。通过chunkspy反汇编看到`__index=mt`这句对应的是getglobal指令，就是说在构造等号右边的表时，看不到左边的mt，所以尝试向global空间找，当然是找不到的，所以结果是nil。那么换一种写法：\n\u003Cpre>\nlocal mt = {}\nlocal mt = {a=\"inmeta\", __index=mt}\nlocal tbl = setmetatable({}, mt)\n\u003C/pre>\n似乎规避了刚才全局查找变量不存在的问题，好像也递归地把a设置到元表了，但是访问tbl.a时仍然是nil，说明`__index`的赋值是词法定界，即使看上去把mt重新赋值，但真正查找元素时还是用词法定界时的变量，所以还是老老实实地用`setmetatable({}, {__index=mt})`\n\n!! 弱引用\n\n当想要引用一个对象，但是这个对象有自己的生命周期，不想介入这个对象的生命周期，这时候就是用弱引用。典型场景是cache，持有固然好，被释放也无关紧要。\n\n将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。换句话说，只有cache的内容明确地被其他人需要，才会被保留，否则就被GC了。","modified":"20170921121530000","tags":"lang"},
{"created":"20170125121530000","title":"Lua中udata设置元表机制和回调","text":"\n在Lua语言中可以给表设置metatable，用C语言写Lua扩展库时，返回的句柄\n可以是table(比如luaiconv库)，也可以是userdata(比如lsqlite库)。\n这两个类型设置元表流程略有不同。\n\ntable类型设置元表比较简单，直接`lua_newtable`再用`lua_setfiled(__index)`就行，\n而lsqlite库创建的是sqlite指针，不能用普通的table作为元表。\n因此Lua提供了`luaL_newmetatable`函数，这个名字有点迷惑性，\n其实是专门用于给udata创建元表的。\n\nudata的元表创建机制虽然特殊，但是设置元表机制和普通的table是一样的，\n用`lua_setmetatable`就可以了。\n创建udata的元表使用自定义字符串方式，这种方式对使用者很友好。\nlsqlite的4个udata元表定义不包含`__index`方法，而是又封装了一个`create_meta`函数，\n在这里面统一来`lua_pushstring(L, \"__index\");`，并用`lua_rawset`把元表设为自己的元表，\n再将这个元表用`lua_setmetatable`设为udata的元表。两个步骤且使用的方法不同，\n一定要区分开。\n\n另一个问题是，那些在Lua中设置的回调函数，明明参数是Lua的函数，底层又是C语言的形式，\n在C语言中如何执行这些Lua函数？\n从原理上C语言的回调仍然是C定义的函数，因此这中间一定有一层转换。\n首先原生注册的肯定是C函数，在这个C的回调被触发后，要找到当初设置进来的Lua回调，\n这时就要用从`LUA_REGISTRYINDEX`这张特殊的索引代表的table去找到当初设置的Lua回调。\n从这里可以反推，一定是在设置入口，先用`luaL_ref`方式把Lua函数记在int里\n(`luaL_ref`的返回)。等进到C回调时，用`lua_rawgeti(L, LUA_REGISTRYINDEX, int)`\n再取回来，最后用`lua_call`的方式去执行Lua函数。至此流程打通。\n\nlsqlite库实现还有个值得注意的地方，创建了一个到DB的connection之后，代码中有这么一段\n\u003Cpre>\n    lua_pushlightuserdata(L, db);\n    lua_newtable(L);\n    lua_rawset(L, LUA_REGISTRYINDEX);\n\u003C/pre>\n给db这个udata又另外注册了一个table。原因是SQLite中，光有connection还不够，\n经常会使用db，通过调用prepare函数创建statement句柄，即句柄层数不止一层，\n为防止statement忘记回收，每次创建了stmt句柄，就把它放到db关联的table中，\n当db被close时，再遍历table把所有的stmt进行回收。\n\n除了用int外也可以用字符串，比如lua和libuv的绑定代码：\n\u003Cpre>\n  // Tell the state how to find the loop.此前已把udata压入栈顶\n  lua_pushstring(L, \"uv_loop\");\n  lua_insert(L, -2);\n  lua_rawset(L, LUA_REGISTRYINDEX);\n\u003C/pre>\ninsert这句参数-2等效于把顶上两个元素换个位置，再用rawset方式把`uv_loop`字符串\n和udata绑定，以后再用同样的字符串取回即可。","modified":"20170125121530000","tags":"lang"},
{"created":"20170227121530000","title":"LuaJIT的编译过程和FFI接口","text":"\n编译LuaJIT比Lua要复杂很多，共分三个步骤。先看src目录下的host目录，首先要编译出host内的minilua，用它驱动dynasm/dynasm.lua并配合`vm_xxx.dasc`来生成`buildvm_arch.h`(但是也可以在Makefile中指定minilua的替代品，所以它并不是严格意义的必须)，这个头文件是生成buildvm程序的关键文件。有了buildvm之后，再用它生成`lj_vm.o`和一系列的`lj_xxx.h`以及jit/vmdef.lua文件，都具备后才能最终生成LuaJIT程序。\n\n但是偶尔也有意外，比如我在Win7环境用gcc编译，本来期望生成`lj_vm.o`，却生成了`lj_vm.s`汇编文件，用gcc转成.o会报错，大意是.hidden位置不对。我查了原因似乎是这样，.hidden是ELF格式的指示符，在windows平台没有这种特性，所以会报错。说明虽然gcc本身跨平台，但如果用了些汇编级别的文件格式相关的指令，还是会编译不过的。但这个可以规避，至少vc就没有这个问题，应该是某个编译开关没考虑周全导致的。除了这个，生成的动态文件名也有些差异，windows平台是51，而其它平台是5.1，不知道为什么windows会少一个点，莫非又搞特殊化？LuaJIT的接口一直保持和5.1兼容，后来也慢慢导入5.2的接口，到2.1.0版本共引入了8个5.2的C-API。\n\nbuildvm的作用是，它会先执行`build_code`，再根据处理器和OS生成汇编码，比如windows就是`emit_peobj`。\n\nOpenResty的核心模块`ngx_lua`是用Lua的CFunction方式实现的，\n从issue得知有lua-resty-core是基于ffi的实现，且后续会放弃对CFunction方式的支持。\n看了LuaJIT的FFI介绍并简单看了源码，才发现错过了这么好东西。\n\nFFI简单的说就是只要能拿到动态库(dll/so)均可，并且有相应的函数声明，\n就可以直接地从LuaJIT中调用C语言函数。而且调用方式非常简单直观，\n就和调用C语言一样，完全不需要像Lua那样的各种压栈操作。\n\n实现原理是需要先调用ffi.load(\"ssl\")，这个函数的内部实现就是LoadLibrary/dlopen。\n再通过ffi.cdef中定义的函数名，通过GetProcAddress/dlsym找到函数地址就能调用了。\n当然这里还有些cdecl/stdcall的转换动作。\n如果在Windows平台上还会默认加载kernel32/user32/gdi32这三大默认库，\n因此常用函数甚至不需要load就能调用了。\n\n有这么好用的功能，难怪`ngx_lua`的实现都换成FFI方式了。","modified":"20170227121530000","tags":"lang"},
{"created":"20170301121530000","title":"LuaUnit记录","text":"\n单元测试的条件如果是函数，则首4字母为test，如果是表，则表名和函数名前4字母都为test，均忽略大小写。判断代码\n\n* if string.sub(s,1,4):lower() == 'test' then\n\n可以这样来执行测试命令\n\n* lua example.lua test1 test2\n\n表示只测试test1和test2，注意这里大小写必须匹配上才行。\n如果没有，则还按全局搜索出来的测试。\n\n函数入口上看，首先是runSuiteByNames，然后会从`_G`中取合适的名字，\n生成table后再调用runSuiteByInstances\n\n用过luaunit的两个版本，3.0和3.2。其中3.0的内部函数大量使用了全局函数，甚至一些标记开关都用了全局函数，这显然破坏了环境。\n到了3.2版本则全面收敛了这种往全局空间写符号的恶习，包括assertEquals等都在table里，不再是全局函数。\n但是3.2在执行时一定要用.run(...)语法。开始我误写成:run()语法，在3.0能正常执行，到了3.2总是出错，经过打印才恍然大悟把self给压栈了。\n执行的时候可以传入各种参数，非常灵活方便。\n\n* ut.run('-v', '-o', 'tap', 'testA', 'testAa1')\n\n再比如执行测试时，有些函数需要一些特殊的参数，比如一个文本解析函数，需要传入一个文件对应的fd，这时使用class的测试方式就能提供额外的便利，可以给这个class定义setUp和tearDown方法(命名全小写也可以)，而且用testA:setup() self.xxx end这种格式也是允许的。luaunit框架这部分的执行流程是这样：\n每个test函数都会进入execOneFunction执行一次，执行前后判断有无setup/teardown，有就自动调用这两个方法，执行则通过xpcall因此即使内部assert/error也不会异常退出。执行结果保存下来后，退出前执行endTest函数，会根据PASS/FAIL/ERROR分别增加计数结果。\n\n如何非侵入式地写测试呢？比如有个lib.lua库，想对其中很多的内部函数写测试，\n直接在lib.lua写显然相当不友好，肯定再建立一个ut.lua来放置测试用例。两者如何关联呢？\n\n1.lib.lua中require 'ut'，这种方式相当于把require之前的lib.lua的环境作为ut的ENV，所有想导入ut.lua的符号只能走这个ENV，\n显然只能以全局函数的方式传递给ut.lua，明显不合理，放弃。\n\n2.ut.lua中require 'lib'，这种方式可以把lib.lua中要测试的函数封装在另一个专门做ut的导出表，并在ut.lua中接收并测试，\n但是有个问题，就是lib.lua到底要返回正常的导出表，还是给测试的导出表，无法区分。目前想到的办法，只能在导出的附近定义一个常量，\n通过修改常量的方式来测试。虽然还是有改动，但也是目前惟一能想到的方式了。\n\n说完luaunit，再引申说说PHPUnit，其实单元测试在我理解，就是语言有机制能提供当前环境中的所有符号名，lua用`_G`变量，而PHP有`get_defined_functions`和`get_declared_classes`这两个方法，通过同样的策略可以实现和luaunit一样的调用方式。不过PHPUnit似乎要指定类名才能执行测试，我觉得这种方式未免笨拙了。\n\n最后附记两个Lua小技巧：\n\n1.检查一个字符串是否全落在字符集中，执行string.gsub('[]', '')，并检测结果是否为空串\n\n2.判断string.find的返回布尔值，使用return not not string.find方式","modified":"20170301121530000","tags":"lang"},
{"created":"20230625121530000","text":"\n!! 历史与标准\n\nJohn Gruber和Aaron Swartz（测试）于2004年发明了Makrdown编辑格式，它最初是定位给web写作者，因此首要的功能就是markdown到html转换。由于简洁的设计，在网络上受到极大的追捧，因为面向html的设计初衷，它的元素也分为块级元素和行内元素。开始的功能并不完整，其实这也不是什么问题，但是Gruber认为没有一种规范能满足所有人的需求，也不愿意扩展Markdown语法，在发布同年的12月，版本更新到1.0.1就不再迭代。后来社区想成立一个standard markdown的论坛也被他拒绝了。最终导致了Markdown演变到今天，虽然已是互联网最流行的书写格式，但五花八门的扩展也始终是一个无法消除的问题。\n\nGruber定义了一套非形式化的语法，并且提供了markdown.pl脚本来验证格式的正确性，但毕竟不是严谨的定义。从2012年开始Jeff Atwood就提议要标准化地描述Markdown格式，最终在2014年，由UC Berkley的哲学教授John MacFarlane作为主要编写者，共同确定CommonMark成了至今最完整和详实的规范定义，虽然没有达到1.0，但已经被众多网站接受。CommonMark和其它流派不同，并不强调功能的扩展，而在明确定义诸如优先级、缩进、嵌套等容易引起歧义的地方。\n\n!! 各种流派\n\n虽然有众多的扩展变体，RFC7764还是记录了几个比较流行的方言\n\n!!! GitHub Flavored Markdown\n\nGitHub在2017年发布了基于CommonMark，有形式化描述的扩展标准。这个也许是接受度最广，甚至个人觉得有可能成为事实标准的增强版。\n\n!!! PHP Markdown Extra\n\n虽然名字带了PHP，但也有Ruby(Maruku)和Python Markdown实现。区块代码和表格的扩展语法和GFM一样，接受度也比较高。\n\n!!! Pandoc\n\n与其说是一种markdown流派，更确切的定义是格式转换界的顶峰，作者就是上文提到的CommonMark的发起者MacFarlane。它使用的语法和GFM不太一样，其扩展语法格式的流行程度远不如这个软件本身。\n\n!!! Kramdown\n\n据作者自称是最快的纯Ruby实现，支持输出LaTeX，同时还支持XML2RFC格式，我猜是不是因为这个特性所以被RFC收录了。\n\n!! 语法体会\n\n开始使用tiddly，需要把md的语法平转成WikiText，为此还写了个小工具。好在除了标题和有序列表外，我自己常用的都可以做到一样，但还是对以往写的内容做了些调整\n\n# 标题用#语法，不要用==或--，因为后者在标题行的后一行，转换时会稍麻烦\n# 行内引用和块引用的区别是，块引用在code标签外面还包了一层pre标签，由此改样式必须要配置pre code父子语法 [[CSS的一些理解]]\n# 少用md的`*word*`语法，浏览器默认的斜体样式渲染中文不好，且容易误匹配\n# 用了md至少5年以上，才知道引用语法是>","title":"Markdown的渊源与流派","modified":"20231029060243856","tags":"tool"},
{"created":"20210129121530000","title":"mount和文件路径改写","text":"\nmount的参数很多，关键概念就是将device挂到mountpoint。其它的参数是因为device必然涉及很多控制选项。\n\n有两个重要的关联文件\n\n* /etc/fstab 启动时要挂载哪些设备，用UUID标记部分磁盘分区，记录物理分区，注意整块盘没有UUID。使用systemd系统时，systemd接管了挂载/etc/fstab的任务。在系统启动的时候，systemd会读取/etc/fstab文件并通过systemd-fstab-generator工具将该文件转换为systemd unit来执行\n* /etc/mtab 内核已挂载的文件系统，像proc、sys这类特殊的文件系统都会记录\n\n!! proc下的3个mount文件解析\n\nmountinfo\n\n* mount ID\n* 父mountID\n* device主编号:子编号\n* mount源路径\n* mount目的路径\n* mount属性，如ro/rw\n* mount点share subtree的flag：shared:23，共享组ID；slave:24，master的组ID，直近の共有を継承しているシステムのマウントID；unbindable:不能被bind\n* 文件系统名称\n* 设备名（取决于`show_devname()`内容，否则和文件系统一样）\n* 超级块的属性，比如ro/rw\n* 超级块的选项（文件系统所属的`show_options()`内容）\n\nmounts\n\n* 设备名（取决于`show_devname()`）\n* mount目的路径\n* 文件系统名\n* mount属性，如ro/rw\n* 超级块option，我所见都是0\n* mount options，我所见都是0\n\nmountstats\n\n* 内容较少，且条目数和mounts一样，不再介绍\n\n!! proot\n\n沿着文件路径改写再往前想，如果把整个发行版的内容挂载到某个目录，并以此目录为根，我们就在一个系统内有了另一个子发行版。限制根目录访问是chroot系统调用，需要root权限，于是又产生了proot这个不需要特殊权限的应用程序。\n\n虽然都带root字样，但两者差别极大。chroot是系统函数，而proot则是基于ptrace接口的应用程序，p猜测是pseudo的简写。proot对fork的子进程做了ptrace挂钩，当子进程读写文件时，由父进程转成对/proc/pid/fd的读写，实现了子进程内对文件路径的改写。","modified":"20210129121530000","tags":"os"},
{"created":"20171129121530000","title":"MySQL和Redis备忘","text":"\n!! 连接与数据格式\n\nMySQL远程的访问，支持Unix的域套接字、Windows的共享内存和命名管道模式以及应用最广的TCP。TCP协议的首字节是版本号，官方文档可查最早是版本9，自3.21.0开始切换到10以后没再变过。这份协议格式符合GPL。\n\n连接要配置用户名(最多16个字符)，用`mysql -uxxx -pxxx`的方式登陆，注意`-u`和用户名中间没有空格，和一般的软件习惯有些不同。标准语句外，额外支持show,desc,use指令。\n\n数据格式比SQLite要细分得多，在SQLite里字符串就是TEXT类型，但MySQL的TEXT表示65535以内的字符串，如果需要更大的空间，要换成MEDIUMTEXT或LONGTEXT。编码支持多种，创建table时要注意指定，或者用`alter table xxx character set utf8`修改。varchar的长度只限制了取出，如果超过范围仍能写入，但取出会被截断。\n\n空有两种表示方法，NULL或者''。在MySQL中，NULL会占用额外空间，MyISAM是1个bit，且不能被索引，所以关键字段如果用NULL会影响检索效率，而''完全不占用空间。好比NULL是空气，看起来没有实则还是有的，''是真空。用CHAR_LENGTH对这两种取值，NULL返回还是NULL，而''返回是0。所以建议所有的字段都设置为NOT NULL。即使设置成NOT NULL，插入时如果不指定，CHAR默认是''，而DATETIME默认是全0。\n\n!! 数据存储\n\nMySQL的数据保存在datadir指定的目录（默认是data），生产部署时会把datadir指向单独分区，方便数据整盘迁移或调优。data目录的每个子目录对应一个数据库，因此数据库不能指定存储引擎，只有表需要引擎参数。\n\n不过把整个目录直接移到另一个MySQL，虽然可以看到这个目录和表，却不能进行操作，可能在其它地方还有记录库和表的关系吧，也因此迁移数据不能简单地移动文件。库目录一定有db.opt文件，通常用来指定创建新表用的character和collation。\n\n当第一次安装完成，会自带mysql目录，这个库里会有db/func/user等保存元信息的表。另有`information_schema`库，该库的机制是视图，所以没有外部文件。更高版本的MySQL还有`performance_schema`库，了解不深。\n\n!!! MyISAM引擎\n\n每张表对应3个文件，后缀分别是frm,MYD,MYI。\n\n* frm: 描述了表的结构\n* MYD: 保存了表的数据记录，以行为单位记录数据，每写入一条数据，都会在文件大小上，精确到字节地反映出大小变化。\n* MYI: 保存表的索引\n\n!!! Inno引擎\n\nwindows下，每张表有frm和ibd两个个文件存放数据（是否有ibd文件取决于 `innodb_file_per_table` 是否打开，低版本默认关闭就只能看到frm文件）。ibd在创建空表后就有96K，插入单条数据只能看到ibd文件时间有更新，但看不到大小变化，只有累积到一定数量（疑似16K）才会增长。和数据库目录平级的目录下，有ib_logfilex,ibdatax和若干个文件夹。ib文件记录了redo日志和inno引擎的事务消息。\n\n!! 启动方式\n\n启动日志报各种奇怪的错，数据库不存在，InnoDB起不来。mariadb会默认装在/usr/var/lib/mysql/目录。\n\n# 删掉三个文件：ibdata，ib_logfile0和1\n# mysql_install_db --user=mysql --basedir --ldata\n\n!!! mysqld_safe\n\n把my.cnf文件放到默认位置（通过mysqld --verbose --help查看），再执行mysqld就能启动监听，可能会报错，但似乎不影响执行。\n\n```\n[mysqld]\nuser = xx\nbasedir = /pathto/mysql\ndatadir = /pathto/mysql/data\nport=3306\nserver-id = 1\n\n[client-server]\nsocket = /var/run/mysql.sock\n```\n\n除了原始的mysqld命令，用safe脚本会多做以下几件事\n\n# 从多个目录寻找mysqld，并配置额外参数（malloc、PRELOAD_LIB）\n# 对信号进行trap捕获，防止意外退出，配置日志目录\n\n!!! 用户机制\n\nuser表记录所有的用户密码和权限，似乎做了SHA1，另外MySQL5换过保存方式，不过手头没有版本4，也无从察看。因此安装包通常会告诉你初始密码是什么，否则没法登陆了。可以用mysqladmin工具修改密码，如果忘记密码就要让mysqld进行无授权模式启动，在my.ini的`[mysqld]`配置`skip-grant-tables`，这时就可以免密码登陆，然后再用`use mysql; update user set password=password('123456') where user='root' and host='localhost';`语句修改mysql库的user表，退出后去掉免授权模式，重启mysqld就可以用新密码登陆了。\n\n要注意user表是host和user双字段联合主键，同样的用户名从不同地方登陆可以设置不同密码和权限。又比如常见的root用户不能远程登陆就是因为user表没有host为%的记录，不存在从任意主机连接过来的root用户，当然就会报错了。host是localhost代表unix socket，而127.0.0.1代表berkley socket。\n\n创建或修改用户密码\n\n使用`mysqld_safe --skip-grant-tables&`跳过检查，然后一定要`flush privileges;`，否则mariadb会报不能执行权限类操作。\n\n* mysql5.5: `update user set password=password('root') where user='root' and host = '%'; flush privileges;`\n* mariadb: 从10.4版本开始，user表已变成视图，不能修改。要用`alter user user@'%' identified by 'user'`，或者添加用户`create user user@'%' identified by 'user'`。\n\n!! binlog\n\n在项目中遇到数据库连接和表都在，但其中一张表的大量数据丢失，虽然到最后数据都没能恢复出来，但binlog和备份的重要性再一次刺激了我。\n\n命令行工具叫mysqlbinlog，但是变量命名是`log_bin`，因为日志除了bin，还有error、syslog等多种。binlog在主从同步时起关键作用，因此是数据库级别，不能针对某张表开启，因此binlog可以用 show master logs。\n\n最简单的用法：mysqlbinlog --no-defaults mysql-bin.00000x 就可以显示所有的执行日志。\n\n!! 数据库备份\n\n* 备份整个库: mysqldump -h xx -uxx -pxx --databases db1 db2 > back.sql\n* 备份表: mysqldump -h xx -uxx -pxx dbname tbl1 tbl2 > back.sql\n\n以上命令可以用--no-data方式只备份结构。除了表之外，默认只转储触发器，不会转储事件和过程，要加上-E(事件)或-R(过程)。视图无法导出，要备份视图定义的frm文件，导入后再次恢复。\n\n!! Redis记录\n\n总计有1314099条时，占用内存近12G，平均下来一条9K，远超实际长度。设置 maxmemory防止无限增长。\n\n认证命令auth，不过只是一个很弱的安全措施。可以用config get requirepass查看。","modified":"20171129121530000","tags":"data"},
{"created":"20231028132627253","text":"em{color:#00f;font-style:normal;}\nstrong{color:#f00;font-style:normal;}\n@media (min-width: 960px) {.tc-tiddler-frame {padding-bottom: 0px;margin-bottom: 12px;} }\n.tc-tiddler-body h2{color:#037;}\n.tc-tiddler-body h3{color:#409eff;}","tags":"$:/tags/Stylesheet","title":"MyStyle","modified":"20231029140404352"},
{"created":"20190615121530000","text":"\n!! 工作流\n\nmaster-worker的流程如下\n\n![flow](/img/ngx-master-worker.jpg)\n\n当worker被意外终止时，master会启动一个新的，且work-id不变，保持逻辑一贯性。即使master挂掉，worker会正常工作，这也是resty的工作原理。只是worker再挂掉就没有进程拉起了。\n\n每次的请求都会随机分配给一个worker处理，通过 accept_mutex 指令防止惊群。这是一个加在accept上的一把互斥锁。即每个 worker 进程在执行 accept 之前都需要先获取锁，获取不到就放弃执行 accept()。有了这把锁之后，同一时刻，就只会有一个进程去 accpet()，这样就不会有惊群问题了。accept_mutex 是一个可控选项，默认打开，可以显示地关掉。\n\n解决这个问题还有一种办法，1.9.1版本引入套接字共享选项，listen 80 reuseport; 这种方式和accept_mutex互斥，所有worker都在监听，但不需要worker抢锁，而是由内核来分配，但需要Linux在3.9以上才支持。\n\n!! 模块\n\n要对Nginx做扩展，都是在nginx.conf里通过命令调用来完成的。这些命令是归属到某个module中的。命令本身不会显式支持命名空间，\n还是要写扩展的人按照良好的习惯对命令命名，Nginx的风格是C式的蛇式命名。但是也不一定。比如echo命令就是echo这个module，但是`content_by_lua`又属于`ngx_lua`模块，我猜大概是Nginx的作者在设计之初并没有想过有一天会这么受欢迎吧。\n\n从语法上看，模块至少要包含context和directives两个最核心的定义(其余版本、类型简单)。\n比如`ngx_module_t`的context对应`ngx_http_module_t`，directives则对应`ngx_command_t`。\n\n以上是针对Nginx module的定义包含context和directives，还有一种http module定义，\n主要定义的是create/init main/server/location configuration的函数定义。\n因为每个command在运行前势必要得到其所在的上下文，对应就是上面说的configuration的创建。如果命令所在的阶段不同，定义也不一样。这些定义都是嵌套在`ngx_module_t`里的。\n\n!! 问题排查记录\n\n# 访问报403无权限: 检查目标目录权限755，nginx的启动用户root都没有问题。网页文件在root目录下，尝试移到/var目录，保持权限755终于可以访问（644仍提示无权限）\n","title":"nginx工作流与模块","modified":"20231026060553324","tags":"web"},
{"created":"20170516121530000","title":"OpenBSD学习与使用","text":"\n系统分为内核文件和应用层套件，根目录下放置启动器boot和内核文件bsd，对一些支持多核的芯片，会另有bsd.mp文件，但不清楚此时bsd是否仍必须。\n\n用ksh作为默认shell，功能少很多。每个版本升级会带来若干改动，升级换内核前必须做好充分准备工作。\n\n!! 系统工具\n\n* syspatch 更新系统的应用层套件\n* pkg_add 包管理器，修改/etc/installurl可以换源\n\n!! ps程序走读\n\nps程序要从内核读取进程消息，BSD内核上承SunOS使用了kvm.h，这并不是Linux下的虚拟机，而是kernel virtual memory的意思。是用户态读取内核的交互接口，kvm的一些操作需要root权限，这也是BSD系列的ps和Linux的ps不同的原因。\n\n大致来说，先用`kvm_openfiles`打开一个kvm句柄，然后用`kvm_getprocs`读取内核参数，并返回一个`kinfo_proc`数组，用qsort对数组进行排序，排序的比较方式有DEFAULT/CPU/MEM三种，内存排序值得说说，`kinfo_proc`是个非常大的结构，计算内存使用了其中有的tsize/dsize/ssize三个变量，分别表示text/data/stack size，另外还有rssize，即RSS，注释是current resident set size指包括栈和堆在内的占用物理内存。但排序并不把这个值计算在内。显示的时候还有VSZ表示virtual size，但奇怪的是在OpenBSD上，VSZ却比RSS还小。\n\nps在检测进程状态有个-t选项，表示只显示与这个tty关联的进程，/dev/下有100多个tty，命名都是/dev/tty开头，这是在paths.h的`_PATH_TTY`宏来定义，这个文件定义了很多与路径相关的变量，Linux也有，应该是为了让程序跨平台用的。与操作者相关的是ttyp0和ttyp1，另外还有ttyC，ttyc、ttyP、ttyVI等好几个大类的终端。\n\n另外还有大量的代码都是在处理各种参数，因为ps的参数实在太多了。","modified":"20170516121530000","tags":"os"},
{"created":"20160304121530000","title":"Openresty代码初读","text":"\n我在公司内网的服务器从Apache httpd换成Openresty也有半年左右了，切换之后没有去深入研究，最近重新开始研究，一点初步的理解，记录在这里。\n\nnginx给我最初的印象不是快或者节省资源，而是它居然的扩展机制。现在的软件都说自己是插件化体系，放个dll或so进去就可以增加功能，但nginx却需要每次重新编译，把扩展代码和执行程序编在一起才行。好像淘宝有个Tengine的扩展，可以用动态库的方式扩展，不过openresty没有用，那就还是看nginx的代码好了。\n\nopenresty的编译也是用configure脚本，却不是用GNU的auto系，而是在平级目录下有个auto目录，里面有各式各样的脚本检测OS或编译器选项，这块不清楚是不是个独立的项目，又或者是作者自己手工写的。\n\nnginx编译添加模块的方式是在./configure后面用--add-module=指定路径方式，从configure脚本可以看到，是在指定目录下寻找config文件，如果有再从config文件读入相应的源代码和模块名信息。config定法也不复杂，就定义一些shell变量，然后统一被写入编译文件列表。nginx内一个很重要的概念是模块，代码中是个名为ngx_module_t的结构体，官方提供的http和mail功能是用模块，扩展功能也是同样实现这个模块。在core目录下，可以找到`extern ngx_module_t  *ngx_modules[];`这样一句声明，而在main函数中就直接循环遍历这个数组了。找遍nginx目录也没有找到这个变量定义的地方，再结合每次扩展需要重新编译，恍然大悟去编译目录objs/下果然找到`ngx_modules.c`这个文件，里面赫然定义了`ngx_module_t *ngx_modules[] = {`以及之后的若干个模块，之就是nginx静态编译扩展的原理了。模块分了CORE、CONF、HTTP和MAIL四个大类但定义是分散在core/http/mail三个目录下，似乎除了CORE会用于逻辑判断，其它几个并没有严格地规定。模块版本号目前都是1，也没有做逻辑判断，可能是为了将来扩展吧。另外模块中真正起作用的，就是content指针和7个函数指针。不过有些扩展模块并未实现函数指针，只有content是必须实现。或许是因为大多数模块并不需要参与nginx的核心调度，只要有content环境能和核心进行交互即可。像openresty中非常重要的lua扩展，也只不过实现了7个函数指针中的`init_process`这一个函数。\n\n由于模块是编译进程序，运行自然也就和nginx在同一个地址空间，遍观如今排名前20的主流语言，体积小功能完整的，还真就只有lua了。因为扩展是直接在nginx的worker进程跑，如果扩展出点问题，worker进程是会直接挂掉的，开始我不知道，用ngx.say去遍历打印ngx内部的成员名和类型，结果浏览器就没有结果显示，后来看了代码才发现，因为table中有ngx.say不支持的类型值，结果lua扩展直接触发了abort();这个问题后续还是要注意，如果nginx中要执行长会话动作，这种abort还是很危险的。","modified":"20160304121530000","tags":"web"},
{"created":"20170224121530000","title":"Openresty的应用开发","text":"\n每个版本都是在nginx的基础上做扩充，所以版本号会多出一位。ngx_lua、memc、srcache都是扩展。自带resty的命令行工具，启动一个`master_process off`的nginx程序，主要用于验证扩展的lua程序是否正确，配合测试极好。\n\n用lor框架开发，首先要记录关于路径的部分。启动脚本是通过nginx加载指定的配置文件来启动，从而实现dev或prod的简单分离。从nginx.conf看，整个流程的路径从app/main.lua进入，所有的路由也都记在这里。\n\n先在main.lua打印看lua的package.path，lor的默认配置类似\"./app/?.lua;?.lua;...\"，\n当前路径的.到底是哪里的？开始我错以为是main.lua所在的路径，这是受了PHP的影响。\n因为nginx和PHP的开发，说到底nginx只是个fastcgi的转发器，最终还是用PHP来跑，\n所以PHP的话，路径是首个PHP文件入口，但是openresty方式不是，利用的是nginx的prefix path，默认是/usr/local/openresty/ngingx/这个。\n但是我们的程序显然不可能放在这里，所以这个路径没有意义。幸好nginx提供了-p选项，在lor的start.sh脚本写法是这样：\n\n* nginx -p `pwd`/ -c conf/nginx-${PROFILE}.conf\n\n通过-p的方式把prefix path导引到lor所在的目录，于是main.lua中require('app.server')就能顺利找到了。\n\n使用lord脚手架生成的程序，在根目录有main,server和router这三个文件，\nmain的注意事项上面已经介绍过了，接下来说router。Web应用开发最主要的就是处理URL请求，\n再细化一点，要根据方法要区分GET/POST。这个过程行话称为后端route。\n能看到router文件中有类似app:get(\"/hello\", function(req, res, next) end)这样的定义，\n这是一种框架定义的简写法，表明有GET请求到/hello路径时，触发与之关联的方法。\nURL的写法似乎只支持原始的和/hello/:id/这一种扩展。不过即便是这样，\n要实现PHP的Cemvc框架的路由效果也足够了。比如定义一个/lor/:cls/:mth/:param/的路由规则，\n根据cls从已加载的业务代码中找对应的类。(因为lua语言的require如果失败会强制退出，\n只能先加载再查询，这是语言不同带来的使用风格不同)。\n另外function处理细节也比较多，后续再写了。\n\nserver是封装lor库的内容，使用app:erroruse函数，可以增加一些错误处理机制。简单的Web开发通过这三个脚手架差不多可以搞定了。\n\nnginx程序共四大阶段， 初始化 -> 重写 ->  内容  ->  日志。初始化阶段只在启动时会执行一次，以后再也不会执行，一般定义全局变量或加载常用模块，之后的请求就不用去磁盘加载文件了。如果这个环节的代码抛异常，会导致nginx启动失败。重写和内容对应客户端的一次请求，而日志在响应之后，因为是异步操作，不会影响响应时间。\n\n初始化分 init(作用于master) 和 `init_worker`(作用于worker进程)，重写有 ssl_certificate,(这是可选的) set, rewrite, access ，内容有 content(balancer), `header_filter`, `body_filter` ，日志只有 log 。\n\n每个阶段能做的操作是不同的，比如init阶段由于还没有收到连接，所以ngx.say没有地方可以输出，显然是不能执行的，只能执行ngx.log操作。相应的指令是 `error_log`，要指定写入的文件名和级别，如果代码中的级别低于`error_log`设置的级别，就不会输出。这条指令的名称略带迷惑性，不限于error级别，所有的级别都可以打印。最低级别的debug，需要编译时打开--with-debug选项才行，当然如果用户指定这个级别也能输出。\n\n开发阶段会开启`lua_code_cache off;`，这句指令只影响请求到来时要不要创建新的VM，显然对初始化阶段的语句是无效的。\n\n请求的值可以从 ngx.var.xx 中得到，比如地址是 ngx.var.uri ， 参数是 `ngx.var.query_string`。其实一旦存在，还有更简便的方法，ngx.var.arg_keyname直接可以获取。\n\n取body稍有些不同，因为nginx的定位是消息转发而不是处理，只要读出Header就能满足，默认不会读内容。需要的话用ngx.req.read_data()，再调用local body = ngx.req.get_body_data()\n\n支持响应请求后再做事情，有ngx.eof()和ngx.timer.at(delay, callback)两种做法。\n\n数据库很方便，集成MySQL连接池后，简单的两句话得到值，用ipairs遍历res，每次遍历的值，再用数据库的列定义去取值。\n\n```\nlocal mysql_pool = require 'applua/mysql_pool'\nlocal ok, res, state = mysql_pool:query('select * from one_table;')\nif ok then\n  for k,v in ipairs(res) do ngx.say(k..' : '..v.name) end -- change name to other column \n  ngx.say(res[1].name)  -- direct access first result\nend\n```\n\n正常结束，则返回的res是table，异常时res就代表错误码，此时state也会被赋值，额外介绍下，根据 X/Open 和 SQL Access Group SQL CAE 规范 (1992) 所进行的定义，SQLERROR 返回 SQLSTATE 值。SQLSTATE 值是包含五个字符的字符串 。五个字符包含数值或者大写字母， 代表各种错误或者警告条件的代码。SQLSTATE 有个层次化的模式：头两个字符标识条件的通常表示错误条件的类别， 后三个字符表示在该通用类中的子类。成功的状态是由 00000 标识的。SQLSTATE 代码在大多数地方都是定义在 SQL 标准里的。\n\n如果SQL语句是INSERT或UPDATE，得到的res是key-value的table，会记录数据库受影响的状态。打印结果像这样\n```\ninsert_id : 3\naffected_rows : 1\nserver_status : 2\nwarning_count : 0\n```\n\n* 注意，SELECT返回的table格式，和另外三种都不一样。查询是数字下标，且值还要展开一层，而修改类的操作就是普通的k-v对。\n\n在worker进程执行os.execute有个很坑的特性，sh的环境变量不一样。原因是我做了个升级脚本，在命令行下怎么运行都正常，但work就会报java版本不匹配，拉不起程序。最后发现在shell中执行的java是/etc/profile中额外加入的java8，而worker中是看不到这个路径的，于是找了版本7。用env打印会发现少非常多变量。最后把/usr/bin/java定位到java8得到解决。","modified":"20170224121530000","tags":"web"},
{"created":"20170429121530000","title":"P2P及SIP和xinetd","text":"\nP2P穿透涉及的协议有STUN/TURN/ICE，STUN是真正的UDP打洞，但只适用于cone NAT的网络环境下(完全、限制、端口限制三种都支持)，因为STUN的核心是子网内的客户端和公网建立连接后，NAT映射后的公网地址要能被另一个客户端使用，只有cone NAT才满足这个条件，symmetric NAT不允许公网端口复用，因此无法即使从公网上获取了NAT后的地址，也不能用来和另一个对端连接。\n\n对symmetric网络，只能使用中继方式，就用到TURN的方式，ICE要解决的问题和TURN类似，但两者的差异还没有完全清楚。\n\nP2P之后两个端就要建立会话，SIP是定义非常严谨的协议，明确地分了4个层级，基础的用ABNF规定了文档用语的格式，然后是传输层，接着是和业务关联最紧密的事务层，事务层之上还有个可选的事务用户(TU)，但这一层并不是必须的，比如无状态的proxy就没有TU一说。\n\n!! xinetd类程序\n\n知道xinetd这玩意属于偶然，本想尝试着在linux上跑cvs的server端，然而还是失败了。所有的服务端程序都需要监听端口，比如httpd就自己监听80，但是如果有大量非高频程序，要监听各式各样的端口，全数都启动显然是浪费资源，super server daemon也就是xinetd就是解决这类问题。这个程序的前身是inetd，不过现在都切换到xinetd了。\n它的功能是配合/etc/service配置项，监听各种各样的端口，然后把端口请求转发给相应的程序。比如在/etc/xinetd.d/目录下配置2401端口由cvs监听，平时cvs不会启动只有2401端口来请求时就唤醒cvs来处理。很多本身不带网络服务的程序，通过xinetd就具备了通信功能，有点CGI的味道。\n\n从功能上可以看出xinetd属于优化类程序，并不是默认自带程序，Alpine linux甚至都没有包。在Cent7下通过yum install xinetd安装，也可以通过下载包手动安装，依赖很少。xinetd程序也很小，x64版本不到200K。安装后还需要通过service xinetd start启动，这样才真正开始监听。\n\n用xined监听telnet遇到问题，系统默认telnet只能监听23端口，但是这要求有root权限，这种情况下要先在service增加一个伪telnet服务，让这个服务监听新端口，然后配置这个伪服务，最终导给telnet监听。\n\nbusybox有类似的程序tcpsvd，配套telnetd和ftpd一起使用。","modified":"20170429121530000","tags":"protocol"},
{"created":"20190623121530000","title":"perf使用","text":"\n包含二十多个命令的合集入口\n\n序号\t命令\t作用\n1.\tannotate\t解析perf record生成的perf.data文件，显示被注释的代码。\n2.\tarchive\t根据数据文件记录的build-id，将所有被采样到的elf文件打包。利用此压缩包，可以再任何机器上分析数据文件中记录的采样数据。\n3.\tbench\tperf中内置的benchmark，目前包括两套针对调度器和内存管理子系统的benchmark。\n4.\tbuildid-cache\t管理perf的buildid缓存，每个elf文件都有一个独一无二的buildid。buildid被perf用来关联性能数据与elf文件。\n5.\tbuildid-list\t列出数据文件中记录的所有buildid。\n6.\tdiff\t对比两个数据文件的差异。能够给出每个符号（函数）在热点分析上的具体差异。\n7.\tevlist\t列出数据文件perf.data中所有性能事件。\n8.\tinject\t该工具读取perf record工具记录的事件流，并将其定向到标准输出。在被分析代码中的任何一点，都可以向事件流中注入其它事件。\n9.\tkmem\t针对内核内存（slab）子系统进行追踪测量的工具\n10.\tkvm\t用来追踪测试运行在KVM虚拟机上的Guest OS。\n11.\tlist\t列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点。\n12.\tlock\t分析内核中的锁信息，包括锁的争用情况，等待延迟等。\n13.\tmem\t内存存取情况\n14.\trecord\t收集采样信息，并将其记录在数据文件中。随后可通过其它工具对数据文件进行分析。\n15.\treport\t读取perf record创建的数据文件，并给出热点分析结果。\n16.\tsched\t针对调度器子系统的分析工具。\n17.\tscript\t执行perl或python写的功能扩展脚本、生成脚本框架、读取数据文件中的数据信息等。\n18.\tstat\t执行某个命令，收集特定进程的性能概况，包括CPI、Cache丢失率等。\n19.\ttest\tperf对当前软硬件平台进行健全性测试，可用此工具测试当前的软硬件平台是否能支持perf的所有功能。\n20.\ttimechart\t针对测试期间系统行为进行可视化的工具\n21.\ttop\t类似于linux的top命令，对系统性能进行实时分析。\n22.\ttrace\t关于syscall的工具。\n23.\tprobe\t用于定义动态检查点。\n\n全局性概况：\n\n* perf list查看当前系统支持的性能事件；\n* perf bench对系统性能进行摸底；\n* perf test对系统进行健全性测试；\n* perf stat对全局性能进行统计；\n\n全局细节：\n\n* perf top可以实时查看当前系统进程函数占用率情况；\n* perf probe可以自定义动态事件；\n\n特定功能分析：\n\n* perf kmem针对slab子系统性能分析；\n* perf kvm针对kvm虚拟化分析；\n* perf lock分析锁性能；\n* perf mem分析内存slab性能；\n* perf sched分析内核调度器性能；\n* perf trace记录系统调用轨迹；\n\n最常用功能perf stat/record，先定性地看一个进程问题在哪，再详细记录调用情况。尤其stat结果的第一条task-clock能很明确地告诉你CPU占用率是多少，比如写一个无聊的lua脚本只做个打印，发现整个程序的CPU占用率是39%，即打印操作占了61%，还是IO占的时间更多。（越接近1表明CPU Bounded）\n\n* pref record记录信息到perf.data；\n* perf report生成报告；\n* perf diff对两个记录进行diff；\n* perf evlist列出记录的性能事件；\n* perf annotate显示perf.data函数代码；\n* perf archive将相关符号打包，方便在其它机器进行分析；\n* perf script将perf.data输出可读性文本；\n\n可视化工具perf timechart\n\n* perf timechart record记录事件；\n* perf timechart生成output.svg文档；\n\n比如要监听某后台程序的性能，先用ps获取pid。这里我犯了个错误，其实ps出来的第一列就是pid，我却错找成后面的数字了，要注意。然后这样输\n\n* perf record -e cs -a -g -p xxx\n\n-e表示记录所有cs事件(事件名从perf list获取),-a表示记录所有CPU行为,-g表示记录call graph，而最后的-p就是指明pid。\n然后perf就开始监听直到按下Ctrl-C才会停止。停止后会自动生成perf.data文件，\n再用perf script(用于显示跟踪输出，而perf report命令也会自动读取perf.data并生成profile，火焰图需要的是跟踪输出，所以是script命令)。命令如下\n\n* perf script | stackcollapse-perf.pl | flamegraph.pl >perf.svg\n\n中间两个perl脚本从[这里](https://github.com/brendangregg/FlameGraph)下载。最早版本的stackcollapse是从DTrace来的，后来发展出各种工具的适配版，perf是其中之一。\n\n不仅用户态有线程和栈，内核的调度也以线程为单位，同样线程也有栈。硬件中断的处理就很典型，中断程序分为上下两个半部分，上半部分响应很及时，但是此时处理器处在中断禁止模式，所以必须尽快地完成重新开放中断。如果业务太多处理不完，只有交给下半部分，下半部分就和应用态类似tasklet，由线程管理器统一调度。\n\n像nodejs也追加了对perf的支持(V8支持)，像这样运行`node --perf-basic-prof xxx.js`就会生成/tmp/perf-pid.map文件，用`perf record -F 99 -p \\`pgrep -n node\\` -g -- sleep 30`记录运行数据就可以了。但是生成的map文件会不停增长，可以用`--perf-basic-prof-only-functions`来延缓map文件增长速度。java据说8u60版本后，打开`-XX:+PreserveFramePointer`也能和perf协同。","modified":"20190623121530000","tags":"os"},
{"created":"20170403121530000","title":"php-fpm记录","text":"\nPHP的组成，从内到外大致分3层\n\n# 解析器核心，在形态上表现成php.dll，实质是zend引擎，做语法解析和字节码执行。对应配置php.ini\n# 函数和标准库\n# 外覆层，引出SAPI概念，进入解析器的入口可以有多种模式，这些模式就称为SAPI。比如php-fpm，对应配置php-fpm.conf\n\n写web程序时，可以很方便地调用`$_GET`，这个变量不是核心层的特性，而是在SAPI层解析了CGI环境变量后，再传给核心的。所以不同的SAPI，会提供不同的外围特性。\n\n比如在linux下默认编译出的有php(cli)、php-cgi(cgi)和phpdbg(dbg)这3个可执行程序，如果要配合nginx，在编译选项增加`--enable-fpm`就能得到php-fpm(fpm)。它们都能解析PHP，PHP-FPM存放在/usr/sbin/下，其它几个则在/usr/bin/下。但是不知为何linux并没有用动态库，上述4个程序都是静态编译，每个29M，这样做很浪费空间，也许是我编译选项没有打开？逐个说明这几种SAPI：\n\n* cli : 命令行接口，也是其它语言最常见的模式，像python/ruby等程序都可以理解为cli模式。\n* debug : 调试接口，和`perl -d`方式效果相同(也许其它语言也有类似的)。这个接口似乎是5.6或稍早的版本被合进主干的。\n* cgi : 这个接口就体现PHP天生为Web语言的一面了，支持FastCGI/CGI规范，相当于在PHP的语言内核外，增加了对FastCGI网络请求的解析，在windows版的phpstudy默认就是运行4个`php-cgi`进程常驻后台。\n* fpm : 最初只是个第三方开发的PHP进程管理器，后来在5.4时代被官方合并，并支持PHP解析。是目前主流的FastCGI容器方案，由于用了fork只能运行在`*nix`上。\n\n由于php-fpm只是外围入口，很多php自身的参数仍然需要设置，所以它有两个配置选项，-c指定php.ini路径，-y指定fpm路径。重启使用kill -USR2 PID方式，关闭使用-INT。如果要快速找到pid可以打开配置中定义的pid文件路径，默认因为不保存所以要用ps加grep来查找。\n\n要想加速php，少不了opcache模块，从5.5.3开始默认包含。它属于zend extensions，并且要指定完整so路径。原理是把编译后的PHP字节码缓存到内存，下次请求来的时候，根据文件名找到编译后的字节码，就能极大地节省时间。PHP对应cli模式，执行完毕就退出，显然这种模式无法利用缓存在内存的字节码，但不知为何7.1版本默认打开cli模式下的缓存。既然cli模式不行，通过PHP-FPM常驻内存，并fork多个子程序，子程序和父进程使用共享内存，子程序能完整地执行PHP字节码，并不依赖cli程序。一个佐证是Android上的phprunner程序中，就只有惟一的PHP-FPM程序配合lighttpd运行；而PHP Server这个包选择php和php-cgi程序，没有web服务器和php-fpm，靠php的web模式也能接收网络请求。\n\n还要注意的一点，一旦打开缓存，所有的PHP的内容就都会用缓存的数据。我之前页面中的一些数据采用PHP的方式内嵌，导致缓存后无法更新，只有重启PHP进程才能更新数据，后来改成从txt文本读取才解决这个问题。","modified":"20170403121530000","tags":"web"},
{"created":"20180219121530000","title":"PHP的一些语言特性","text":"\n!! 程序辨析\n\nphp包装好后，会有php和php-cgi两个很容易混淆的程序（php-fpm单开一篇讲），这和php最早就是作为web开发语言有关。其它的脚本语言，主要都是运行在cli下，通过一些库也能运行http程序，但不是程序核心部分。虽然我没有证据，但初版的php语言可以认为只有php-cgi。在这种模式下，输出要服务于html，因此所有的文字都会包裹上适当的html标签。随着php的发展，也有人把它用于终端开发，这时就有了php程序，此时的输出就是纯粹的文本。\n\n!! ini默认配置\n\n启动时会读入php.ini配置文件，虽然不读也可以，但鉴于常用选项太多，最好还是配置一下。因为有些扩展，如果不在ini文件中指定是不会加载，虽然可以通过dl手动加载，但毕竟没有ini直接指定来得方便。其它语言虽然也有类似机制，但远没有像PHP这么重视启动加载文件。\n\n!! 动态性\n\nPHP的动态特性让人印象深刻。\n\n首先是字符串可以在一定程度表示函数。比如`spl_autoload_register`函数传入的参数是string，实际对应的是同名函数。\n另一个例子是构造一个对象$obj，再定义一个字符串变量$foo='bar'，用$obj->{$foo}()的方式就可以调用$obj实例的bar方法。\n\n从字符串推导出函数就是反射，对动态语言来说并不是独一无二的能力，但PHP把字符串直接映射函数这个特性，结合到部分特性的上下文，做成了很好用的语法糖。\n\n所有语言动态能力的源头都是eval，PHP/JS/Lua都有这个函数(Lua对应load)，比如eval('$abc=123;')执行后，$abc就可以使用了。JS的书中对eval的闭包有很详细的解释，eval最重要的参数是环境，不填有可能是当前环境或根环境，不同语言偏好不同。\n\n再说说观察者模式和语言的结合，PHP支持SplObserver和SplSubject。在Ruby中也有类似的observer模块。差异是PHP的notify时是把SplSubject整个对象传给SplObserver对象，而Ruby可以传递任意个数的参数，多少也体现了Ruby语言的灵活。\n\n相对路径是程序中很容易引起混淆的地方，比如`__DIR__`或`__FILE__`变量，单独执行时很容易理解，但从另一个文件载入这个文件时，值并不会变化。原因是这个变量是从属于被执行的文件，并不会随着调用方而变化。\n\n!! 自动加载\n\n要使用composer生成的自动加载代码，除了在调用端和源端按规范使用命名空间外，最重要也最容易忽视的，就是要配置好composer.json和生成加载代码。\n\n假设项目目录是这样\n```\nProject\n|__composer.json\n|__main.php\n|__lib/\n    |__A.php\n|__vendor/\n    |__autoload.php\n```\n\n假如代码在lib目录下，务必在项目顶级的composer.json加上\n```\n    \"autoload\": {\n        \"psr-4\": {\n            \"your-namespace\\\\\": \"lib/\"\n        }\n    }\n```\n之所以显得有些啰嗦，是因为还存在psr-0和files方式，所以必须在autoload节点下再嵌套一层。\n\n然后在main.php使用`use your-namespace\\A`，而在A.php中定义`namespace your-namespace`。\n\n到这一步还不够，必须要手动执行一次`composer dump-autoload -o/-a`，-a表示一旦找不到就不再查找，而-o还会尝试按psr4方式再找一次。至此加载器才能正常工作。说明加载器并不是全自动的，而必须要手工介入，且最顶级的命名空间，是用配置绑定，并不要求命名体现在文件系统上。\n\n看过vendor/autoload.php的源代码就可以知道，所有加载类的路径，都是事先在代码中保存在一个array变量classMap里，并不是运行时拼接路径加载，所以运行前执行一次dump-autoload就好理解了。\n\n简单解释一下autoload的源码，vendor下的autoload.php只是一个入口，先加载autoload\\_real.php，虽然名字带了real，并不是真正的加载函数，还要依赖ClassLoader.php和autoload\\_static.php，这两个类各有分工，ClassLoader负责调用spl_autoload_register，而static则提供classMap，这两个类在调用链上经过Closure::bind被绑定到一起。\n\n!! stdClass\n\n用`json_decode`函数，却不能直接用[\"name\"]取值，原因是返回的是类型为stdClass的值，既然是对象，就要按对象的语法`->{\"str\"}`取值。\n\nstdClass有点像Java的Object味道，当然它是类不是对象。也可以new stdClass()创建一个什么都没有的空对象。\n\n对象和array看起来很像，能表达的内容也差不多，目前所知最大的差异就是在赋值时，array会把所有元素的值全拷贝一遍，而new得到的对象，赋值后只是一个引用，拷贝对象是几乎没有开销的。\n\n从语言历史来看，array在PHP4时代就出现了，而完整的对象语义直到PHP5才成形。而引用也是相对高级的特性，因此和对象关联在一起也就好理解了。\n\n!! 源码结构与SPL\n\n最主要的3个目录，Zend/ext/sapi。Zend编译虚拟机，ext是标准库和常用扩展库，如PDO/XML等等，sapi则是最外层的接口。三个层次非常清晰。\n\nPHP的`file_get_contents/fopen`可以直接打开url，即直接获取网页内容。这些接口虽然简单，但一来灵活性低，另外只能阻塞没有超时设置标志，因此还有一种层次更基础的fsockopen，是socket的封装，且可以控制超时时间。如果要通过fsockopen来获取HTML页面，要自己封装请求，HTTP1.1需要至少3个字段，除了方法还必须Host和Connection才能取得网页。\n\n做C++开发的人都知道STL，对于PHP来说对应的就是SPL(Standard PHP Library)了。这是从PHP5时代开始发展并成熟起来的技术。所有SPL的函数以`spl_`开头，除了函数还有若干窗口类的接口，比如SplHeap、SplStack等，另外就是迭代器和异常。\n\nURL的禁则：`+`号是要转码的，但是奇怪的是form中如果输入空格，空格会转成`+`。而真正的`+`会用%转码。PHP有个函数叫parse_url，能把url拆成path和query，但是又不做转码。","modified":"20180219121530000","tags":"web"},
{"created":"20161217121530000","title":"PHP的SESSION机制","text":"\nHTTP/HTML起初是为展示文件而设计的，天然就是短连接没有状态。\n像登陆业务却需要长连接，加之PHP又不具备daemon化特征，因此解决这个问题就要有些技巧。\n\n先说短连接，TCP基于无连接的IP能达到流式效果，大概是有TCP首部的序号和确认序号机制，\n要在HTTP的短连接上要达到同样的效果，一样要有类似TCP序号的标记，这就是COOKIE。\n比如第一次登陆后返回一个特殊的COOKIE值，下次客户端把COOKIE带上，就能在短连接上模拟长连接的效果了。浏览器出于安全方面的考虑，不会主动添加COOKIE，都是由服务端增加，有时会对COOKIE设置超时时间，到了之后浏览器删除。\n\n传输层面的问题解决了，接着就是服务端识别问题。如果像C或Java一直在监听，只需要把会话号记在内存就可以了，PHP却只能依靠持久化的方式，比如写文件来标记。\n前面提到COOKIE必须是服务端主动添加，要开启该功能就要调用`session_start`函数，也可以理解为服务端要向HTTP回复中写入Set-Cookie了。\n\n通过HTTP请求抓包中的COOKIE部分进一步地理解(如果是服务端返回则用Set-Cookie)：\n\n* Cookie: TRACKID=6a366db255a08732cc44b1e1913dd2da; PHPSESSID=hamehnglgsj2sg6nbguq2146o3\n\nTRACKID是Lighttpd的`mod_usertrack`模块产生的，用于配合clickstream功能，不去分析它，只关注PHPSESSID。PHP的session和上例的Key=Value类似，对应PHP的两个函数：\nKey是`session_name()`，可以在php.ini自定义，对应HTTP包头中的标记，不同的语言都会有不同定义，JSP默认用JSESSIONID定义。\n\n* session.name = PHPSESSID\n\nValue是`session_id()`，同样在php.ini有两个设置项\n\n* `session.hash_function` = 0  // 0-MD5，1-SHA1\n* `session.hash_bits_per_character` = 5 // 每5bit生成一个可打印字符\n\nvalue不能由用户定义，但可以变换表现形式。以上的例子使用MD5且每5bit表现成一个字符，因此128/5=26。和抓包符合。\n\n下一个问题，每次请求来的时候PHP被唤醒，因此必然会把持久化的session恢复到内存。持久化方式有files、memcache、redis等，当然最简单的还是files。\n\n* `session.save_handler` = files  // 对应的方法`session_module_name()`\n* `session.save_path` = \"/tmp\"\n\n如果files就要配置保存路径。对应memcache的话就是IP和端口。\nfiles的名称一般是`sess_idvalue`，对应刚才的抓包，持久化的文件名就是`sess_hamehnglgsj2sg6nbguq2146o3`。每次请求到来，根据Cookie构造出session文件名，如果能读取文件，说明会话存在，从这个文件就可以还原回上一个状态。\n\n当然session的id值不能一成不变，默认3小时一换。通过`session.cache_expire = 180`来调整。\n会话的id值如果想省事可以交给PHP来生成。高级点的玩法比如通过浏览器请求的其它数据来构造，\n然后先调用`session_id`再调用`session_start`，就能自定义会话号了。\n不过看反馈，似乎把`session.use_strict_mode`置为1会失效。\n\n如果要在PHP中打开会话，调用`session_start()`，先检查`$_COOKIE`变量(由HTTP包头的Cookie构造得来)里的PHPSESSID。\n如果存在和COOKIE[PHPSESSID]对应的文件，就读取这个文件，并通过`session_decode()`得到`$_SESSION`变量，\n除非我们手动管理会话的持久化方式(比如用redis或其它数据库)，否则不调用`session_start`直接访问`$_SESSION`，因为变量没有构造，PHP会报警告。\n\n`$_SESSION`里的键值对的持久化方式可配\n\n* session.serialize_handler = php\n\nphp和serialize()一样，还有binary等其它方式。至于会话内容可以通过`session_encode()`看到，修改后再用`session_decode()`设置回`$_SESSION`。\n\n说完服务端，再说说浏览器端。每次发起请求，看似只是个地址，但头部至少有Host, Connection, Agent, Referer, Cookie字段。即使跨域也会携带Cookie，这也是引起CSRF的根本原因。\n\n总结起来可以说，Cookie是有形的手，而Session是无形的手，要启动这只无形的手，需要`session_start`的一声令下。","modified":"20161217121530000","tags":"web"},
{"created":"20161120121530000","title":"PHP两种模式下的调试功能","text":"\nPHP语言相较于其它语言一个很大的不同，从一开始就定位在一种宿主语言。\n它是由Web服务器来调用，而不像其它脚本语言，如Perl或Python那样用于命令行。\n因此在PHP5以前，默认的主程序都是以cgi的SAPI模式运行，到了PHP5以后，\n默认的php.exe才切换为cli的SAPI模式，而php-cgi.exe则代表cgi方式的执行体。\n这两种模式支持的语法和特性是一样的，差异点有：\n\n# 输出是否会带上html标签(CGI带，cli不带)\n# daemon时作用不同\n\n先说监听模式，php-cli能通过-S选项打开build-in的Web Server模式，这时就不需要开Apache了，\n初学者使用这种方式上手PHP还是挺不错的，但比起完整的Web服务器，不能做URL Rewrite等功能。\n而php-cgi的-b选项是FastCGI Server模式，这种模式不支持HTTP请求，只支持FastCGI请求。\nFastCGI的specification比较简单，开始的请求头是8字节描述，包括版本号、类型信息，\n接着就是各种CGI定义的元数据，比如`SCRIPT_FILENAME`等字段，php-cgi判定协议头，\n并读取这些信息，执行完成后再将应答返回给Web服务器。因此这两种模式的作用差异是很大的。\n\ncli和cgi的调试也很不一样。cli模式使用phpdbg.exe程序，用法和GDB等类似，\n在命令行下进行操作，而cgi模式需要用到扩展模块xdebug，且开启xdebug还不够了，\n需要和另一个进程以C-S模式交互才行。\n\ncli模式使用phpdbg，最开始是5.4版本以补丁形式出现，到了PHP5.6以上，官方合入了这个补丁，\n通过命令行方式启动，载入程序后可以打断点、单步或查看栈帧等。\n和普通的命令行调试器很像，就不多做介绍了。\n\nxdebug是个远程调试扩展插件，需要在php.ini中载入对应的dll，\n且还要配置`xdebug.remote_enable`为1才能用，\n离奇的是，即使仅载入dll也会造成性能开销，因此如果不需要调试时，\n务必把载入dll行给注释掉。\n前面提到xdebug是C-S形的调试器，xdebug自身嵌在PHP内，是S端，因而必须要配置C端的地址，\n指令就是如下两条：\n\u003Cpre>\nxdebug.remote_host = \"127.0.0.1\"\nxdebug.remote_port = 9000\n\u003C/pre>\n通常C和S在同一台机器上，`remote_port`代表的是C端的监听端口。\n当xdebug收到`XSESSION_DEBUG_START`这个特殊的字段，\n就表示要开始调试，并向上例中的9000端口发起协商，通常xdebug客户端集成在IDE中，\n在IDE内进行单步/设断点等操作，遵循xdebug协议向PHP服务发请求，就能达到调试的目的。\n","modified":"20161120121530000","tags":"web"},
{"created":"20161219121530000","title":"PHP模板引擎学习","text":"\n用了3种模板引擎，从Smarty入手，但是这个库很大，文件又多。另外找了两个模板库，\nTinyButStrong(简称TBS)和RainTPL。TBS这个库很有欺骗性，可能和Smarty比确实小，\n但也有近150K。说真的不能算tiny，而且它的功能有点过于强大了。\n可以直接把SQL查询语句写到模板赋值里，\n这大大超过了我的期望。RainTPL是个约30K的单文件，在3者中最符合我胃口。\n\n既然是模板引擎，除了最常用的赋值，次常用的就是循环了，TBS太复杂，\n就比比Smarty和RainTPL吧。\n\nSmarty的循环语法相当不直观，类似下面这样\n\u003Cpre>\n\u003C% foreach item=rs from=$arivList %>\n\u003C% $rs %>\n\u003C% /foreach %>\n\u003C/pre>\n尤其是item=和from=那两句，每次都让人无法记住，而且你还不知道怎么表示key。\n反观RainTPL，简单到爆啊有没有\n\u003Cpre>\n{loop=\"arivList\"}\n{$value}\n{/loop}\n\u003C/pre>\nRainTPL直接把键值命名固定，和Tiny一样。其实我觉得这种地方真没有定制化的必要，\n都是程序员，简单直观就行了。有现成的$key和$value，谁愿意自定义啊。\n而且自定义又增加了上下文关注的成本，我觉得是非常不划算的。\n\n从刚才的循环可以看出，RainTPL使用了`{}`花括号对方式来标记，\n和TBS的`[[]]`又或者Smarty的自定义一样，和HTML区分开。这里又要说说Smarty，\n这种没有必要的自定义，挺分散精力的。\n\nRainTPL除了{loop}和{/loop}之外，也提供了常用的其它语法\n\n* {include=\"xxx\"} 从html模板的目录下导入文件，由于RainTPL可以配置后缀，\n所以这里不用填.html字样\n* {if=\"expr(true/false)\"}{elseif=\"\"}{else}{/if} 分支语法，风格一致很好记\n* {function=\"foo($bar)\"} 在html写函数，不过暂时觉得没什么用？\n* {$value.name|strtoupper} 把一个变量作为`|`后面的函数的参数，用返回值替换，\n有点pipe的味道，不过我还是倾向尽量不要在模板中引进这种太花巧的语法。\n* {noparse}{/noparse} 在这中间的变量不作转换\n* {ignore}{/ignore} example没有示例\n","modified":"20161219121530000","tags":"web"},
{"created":"20160611121530000","title":"PHP与Web服务器的集成方式","text":"\nPHP早期作为Web开发语言，监听HTTP请求并不在PHP做（虽然可以用-S选项来监听http请求，但毕竟不专业），产生环境中往往是由Web服务器(如Apache或Nginx)完成，当检测到是一个动态网页的请求，比如Url的后缀是.php，则把请求转给PHP程序，由它来处理后续的工作。在Windows上个人觉得比较好的集成工具是[PhpStudy](http://www.phpstudy.net)，集成了Apache/Nginx/Lighttpd等多种服务器(最新的2016版把Lighttpd去掉了)，而且支持多种PHP版本，就以PhpStudy安装后为例，分别说说两者的集成方式。\n\n!! Apache\n\n官方标准的方式有三种，经常用到的有两种(CGI基本用不到，完全被FastCGI替代)。分别是\n\n* 作为Apache内建模块运行，官方文档称为handler方式\n* 以FastCGI方式运行\n\nhandler方式就是在httpd的worker进程直接执行php程序，这种方式的配置会加载一个php-sapixx.conf文件(PhpStudy的写法，非官方)，xx是PHP的版本号，\n比如55、70等。从conf文件可以看到，其通过LoadFile和LoadModule指令加载了php5.dll和php5apache2_4.dll。数字随着使用的版本而变。\nLoadModule直接和Apache交互，从dll名字也可以看出，包含了php和apache两个程序，像PHP这么复杂的应用，不可能完全通过module代码完全实现，\nmodule更像是个桥接器，真正的任务还是要通过PHP来完成，因此和LoadModule配套，还要用LoadFile指令载入php5.dll，负责真正的PHP执行代码。\n另外PHP5.2版本，还通过LoadFile载入了libmysql.dll。也许是PHP和MySQL没有打通吧。如果module载入成功，通过\n\n`PHPIniDir \"D:/phpstudy/php52/\"`\n\n这句指令来设置php.ini的路径。(命令行的php方式可以使用-c选项，在宿主环境下就要配置了)。岔开一句，载入lua扩展只要LoadModule就可以，不需要LoadFile来指定lua.dll的位置。\n遍观所有配置，除了PHP的SAPI方式，也只有httpd-proxy-html.conf配置，用了LoadFile来加载zlib.dll,iconv.dll,libxml2.dll。\n\nFastCGI方式则不同，需要先加载FastCGI的运作器，注意模块名是fcgid，而不是fastcgi，这是两个不同的项目，差别我引用网上的说法：\n\n> `mod_fastcgi`因为实现方式的限制，所以可能会创建了很多不必要的进程，\n  而实际上只需要更少的进程就能处理同样的请求。\n  `mod_fastcgi`的另外一个问题是每一个CGI的多个进程都共享同一个管道文件，\n  所有到同一个fastcgi的通讯都通过这个同名的管道文件进行，\n  这样当出现通讯错误的时候，根本不知道正在通讯的是哪一个fastcgi，\n  于是也没有办法将这个有问题的进程杀死。\n\n> `mod_fcgid`尝试使用共享内存来解决这个问题。共享内存里面有当前每个fastcgi进程的信息\n  （包括进程号，进程使用的管道文件名等），当 每次尝试请求fastcgi工作的时候，\n  Apache将会首先在共享内存里面查询，只有在共享内存里面发现确实没有足够的fastcgi进程了，\n  才会创建 新的进程，这样可以保证当前创建的进程数量刚好能够处理客户的请求。\n  另外，由于每一个fastcgi进程使用不同名称的管道文件，\n  所以可以在通讯失败的时候知道到底哪个fastcgi进程有问题，而能够尽早的将其剔除。\n\n所以现在apache官方推荐使用的模块就是fcgid了。有一个专门的fcgid.conf文件，fcgid的参数很多，\n比较典型的，如FcgidMaxProcesses表示最多允许打开多少个进程。由于参数由Apache来读取，创建进程，控制进程的数量也同样是Apache。\n所以这种模式下可以看到的httpd进程中，有些并不是执行Web请求，而是执行PHP的宿主。有了宿主，接下来就是找到PHP并执行，和php关联的是这句指令\n\n`FcgidWrapper \"D:/phpstudy/php55n/php-cgi.exe\" .php`\n\n把请求直接导向了php-cgi程序。php-cgi本身就依赖于php5.dll，\n因此FastCGI方式下不需要通过LoadFile来载入php5.dll。指定php.ini仍然不能少，通过\n\n`FcgidInitialEnv PHPRC \"D:/phpstudy/php55n\"`\n\n这种方式，Apache会常驻进程，减少每次请求的创建进程开销。fcgid的耦合度比Handler方式更小，体现在\n\n# httpd进程的作用分离，Web请求和PHP执行在两个进程\n# 载入PHP方式，从.dll换成了.exe，从而避免了代码的强耦合。换句话说，Handler方式必须依赖php5apache2_4.dll，而CGI方式调用PHP的程序即可。\n\nHandler和FastCGI的方式，进程的所有者都是Apache，随着PHP自身的演化，5.3.3版本后的PHP官方代码也支持FastCGI模式，就是PHP-FPM(FastCGI-Process-Manager)，\n这个包还没有windows的移植版本。从命名就能看出，它是一个进程管理软件。\nPHP-FPM是daemon程序，它启动一个进程池，和Web之间通过监听TCP端口或Unix域套接字来进行通信。\n并会随着负载大小动态地增加或减少进程数量(可配置)。因此Apache的2.4版本之后，又增加了一种模式`mod_proxy_fcgi`，这种模式下Apache不需要知道PHP的文件或库位置，只管把请求发到指定的端口或域套接字就可以了。\n\n!! nginx\n\n与Apache相比，nginx官方实现不支持动态载入模块，所有的功能都需要在编译时指定，也就没有对应Apache的handler方式一说。\nnginx也没有和PHP做整合，在nginx里不会看到PHP路径配置，仅支持类似Apache的mod_proxy_fcgi配置方式，由于Windows版本没有PHP-FPM，因此运行PHP并监听端口，通过phpstudy这个管理程序来实现。\n\n从nginx的配置可以看出，在和PHP通信时，有大量的fastcgi_xx的指令。其中的`fastcgi_param`指令，就对应CGI规范中的Request Meta-Variables。\n比如`SRIPT_NAME`、`QUERY_STRING`。这些值需要在nginx.conf中设置，nginx会把`fastcgi_param`设置的值传递到PHP。从而在PHP中`_SERVER[\"SCRIPT_NAME\"]`的方式可以取值。\n\n比起CGI的RFC规范，PHP可用的Meta-Variables要多一些。比如RFC只定义了`SCRIPT_NAME`和`QUERY_STRING`，\nPHP多定义了`SCRIPT_FILENAME`和`REQUEST_URI`。`REQUEST_URI`是`SCRIPT_NAME`和`QUERY_STRING`的字符串连接。`SCRIPT_NAME`和\n`SCRIPT_FILENAME`的差别在于`SCRIPT_FILENAME`是绝对路径，nginx中一定要通过指定`SCRIPT_FILENAME`才能真正调用到PHP脚本，`SCRIPT_NAME`就是相对路径了。\n\n现在RESTFul大行其道，以资源形态表示的URL上，是肯定不会看到script.php的字样的，最直接的做法，就是在nginx配置这样一句：\n\n`fastcgi_param  SCRIPT_FILENAME  $document_root/script.php;`\n\n也就是说虽然在URL上看到的只是个资源，但是到了Web端仍然是对应到具体的PHP文件。在这个script.php中可以再从`REQUEST_URI`分离出资源信息，\n从`REQUEST_METHOD`得到操作信息，这样就可以完成资源到操作的转换。因为CGI出现的背景就是执行独立程序，因此规范直接定义`SCRIPT_NAME`就不奇怪了。如果请求报错no input file，说明nginx找不到php文件所在位置，一种解决方法是用root指令设置完整的根路径，保证`$document_root`值是对的。如果不设置root，默认会指向nginx程序所在的html目录，再以这个为根，自然就找不到php文件。\n\n像`REQUEST_URI`这种值，其实都是由Web服务器来设置的，如果不在RFC规范，就完全看Web服务器的实现了，因此会有些框架做些兼容处理。\n\n!! 小结与比较\n\n比较两种Web服务器的加载后进程列表，选择apache启动方式，进程管理器只能看到数个httpd进程，而选择nginx的话，除了nginx还能看到数个php-cgi程序。\n原因就是apache的FastCGI方式是以自身程序模块在运行，在httpd进程中执行php程序，因此进程管理器看不到php的名字。而nginx更有代理的味道，把请求数据向php-cgi监听的端口送去后，就和nginx无关了，因此php-cgi是以独立进程方式存在。\n\n这方面还遇到过一个奇怪的问题，本地调试网页用httpd正常打开，用nginx却总是超时。nginx下php-cgi默认分配的是9000端口，于是用netstat -ano查了到底哪个进程占用了9000端口，果然这个端口被其它程序给占住了，但是phpstudy并不会报异常，也就表现在nginx超时，如果用openresty方式运行就不会有这个问题，因为openresty也是类似httpd方式，直接在nginx内执行业务逻辑。\n\n","modified":"20160611121530000","tags":"web"},
{"created":"20160328121530000","title":"PNG格式的启发","text":"\n都说PNG格式是二进制格式中的优秀范例，文档也写得非常好。这周断断续续看了RFC2083，常有拍案之处。\n\nPNG的总体格式是8字节的格式头和一系列的chunk构成。\n\n先说8字节头，8字节分别是137 80 78 71 13 10 26 10。第一字节特意用了一个非ASCII字符，防止编辑器将PNG文件误认为是文本文件，同时可以检测程序是否过滤了最高位(似乎说的是邮件处理程序？)。Lua编译出的二进制文件也用了类似的思路，不过那里用还是ASCII的不可打印字符027。\n\n头部之后就是一连串的Chunk。Chunk也有个固定格式，4字节的长度+4字节的类型+数据+CRC32。为什么把长度放在类型前面？因为CRC是流式计算的，也许一开始并不知道最终的长度，所以如果把类型和长度互换，可能会造成CRC的计算困难。而且因为最开始已经有文件头，先放长度也不会造成识别的困难。再说一个小细节，4字长度文档特意标注是一个无符号整数，但范围是2^31-1，即最高位一定是0，原因是考虑到部分编程语言无法表示4字节的无符号整数(至少Java就是这样)。另一个我在工作中遇到有点类似的情况是，可能会有代码一开始错误地按int来实现，当发生对接错误的时候，才意识到要改代码，这时只要限定范围即可，算是保留了一点裕量。\n\n类型部分很有趣，PNG的Chunk类型有两种。一种是大写字母开头，称为Critical，比如IHDR、IEND，再一种是小写字母开头，如sPHY。如果增加了新的Critical类型，客户端无法识别，可以提示用户升级客户端，而不重要的Chunk又可以跳过。当然Critical不是必须要带，只是携带的时候，就相当于需要服务端和客户端做一个版本同步保证。这种策略不需要版本号，也可以达到C/S各自地升级兼容。\n\nPNG的设计目标是用于文件的保存和传输，但其中Chunk的设计策略对交互式的协议也是有借鉴作用的。","modified":"20160328121530000","tags":"protocol"},
{"created":"20190913121530000","title":"PostgreSQL备忘","text":"\n其前身是由Stonebraker创造的ingres（1974）和postgres（1986），Postgres和ingres在90年代之前都不支持SQL，而是用的自己的QUEL语言。他的几个学生在1996年改写了postgres来支持SQL，和他没有直接关系。Stonebraker因为前两个系统对于数据库的贡献得了图灵奖。\n\nPostgreSQL功能完备但速度稍慢，国内一直不流行。1997年发布6.0版，之后大约每5年更新大版本，到2017年的版本10开始每年更新一次大版本。\n\n!! 启动和命令工具\n\n后台命令是`pg_ctl`，是postgre或postmaster(采用多进程模型，主进程叫master，不过现在合一后，都叫postgre了)的封装，postgre用-C并指定选项名可以查看配置。启动停止状态监控都是它。创建数据库用环境变量指定PGDATA或者参数指定，比如~/pgdata且必须是空目录，接着用`pg_ctl init`或initdb初始化这个目录。会创建若干子目录和默认配置文件，模板和结构定义，有39M（版本不同稍有差异），默认创建名为postgres的数据库。\n\n使用`pg_ctl start`会启动监听TCP和Unix Domain两种方式，如果不想用PGDATA环境变量，就用-D指定数据库位置。默认只能在同一台主机上用psql访问 ，要想跨主机访问，要修改postgresql.conf的listen\\_address改为`'*'`和pg\\_hba.conf的IPv4地址改为'0.0.0.0/0'。初看这种启动时指定目录的方式有点不习惯，但细想可以在一台机器上启动多个完全不干扰的库，非常灵活。\n\n客户端连接用 psql -d postgres，如果不指定数据库，会使用登陆用户名作数据库名。\n\n!! 概念和特色\n\n库-模式(schema)-对象3级结构组织。对象包括表、视图、序列、函数等。由于连接数据库时，会有默认名为public的schema，不注意的话会误以为库下面是表。\n\n特有的表空间TABLESPACE概念。默认有`pg_default`和`pg_global`两个表空间。分别保存在$PGDATA目录下的base和global目录，base占了初始空间的一半还多。表空间用于描述表在物理介质的存储方案，创建数据库时可以指定属于哪个表空间。\n\n安装完成会有3个初始库，template1, postgres, template0，其中template1是最源头的模板，另两个是从它复制得到的。因为template1允许用户修改，所以增加只读的template0表示纯净的数据库。这3个库分别对应PGDATA/base/下的3个目录，每次新增数据库，如果用默认表空间，就会在base目录下新增一个目录，目录名是oid数字，通过`select datname, oid from pg_database`能查出映射关系。\n\n创建一个空的数据库，目录内会初始创建数百个数字命名的文件，可以用`select relname, relfilenode from pg_class`查看每个文件的表名。有些数字文件会以fsm或vm结尾，分别对应free space map和visibility map。同样这个语句，如果加上`where relfilenode=0`会展示全局的表名。\n\n命令行叫createuser，但psql中是role，似乎是等价的。修改用户密码`ALTER USER postgres WITH PASSWORD 'postgres';`","modified":"20190913121530000","tags":"data"},
{"created":"20170601121530000","title":"PPT到底做什么","text":"\n不是动画也不是美学，是观点以合理的逻辑顺便呈现。\n\n提到Jobs在第一代iPhone发布会上，三种功能因为是并列关系，不能以开门的方式展现。也许观众不会注意，但从组织观点角度看，平铺的方式确实是对的。\n\n幻灯片根据使用场景不同，制作方式的差别是非常大的。如果是用于看的幻灯，内容可以多，更像写一个Word，只是在呈现上每个版面空间有限放的内容更少。但如果是给人讲的幻灯，则重点在于控制观众的注意力。控制注意力就是把控焦点，所以内容呈现上决不可出现大量的内容，即使有，也要用渐隐方式每次只呈现一点，这样才能始终引导焦点。\n\n定位mp4播放失败，先看http抓包以为是回复的MIME类型错误application/http，但改成octet-stream和video/mp4均没用。后者甚至是RFC规范。\n\n看mp4包头似乎也没有大问题，但拿到完整文件才发现中间少了一截，50M的文件在9M处少了260K就一点都放不了，这和MP4非流式的文件特性有关。可能是wireshark本身的问题，数据是完整的，但就会存在数据丢失的情况，怎么证明抓TCP包会丢，seq和ack明显不连续，从IP包序号看源端发出了但收端没有捕获。一般只能重抓。","modified":"20170601121530000","tags":"design"},
{"created":"20170202121530000","title":"procfs记录","text":"\n!! 历史\n\nprocfs诞生于1984年的Unix第8版，愿望是对ptrace的一种改良。起初是每个进程对应一个文件，经过Plan9改造成伪文件系统，且成了Linux的代码来源，所以在Linux用得非常多。Linux多年的改进，已经不限于进程的内容，还加入了CPU、内存、中断等各种信息。\n\nFreeBSD用的是sysctl，并对procfs说`Gone but not forgotten`。原因大概是sysctl最初就是4.4BSD开发出来的，而BSD社区的人更倾向用sysctl，加之procfs的代码在BSD社区中没什么人维护，所以就逐渐转移了。Linux的/proc/sys/也具备类似sysctl的功能，命名风格很像但不相同。类似的，solaris的kstat的实现是用ioctl去操作/dev/kstat。sysctl和solaris都是专属命令工具。相应的，/proc伪文件系统，可以直线用各种命令行工具操作。\n\n因为procfs下被塞进了太多东西，所以Linux的2.5版开发了/sys/虚拟文件系统。\nsysfs最初是设计用于提供设备驱动的统计数据，后来不断扩展，能察看和操作内核对象。在2.6内核出现了configfs用于创建和销毁内核对象，两者互为补充。不过在configfs并不是都有的。\n\n造成两个系统差异的根本是内核对sysctl支持程度不同。BSD内核直接开放sysctl，所以整个社区也倾向用它，而Linux虽然也有sysctl，但却是基于procfs的一个wrap，性能上会差很多。\n\n!! 解读\n\n* smaps: 程序自身以及加载so的段内存映射。第1个似乎是程序自身程序\n\n* task目录: 只有多线程程序，进入这个目录才会发现更多的TID对应的具体信息\n","modified":"20170202121530000","tags":"os"},
{"created":"20221019121530000","title":"promise和future的区别","text":"\npromise/future是指差不多的东西，只是不同语言的叫法不同。少数语言可能同时有promise/future并有差异，如果同时有两者，一般future指获取值的能力（只读视图），可翻译为「期值」（future作为金融术语即为「期货」），promise指设置值的能力，可翻译为「约定」。这些术语与cancel没有关系。（这个误解可能来自于早期的DOM Future草案有cancel而后来改名为Promise时同时删去了cancel？）\n\n为什么promise不支持cancel？从用例需求的角度，当然是有cancel和progress的需求的，所以原本DOM future的草案里也有这些能力，但JS标准化要考虑的问题比较多。绝大多数时候只会推进大家有一致意见的东西。像cancel的能力后来DOM是改用了AbortSignal机制，估计将来JS也是会标准化的（虽然已经延宕了很久，目前也还不知道到底什么时候会推进）。而progress的能力则由DOM ProgressEvent来完成了。\n\n早期JS社区的某些promise库则使用promise/deferred来表示future/promise。JS后来流行并标准化的promise的设计是两种能力的合体，promise本身的接口（then）提供获取值的能力，而promise构造器工厂中的resolve/reject函数提供设置值的能力，不再有单独的deferred接口。\n\n对于合体型的promise/future概念，我提出了「期约」作为译名（一个原因是「期约」作为「期/约」的合体可对应future/promise的合体，这样就不必在不同语言中因为采用future还是promise作为术语的不同而译名也不同），为《 JavaScript高级程序设计（第4版）》中译本所采用。\n\n在 Promise 提出之前，除了规范里存在事件循环，普通前端是基本不讨论事件循环这个概念的，那就更不用说 microtask 了。\n\n的确是 Promise 让这两个知识点成为焦点，为了解释那些代码执行顺序问题。但 microtask 是要比 Promise 的提出更早一些，最早它是为了定义 MutationObserver 的行为而产生的，只存在于 HTML 和 DOM 规范里。\n\n在 ES6 里想要给 JS 加上异步的时候，最早也不是为了 Promise，而是 Object.observe()， V8 为实现 Object.observe 加上了类似 microtask queue 的机制，当时 ES6 没有打算加 Promise，而是 DOM 规范想要加一个类似功能的名为 Future 的东西，后来决定直接加在 JS 里，为了 nodejs 里也能用，改名 Promise，DOM 里就不搞了。","modified":"20221019121530000","tags":"lang"},
{"created":"20200122121530000","title":"putty的配置","text":"\nputty是个免费且方便的终端工具，其它像xshell等在按下Alt时会触发菜单栏，导致使用emacs时不好用，但是putty默认的配置不如xshell方便，列举如下\n\n首先在Connection菜单开启保活，keepalives设置为300，否则长期不用会断开远程连接。\n\n默认情况下字体很少，先勾上Appearance的Allow selection of variable-pitch fonts，就能选择Lucida Console，此后关掉这个选项还是可用，怀疑是个bug。\n\n配色，终端定义了文本、背景和8种ANSI颜色，每一种又可以叠加Bold属性。规范只定义了有这些选择，具体如何展示还取决于终端软件的设定甚至和显示器效果也有关系。putty默认文字颜色较暗且文件夹的蓝色和背景接近，很难看清，建设改为以下配色\n\n以下3个数字分别表示RGB\n\n* Default Foregroud: 230/230/230  网上很多方案推荐全用255，这样会和Bold Foregroud一样，不能区分两种信息，最好稍暗一点\n* Blue: 30/140/240\n* Blue Bold: 85/190/255\n* Red: 200/0/0\n* Magenta: 200/0/200\n\n还有一些ANSI控制码，如：nA (光标上移n行 )、nB(光标下移n行 )、nC(光标右移n行 )、nD (光标左移n行 )、2J(清屏)、K(清除从光标到行尾的内容)、s(保存光标位置)、u(恢复光标位置)、?25l(隐藏光标)、?25l(显示光标)。     其中 ，'\\033[0m'用于恢复默认的终端输出属性，否则会影响后续的输出。\n\n基于常用参数，可定义如下单一控制宏，用于printf系列语句：\n```\n#define NONE                 \"\\e[0m\"\n#define BLACK                \"\\e[0;30m\"\n#define L_BLACK              \"\\e[1;30m\"\n#define RED                  \"\\e[0;31m\"\n#define L_RED                \"\\e[1;31m\"\n#define GREEN                \"\\e[0;32m\"\n#define L_GREEN              \"\\e[1;32m\"\n#define BROWN                \"\\e[0;33m\"\n#define YELLOW               \"\\e[1;33m\"\n#define BLUE                 \"\\e[0;34m\"\n#define L_BLUE               \"\\e[1;34m\"\n#define PURPLE               \"\\e[0;35m\"\n#define L_PURPLE             \"\\e[1;35m\"\n#define CYAN                 \"\\e[0;36m\"\n#define L_CYAN               \"\\e[1;36m\"\n#define GRAY                 \"\\e[0;37m\"\n#define WHITE                \"\\e[1;37m\"\n\n#define BOLD                 \"\\e[1m\"\n#define UNDERLINE            \"\\e[4m\"\n#define BLINK                \"\\e[5m\"\n#define REVERSE              \"\\e[7m\"\n#define HIDE                 \"\\e[8m\"\n#define CLEAR                \"\\e[2J\"\n#define CLRLINE              \"\\r\\e[K\" //or \"\\e[1K\\r\"\n```","modified":"20200122121530000","tags":"tool"},
{"created":"20210721121530000","title":"PySpark分析","text":"\n!! 执行过程\n\n常用的有local和yarn两种模式，写代码或调错阶段，无特殊情况用local，速度快很多。\n\npyspark和scala的spark不同在于，某些情况下数据会从jvm回传给py，这个回传的过程是怎么样的？首先，Spark会先把所有py文件放到此次任务driver端所在的节点，比如我的环境放在 /yarn/nodemanager/usercache/xxx/appcache/application_xx/container_xx_01/main.py 目录，启动py的命令是`path/bin/python main.py --arg=xx`。同时spark会在driver放一个pyspark.zip，解决Py与spark集群通信的问题。driver端任务运行一段时间后，如果发现计算需要把数据传递给executor上的python，就会启动`path/bin/python -m pyspark.daemon`，没有额外的参数。pyspark.daemon会fork一个进程，然后在子进程里执行pyspark.worker.main函数，数据读写的源头也改为来自socket。实际代码中先会做dup，把socket复制出来提高效率。driver和executor之间通过环境变量和socket传递数据和代码（似乎是pickle序列化），此时的executor会在container_xx_02或03目录内执行。\n\n进入py代码后，先构建SparkContext对象，构建过程会查找并执行`spark-submit pyspark-shell`命令，构建一个java的gateway，再通过Py4J包，以类似RPC的方式把py代码通过Gateway发送到jvm，进行spark操作。如果计算过程中需要python的udf，则数据必须发送到work节点，过程是由spark启动python的worker.py进程，并以环境变量的方式把端口告知worker，worker会用socket去连接这个port，并做一系列判断，比如driver和worker的python版本必须一致，计算结束后再用socket发送回spark。理论上只要数据不回传给py，开销只是方法的传递，性能和scala的实现是一样的，如果有数据回传，速度会降低一倍以上。\n\n!! PySpark内容\n\n!!! 包层次\n\n顶层目录pyspark包含SparkConf、SparkContext、RDD等spark的基础概念，包含sql、streaming、ml、mllib等多个子模块。\n\n!!! 流程和关键概念\n\n如果是写类SQL功能，流程是套路化的\n\n# 获取SparkConf，设置master和appName。我只用过yarn模式\n# 把Conf作为参数传给SparkContext。注意，必须构造context，否则无法和spark通信。Conf可以没有，但考虑要设置的参数很多，用Conf方便，另外还有序列化类参数可传入，默认用pickle序列化py和jvm之间的数据\n# 通过Context来获取SparkSession。这个Session是属于pyspark.sql的类，整合了SQLContext和HiveContext等多个SQL会用到的功能\n\n拿到SparkSession后，读取文件得到的数据呈现形式就是DataFrame类，这个类具备很多SQL语义的API（因为Session就是sql包下的一个类）。DataFrame可以链式操作，即操作后返回的值大部分情况下仍是DataFrame，如果做了groupBy操作，得到的是GroupedData类型。\n\n!!! PySpark命令\n\n执行这个命令，会自动加载shell.py脚本并初始化sc(pyspark.context), spark(pyspark.sql.session，对应原生SparkSession类), sql(spark.sql的别名), sqlCtx/sqlContext(pyspark.sql.context.SQLContext)共4个全局变量。","modified":"20210721121530000","tags":"data"},
{"created":"20200606121530000","title":"Python的包机制","text":"\n!! 包的封装机制\n\npython社区前后有easy_install的egg和pip的wheel两种包封装机制，另有anaconda给出的conda方案。python由于版本不兼容原因，最好配合venv/virtualenv指定版本，否则依赖库会冲突。wheel只是发行格式，安装完成就变回普通的文件夹和文件，而egg不仅是发行格式，也是运行时可以直接加载的格式。通常都建议wheel，毕竟有PEP背书，特殊场合比如不想被直接看到代码，打包到一个文件更简洁。\n\n安装PyHive包，以tar包源码形式发布，执行setup.py之后在这台机器上可用，但去site-package目录下看到的却只有一个egg包，和pip方式安装得到的几个目录方式不同，直接复制这个egg包到其它目录后，会提示无法找到PyHive。直到用easy_install安装这个egg包，才明白要在site-package下的easy-install.pth文件里添加一行关于PyHive的版本说明，才能找到。大概原因是import机制会忽略带有连字符的包，而egg包一定有连字符，需要需要.pth文件做个牵引。\n\n!! 使用C/Cython写扩展并用setup.py安装\n\n官方早期提供的distutil包可以制作无依赖的安装包，为支持更复杂的场景，产生了第三方的setuptools，包制作仍然基于distutil，扩展了依赖包管理。但是distutil的文件比较混乱，而且setuptools都会完整地内嵌一份，到了3.10版本官方正式确定废弃distutil，全面改用setuptools。easy_install现在也是setuptools的一个子模块。\n\n最基本的扩展需要setup.py和xx.c两个文件，c文件要依次注册module和method集，以及具体的method wrap实现，最终通过注册函数在加载时导入python空间。这种方式显然非常复杂，可以换用cython语法写pyx，通过cythonize转化为C语言，一样能开发扩展且极大简化开发过程。注册示例\n\n```\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\nsetup(ext_modules=cythonize(\"xxx.pyx\", language_level=3))\n```\n\n执行setup.py有多种子命令，bdist编译egg包，如果本地装了wheel，可以用python setup.py bdist_wheel指令打成wheel包。egg包放到pypi的仓库中，无法用pip安装，会提示no match version之类错误，但包名是包含了版本的，原因不明。\n\n存放代码的目录可以随意命名，distutils的setup函数有非常多参数，有一些概念要注意区分\n\n* name='abc' 包的名字，只是一个宣传用的名字，对程序运行没有特别的作用，也不要求和import的包名一致。安装之后，包描述目录的METADATA文件会显示这个name\n* packages=[] 包安装到site-package后的目录名，可以和包名不同，也可以有多个。一般一个包安装一个目录，但像cython就会装两个目录(cython和pyximport)\n* package_dir={} 安装到site-package的目录名和源码目录的映射关系\n* ext_modules = [ Extension('x', sources=['x.c'])] C语言写成的扩展模块\n\n上面packages两条，我觉得都是非常糟糕的设计，灵活到让初学者非常迷惑，比如import的包名，在pip freeze却很可能找不到对应的包名，甚至描述目录名都没有与之对应，直到找到了目录的MEATDATA文件才找到包名。但也可能是import用的名字会有很多人想要，于是允许不同的包名安装时用不同的名字（相当于pip注册时是不同的），但安装后用同一个目录名。如果真的产生冲突，那就由用户自己决定。\n\n有些包用pip安装后会触发C编译，如果头文件不在标准路径下会失败，用`pip install --global-option=build_ext --global-option=\"-I/your/py/head/\"`方式添加头文件路径可以正常编译。\n\n!! 自定义安装位置\n\n标准版本启动时会执行`import site`，而embed版本则没有此行为。标准版通过-S选项关闭此特性，embed版本则通过修改.pth文件来打开此特性。如果有-S选项，会反映在`sys.flags.no_site=1`。\n\nsite.py一旦被导入，会在builtins中增加help, copyright, credits, license变量。除此外可以额外添加两个加载包的路径，`USER_SITE`类似全局的位置，而`USER_BASE`则默认指向当前用户的.local目录。第三方可以仅给某些用户安装，因此`USER_BASE`的价值就体现出来了。但要启用这个机制还有个前提，getuid和geteuid，getgid和getegid的返回必须相同，否则会认为是sudo行为，不予加载。\n\n!! 控制符号的导出\n\n`__all__`变量只对import \\*语法有作用，如果手动地导出一个确实存在的变量，`__all__`是不会阻拦的。从字面含义也好理解，all对应的是\\*，当然不影响手动导出符号，不过也可见这套机制的简陋。同样py文件中的函数也是这个道理，所有以_开头的函数，用import \\*都是看不到的，但是如果知道名字，仍然可以手动调用，所谓防君子不防小人是也。\n\n!! Windows环境的包特性\n\nPython标准包有近百个目录和文件，在分布运行时非常不便，尽管可以把第三方包做成zip，但标准包却不行。因此官方针对Windows提供了embeddable方式的二进制包，把标准包也做成了zip包，而python程序在编译时加了特殊配置，直接加载标准zip包。\n\n包的加载路径，如果存在site-packages目录，它会被加入sys.path；而如果根本没有这个目录，sys.path就不会去搜索这个目录。有些包会额外产生一个命令行程序，典型的比如pip。pip在更新自己时需要替换pip.exe，但由于Windows的机制不允许替换自己，现象是pip目录会被改名为\\~ip，再次执行会报找不到pip。解决办法就是把\\~ip改回pip就可以了，因此Windows上似乎只能删了重装pip。\n\n!! venv机制\n\n官方提供的venv包会把一个目录做成相对独立的环境，具体过程不复杂\n\n# 在该目录下建立bin/lib目录和pyvenv.cfg文件\n# 将venv目录的activate文件复制到bin\n# 使用标准库ensurepip安装一套独立pip/setuptools到bin和lib\n\nvenv初始化后，source bin/activate，会把当前目录放到PATH的开头。于是当前会话下的pip操作就会把要安装的新包放到这个独立目录（退出shell或执行deactive则仍旧用全局pip）。python复用全局命令，观察此时的sys.path，会发现site-package已经换成venv指定的目录了（其它标准目录不变）。\n\nvenv有个个人认为很重要但默认没有开启的选项--system-site-packages，但其实也可以编辑pyvenv.cfg将include-system-site-packages = false改为true就可以了。解析pyvenv.cfg的逻辑是写死在site.py中，只要包含了基础包即可，不依赖pip。引用原始py的包后，仍可以升级且不会破坏原始的包版本。升级后，虚拟环境中是新版本的包，而原始环境仍保留不变，两边各留一套互不影响。\n\n还有--without-pip选项，不过除了构建虚拟环境快以外，我想不出有什么使用场景。在venv中使用pip和原生使用的配置文件是一样的，意味着用同样的代理，这也好理解，毕竟venv的机制是对PATH做文章，而pip读配置是用户的HOME目录，两者没有交集。\n\n!! import过程\n\n结合q这个包和一些试验，看整个import xxx过程发生了什么。\n\n# 先判断sys.modules['xxx']是否存在，有值直接结束，没值则查找文件。注意：*不是判断当前上下文是否有xxx变量*。\n# 找到xxx.py并读取，在开始读取前，sys.modules['xxx']已经被初始化，并且具有了`__name__`、`__doc__`等内置变量\n# 随着对xxx.py的解析，xxx模块定义的类、函数也会被添加到sys.modules['xxx']\n# 结束对xxx.py解析，在当前上下文，新增xxx变量，并让xxx指向sys.modules['xxx']。如果在import xxx之前已经有xxx变量，会覆盖xxx。\n\nq这个包就在第3步结束前，覆写了sys.modules['q']变量，实现了import q后，q就能使用的魔术技法，同时也隐藏了q的实现类，非常巧妙。\n","modified":"20200606121530000","tags":"lang"},
{"created":"20220115121530000","title":"Python的数据科学相关库介绍","text":"\nPython在数据科学领域能取得如此成功，离不开支撑它的众多库，但很多人即使用了这些库很久也不清楚这些库的历史和渊源。\n\n最早也是最基础的，应该是NumPy了，其前身发起于1995年的Numeric库（当时Python才面世6年），创始人Guido van Rossum也在其中扩充了Python语法（尤其是数组索引方式）。在演进的过程中，出现和竞品Numarray，Numeric在小规模上速度较快，而Numarray适合大量的数据。显然这种情况并不是大家想看到的，于是Travis Oliphant对这两个库做了统一，并最终在2006年发布了NumPy的1.0版本并持续演化至今。\n\nNumPy主要的功能是向量和矩阵运算，然而学术界的需求显然不止于此，于是2001年，Travis Oliphant, Eric Jones, Pearu Peterson等人将一些基于Numeric库的科学计算的程序，以SciPy的名字作为一个整体发布。随后不久IPython和Matplotlib也陆续发布，整个数据分析的生态就此奠定。2014年从IPython分出来的Jupyter也同样是数据分析的利器。\n\n大概是觉得NumPy还不够快，Oliphant在2012年启动Numba项目做jit加速。顺便说一句，Oliphant还是Anaconda的联合创始人，Numba也是Anaconda的资助项目。\n\n如果说NumPy/SciPy这一支是源于学术界的科学计算，另一个同样有名的库Pandas则源起自Wes McKinney于2008年在AQR资本管理公司做量化分析的工作需求，因此不仅具有强大数据提取、分析功能，还有众多的外部数据接入功能。\n\n为了追求性能，这些库都用了C或Cython实现，NumPy这一支由于和科学计算更强相关，还依赖BLAS/LAPACK这样的线性代数专用库。通常编译的NumPy会使用openblas，而Anaconda会采用inte免费提供性能更好的libmkl库实现BLAS接口（但不开源）。\n\n机器学习是科学计算和量化分析之外，另一个数据科学的重镇，David Cournapeau在2007年启动的scikits.learn项目，从名字就能看出是SciPy Toolkit，这个系列最有名的两个包是scikit-learn和scikit-image。顺带说一句，scikit-learn在Python语言中，是以import sklearn方式导入，导入名和包名不完全一样。\n\n前面提到这些库的底层实现用了C或Cython，这个Cython和平时用的CPython一字之差，是一个有着类似Python语法，但又有所扩充的语言。Cython语言的理念源于2002年的Pyrex（一个更好地编写Python扩展模块的语言），在2007年的时候，SageMath库的开发者不满于Pyrex的一些限制，提交了补丁给Pyrex的作者Greg Ewing，但被Ewing拒绝。于是Sage的开发者们fork出了SageX和Sage一起发布，但不久后他们发现单独的SageX很受欢迎，于是就把SageX剥离出来，并合并了lxml库，重新命名为Cython发展至今，而Pyrex在2010年发布了0.9.9后不再有新版本。使用Cython语法写的代码，最终会被C语言编译器生成二进制代码，在优化了性能的同时，还提供了相较C扩展Python模块更简单的写法。","modified":"20220115121530000","tags":"lang"},
{"created":"20200925121530000","title":"Python进阶学习点滴","text":"\n!! 迭代与惰性\n\niterator概念体现在很多地方，甚至str都可以迭代，list('abc')会返回['a','b','c']。具备迭代的函数又分eager和lazy两种，list是eager行为，enumerate/map则是lazy行为，返回一个可迭代对象，对这个对象用for循环或tuple/list进行求值。\n\nlazy对象一旦被求值，这个对象就成了空壳，因为lazy对象从语义上就不把值放在内存，可以理解为外部源的一个门户或代理，当真正的外部源被求值完毕，则lazy代理自然没有了内容来源。\n\n内建3大基础类型tuple/list/dict都具备对lazy迭代对象求值的能力，dict因为语义原因，每次迭代必须有两个值。\n\n求值是严格模式，要想实现惰性，由于缺少宏和编译期展开能力，能想到的办法只有foo(lambda: x)，然后在函数体内展开。\n\n!! 多行lambda\n\n语法上要求返回一个expression，不能出现冒号和赋值（因为赋值是statement，可以用3.8后的:=assignment expression）。利用tuple和切片索引来打包多个独立行为，利用if的一行式来做简单的条件\n\n```\ndef main(n):\n    return lambda x: (\n    print(x),\n    x+1 if x > 0 else x-1,\n    x + n)[1:]\n```\n\n!! 多线程\n\n拜臭名昭著的GIL所赐，多线程只在IO密集场景下有一战之力。即便只能用到一个核，锁还是必须的，但这个锁和OS的锁不同，是语言级别的锁，不会触发futex调研。有人解释说这种锁的获取和释放，会引起GIL的调度，暂时不能确定。另外py3新增了asyncio后，多线程的使用场景似乎更少了。\n\n!! 多进程\n\n多进程库有两种构造进程的方式，Process（构造一个）和Pool（构造多个功能相同的进程）。从实际效果来看，每生成1个进程，实际会生成2个线程。以生产消费模型，结合队列来举例子。\n\n先说队列Queue，生产者用put方法，消费者用get方法，但是这里有个隐秘且反直觉的地方，调用put会将队列的计数加1，但get并不会减1，需要在get之后再调用task_done才行，背后的原因是get允许异步获取，所以必须消费者确认得到消息后，才能将队列次数减1。队列的次数可以通过empty方法得到。真实代码中，生产者会用队列的join方法，join会阻塞直到队列为空才执行下去。\n\n就产生了这样一种方式，消费者用with Pool结构，在这个结构内，用Process来创建生产者，生产者全部start()后，会挨个join()，直到每个生产者执行中，队列的join通过后，才会结束。*注意，这里有两个join，分别作用在队列和进程上，而进程的join又被队列的join所阻塞，最终等待消费者消费完所有消息，这就构成了完整的闭环*。当生成者结束后，with语句块的生命周期结束，调用Pool的`__exit__`方法，它又触发了Pool的terminate()，将所有消费进程强行停止，于是所有进程就都正常回收了。\n\n一开始我看这段还很疑惑，为什么while Tue循环里只有队列的get，看不到判断和退出，其它是用了with块的方式强行中止了进程，自然就不用判断队列。\n\nJoinableQueue objects should only be shared between processes through inheritance\n\nPool创建的进程，和Process没有继承关系。跟踪系统调用发现，都是用clone函数，无非用的标志位不同\n\n* CLONE_VM: VM shared between processes，内存共享，大约等于线程\n* CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID:  Store child thread ID in child memory.Erase child thread ID in child memory space when child exits.\n* CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID:\n\n!! 进程池\n\n使用进程池Pool启动多进程建议用`apply_async`，这个方法默认不会阻塞，想要等待必须连用Pool的close和join方法，网上文章几乎不提为什么。看了源码才知道，Pool有4种状态，INIT，RUN，CLOSE，TERMINATE。构造进程池对象时，内部会经由INIT状态切到RUN状态。CLOSE状态是为了配合join使用，如果不切换到CLOSE状态，join动作会报错。join内部调用到的方法有wait，只是觉得都用join还是有些混淆。\n\n!! 多进程的队列\n\n底层使用操作系统的pipe作为传输，但为了实现任意py对象的传输，在数据写队列前，会先用pickle序列化，读出的一方会先确认pipe内的消息长度，读出后再反序列化。复杂队列的实现，发送者每次发一条消息，会创建一个线程，由这个新的线程向pipe写数据。\n\n!! defaultdict\n\n出人意料的是这个容器是builtin的，实现在`_collection`包中，不是一个独立的磁盘文件，而是和C语言实现打包在一起，可能对字典的操作需要极高的性能，因此无法用py实现吧。\n\n!! namedtuple\n\n是一个函数返回一个用type方法动态构建的类\n\n!! pickle序列化\n\n首字节固定0x80，然后跟1字节的版本号，截止3.8共有1-5的版本。\n\n每遇到新的复杂结构（tuple/list/dict），都会写入一个新的标记符，`EMPTY_XX`，然后跟着具体的值。\n\n结构内的字符串，以类型+长度+值的方式保存（典型的TLV格式）。\n\n字典内容都结束后，以一个's'（SETITEM动作）把kv的pair对加入字典。\n\n最后以'.'结尾这个pickle。\n\n当然过程中会用MEMOIZE技术复用已保存的字符串，达到节约空间的效果。整个pickle不仅仅记录了值，更记录了从一片空白到完成所有对象的整个操作步骤，在构建过程中逐步还原出对象。\n\n!! 魔术方法\n\n`__getitem__`作用于方括号下标，而`__getattr__`作用于对象的点式取值。还有要注意的是，这两个方法虽然是class上定义，但却只对实例后的对象生效。\n\n!! 类型标注\n\n初看`Union[int, str]`语法会觉得很困惑，因为下标引用只能是1个值，但是换成Union(int, str)又会提示不是callable，说明只能是`__getitem__`方法，再自己实现后才明白原来[int, str]会被转换成[(int, str)]形式。\n\nOptional基于Union扩展，但做的时候偷了个懒只能传递单参数，因此实际用的时候往往会写成`Optional[Union[]]`形式。\n\n!! 源码初读\n\n几个关键目录的目标\n\n* Object和Python: 定义对象的内存布局，核心的so要实现的编译及导入功能\n* Lib: py实现的标准库\n* Modules: py库会引入c实现的so(lib-dynload目录)，都在这里实现\n* Parser和Grammar: 词法语法解析","modified":"20200925121530000","tags":"lang"},
{"created":"20170323121530000","title":"Python自学手册","text":"\n整个执行包是目录不敏感的，比如编译时指定安装目录是/usr/py3/目录，安装后整体移动到/opt/py3/目录后，依然能正常运行。熟用dir/help函数帮助，不过help依赖pydoc，如果是精简环境会出异常。\n\n常用的sys和os，级别并不一样，sys是built-in模块，os只是个普通的py脚本文件。比如sys.path和os.path就很不一样：sys.path是普通数组，而os.path是个module，主要提供一系列操作函数。\n\n!! 类型\n\n从大的分类来说，有两种分类，类型（Type）和实例（Non-Type）。类型中有两个特殊的存在，type和object。所有的内置类型如tuple、list都继承自object（即`list.__bases__`是(object,)），同时它们的type就是type（即`list.__class__`是type）。\n\n所有的值，不管是简单的数字、字符串、None或复杂的容器类型，都有所属的class。不同的class具备的特性不同，比如sequence属性就是tuple/list/str还有range类型特有的(range不仅是一个函数，其生成对象的类型就是range，可以迭代)。\n\n!! 类和继承体系\n\n从py3开始，声明一个新的class默认继承自object，前面提过除了object外，还有个特殊的type，因为class关键字其实是对type的封装，class A:声明形式等价于A=type(\"A\", (object,), dict=())，所有的类对象，都是type的派生（严格的说是type产生了metaclass，而由此再产生普通类）。\n\npy支持多继承，使用MRO解析方法调用顺序，这就对继承有了约束。比如B(A)，那么只能C(B, A)，不可以C(A, B)，因为后者无法满足MRO的要求。当super作用在多继承的子类时，也只会解析出最优先的惟一类，不会把所有父类都调用一遍。\n\n!! 迭代\n\n有两个容易混淆的概念，iterable和iterator。iterable只要支持`__iter__`，可以配合for使用，list、tuple等可迭代对象都是要迭代的。而iterator除了要支持`__iter__`外，还要支持`__next__`，但只能迭代一次，不能重复迭代，优势则是占用内存较少。最简单的构造iterator方式是通过iter()方法转换。\n\n!! 模块的查找（finder）与加载（loader）\n\n最小的代码单元称为module，主要有2种类型\n\n# pure python module: 纯用py写的单元，最简单的情况下，单个py文件就是一个module\n# extension module: 用C语言写的py扩展，so或dll文件\n\n多个module可以组成package，一般含有`__init__.py`的文件夹称为regular package，还有种namespace package。\n\n不管是module还是package，都可以用import xxx来导入，但深入去看还是有区别的。通过import导入的模块可以用del删除，但千万别把自带的给删了，那就再也找不回了。import语句本质是`__import__`函数的二次封装，还有一个importlib包，可以修改一些导入细节，实现特殊效果。\n\nimport动作的背后，分为find、load、bind三个阶段动作：find失败会执行load，有些文章会把finder和loader合起来称为importer。find过程可以加hook，通过`sys.meta_path`或`sys.path_hooks`变量来调整行为。bind则是把sys.modules中这次被导入的变量加到globals()或locals()对应的字典，这样代码中才能直接引用。这里有个非常triky的地方，比如import mod，找到mod.py（或者`mod/__init__.py`）并执行到结尾，import语句会往sys.modules写mod变量，再将modules['mod']也绑定到globals()。但是如果mod.py自己向sys.modules写mod，import语句就会直接将这个变量导入globals()，这样就能使import的模块不再是module类型，而是任意指定类型。反观lua，require必须显示赋值给某个变量，把加载和绑定分开，非常清晰，而python最终引入as显然也是认识到import存在的问题。\n\nimport可以导入包、模块、函数、变量，如果包和模块同名，会优先加载包。寻找的顺序：builtin包 --> sys.path（这里又按当前路径、py库目录、二进制库、site-package顺序查找）。加载前会先判断是否已经在sys.modules字典，已经加载过的变量不会再次加载，可以用importlib.reload来强制重新加载。import语句执行后，会绑定一个新的本地变量，变量名是left-most值。比如import a.b.c，执行后会隐式创建a变量，如果要重命名，就要用额外的as关键字，我觉得是不优雅的。sys空间下，共有4个和加载相关的变量\n\n# sys.path: 查找路径列表\n# sys.modules: 保存已加载模块的字典，启动后这里就会有很多预加载模块，但因为没有在全局命名空间bind到变量，不能直接引用，这时import只需要绑定变量即可，速度很快\n# sys.path_importer_cache: 类似sys.path，但内容更多\n# sys.meta_path: 查找器finder列表，一般用内置实现，也可以自定义（实现一个定义了`find_spec`类方法的类）\n\n导入变量额外说一句，据不完全观察，导入的变量是当前时刻的状态值，导入后，即使被导入模块的值定义发生改变，在引用方无法察觉到，这是件好事，本来也不应该以这种方式来共享一个全局变量。\n\n实际中一般会用from package import subpack/module方式，这个语法甚至可以从module加载函数，个人觉得有点过于灵活了。另外from import加载的时间，要慢于import整个加载。\n\n`__import__`的细节要复杂得多，因为from/import这套组合可以有多个参数，而`__import__`只有一个字符串，这就带来一个歧义，导入a.b时，究竟是返回a还是b？此时就要通过fromlist来区分，不带fromlist时，返回最左侧的a；如果fromlist是个tuple或list且全部是str值，返回最右侧的b，fromlist只要有str值即可，随便填什么都行。之所以做成这样，我猜测原来想利用fromlist来指定加载的子模块，后来发现多此一举，干脆就退化成指标加载最左或最右的标记位了。\n\nimport能导入3个层面的对象，造成这么复杂的原因，猜想可能是最初的import只能导入module，后来随着规模变大，又引入了package的概念，语法上增加了from，可能为了适用性，把from适用于module，导入函数。虽然简单，背后却不简洁。\n\n总结两者的差异如下\n\n* package: 有特有属性`__path__`，而且可以在`__init__.py`通过`__all__`列表控制`import *`的导出。无法通过getattr获取module\n* module: 只能整体内容导出，似乎不能控制。可以用getattr获取function或class\n\n!! 文件身份的识别\n\n前面说过一个py文件就是一个module，其自带很多内置属性，加载的方式不同，会导致这些内置属性的值发生变化。\n\n* `__all__` ，控制导出的符号列表，但又只适用于部分导出场合\n* `__file__`，在磁盘上的绝对路径，.py结尾\n* `__name__`，如果在命令行被调用，则被赋予`__main__`这个特殊名，如果是被import，是不带py的相对文件名（取决于顶级调用路径）。\n* `__package__`属性，如果这个文件平级没有`__init__.py`文件，那么`__package__`的值是None，否则就是这个文件所属文件夹的名字。\n* `__doc__`，文件开头的整体声明，不得不说对文档的重视程度还是不错的\n* `__spec__`和`__loader__`，模块在加载器的对象描述，不同类型模型的加载器各不相同\n\n展开说下`__loader__`，随着载入模块的不同，有3种\n\n# _frozen_importlib.BuiltinImporter 用在内嵌模块，比如sys\n# _frozen_importlib_external.SourceFileLoader 用在标准库的py文件，比如os\n# _frozen_importlib_external.ExtensionFileLoader 用在C写的so扩展库\n\n虽然语法中没有类似package或namespace关键字，实际上会把每个文件中创建的函数、变量限定在一个范围内，猜测是`__name__`这个命名空间。\n\n!! 对代码格式统一的努力\n\n# 缩进曾被作为卖点之一，但现在似乎更倾向用外置format工具来做。用了缩进后，不能做压缩，也多出了特有的类似pass的占位语句。\n# 函数形参可以加`*`或`**`，表示这个变量是tuple或dict。只看效果是个很简单的语法糖，但用这种形式强制规定了元组在前，字典在后的形式，并引出了posional argument和keyword argument两个概念。\n\n!! 装饰器\n\n@方式在函数外部引入的装饰器，会导致实体函数的元属性被装饰器拦截，如果想保留实体函数的元属性，要额外地import functools import wraps\n\n```\nfrom functools import wraps # 引入functools模块的wrap装饰器方法\n\ndef repeat_twice(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        func(*args, **kwargs)\n        func(*args, **kwargs)\n    return wrapper\n\n@repeat_twice\ndef foo():\n    print 'hello world'\n\nprint foo.__name__      # Out: foo\n```\n\n!! 搭建PyPI仓库\n\n仓库本质上是个http服务，目录包含若干压缩包和这些包的索引，PEP定义过仓库的规范，通常仓库的目录结构类似下面这样：\n\n```\n/pypi\n|__packages\n    |__/51/36/32/cc660efa43e482b97d4c2c2bcfdfde03b4f88c82f261d128cf/pandas-1.0.1-cp38-cp38-linux_aarch64.whl\n|__simple\n    |__pandas\n```\n\npackages下放whl或tar包，包名必须带版本号，否则无法进行语义化比较，不能放其它类型的文件；simple是索引目录（通过dir2pi /pypi命令，递归遍历目录内容后自动生成），pip查找或安装时，先在索引目录定位到包。包有wheel和源码两种形式，wheel是编译好的格式，安装比较快，如果只有源码包，则会下载到本地并编译成wheel（默认在~/.cache/pip/wheels/），在下次安装时能加速。","modified":"20170323121530000","tags":"lang"},
{"created":"20160813121530000","title":"RAII、智能指针和GC","text":"\nC++作为接近底层控制的语言，天然地要负责资源管理。资源并不单指内存，\n还包括了文件句柄。从这个角度看，动态语言所带的垃圾回收只管理内存，\n却不能正确地回收文件句柄。`C++`在长期发展的历程中，实践总结出了RAII这个特性，\n也是这门语言区别于其它语言的最大特征。\n\n在解释RAII之前，先来看`C++`的一个特性：栈上变量的自动析构。\n`C++`是打着A Class With C的名号发展起来的，类是最初区别于C的地方，\n通过定义类，然后使用类来创建/销毁对象就是最基本的动作。\n加之变量可以在栈上分配，一个在栈上分配的对象，在函数结束后由于内存已经被回收，\n必须要在内存回收前执行析构，所幸这个动作由编译器替我们做了。\n\n就是这么个看似很普通的特性，却在实践中发展成了资源管理的最佳方式。\n试想如果在函数执行过程中，会涉及很多资源(包括内存和句柄)。在执行过程中如果发生错误，\n需要结束函数并释放资源，如果每次都写if/else，并写上很多重复代码，代码一定很难看。\n这时就可以把这些需要的资源，封装成一个类，在开始执行前，通过构造对象的方式，\n在对象的构造函数中获取这些资源，接下来执行逻辑，一旦发生了错误，直接退出函数即可。\n因为编译器会自动执行对象的析构函数，只要我们写好析构函数，不管在函数的哪个地方出错，\n相当于编译器都会自动地替我们回收这些资源。\n\n这里的构造函数中获取资源，就是RAII：Resource Acquisition Is Initialization。\n两句话表述的方向不同，但强调的意思是一样的：把构造和获取资源等同起来。\n\n刚才给的例子使用栈上变量，那么堆上变量怎么办？办法就是把堆上变量封装成栈上变量。\n把new的操作结果，作为一个栈上对象的构造参数传递，\n从而在栈上对象析构时把new的结果delete。而承担了这种任务的对象，就是智能指针。\n随着使用场景的不同，智能指针又细化出了多种类型\n\n* 资源共享型：shared_ptr以及为了解决环形计数而引入的weak_ptr\n* 所有权控制型：auto_ptr、unique_ptr\n\n这些指针的实现方式和差异，各种文章介绍的很多，这里就不细说了。\n\n写这篇文章的缘由，是在公司内网看到有人发帖提问，通过一个构造函数的出参返回一个指针好不好？\n虽然这个问题相当的愚蠢，但我想也许正是因为`C++`的复杂和灵活，才会让这样的蠢问题出现。\n结合上面的介绍，指针往往代表了一个资源(否则要指针干嘛？)，如果把资源放出来，\n一定会带来资源的手动管理问题，显然也违背了RAII的最佳实现实践方针。\n\n!! RAII的感知和函数动态创建\n\nRAII无非就是让使用者在退出栈之前，得到一个感知的机会，本质还是汇编层面才能做，所以C语言在这里一点办法都没有。脚本语言的栈是在C层面控制的，因此可以记录和追踪生命周期，但在C语言自身，除非扩展语法，在函数退出前能注入一段行为，才能解决这个问题。\n\n延续也类似，在语言层面把运行的流程暴露出来，让人可以介入并控制。C语言的函数不仅不能嵌套定义，也不能在运行过程中定义。所有的函数都被编译到text段，整个生命周期永远存在，这使它比堆上数据就多了一份持久，但也少了运行期动态变化的能力。\n\n!! Lua的GC\n\n使用三色标记法，对象分为白灰黑三种颜色。白表示死对象，可以用白事来简单记忆。经过标记为灰，灰再到黑。剩下的白对象就被收集了。先把所有的对象放在白链上，然后扫描这条链，把能reach到的对象放在灰链，再遍历灰链，把所有对象都mark成黑后，在灰链为空时把白链的对象清空，从而达到垃圾收集的目的。\n\nLua对表的GC做了特别的优化。5.1的时代只要表具备weak属性，全放在g对象的weak链处理。到了5.2时代作了细化，weak链被拆成三条链，只有weak value的表记录在g对象的weak，weak key的表记录在g对象的ephemeron，key和value都是weak则记录在allweak。\n\n每次扫描时会用sweeplist遍历，最多遍历count次，如果是白对象，则释放它。","modified":"20160813121530000","tags":"lang"},
{"created":"20170816121530000","title":"RSA/DSA/EC三种算法记录","text":"\n从Openssl的命令行操作来一探这三种非对称加密的端倪。三者的操作命令并不对称，支持的列表如下\n\n* RSA：genrsa/rsa/rsautl\n* DSA：dsaparam/gendsa/dsa\n* EC：ecparam/ec\n\n!! RSA说明\n\n生成私钥的命令是`openssl genrsa -out xxx.pem 2048`生成2048的私钥，但文件并不是2048bit，因为RSA私钥包含的内容很多，要看私钥文件的具体内容，可以用`openssl rsa -noout text xxx.pem`显示，从内容可以看出，modulus和privateExponent是2048bit，publicExponent是0x10001，其它的prime1/prime2等都是指定位长的一半，即1024bit。同理如果genrsa指定的长度是1024，modulus和privateExponent是1024bit，prime1/prime2等都是512bit。modulus和publicExponent共同构成了公钥文件的内容。RSA的加密会用到padding算法，解密必须指定相同的padding才能成功，因此其使用上的复杂度要高于椭圆曲线。\n\n使用openssl rsautl系列命令可以加解密。公钥加密私钥解密用`-encrypt -decrypt`，私钥加密公钥解密则是`-sign -verify`这对命令，但是libressl版的openssl支持用私钥调用-encrypt，却无法解密，不知道算不算bug。\n\n进行加密时为防止同样的明文得到的密文一样，都会填充数据，1.5版本填充方式适用于加密和签名，而OAEP只适用于加密，PSS只适用于签名。\n\nRSA的数字签名应用非常广泛，被固化到U盘作为签名私钥，有种更新的算法RSA-FDH(Full Domain Hash)。PDF的1.5版本只支持2048位的RSA签名。\n\n!! DSA说明\n\nDSA生成公私钥比RSA要多一个步骤，先用dsaparam生成参数文件，这份参数文件可以被多个用户共用，生成每个用户各自的公私钥对。决定签名结果的因素有HASH算法和KEY的长度（推荐1024以上），生成参数命令`openssl dsaparam -out dsaprm.pem 1024`。可以看到生成文件就包含P/Q/G三个大数。P和Q都是素数，且P-1必须是Q的整数倍。\n\n用dsaparam指令的`-genkey`也能直接生成公私钥，独立的genkey指令则可以对生成的公私钥文件进行AES/Camellia加密。这样生成的文件内既有公钥又有私钥，显然不适合分发，需要把公钥提取出来，命令`openssl dsa -in dsakey.pem -out dsapub.pem -pubout`，坑爹的是`-pubout`参数在dsa的帮助命令里居然没有，但从rsa命令的帮助能看到。。。\n\n有了公私钥文件，接下来可以选择一个文件进行签名和验证。Openssl并没有直接提供类似dsautl命令验证签名，需要用dgst指令完成。签名命令`openssl dgst -sha1 -sign dsakey.pem -out sign.dat yourfile`。其中sha1可以换成任意想要的摘要算法。比如选用了1024bit的私钥，生成的sign.dat是46bytes，DER编码的二进制文件，解码DER的话能得到两个大数R和S（位数一样），这一点和RSA的签名不同，两个大数的验证算法和RSA不同，这也是为什么DSA不能用来做加密的原因。验证签名命令`openssl dgst -verify dsapub.pem -sha1 -signature sign.dat yourfile`，通过会显示Verified OK，反之显示Verified Failure。\n\nDSA的密钥强度标准和RSA是一样的，都推荐2048bit。\n\n!! EC椭圆曲线\n\n共有三种用法\n\n# Elliptic Curve DSA，用椭圆曲线做DSA，数字签名。\n# ECDH，用椭圆曲线做密钥交换。\n# ECIES，椭圆曲线的公钥加密。\n\nOpenssl的命令行工具支持前两种，并内建若干条曲线，比如下载的libressl自带了90条曲线，选好曲线的名字如secp256k1，则参数值（prime/A/B/Generator/Order/Cofactor）就确定了。曲线有prime域和binary域两种。域会有位宽，通过openssl的ecparam生成的参数长度和位宽正相关，但并不严格地成线性关系。\n\n使用椭圆曲线和DSA类似，也必须要两个步骤。先确定一条曲线参数，基于这条曲线参数生成公私钥。但Openssl的命令行没有genec指令，都是ecparam指令。\n\n# 首先用`openssl ecparam -name secp256k1 -out secp256k1.pem`先生成一条曲线参数，生成的参数文件内容只有8字节（Base64后12字节）。如果直接用`openssl ecparam -text -noout`只能看到ASN1 OID: secp256k1描述，需要再加上`-param_enc explicit`参数，就能看到域类型和曲线的A/B值等很多值。前面提到了因为曲线描述一旦确定，则所有参数就确定了，所以这些参数我理解，并不是保存在参数文件，而是硬编码在Openssl内。所以8字节的参数文件看上去就有很多输出了。但是这样会有兼容性问题，因为具体的参数硬编码在Openssl程序内，那么高版本程序新加入的曲线，在低版本就会出现无法解析的错误。要避免这种情况，可以通过生成时加上`-param_enc explicit`，这样生成的曲线文件就会大很多，也完整很多。\n\n# 有了参数文件，就可以生成私钥了，命令`openssl ecparam -genkey -in secp256k1.pem -out key256k1.pem`。同样的，要避免高版本和低版本的配套问题，加入`-param_enc explicit`参数就可以了。其实这步和上一步合并也没有问题。通过私钥文件生成公钥的命令是`openssl ec -pubout`，和DSA一样，`-pubout`在帮助中看不到。\n\n使用椭圆曲线进行签名和验证和DSA类似（但不确定是否就是ECDSA），签名`openssl dgst -sha1 -sign eckey.pem -out ecsign.dat yourfile`，验证`openssl dgst -sha1 -verify ecpub.pem -signature ecsign.dat yourfile`。选用secp256k1曲线的签名结果是71字节以DER编码的文件。简单说明一下：\n\n首字节是0x30，第二个字节是0x45，十进制69表示该字节之后的文件长度，69\\+2=71能够和文件总长度对上。第三个字节固定是0x02。第四字节0x21表示R的长度，偏移33字节后又是0x02，后一字节0x20表示S的长度，到此文件结束。不过没搞明白的是通过程序看到的R和S长度一样，为什么保存到文件R和S长度就不一样了。\n\n最后说下椭圆曲线的操作是点在操作，计算用加法，计算结果判断是否无限或在曲线上。\n\n椭圆曲线的操作体现在C函数的接口，则是`EC_KEY`和`EC_GROUP`这两个重要的概念。一条选定参数的曲线就是一个group，用`EC_GROUP_new_by_curve_name`获取一个group，从头文件找枚举代表一种算法。\n用`EC_KEY_new`创建新的key，这样的key虽然名字叫key但只是个空的容器，必须先和group关联。当然也可以用`EC_KEY_new_by_curve_name`一步生成绑定好的key。\n\nkey和group有了关联之后，才能调用`EC_KEY_generate_key`生成公私钥。私钥是个很大的素数，在OpenSSL表现为BIGNUM类型，可以用`BN_print`看结果。公钥则是点，是`EC_POINT`类型，这个类型不开放，所以不能直接打印，如果看源码，POINT内部包含了X和Y两个BIGNUM（其实还有个Z也是BIGNUM，但不确定有什么用）。比如secp256k1的私钥是256bit的数(并不要求是素数)，公钥是形如(X, Y)的点对，计算方式是\n>Q(x,y) = K * G(x,y)\n\nK就是256bit的大数，G随着椭圆曲线的确定是惟一确定的，对应ecparam的G参数。X和Y也都是256bit，所以公钥是512bit。比特币看不出来，但ETC的钱包采用的是HEX编码，容易看出pubKey的长度是privKey的两倍。\n\n虽然公钥保存成512bit没有错，但其实忽略了椭圆曲线一个重要特性**对称性**。来看椭圆曲线的公式：\n>Y^2 = X^3 + aX + b\n\n只要知道公钥点的X，公钥点的Y就能通过开平方计算出来，只要再配合正负号，就可以知道完整的公钥点了。这个发现就是**压缩公钥格式**的来历，严格地说并不是压缩，只是去掉了一半冗余信息。甚至有人开玩笑地说中本聪不是密码学出身，否则怎么会一开始想不到要使用压缩公钥这种形式。\n\n私钥生成后就可以做签名和验证了。不同算法sign得出结果的长度从`ECDSA_size`获取，从48到153字节不一而足。ECDSA签名的结果同样是两个大数R和S，且位数一样。R和S的长度取决于算法，范围跨越20到71，因此把这个范围乘以2，再转成DER编码，就和前面提到的48~153能关联起来了。\n\n用椭圆曲线做密钥交换，即ECDH也很方便，BitShares的加密通信就是ECDH\\+AES，ECDH的流程比较简单，A和B各自持有一对椭圆曲线的公私钥，交换公钥后，再用自己的私钥乘对方的公钥，得到的结果就可以用来做AES密钥。比DH的流程要容易理解。","modified":"20170816121530000","tags":"security"},
{"created":"20190912121530000","title":"SASL、GSSAPI和Kerberos的理解","text":"\n!! SASL\n\n网络协议和认证虽然是不同的领域，二者往往会结合使用。在SASL出现前，两者的组合是乘积关系，SASL使两者解耦，组合的数量变为和的关系。由于SASL的目的是解耦，所以并不包含网络功能，并不承担数据传输功能，只有得到数据后才开始进行处理。同时它又不负责具体的认证，所以种种认证实现都是是SASL插件的方式存在。\n\n使用最广的SASL实现是Cyrus版本（翻译过来是古波斯的居鲁士大帝），从库分布也能看出，主体框架是libsasl2.so，而各种具体实现libcrammd5.so、libdigestmd5.so放在插件目录下。\n\n支持的验证机制包括但不限于：getpwent、kerberos、pam、rimap、shadow、ldap\n\n!! GSSAPI\n\n作用和SASL接近，适用场景有些不同。对LDAP来说，两者都适合，但对HTTP认证来说，SASL的流程有些啰嗦，使用和GSSAPI一脉的SPNEGO就更合适。由于GSSAPI产生得比较早，因此和Kerberos结合地更密切（甚至可以说是唯一的实现机制），其中GSSAPI定义开发语言的API，而Kerberos负责具体网络通信和加密过程。\n\n!! Kerberos\n\n实现用得最多MIT的版本（Heimdal有，微软有个非兼容版本SSPI，而AD则是KDC和LDAP的结合体），协议在RFC定义。理念和用途与TLS不一样，krb用于多点间协同，全部使用对称加密算法，依赖参与者依赖中心点KDC，而TLS依赖非对称加密和数字证书，解决两点间通信问题。\n\n微软的NTLM据说是对标，用在域控管理密码和认证。但没有c和s间的互动。\n\n由于kerberos的实现有多种，接口不统一，GSSAPI的C语言接口定义有RFC背书，且`libgssapi_krb5.so`，即对kerberos的封装，也是我所见仅有的实现绑定，所以两者可以认为是一样的。而适配到SASL会稍麻烦。\n\nKerberos的认证过程可细分为三个阶段：初始验证、获取服务票据和服务验证。第一阶段：客户端向KDC中的AS发送用户信息，请求TGT，请求内容会用客户端的密钥做对称加密，由于KDC有客户端的密钥（可以是KDC给客户端，也可以是客户端告诉KDC，总之kerberos的理念就是必须信任并且把密码让KDC知道）。第二阶段：客户端拿着之前获得的TGT向KDC中的TGS请求访问某个服务的票据。第三阶段：拿到票据（Ticket）后再到该服务的提供端验证身份，然后使用建立的加密通道与服务通信。\n\n* KDC：Key分发中心（key distribution center），是一个提供票据（tickets）和临时会话密钥（session keys）的网络服务。KDC服务作为客户端和服务器端信赖的第三方，为其提供初始票据（initial ticket）服务和票据授予票据（ticket-granting ticket）服务，前半部分有时被称为AS，后半部分有时则被称为TGS。\n* AS：认证服务器（Authentication Server），KDC的一部分。通常会维护一个包含安全个体及其秘钥的数据库，用于身份认证，保证客户端确实存在于KDC的密码库中。\n* TGS：许可证服务器（Ticket Granting Server），KDC的一部分，根据客户端传来的TGT发放访问对应服务的票据\n\n由于KDC机制严重依赖与密钥，所以自带数据库管理工具krb5\\_util和kadmin。\n\n目前主流的中心式密钥分发，一个是Kerberos认证，像windows域控制器认证方式；另一个是Cisco GetVPN，KDC被用于分发TEK（Traffic Encryption Key)。\n\n!! 认证流程\n\n# AS认证：\n\n员工Alice首先到认证中心KDC报道，KDC给了Alice两只信封，一只信封A装的是Alice-KDC session key ，以及Alice ID、IP、时间戳相关信息，用KDC的密码加密，Alice不能打开，待会转交给TGS就够了。\n另外一只信封B是用Alice的密码经过Hash做了加密，里面装着临时密钥Alice-KDC session key ，Alice用自己的密码，解密得到Alice-KDC session key。如果Alice是假冒的，自然打不开信封B，无法访问网络资源。\n\n# TGS认证：\n\n当Alice想访问服务器S，要向TGS出示两个证件：\n信封A和信封C。其中，信封C里面装有Alice ID、服务器S等信息，用Alice-KDC session key 加密。\nKDC用自己的密码解开信封A（因为AS和TGS在一起），获得Alice-KDC session key，用它解开信封C。KDC检验证件合格，于是准备出票。\n\nKDC把票递给Alice，是两个信封：\n信封D，里面装有Alice-S session key、Alice-TGS session key，用服务器S的密码加密，Alice不能打开，待会转给服务S。\n信封E，里面装有Alice-S session key信息，用Alice-KDC session key加密\n\n# Service认证：\n\nAlice解开信封E，得到Alice-S session key，并用它生成信封F，里面包含Alice ID和时间戳，来到服务器S 的面前，出示信封D、F。\n服务器S用自己的密码解开信封D，得到Alice-S session key，然后再用它去解密打开信封F，获得信封里的Alice ID等认证信息，认证通过后，Alice访问服务器资源就用Alice-S session key了。\n\n!! 协议交互\n\n程序分为C和S端，S端又分工具类和守护类。工具类有kadmin.local, `kdb5_util`等负责管理用户。注意kadmin可以让管理员在KDC之外的主机远程操作，不过最好还是在KDC上用kadmin.local。数据库以BerkeleyDB方式保存。守护类有kadmind，krb5kdc，这两个必须都启动才能正常工作。kadmind监听749和464端口，749负责admin，464负责修改密码。krb5kdc监听88端口。\n\nC端调用kinit principal，会找pricipal对应的KDC并获取initial credentials和TGT，服务端返回加密报文后，命令行会提示输入密码，如果正确的话，klist就能看到，退出用kdestroy。\n\nkinit的交互信令通过UDP发给KDC的AS，端口88。含AS-REQ和AS-REP两个报文。REQ包含标明身份的明文client name和realm，以及请求的server name(默认krbtgt)。\n\n输入密码只适用于交互，如果要程序化必须利用keytab方式，就是在KDC侧用kadmin.local的xst指令把某个principal的密钥导出并发给客户机，kinit用-kt选项就免去输入密码这步。默认导出了keytab后，用户密码会变，相当于以后就只能用keytab登陆了。\n\n!! 身份标识\n\nprincipal标识惟一身份，格式是 `\u003Cusername>/\u003Cgroup>@\u003CREALM>`，比如root/Admins@HOME.COM。username也叫primary，是必填项，可以是linux下的用户名；group也叫instance，用户可以不填，服务必须有；realm可以不填，会从krb5.conf查找默认的域，如果有多个域就必须要写上。每个 realm 可以有私有配置，包括 KDC 的地址和加密的算法，都可以独立存在。有些大型公司会创建一个独立的 realm 来分发管理员的权限。\n\nKeytab 是一个包含了（若干）principals 和一个加密了的 principal key的文件。一个 Keytab 文件每个 host 都是唯一的，因为 principal 的定义了包含了 hostname 。这个文件可以用来认证，而不需要传递公开的密码，只要有这个 Keytab 就可以代表这个 principal 来操作。","modified":"20190912121530000","tags":"security"},
{"created":"20220623121530000","title":"scheme的几个实现Gambit/Chibi/Chicken/S7","text":"\n!! Gambit\n\n两个主要执行程序：gsi和gsc，gsi是执行器，可以debug，gsc将scm源码先编译成一种叫gvm(gambit virtual machine)的中间语言，再翻译成C源码方式。转译后的源码内容是各种宏的排列，大约是gvm语言的转译版，完全没有可读性。\n\n用`gsc -c`生成的c文件是，没有main函数，无法编译成可执行程序。main函数的定义在libgambit.a里。但是要将main函数和用户实现函数联系起来，还必须有一个称为link文件的东西。要用`gsc -link`方式生成。如果一份example.scm文件会生成example.c和example_.c两个文件。后一个文件接近500K大小，但是不管scm文件的内容是什么，这个link文件的内容几乎是一样的，因为它的作用主要是初始化scheme环境并调用用户代码。因此有多个scm文件时，只要对其中的主启动文件生成link文件就可以了。\n\n最后再链接入libgambit.a就能生成平台可执行程序了。不过在windows上用gcc编译时提示找不到`chkstk_ms`函数，chkstk要解决的是这样一个问题：每个程序默认分配4K栈长度(64位是8K)，如果超过这个长度，会触发OS的缺页机制，但如果超过2页，可能会引起非法访问，所以微软加了这个函数。GCC也有类似机制，但函数名却不一样。有人说从VC拷贝chkstk.obj可以解决，但是我按这个做法无用，暂时无解。\n\n另一个角度看，由于main函数是定义在libgambit.a中，也没办法把scheme和C混合编程。\n\n!! Chicken\n\nchicken主包有csi和csc以及一些安装egg的程序，优化力度没有Gambit大，但轻量，同时周边生态非常好。由于和C的交互性比较好，还有chicken-libs和chicken-dev两个附加包，libs只含一个libchicken.so.xx（xx是具体实现版本），运行时加载。当然也支持静态编译，就归属于dev包，里面有.h和.a文件，同时还有个.so的软链接。\n\nGambit和Chicken都是能把Scheme编译成C源码的实现(另外还有Bigloo)。\n\n!! Chibi\n\n和前两个相比起来，Chibi只是一个非常小的实现，只有9个文件不到两万行源码，但却很有意思。\n\n9个文件除掉main文件，剩下分为SEXP和EVAL两部分。SEXP包括`gc.o sexp.o bignum.o gc_heap.o`，S表达求值和两种GC策略及大数。EVAL包括`opcodes.o vm.o eval.o simplify.o`，实现求值、虚拟机指令、优化。\n\n和最常见的configure/make编译方式不同，Chibi的configure却顽皮地写了句：`Autoconf is an evil piece bloatware encouraging cargo-cult programming.`，直接用make就可以。即使如此也能做到在很多平台直接编译成功。第一次看到有人这样嘲讽Autoconf，算是说出了我的心声吧。\n\n实现上有很多有趣的实现技巧，比如用GCC的特性，`typedef int sint128_t __attribute__((mode(TI)));`定义128位int，在Windows平台使用`(DBL_MAX*DBL_MAX)`和`log(-2)`定义infinity和nan。\n\n核心形式只有10个：`DEFINE,SET,LAMBDA,IF,BEGIN,QUOTE,SYNTAX_QUOTE,DEFINE_SYNTAX,LET_SYNTAX,LETREC_SYNTAX`。\n\nchibi支持以C语言写插件并调用(如果不这样，scheme也不可能有大用了)，但想从C调用还没找到路径。\n\n!! S7\n\n对tinyscheme做了极大的丰富，并且持续演进。宏和模块机制借鉴CL。\n\n!!! 编译\n\n虽说核心只有.h和.c各一个，但选项很多，又没有提供Makefile，还是要仔细看文档才行。默认把s7.c和repl.c编译成standalone的方式，虽然在安卓上能编译出二进制文件，但运行时要新编译libc的扩展，会遇到诸如没有wordexp.h头文件，没有网络库等。只能加上`DWITH_MAIN`选项编译s7.c得到standalone文件。还有如果遇到复数函数链接报错，还要在编译时加上`DHAVE_COMPLEX_NUMBERS=0`手动关闭。\n\n!!! 模块\n\n特殊变量`*features*`能看到当前加载的所有模块列表，但是可笑的是这个列表可以通过provide随意往里添加。虽然正常都是require然后找到那个文件，由该文件的首行实现provide。总觉得这种方式过于老式且似乎不能防止恶意行为。provide行为和lua的module很像，想来当时也是抄的吧，不过lua自己仅使用了一个版本就弃用，是不是也说明了什么。\n\n!!! 自带库\n\n大量使用了宏和C语言FFI，复杂不易懂。\n\n!! 总结\n\n虽然记录了一堆，但至今没想出scheme在CURD领域有什么用，字符串能力孱弱到只能取子串和拼接，完全无法用于web开发。\n","modified":"20220623121530000","tags":"lang"},
{"created":"20141002121530000","title":"setjmp的机制及lua中的异常","text":"\nsetjmp/longjmp是C标准的函数，常用的做法是用来实现异常/跳转。原型如下：\n\n* int setjmp(jmp_buf env);\n* int longjmp(jmp_buf env, int err);\n\n这组函数依赖于`jmp_buf`的变量类型，从接口声明看，\n`jmp_buf`是值类型的，但每次调用setjmp都会把当前的各个寄存器值包括PC保存起来，\n供以后longjmp来恢复，所以这个`jmp_buf`一定是指针语义的。\n看了GCC 3.4.5的定义，将宏简化之后就是 typedef int `jmp_buf`[16];\n也就是说`jmp_buf`类型其实是个数组，而数组在传参时又是作为指针来处理，\n所以setjmp能改变`jmp_buf`所对应的值，之后的longjmp才能恢复回来。\n实测在32位的XP系统上，只用了0~6共7个值，其余都是置0。\n\n如果没有setjmp就直接longjmp，因为PC值和各种寄存器值一定是乱的，\n必然导致系统崩溃。调试模式下是ntdll下抛异常。\n而每一次的setjmp都将当前状态写入到jmp_buf中并返回0，\n因此多次调用setjmp以后，longjmp会回到最后一次setjmp的地方。\n\n再说说setjmp在lua中的应用。\n\nlua在内部执行操作时，大都是调用luaD\\_pcall，\n这内部调用到了luaD\\_rawrunprotected，在内部会进入LUAI\\_TRY这个宏。\n如果用C++编译，这个宏就被展开成try{}块；如果是C，\n这个宏就被展开成if (setjmp() == 0) {action}这样的形式。\njmp\\_buf的值会随着L带到action中，一旦发生无法补救的错误，\n就会通过luaD\\_throw函数，在判断了存在jmp\\_buf后，\n再调用LUAI\\_THROW宏，实质就是longjmp的形式直接返回。\n由于先判断了L中是否有jum\\_buf，也就不会有异常的死机问题。\n\nLua的语法层面并不支持try/catch/throw这种显式的异常处理方式，\n但是做一些不符合规定的操作，比如数字加nil，\n字符串和nil拼接等等动作，Lua会执行出错，\n如果不是在pcall内执行，导致程序提前终止，\n这其实就是一种变相的固定类型的异常，\n只是自定义异常类这块功能没有开放罢了。\n\n只有系统自带的操作，在执行非法时抛出个可捕获的异常，\n用pcall/xpcall来模拟try/catch，而用类似`1+nil`的方式模拟throw。\n要想程序能够跑完，就要时刻注意用pcall的方式把函数执行做个封装，\n而如果想提前终止，也可以用故意写非法语句来达到类似的效果。\n但是写的非法语句毕竟不能携带自定义信息，只能靠代码行号来反推，\n效果上就差强人意了。\n\n","modified":"20141002121530000","tags":"lang"},
{"created":"20170831121530000","title":"SHA家族的哈希算法","text":"\n由于MD5早就被证明存在碰撞攻击，安全性在严肃场合肯定是不够的，SHA-1(160bit)作为替代品已被越来越多的观点认可，但是MD5有一个理论上的优点，计算长度无上限，而SHA家族的长度会限定在2^64-1或2^128-1内。SHA是一个很大的哈希算法家族，到目前共有0、1、2、3这四类。\n\n* SHA-0：这个很少提及，原因是MD5被成功碰撞后，几乎同时SHA-0也被碰撞，所以没有实际应用\n* SHA-1：只有SHA160一种，不过目前在理论会产生碰撞，17年初Google发了paper声称找到了碰撞方法，git在计算对象摘要时用了SHA-1，但git用它作为完整性校验，并不在意碰撞。\n* SHA-2：共有SHA-224/SHA-256/SHA-384/SHA-256这四种细分类型，224和384分别是256和512的截短版本，至少我还没有看到可靠的质疑的消息，Bitcoin计算交易哈希、MerklerRoot时，用的就是SHA-256算法\n* SHA-3：虽然SHA-2没有明确的证据证明不安全，但NIST(美国国家标准技术研究所，也发布AES、若干种椭圆曲线等其它加密技术)还是未雨绸缪地于2007年开始征集新的下一代密码Hash算法，最终在2012年10月2日，Keccak被选为NIST竞赛的胜利者，对外称为SHA-3，Keccak和SHA-2在设计上存在极大差别(海绵结构 VS Merkle-Damgard)，支持256，384，512多种长度的输出。以太坊出现时间在SHA-3之后，用的是SHA-3算法\n\n!! HMAC与HASH\n\nGo语言规整地把计算HASH的方法统一定义成hash.Hash接口，hmac.New(hash.Hash, []byte) hash.Hash。可以任意组合，不需要为每种HMAC增加特定方法。","modified":"20170831121530000","tags":"security"},
{"created":"20180706121530000","title":"Shell编程说明","text":"\n!! 解析顺序与转义\n\n和函数调用类似，一条命令行的多个部分会在不同阶段解析。先判断整行是简单命令还是复合命令，每条简单命令的参数会先解析，像glob、变量替换、重定向都是参数解析阶段的重头戏，然后作为主命令参数执行。\n\n单双引号可以防止转义，双引号保留$和\\n等扩展语义，单引号完全不做转义。但是$''语法又支持有限转义。比如$'\\u4f60'会转义成汉字'你'，如果没有$，则原样输出。\n\n!! 类型\n\n解析时默认都是字符串类型，所以不需要特意标记双引号或单引号，有两种情况要特意加引号：1-空串，2-\\*之类会被扩展的特殊字符。\n\n在值的比较上，颇有些强类型的感觉，字符串的比较和整形的比较要用不同的操作符。\n\n!! 变量与赋值\n\n赋值的`=`两端一定不能有空格。因为在sh的体系里，空格并不是可有可无的，在语法解析时扮演重要的角色，因此一定要注意。用set或readonly可以看到当前已设置的变量。\n\n环境变量是带有特殊属性的变量，export把变量提升到环境级别，但这个变量依然是变量，可以用unset删除，之后在环境中就没有这个变量了。用env看到的变量比set会少一些，除了前面提到的提升的变量外，set还能看到函数的定义。\n\n位置变量是对函数调用特有的，有个很少人知道的特性，`set -- a b c`可以实现把位置参数替换成a b c这3个值（把--后面的值，赋给隐式的$@，如果--后面无参数，则$@被清空），如果想实现追加在前或后的效果，用`set -- $@ a b c`实现追加到尾部。再配合shift命令，看起来不能修改的位置参数，也能随意操控。\n\n除了=还有:=表示未设置才赋值，:-未设置就替换。像这样`PS1=$'${ local e=$?\\n((e)) && REPLY+=\"$e|\"\\nreturn $e\\n}${PWD:30} '`表示先计算上一条命令的返回值，如果有错误就赋值给REPLY，并把当前路径重新计算一次，丢弃前30个符号。重点是return，如果没有的话，显示的路径就不会变化。这句话在非bash环境，以迂回方式实现了显示当前路径。\n\n等号`=`和圆括号`()`与`$`三者间构成3种不同含义的功能\n\n* =($xx)  把带空格的字符串赋值给左侧\n* =$(ls)  把圆括号内的内容作为命令执行，执行结果赋值给左侧\n* =$((1+2)) 把双圆括号内的内容作为数学计算，计算结果赋值给左侧\n\n值的截取和替换\n\n* ${#var} 取变量的长度\n\n* ${var:=word}\t如果变量 var 已被删除(unset)或为空，那么返回 word，并将 var 的值设置为 word。\n* ${var:-word}\t和=类似，区别是但不改变 var 的值，理解为-是一半的=，所以效果也只有一半。\n* ${var:+word}\t和-相反，如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n* ${var:?message}\t如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，并停止脚本的执行。用来检测 var 是否被赋值。\n\n以上4种替换法，可以想像成{}内的三元表达式，比如${var:=word}可以理解为`isnull(var)?word:var`。以上几种替换法，都可以省略:，区别在于isnull的判断逻辑，变量声明为空串，有:时，空串的isnull为真，无:时，空串的isnull为假。比如`A=;${A=abc}`，因为A已经定义了，值是空串，判断为真，输出前半部分，即仍是空串。\n\n* ${var#expr} 从变量头开始，按匹配expr的表达式删除，支持glob。比如${var#?}表示删除第一个字符，和${var:1}是一样的。如果两个#则启用贪婪匹配\n* ${var%expr} 从变量尾开始，按匹配expr的表达式删除，类似的%%启用贪婪。记忆窍门：删除方向取决于在$的哪侧，#在$左侧，而%在$右侧。\n* ${var/obj/rep} 把变量中obj替换成rep，obj支持glob。只替换一次，如果要想替换多次，写作${var//obj/rep}\n\n$变量的展开和命令解析有一定的顺序，比如要执行`foo 1>/dev/null`命令，但遇到问题时，希望把输出到控制台，如果用`DF=1\\>/dev/null`来控制，用`foo $DF`会报错，大意是`1>/dev/null`参数无法识别。猜测是因为$DF触发了替换后，就直接被当成参数来用了，而1>/dev/null重定向需要一次特殊的解析，但被$替换后，就错过了这种解析。办法是eval \"foo $DF\"才能既展开变量，又能触发重定向。\n\n!! 函数\n\n函数定义有`function name{}`和`name() {}`两种风格，function是bash扩展的，带上后可以不写括号（function或括号都是告诉shell，现在开始定义函数了），如果是busybox的ash，只能用不带function的格式。函数内声明变量最好用declare(字符串类型)或者`-i`(整型)，相当于是内部变量，否则就会在全局空间创建这个变量，typeset是declare的同义词。也可以用declare来看已定义的变量和函数。\n\n函数可以返回unsigned char，但是不能直接把返回值赋值给变量，直接在`=`后带函数名，函数名会退化成字符串。必须先执行，再用$?赋值。\n\n函数调用不需要括号或逗号，用foo $a \"var\"方式将函数和参数以空格平铺开就算执行了。\n\n`$*`和`$#`都表示所有参数，区别是`$*`是字符串形式，`$#`是数组形式。在传参给执行程序时没区别，遍历用`$#`会方便很多，如下\n\n!! 数组和遍历(仅bash支持)\n\n用圆括号和空格定义，arr=(1 2 3 4 5)，定义后可以用arr+=(6 7)向末尾追加元素。也可以这样\n\n```\ndeclare -a array\narray[0]=\"a\"\narray[1]=\"b\"\narray[2]=\"c\"\n```\n\n遍历（For循环法）：\n\n```\nfor var in ${arr[@]};\ndo\n  echo $var\ndone\n```\n\n遍历（带数组下标）：\n\n```\nfor i in \"${!arr[@]}\"\ndo\n  printf \"%s\\t%s\\n\" \"$i\" \"${arr[$i]}\"\ndone\n```\n\n遍历（While循环法）：\n\n```\ni=0\nwhile [ $i -lt ${#array[@]} ]\ndo\n  echo ${array[$i]}\n  let i++\ndone\n```\n\n获取数组的length（数组中有几个元素） ${#array[@]} 。解释一下 @ 是数组展开，#取长度，$把值取出来。对函数内的参数而言，简化成$#就是数组长度。\n\n!! 向函数传递数组\n\n由于Shell对数组的支持并不好，所以这是一个比较麻烦的问题。除了全局变量外，无完美解法。提供一个变通的思路，在调用函数前，将数组转化为字符串。在函数中，读取字符串，并且分为数组，达到目的。\n\n```\nfun() {\nlocal _arr=(`echo $1 | cut -d \" \" --output-delimiter=\" \" -f 1-`)\nlocal _n_arr=${#_arr[@]}\nfor((i=0;i\u003C$_n_arr;i++));\ndo\n  elem=${_arr[$i]}\n  echo \"$i : $elem\"\ndone;\n}\n\narray=(a b c)\nfun \"$(echo ${array[@]})\"\n```\n\n!! 条件判断\n\nif语句\n\n```\nif [ \"$0\" -eq/= \"$1\" ]; then\n  statement1\nelse\n  statement2\nfi\n```\n\n本质上讲，if 检测的是命令的退出状态，所以then前面必须有;，用;让if做完求值。\n\n**在 test 中使用变量用双引号包围起来**。想判断当前文件夹为空，捕获ls的输出后，一定要用[ -n \"$out\" ]才正确。如果没双引号判断不准，这个过程将变量 $str1 替换的细节如下：\n\n* 如果 $str1 是一个正常的字符串，比如 abc123，那么替换后的效果就是test -z abc123，执行形式相当于main(\"-z abc123\")。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数，正常执行。\n* 如果 $str1 是一个空字符串，那么替换后的效果就是test -z，执行形式相当于main(\"-z \")，这就比较奇怪了，因为-z选项没有和参数成对出现，执行时就会出现意想不到的情况(对于-n和-z的执行结果都是错误，导致if的评估结果一样)。如果给 $str1 变量加上双引号，当 $str1 是空字符串时，test -z \"$str1\"就会被替换为test -z \"\"，调用形式就是main(\"-z \\\"\\\"\")，显然这样 main() 在分析时就不会出错了。正因为此，经常会看到x = x$var的写法，也是为解决空串问题。\n\nswitch格式\n\n```\ncase \"$1\" in\n  start)\ncommand1\n;;\n  stop)\ncommand2\n;;\n  *)\ncommand\n;;\nesac\n```\n\n前面提到过，默认的类型是变量，在条件间断时有一些有趣的现象，比如[ \"x\" = x$empty ]的结果是true($empty是空串)。case后的条件建议加双引号，原因同前，分支语句有没有双引号都没关系，反而想同时捕获error或errors时，必须用不加引号的error\\*才行，加上引号会适得其反。\n\n!! 执行子命令\n\n$()与 ` `(反引号)效果是一样的，优劣如下\n\n* $() bash扩展命令，可以嵌套，似乎busybox也能支持，由于带了$，可以放在=的右侧，命令的运行结果可以赋值到=左边\n* `` posix命令，嵌套时内部的反引号要加转义\n\n另外$(())是用于整数计算，同样可以放在=右侧，不要和$()搞混了。\n\n!! 字面值还是文件名\n\n严格来说，这并不是shell的特性，而是各个程序的特点，比如echo的参数当作字面量，而cat或ls的值则作为文件名来解析。有一个操作符`\u003C()`，会把执行的结果作为文件内容，\u003C()作为一个文件的占位符，等效于匿名文件，有点类似lambda的感觉。","modified":"20180706121530000","tags":"lang"},
{"created":"20201009121530000","title":"shell的历史和流派","text":"\n!! 源起Bourne\n\n最初unix系统用的是ken thompson写的shell，不过这个只在贝尔实验室内部用，最早广泛流行的version 7 unix系统的shell是Bourne shell在1979年重写的，可以说Bourne的版本是最初的原型，已经具备了大多数结构化编程的功能。\n\n!! csh\n\n1990到2000年代在BSD系统上比较多见，是Bill Joy写的另一种风格的shell，意图是加强交互性，但也被批评不适用于编程（比如不支持在脚本中定义函数）。后来FreeBSD又强化出了tcsh，由于使用习惯和Bourne版本差别较大，似乎只有FreeBSD把它作为root用户默认，普通用户不用csh，开发也不太活跃。\n\n!! ksh\n\nDavid Korn基于Bourne的代码，又借鉴了csh的作业控制的改进版，加入了emacs和vi风格的编辑方式。ksh88是POSIX规范的蓝本，另有ksh93是另一个主要的版本。但其所属权一直归AT&T所有，不算开源软件。ksh的很多衍生版本用在商业Unix上，Android 4.0后默认的mksh也是ksh的后代（之前是ash）。\n\n!! ash和dash\n\nBourne版本毕竟存在版权所属问题，Kenneth Almquist重新实现了一个版本，特点是执行速度很快且节约内存，相比ksh，少了行编辑和历史命令。后来debian基于它维护了dash（Debian Almquist shell），虽然行编辑和历史命令作为可选项支持了，但仍然不完全满足POSIX（缺少国际化和多字节）。也正是因为其精简，dash的0.3.8-5版本被busybox所集成，用在很多嵌入式系统上。\n\n!! bash\n\nGNU组织开发了bash，是大多数Linux发行版的默认shell，功能非常丰富。但是由于GPL协议的关系，也受到不少非议，OS X的bash版本就长期停留在3.x，后来干脆换成zsh来规避GPL。\n\n试举一个特性，通过`PROMPT_COMMAND`环境变量来控制显示，和PS1的区别在于PS1只是显示字符串，而PROMPT会先执行后面的语句，把语句的结果作为提示符。这就是z.lua似乎没有特别地增加路径，却可以记录每次到过路径的原因。\n\ncomplete是可配置的选项，对特定命令丰富补全功能。\n\n!! zsh和fish\n\n对bash的扩展仍然觉得不够，于是有了这两个版本，了解不多，先记一笔。","modified":"20201009121530000","tags":"tool"},
{"created":"20200108121530000","title":"shell的模式与选项","text":"\n起因是看到有人写脚本，用/bin/cp方式复制文件，说是因为cp在复制时如果文件名相同会提示是否覆盖，导致脚本会停住。这个行为是因为操作系统对root用户默认alias cp='cp -i'导致的，所以用/bin/cp绕过，我于是想到为何不在脚本开头用unalias去掉cp的定义，后面直接写cp就方便了。\n\n验证时却发现会提示unalias cp not found。于是在终端下尝试，第一次成功，第二次提示同样错误，这就说明在fork出的shell环境下没有alias，不需要特意用/bin/sh。但是为什么子shell没有继承alias？又加了alias发现不仅cp没有继承，其它的都没有被继承。\n\n网上有人说这个特性只有交互模式才会打开，即bash --login才能用，又有人说要用shopt方式显示打开，可是试了似乎都不对。忽然想到alias是shell的buildin命令，说明是进程独有的功能，而fork子进程时，只能通过环境变量传递参数，既然alias不属于环境变量，也就无法自动地传递给子进程，只能显示地加载/etc/profile之类的文件才能使alias生效。\n\n!! 交互与登陆模式\n\n交互模式 interactive，仅输入bash，也是最常见的模式，为交互模式。而参数中有文件名或-c方式调用语句，就是非交互模式。看`$-`有没有i来判断。由于不需要交互，.bashrc就不会读入(新版本才有的特性)，节约脚本执行时间。\n\n登陆模式 login，和交互模式是完全正交的。login指非常早期就启动的shell，会读入profile类文件，后面的用户在duplicate shell操作时，是fork了这个login shell，真实得到的是ono login但interac。前文提到的通过ssh触发的bash就是这种模式。登陆模式下可以用logout退出，用shopt 观察。登陆模式用于显示tips或欢迎信息，默认不打开，su的时候就比较静默，也可以强制su --login显示欢迎词。\n\n习惯上，non interactive, login是很罕见的，只在部分X程序会用。\n\n不同模式读入配置是不同的\n\n```\n/etc/profile   交互模式读入，似乎有误，当为登陆模式\n/etc/bashrc或bash.bashrc  似乎并不会被读，通用配置保存在这里\n~/.bash_profile   login按序读以下3个，读到停止\n~/.bash_login\n~/.profile\n~/.bashrc    non-login读\nBASH_ENV   非交互模式使用\n```\n\n!! 选项\n\nPOSIX规范要求用set控制选项，bash增加了特有的shopt并在另一个命名空间保存这些选项。set不能影响shopt，但shopt用-o可以操作set空间。set空间以全大写的环境变量为主，而shopt都是小写。\n\n选项会对脚本的执行带来微秒的影响，有一次我不经意间引入了`set -e -u`，导致程序无法执行，看了帮助手册才明白这代表error exit，当命令退出状态是失败时，整个脚本就退出了。由于我原来的代码中会用grep判断tar包中是否有一个文件，当不存在时grep会以失败退出，如果不加-e选项，并不会引起问题，但当更严格的-e开启后，程序就不再继续执行。而-u则对$1这样的变量展开做了更严格限制，如果不存在就退出，$@和$\\*不受-u开启的影响。\n\n!! 非阻塞同步\n\n后台方式调用其它脚本，紧接着用`$!`记录下进程号，最后用wait方式等待结束。","modified":"20200108121530000","tags":"os"},
{"created":"20220721121530000","title":"spark性能调优记录","text":"\n!! 资源配置\n\n和运行速度相关度最大的是instance数量，我做的业务因为数据量在千万以内，内存只有6G，实例数只会分配个位数。实测发现2个比1个提升明显（至少50%以上），3个比2个有提升但幅度开始减少（30%左右），再往上提升就更少了。而内存在保证不OOM的情况下，多给也只会减少JVM的GC时间，对性能没什么提升。\n\n!! udf和udtf\n\n同行逻辑最初的版本是用udf做，尽管经过数次优化，但始终有内存占用过大问题，计算过程是先对点位分组，然后把每组的数据`collect_list`后交给udf来计算，pyspark的udf每次传递100条数据，到了这个逻辑传递的其实是100个分组，内存肯定很高。但细想会发现这其实这是个标准的udtf过程，于是想到换用udtf每次传递1个分组，内存肯定可以降下来。开始还担心由于传递次数变多，而且udtf得到的是pandas dataframe，需要转换成原生的list，会有性能下降，实测不仅内存确实减少，而且性能提升2倍左右。\n\n这就涉及一个apache的跨项目的arrow库，所传随着大数据组件越来越多，组件间的数据传递成为一个大的开销，社区当然有人意识到这个问题，于是组织起来开发了arrow这个高效的序列化库，经过arrow序列化后的库，不需要反序列化，收到后放到内存就能直接用，udtf利用了arrow库，而udf并没有，说真的arrow对性能有这么大的提升，真的是没有想到。\n\n换成udtf后在k8s会遇到程序终止问题，查看了instance内存，虚拟内存竟然用了9G。经人指点发现是numpy的内存占用受`OMP_NUM_THREADS`影响，默认和CPU核数一样，服务器40核所以内存占用极大。但是我开始验的时候，导入numpy只会多出200M左右的虚拟内存，过了一天意识到验证用的是anaconda，而pyspark是开源的python，开源版numpy依赖的openblas会依赖OpenMP，从环境变量名也可以看出就是OpenMP的行为，而anaconda的并行库是intel的MKL，不会根据CPU核创建这么多线程。\n\nPySpark内存的使用分3部分\n\n* jvm: 主要计算在这里完成\n* overhead: 发生shuffle时，netty要用这块内存缓存网络数据\n* python: 使用udf或rdd会占用\n\n!! 查看UI\n\n正在运行中的代码，第一个job页会显示active job，下面还会有很多complete job。每个job会被分拆成一到多个task，task又会分到不同的instance执行，所以job执行完就表示代码中的一段逻辑完全运行完成，不用担心是否只是部分instance运行完。看tasks往往会看到很多标记了skipped，这里有很多原因：一方面可能是数据被缓存，所以跳过，另一方面也可能是数据倾斜，让引擎以为需要这么多task，但实际执行后发现没有数据，于是就跳过了。job和代码的映射关系还不清楚，但只要代码不改，job的数量就不会变化。","modified":"20220721121530000","tags":"data"},
{"created":"20200725121530000","title":"Spark学习手记","text":"\n组件构成\n--\n作为一个分布式系统，物理节点分为master和worker节点，master调度，worker计算。\n\n运行职责，即进程级的分为driver（属于master）和executor（属于worker），另外还有类似接口协议的进程cluster Manager（和driver通信）。既然是接口，就有多种实现，常见的有spark clusterManager（standalone和local cluster两种运行模式）、yarn clusterManager（spark on yarn） 和mesos clusterManager（spark on mesos）。\n\ndriver端执行main函数，并创建SparkContext，这是Spark启动最重要的类，包含两个必须设置的属性：master和appName。Executor并行计算，是一个执行Task的容器，初始化程序要执行的上下文SparkEnv，解决应用程序需要运行时的jar包的依赖，加载类。SparkContext可以创建RDD。\n\nRDD\n--\n这是Spark中最早，也是最基础的计算元素，可以理解为元素无序的向量（数组）。由于不可变性，每个RDD在Spark会话中都会被赋予一个惟一ID，这些ID又构成计算的链路，在计算出错需要重算时可以方便地恢复。\n\nRDD所有元素的类型相同，分为2种值类型\n\n# 单Value类型：存放简单类型，如int，string\n# Key-Value类型：整个值的类型称为Row，Row类型的第一列是key，剩下的是values，可以想象成lisp的list，key和value分别对应car和cdr操作。针对key可以进行lookup、join等运算。当value包含的内容很多时，为了更细粒度地操作，还可以把Row类型转换为DataFrame，就能对每一列单独指定操作方法。\n\nRDD的五大属性和若干种实现\n\n# partitions(分区数量)\n# partitioner(分区方法，可以为None)\n# dependencies(依赖关系): 运算就是在多个RDD间的变换，如果一个父RDD变换后得到多个子RDD，就是宽依赖，也称为shuffle；一个父RDD只得到一个子RDD，则称为窄依赖。\n# compute(获取分区迭代列表)\n# preferedLocations(优先分配节点列表) \n\nRDD的操作和任务执行过程\n--\n大多数文章都把RDD的操作分为transform和action两类，trans还能再细分，这里采用细分后的4种类型。\n\n# 创建操作（creation）：pyspark只提供了parallelize；scala还提供makeRDD\n# 转换操作（transformation）：从一个RDD得到另一个RDD，绝大部分都是此类操作\n# 控制操作（control）：persist和cache，优化性能\n# 行为操作（action）：将惰性计算进行求值，比如collect, count, take, save, foreach, reduce。特别要提的是，**reduce是行为，但reduceByKey是转换**，二者不可混为一谈。\n\n区分的依据是：trans不会马上执行，而是等到action才会触发计算。为什么trans不触发计算呢，因为计算的成本太高，计算过程要尽量合并，很多中间步骤，在不急于显示结果时，没必要计算。以groupByKey为例，分组不是最终目的，对分组做的聚合运算才是用户真正想要的。因此分组时，只需要把计算过程规划好，不必急于把计算任务派发到数据分区。\n\nRDD的分类，体现在任务运行粒度上，就分为大小两种，app(1个) > job > stage。每当代码中遇到transformation（意味着要创建新的RDD），会继续分析，直到遇到action类操作，就会产生一个job来真正执行所有的transfomation和这个action。job中如果有shuffle操作（trans和action都会产生shuffle），就会产生前后两个stage（HDFS读写文件是stage内的操作，不会产生切分）。也可以说每个stage内部是窄依赖，会做fusion优化，而stage之间则是宽依赖。每个stage处理的rdd数据，又会根据其有多少个 partition，运行相同个数的 task（每个task是一个线程），每个 task 只处理一个 partition 上的数据。所以一个stage也叫一个taskset。\n\n任务执行过程分4步\n\n# 解析代码中的RDD操作，根据转换关系形成DAG图\n# 将DAG图交给DAGScheduler组件（包含在SparkContext中）进行逻辑拆分，具体做法是从最后一个RDD向前回溯，遇到action算子切分出一个job，每个job内根据shuffle类划分stage\n# 拆分后的stage链，交给TaskScheduler（包含在SparkContext中）做物理执行，分派到具有空闲资源的worker结点\n# work对收到的每个调度，启动一个线程执行task，结果结果返回给TaskScheduler，最终在driver端汇总\n\n!!! 分区的解释\n\nRDD是个逻辑概念，它的数据通常会分布在多个worker节点，拆分的个数由partition决定，partition数量既可以大于，也能小于worker数量，计算一个真实有数据的partition对应一个task任务。分区的数量，如果直接创建，可以在参数指定，如果是从HDFS读取，则由文件分块数量决定，最小是2，大的有十几甚至上百。题外话，正因为数据是分散在多个worker节点，如果想要看到全貌，要用collect()，方法命名非常到位。\n\nRDD实现类举例\n\n# MapPartitionsRDD\n# ParalellCollectionRDD\n# ShuffledRDD\n# ReliableCheckpointRDD\n\n从RDD到DataFrame的转变\n--\nSpark最初只有RDD做为通用的计算接口，也称为Spark Core，并没有SQL功能。因为无类型，导致性能优化遇到瓶颈，在1.3版本演化出了DataFrame，天然和SQL相近，此时整个项目的核心也迁移到Spark SQL。为了管理库和表元数据，在SparkContext基础上，加入SQLContext（是个InMemory实现，2.0版本还有一个外部源实现HiveContext），就变成了SparkSession。session类有个catalog成员可以查看映射的库和表。SQL也是经由DataFrame最后转成RDD才执行。\n\n2.0版本只能指定一个catalog，3.0版开始支持multiple catalog。\n\nDataFrame\n--\n是Row类型RDD被绑定schema后的性能优化版。RDD用.toDF转化为DF（简单类型的RDD不可以转化为DF），每个DF也可以通过.rdd属性得到对应的RDD实例，通过.schema得到结构。多说一句，RDD的toDF方法，其实是构建SparkSession的时候，硬塞在RDD上的猴子方法，最终调用的还是SparkSession.createDataFrame方法。由于是从RDD转化而来，分区数和RDD一致。\n\n运行DataFrame算子，还是会编译为RDD后才真正执行，因此RDD仍是Spark惟一的运行时，可以将DataFrame比作编译过程的中间代码优化器。对开发者来说想要手写出和DataFrame编译成的RDD相同性能的代码，困难且无必要，因此社区鼓励大家迁移到DataFrame。","modified":"20200725121530000","tags":"data"},
{"created":"20190907121530000","title":"SQL的行转列与列转行","text":"\n!! 行转列\n\n指把键值关系表（如从BerkleyDB导入的数据），变成围绕一个中心元素的详细表（列通常会很多）。就从原始的很多行的KV数据，变成行数很少（因为有重复）但很宽的形式，所以叫行转列。case when和group by是典型写法\n\n```\nselect name,\n  max(case course when 'math' then score else 0 end) math,\n  max(case course when 'phy' then score else 0 end) physical\nfrom rel_score\ngroup by name;\n```\n\ncourse列被case多次，从而实现从窄表变成宽表。我把这种一个列变成多个列称为影分身，行转列一定伴随着影分身。\n\n!!! 利用Hive的map类型实现 up 23.05.06\n\n需求是从轨迹表，计算出每个实体在每通道的每小时出现总次数。\n\n第一步先得到行表： `GROUP BY id, channel, from_unixtimestamp(captime, 'yyyy-MM-dd HH')` 。注意GROUP BY只能支持expr，不能用alias，所以最后的udf结果不能as，需要在SELECT时候重新写一遍再as hh，不确定会不会优化掉。\n\n第二步对第一步的行表再做一次 `GROUP BY id, channel, substr(hh, 1, 10)` 接着在SELECT中，使用collect_list(substr(hh, -2) || cnt)把小时标记，和每个小时的次数拼接成array。接着再用str_to_map(concat_ws(array))把array变成标量的map值。得到包含 id, channel, map 的行表，此时的map有最小1个最多24个kv对，已经基本达成目的了。\n\n最后一步就是从map分别取出24小时，再用nvl将不存在的值转成0。\n\n整个过程中，最难想到但也最妙的自然就是第二步，利用collect_list这个UDAF函数再结合map类型，将每个分组的内容放在一行内，使一维行表具备更高维度的内容（但似乎也破坏了范式？），从而为最后一步平铺准备好了素材。不过这个方法强依赖引擎，像SQLite只能支持group_concat一种UDAF，并且没有map类型。勉强能用group_concat构造出json，也能凑合实现，但不如Hive这么方便。\n\n!! 列转行\n\n指把定义很宽的表（即列很多），变成每行只有A、B键值对的形式。经过这样的转换，行的数量会大大变多，所以叫列转行。union是典型写法\n\n```\nselect name, 'math' course, math as score from lika\nunion\nselect name, 'phy' course, physical as score from lika\norder by name, course;\n```\n","modified":"20190907121530000","tags":"data"},
{"created":"20211222121530000","title":"SQL的JOIN种类与选择","text":"\n!! JOIN关联和WHERE谓词\n\n关系代数鼓励把重复的数据拆分，必然导致查询时要把分开的表再合并起来，这个合并的动作在关系代数里称为JOIN连接。连接分交叉连接（再细分出内连接）和外连接（再细分出左连接、右连接、全连接）。很重要的区别是交叉连接时，两张表是对等关系，而外连接有关注表和补充表的区分。回顾一下SQL规范，\n\n* SQL89时没有明确的JOIN语法，而是用逗号实现CROSS连接。\n* SQL92时，出现JOIN。由于CROSS JOIN的语义就是笛卡尔积，因此不能有ON条件；而INNER JOIN是笛卡尔积的过滤，必须有ON条件。但MySQL实现得不规范，CROSS，INNER是等价的。JOIN是INNER的简写形式，自然也等价。此时的外连接语法是在从表后面带上`(+)`\n* SQL99出现了LEFT和RIGHT连接，而且允许多张表用多个JOIN语句分段写，可读性更好。也因此目前常见的写法都是按SQL99写的\n\n交叉连接可以简写为 FROM a , b，结果是所有连接中最大的，实际应用一般都会选INNER，即带了ON条件。**外连接必须有ON语句**。一开始我经常把ON语句误写作WHERE，看其他人的代码，也发现这种错误，说明这对SQL掌握不深的人来说，可能是普遍现象，详细剖析下这两个关键字的语义区别。\n\n从简单的单表查询可知，WHERE是对结果表做过滤的谓词。JOIN动作是针对两张表的笛卡尔积，为了满足只取特定的JOIN结果，引入了ON谓词，专门用于多表JOIN过程中的判定，所以虽然WHERE和ON后面都可以跟比较语句，但两者的作用阶段是不同的。如果不用ON，只用WHERE最终也能得到正确结果，但是理论上一定会带来性能的额外开销：前面提到WHERE是针对单张表，意味着JOIN必须生成所有的结果集，得到这个结果集后，才能做WHERE过滤，这就会导致中间结果集过大，而ON恰恰能解决生成结果表过程匹配的问题。另外前面提到了优化器会把WHERE动作前置，但是并不会把WHERE条件作用于JOIN的过程中，所以说ON是JOIN的伴生动作，而WHERE是完全独立的另一个阶段，这两个阶段的顺序可以调换，但绝不会融合。\n\n连接首先分交叉连接和外连接，两者结果的约束是很大的。交叉连接的结果数是两张表的积，而外连接则是以一张表为准。\n\n外连接细分了LEFT、RIGHT、FULL这3种连接，LEFT OUTER JOIN可以简写成LEFT JOIN。左右只是方向不同，只需要实现一种就可以。左连接后面的限定条件*可能不生效*，结果既包含符合满足限定的连接行，也包含不满足限定的左(或右)行，这些不满足限定的行会由NULL来填充。这正是NULL必须存在的理论依据。所以即使表定义的某列规定了NOT NULL，但在连接结果还是会出现NULL，无法避免。两张表的LEFT JOIN的意义不太明显，如果有多张表会更好理解。\n\n考虑学生选课场景，学生和课之间是多对多的关系，表s记录了学号和学生的详细信息，表c记录了课程信息，表sc记录了学号和课程号的关联，如果要还原出学生姓名和课程名字，用这句\n\n```\nselect s.Name,C.Cname from student_course as sc left join student as s on s.Sno=sc.Sno left join course as c on c.Cno=sc.Cno\n```\n\n在计算过程中，用sc表作为左连接的左表，先替换学生信息并保持住课程的信息(暂时还无意义)，等第二次左连接的时候，用课程信息替换掉上一次左连接的内容，最终的select结果中不保存sc的任何内容。\n\n!! JOIN的实现算法\n\n有单机和分布式，但是单机是基础，如下3种\n\n# Nest Loop Join: 最简单但性能也最低，拿左表的每一行，从右表循环匹配，复杂度O(MxN)。过程中可以利用右表的索引来加速。\n# Sort Merge Join: 将两张表分别进行排序，然后再扫描的时候，因为顺序已经固定，所以就不需要做全表扫描，因此连接的复杂度是O(M+N)。不过考虑到对两张表排序的成本, 不能过分乐观。\n# Hash Join: 将小表的joinkey和关联内容提取出来，对joinkey列做hash，得到中间表保在在内存，对大表做scan并按同样的hash去内存中找到匹配记录\n\n对于常见的等值连接来说，如果小表的内容足够小，都会采用Hash的方式。要注意的是，这个足够小，并不是仅指joinkey，而是要把关联的内容一起算上看总大小。\n\nNest Loop尽管复杂度高，但在不等值连接的时候一般都用这种方式，因为Sort Merge要求表必须做排序，而排序的成本不低，所以权横后还是会选择用的Nest Loop。\n\n分布式场景怎么又增加了shuffle和broadcast这两种策略，和单机版组合理论上一共有6种策略。但是spark放弃了broadcost和sort merge组合，比hash性能不足，能力上又不如NestLoop，因此最终就只有5种策略。\n\n!! semi和anti\n\n这两种都是从子查询优化中演化出来的，也间接说明原生几种join的表达力不足。\n\nleft semi join表示半的语义，具体有这几条\n\n# 只能select左表数据，这也是semi最核心的含义\n# 结果不会受右表关联重复数据的影响，从第一点可以看出，右表只是用于关联，不参与结果构建，也就不会导致重复\n# 必须搭配left/right其中一种，不能单独semi，否则无法确定取哪一半\n\nanti表示的反，等效与先left再取右边为null，但写起来方便。可以left anti join，也可以直接t1 anti join t2取t1有而t2没有的数据。\n\n这两种更像子查询优化而不是独立语义，所以没在标准中找到，但部分实现会支持。","modified":"20211222121530000","tags":"data"},
{"created":"20190808121530000","title":"SQL语言梳理","text":"\n!! 历史脉络\n\n首先说一下这帮人当时都在IBM，大概因为大规模的数据应用主要的受众是商业公司，刚好和IBM主业匹配。Codd在1970年发表了关系代数论文，引发IBM在1973年立项System R来研究可行性，然后Donald Chamberlin和Raymond Boyce于1974年发表了SEQUEL语言，但因命名重复所以改名为SQL，Boyce在发表论文后不久死于动脉瘤，后来的荣誉都给了Chamberlin。在这期间Jim Gray确立了事务机制、粒度锁系统和隔离级别。差不多时间，Berkeley的Stonebraker开发的Ingres系统用的是QUEL语言，直到后来他的学生开发Postgres后才换成SQL语言。以上这些人中，除了SQL论文的成色稍次，其他3人都获得了图灵奖。在之后的1975年，台湾的Peter陈品山，发表了虽然不是基于关系模型，但对业界影响很大的ER模型论文。\n\n!! 理论依据\n\nSQL背后的理论支撑是集合论、关系代数和一阶谓词逻辑（Codd的原始论文曾设想二阶谓词，因太复杂放弃了）。操作的结果是封闭的，即输入和输出都是关系，这也是查询的结果可以作为插入动作的输入的原因。在时间的发展上，关系是在层次模型和网络模型之后提出的，它的目标就是避免出现地址概念，达到彻底的逻辑和物理分离。因此SQL语言没有变量（地址）的概念，AS只能表达不可变引用。\n\n由于关系代数是三值逻辑，SQL继承三值逻辑后，计算中就必然会存在NULL（严格地说是NULL有未知和不适用两种含义，最原始的也是四值逻辑，但后来被合并，所以仍是三值）。NULL并不是值，只是一个用于填充的标记，所以对它做比较是无意义的，只能IS NULL判断。NULL在计算时会引发propagate，甚至NULL/0也是NULL。AND和OR等短路运算时，NULL的优先级介于TRUE和FALSE中间，即TRUE OR NULL = TRUE；FALSE AND NULL = FALSE。\n\n虽然很多时候都提倡用NOT NULL，但由于NULL的概念根植于SQL的底层，在外连接或CUBE/ROLLUP的GROUP BY时，还是会不经意间引入NULL。\n\nSQL基于的关系代数，严格的说是Relation Bag Algebra，并不是Codd最原始的Set定义，差异在于Bag允许关系数据重复，而Set的数据必须唯一，所以有DISTINCT和ALL这类关键词来指定结果要set或bag。但是SQL和关系代数有几个很不一致的地方，比如SQL的SELECT对应的关系代数是PROJECT，SQL的WHERE和HAVING才对应关系代数的SELECT。\n\n关系代数的核心操作只有5种，分别是并、差、积、选择、投影，操作的都是元组。所有的SQL语句最后都能用这5种操作组合完成。比如一个嵌套子查询可以等价转换成一个连接（join）操作。UPDATE操作看起来是对字段(Attribute)的修改，但严格来说，是用一条记录替换掉原来的记录，本质还是行级。\n\n!! 功能分类\n\nSQL规范定义了几种不同领域的操作，使用的指令不同。虽然最常见的是增删改查，但从完整的BNF方法列表来看，其它几种分类占的比重更大。\n\n* DDL - 数据定义语言(CREATE，ALTER，DROP，DECLARE)\n* DML - 数据操纵语言(SELECT，DELETE，UPDATE，INSERT)\n* DCL - 数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK)\n\n对语法有疑问时，查BNF定义是最好的，比如查询语句后面如果是子查询必须有别名，但如果是关联就不需要别名，似乎也没什么理由，就是文法这么规定的。\n\n!! 表达式类型\n\n* 表表达式：对表的操作，FROM、WHERE、GROUP BY、HAVING\n* 条件表达式：专门用在WHERE表达式，有AND、OR、IN、LIKE\n* 标题表达式：如各种算术运算符、CASE\n\n!! 值语法和类型\n\n所有的值都是用圆括号`()`包起，可以出现在很多位置，比如VALUES后的字面量，或是FROM后的子查询，甚至在SELECT、WHERE等出现变量名的位置。值有两种类型，标量和集合。\n\n!! 查询的顺序\n\nSELECT查询涉及众多关键字，最核心的有3个：JOIN、WHERE、GROUP BY。执行顺序并不是从前到后，正确的顺序如下\n\n* 7 SELECT 8 DISTINCT 10 TOP NUMBER\n* 1 FROM 3 JOIN\n* 2 ON 4 WHERE\n* 5 GROUP BY 6 HAVING\n* 9 ORDER BY\n\n在不影响结果的前提下，优化器对顺序会做微调，比如 FROM a LEFT JOIN b ON a.x=b.x WHERE a.name=x and b.age=x，WHERE的a语句会先执行，再做JOIN，最后再做WHERE的b语句，术语叫Predicate Pushdown Filter。因为对LEFT JOIN来说，将右表的过滤放到JOIN前，不会影响JOIN的条数，这就和WHERE原始的后置语义不同，因此不会被优化；如果想优化也很简单，将WHERE中对右表的过滤，放到ON条件来做。\n\n!! 横向与纵向操作\n\nSQL是对关系的操作，这种操作有两个方向，横向的代表是JOIN，而纵向的代表是GROUP BY。JOIN内容太多，单开一篇讲。\n\n!! GROUP BY 层级和阶\n\n引入了谓词逻辑中阶(order)的概念，最明显体现在GROUP BY上。一但用了GROUP BY，操作对象就由0阶的行，变为1阶的集合，不同的阶需要用不同的谓词去操作。典型的WHERE操作0阶的行，而HAVING操作1阶的集合，其背后是有严格的理论支撑的。\n\nGROUP BY后可跟一到多个关键字，将集合按这些关键字形成子集，每个子集内只含一种这些关键字值的组合，此时其它值也在，但因为阶变了，不能显示地查看其它值明细（换句话说，其它值都在子集内，但不能直接查看），但是部分数据库提供了`group_concat`函数，将所有明细值表示成一个字符串，相当于把明细值做了聚合。\n\n!!! 高级分组cube和rollup\n\n先看这个语句`GROUP BY a,b GROUPING SETS ( (a,b),a)`，怎么理解？相当于`GROUP BY a,b UNION GROUP BY a`。在这个基础上，再来看cube和rollup。\n\n`GROUP BY a,b WITH CUBE`等效于GROUPING SETS( (a,b), a, b, ())，会严重膨胀。\n\n`GROUP BY a,b WITH ROLLUP`等效于GROUPING SETS( (a,b), a, ())，从左向右下钻。\n\n!! NULL的比较与排序\n\n排序时如果有多个字段，可以为每个字段分别指定ASC或DESC，默认升序ASC。原理上NULL是不能排序的，在max/min函数也会忽视NULL值（除非数据全部是NULL），甚至count如果指定列名，而这里面如果有NULL值，也不会计入总数。但是ORDER BY的时候，NULL值会在结果里显示出来。排序的结果是实现相关，主流的几种数据库行为分为两派\n\n* NULL比任何值都小： 包括MySQL、SQLServer、SQLite，表现出的行为是，ASC时，NULL值最前，DESC时NULL值最后\n* NULL比任何值都大： 包括Oracle和PostgresQL\n\n为弥补未定义NULL排序的缺失，SQL规范增补了NULLS FIRST或NULLS LAST关键字，通过放在ASC或DESC后来改变行为，遗憾的是只有Oracle、PG以及3.30版本后的SQLite支持。\n\n!! 索引\n\nwhere条件如果是OR，索引不起作用。联合索引符合最左原则，即索引是A,B,C时，支持A或AB或ABC，其它没有作用。\n\n!! 窗口函数\n\nSQL99规范定义了窗口函数，反而最常见的MySQL直到8.0版本才支持。窗口函数有点类似GROUP BY，但由于它是函数，并不会改变结果的阶，因此可以作用在每一行上。\n\n窗口函数有两大类：聚合函数和排序函数，聚合函数和GROUP BY类似，也是SUM、MAX这些，但可以添加到每一行上。\n\n排序函数用得比较多，有ROW_NUMBER、RANK、DENSE_RANK，结合分组能知道在每个分组内的顺序，进而做一些分析操作，这是GROUP BY不具备的。\n\n!! UDTF与侧视\n\nSQL处理二维表，意味着列只能是标量。但如果列就是矢量，或者想作为向量用，就引入了UDTF和与之配套的LATERAL VIEW语法。\n\n设想一条记录，主键是身份证，接着一列手机号，该列的定义是逗号隔开的字符串，怎么转换成每行一个手机号呢？\n\n首先用split把逗号拼接的字符串向量化成array，但这时还是在一行里，要进一步用explode把这行炸开，但是UDTF炸开后的值是个Table，不能用select，所以就要用如下语法\n\n```\nfrom t\nlateral view explode(split(col1, ';')) table_identify as col11\nlateral view explode(split(col2, ',')) table_identify as col22\n```\n\n直观解释一下，对一张表t，选择其中若干行炸开，所以取名lateral横向view关键字，紧接着跟一个UDTF函数产生的临时表，带一个临时表别名，这个表别名的可见范围只在lateral view这行，多行可以取一样的别名，因为最终要的还是列，所以要as一个列名，给最外层的SELECT用。每次炸开都会触发一次行级别的笛卡尔积，炸开列越多性能越差。\n","modified":"20190808121530000","tags":"data"},
{"created":"20170115121530000","title":"SQLite的扩展机制","text":"\nSQLite的基本单元是table及配套的view和index，如果要扩展功能就要使用virtual table机制，常见的有Full Text Search，\nJson和CSV等。\nvirtual table只是概念，要实现需要module，看`sqlite3_create_module_v2`函数实现。通过`sqlite3_compileoption_get`函数可以看到使用版本中被编译了的模块。\n\n如果想实现一张全文索引表，这样写 `CREATE VIRTUAL TABLE enrondata1 USING fts3(content, tokeniz=porter);`\n\nfts3就是一个module名，被创建的虚表用USING来继承一个已经实现的module，\n这个virtual table就具备了fts3这个module具备的全文检索能力，使用MATCH关键词的匹配速度快很多。\n\n全文检索最核心的要素是分词器，即tokeniz指定的值，不指定则默认simple，不过至少要用icu才能处理中文。这种方式创建出的表，如果用.schema去看，会对应另外3到5张普通的table，3张是fts3和fts4共有，加了content、segdir、segments后缀的表。fts4则多两张start和docsize表，称之为Shadow Table。\n\n要关注的类型就int64,double,text,blob这4种，还有个null类型，但是以前看过一本书强烈地批判了SQL规范中纳入null这种不严谨类型的坏处，所以我想还是尽量少用为妙。\n\nSQLite最晚在3.15版引入了json扩展函数，但至少3.6版是没有的，也许SQLite的演化就是加入这种新功能吧。不过虽然代码有，默认是不编译的，需要定义宏才能把这些特性编译进来。创建一张表的时候，可以在最后用\n`primary key(a_key, b_key)`这种方式指定两列为联合主键。\n\n如果就用gcc sqlite.c编译，通过`sqlite3_compileoption_get`只能看到3个选项：\nCOMPILER、SYSTEM_MALLOC和THREADSAFE=1。其它高级特性都需要定制宏打开。\n看的方法很简单，打开SQLite输入`select sqlite_compileoption_get(n)`就能看到。","modified":"20170115121530000","tags":"data"},
{"created":"20190121121530000","title":"SQLite分析","text":"\nSQLite指针是个很大的结构，包含vfs和Db结构。允许attach特性，可以同时有多个数据库，因此DB成员是数组，每个DB的最关键结构是BTree，最终读写OS上的磁盘页。\n\n使用Btree是针对磁盘的惯用法，m阶B树表示每个节点最多有m个出度，又叫分叉。因为m很大所以深度就浅了，相当于用内存多查几次换磁盘IO。B树另一个特点是至少有m/2个出度，原因同样是保持树尽可能浅，让树每一级承载的信息多一些。不取更高是考虑到有插入，太满的话旋转次数过多，因此要折衷。作者曾试图换成LSM Tree开发v4版，但最终停掉这个计划，大概是因为LSM太占内存，而在小型化场景一方面没有这么多内存，另外保障数据尽可能快地写入磁盘也是很重要的，结合来看B-Tree仍是最好的选择。\n\n管理每个存储数据的是pager，每个节点称为page，page大小一致，新数据库可设置，一旦持久化就不能改变。一定是2的幂，界于512到65536之间（在17和18字节表示，1表示65536）。\n\n第一页比较特殊，前100字节格式包含Magic Number，页大小，版本等。创建一个只有表定义，但没有数据的库，占2K，共2页，第一页是`sqlite_master`。\n\n表用B+树，数据只存在叶子上。索引用B树，所有页都有数据。展开一下，如果数据用B树保存，在条件检索时，结果数据会分布在不同层级，这就导致很多的磁盘随机访问，对机械硬盘非常不友好，SSD稍好，但仍然是连续访问优于随机访问。因此最终选择了B+树。页内最小单元是cell，每页头部是指针，尾部是内容，中间全为0，添加数据直接用中间区域，速度很快。\n\n!! lua与sqlite整合\n\n依赖userdata，因此一定配合newmetatable函数，元表关联ud实现在lua中无缝使用的体验。引申一句，通过newmetatable创建的表内部仍是通过newtable创建，只是这个表一定有名字，且名字会被保存在表的`__name`字段。另外元表也会记录在C的`LUA_REGISTRYINDEX`大表中。\n\n动态库入口创建4个元表，分别是对db的操作，对prepare产生的vm的操作，对context的操作，以及backup操作(需要两个db实例)。然后用`register_lib`创建动态库，这个库除了查版本外，就是创建db。\n\n!! 测试数据\n\n* 5万条: 查整数的耗时只有5毫秒左右，定长31字符串的LIKE查询在15毫秒上下。\n* 10万条: 查整数不超过15毫秒，字符串LIKE查询30毫秒。\n* 30万条: 查整数不过30毫秒，字符串LIKE查询80毫秒。\n* 150万条: 查整数140毫秒，字符串540毫秒。一旦开启索引，查整数5毫秒。\n\n索引占空间的大小取决于类型，150万条100M左右的库，整数索引增加16%，字符串索引增加95%（由于数据主体是字符串，可以认为翻倍）。\n\n即使做了字符串索引，似乎效果也不好，完全匹配的速度并没有提升，一旦用LIKE的后置%，速度降低到1/10。如果前后都有%，**索引完全不起作用**，耗时变为2.5倍。\n\n字符串建索引，对第一次不生效，但似乎会对结果做缓存，第一次查字符串，会耗时300毫秒，同样条件再查询不再耗时。作为对比，不开索引的库，始终耗时200毫秒。\n\n无索引查字符串，第1条0毫秒，中间第75万100毫秒，最后的150万200毫秒，非常严格地符合线性关系（要加limit 1，否则会全遍历耗时是一样的）。","modified":"20190121121530000","tags":"data"},
{"created":"20160204121530000","title":"SSH点滴","text":"\n!! 验证方式\n\n从日志能看到3种验证方式，debug3: preferred publickey,keyboard-interactive,password。后两种表现上都是密码输入，区别是password是RFC-4252(sec 8)定义的，而keyboard在RFC-4256定义。理论上keyboard会询问用户各种问题，但从实现角度看，只用了密码一种方式。所以两种不同的规范看起来就像一样了(甚至xshell面对keyboard模式能自动输入密码)。两者都可以在`sshd_config`中独立控制，keyboard是KbdInteractiveAuthentication(也可以不设置，用ChallengeResponseAuthentication)，password是PasswordAuthentication。\n\n使用的加密套件是一直在加强的，遇到过用15年的dropbear连接20年的版本，会报没有合适的mac套件，如果是openssh可以加`KexAlgorithms diffie-hellman-group1-sha1`强制允许不够安全的加密方式。\n\n!! 公钥登陆\n\nTinysshd不支持用户名密码登陆(甚至还删除了RSA公钥，只支持ed25519)，又比如安卓的用户体系被裁剪，只有PubkeyAuthentication。部分魔改的安卓程序可以支持用户登陆，比如dory的nodejs，就支持将密码做了SHA256的值保存到~/.ssh/doryauth，不过不是通用做法。\n\n首先使用ssh-keygen -t rsa -C \"your@email\"工具产生公私钥对，会提示输入passphrase，这是私钥的一个密码，相当于做了二次的保密。如果是生产环境，这个私钥的密码是必须要设置的，我用在内网和虚拟机比较多，再说用公钥登陆本来就是为了方便，所以暂时先不设了，但从安全性角度看，为私钥加个密码，在私钥丢失的时候，还是很有作用的。除了rsa还有dss, dsa, ecdsa, ed25519等很多方式，从7.0版本开始默认不再支持dss。\n\nSSH2版本的公钥文件格式有IETF SECSH(似乎又叫SSL PEM)和OpenSSH两种格式，SSH1已经看不到，不去管它。\n\n* SSL PEM: 文件内容以`-----BEGIN RSA PUBLIC KEY-----`开头，以`-----END RSA PUBLIC KEY-----`结尾\n* OpenSSH格式: 从OpenSSH 7.8版本(18年7月)开始作为默认格式，内容全在一行，以ssh-rsa开头，rsa可以换成其它加密技术\n\n命令执行后，生成密钥对，分别是私钥id\\_rsa和公钥id\\_rsa.pub(算法不同名字会有差异)。需要把公钥上传服务器你想登陆的用户名目录下。\n把生成的公钥文件id\\_rsa.pub上传并导入ssh服务器的用户目录下的~/.ssh/authorized\\_keys文件(OpenSSH和Dropbear都是这个文件)。这样服务器的配置就完成了。补充一点权限相关内容，.ssh目录需要0700权限，而authorized\\_keys则需要更严格的0600权限。\n\n为什么上传公钥呢，因为公钥是你发送给运维的，当然不能含有密码，从这个角度看，私钥是更不能外泄的。\n\n接下来就是配置客户端了，只要能拿到RSA私钥的关键数据(即N、E数)，私钥的文本格式不重要。选用putty或SecureCRT的作法稍有不同，\nputty用的格式比较特殊，需要使用puttygen这个工具把ssh-keygen生成的id\\_rsa转成.ppk后缀的文件，\n不过这不影响私钥的数据。如果原始的私钥是带passphrase，puttygen在转换时也会要求输入原始密码，如果输入正确，可以修改密码，\n如果输入错误，则是无法转换的。passphrase是用sha256加密，所以puttygen实际上是无法得知原始密码的。当然转换后保存的也是经sha256计算得到的值。**如果用命令行ssh，一定要保证id\\_rsa以LF结尾**，出现过误将回车符保存成CRLF，导致ssh报错Invalid format。如果本地有多份id\\_rsa私钥，用-i选择指定。虽然默认会用当前用户名路径下的id\\_rsa，但不代表绑定当前用户名，比如从A机器用u1用户登陆B机器的u2，即使私钥文件放在u1的目录下，只要指定了登陆B用u2用户，私钥就会和u2目录下的公钥匹配。*私钥放在哪里，并不代表绑定哪个用户，但公钥放在哪个用户的目录下，是绑定该用户的*。\n\n到这步，公钥和私钥都准备好了，怎么在登陆时让putty自动找到私钥呢？putty对不同的ssh服务器有个session的概念，首先load需要登陆的服务器session，在Connection->Data菜单的Auto-login Username输入登陆的用户名，\n这样就能在服务器对应目录下寻找公钥，然后在Connection->SSH->Auth的Private key file for authentication中配置转换好的.ppk私钥路径。最后把这些改动save到putty的session中。之后对这个session直接点击open，就可以用公钥方式登服务器了。\n\n**归纳起来就是：先用ssh-keygen生成公私钥，公钥上传sshd服务器，私钥指定给ssh客户端。**\n\n在配置了公钥登陆后，甚至可以禁止密码登陆方式，修改/etc/sshd/sshd_config文件，PasswordAuthentication no。默认允许密码认证。\n\n为了方便使用公钥，专门设计出了ssh-agent和ssh-add这两个程序。首先用ssh-agent $shell启动代理，代理会在/tmp用域套接字监听，然后用ssh-add添加私钥，如果有phrase则输入，代理就得到了私钥。之后再连接远程就不再需要输入私钥的phrase。\n\n主流的生成公私钥对工具是ssh-keygen，偏偏putty提供了类似的puttygen，但格式又不同，生成公私钥对后，千万不要用save public key按钮，因为openssh不识别这种文件格式，需要把窗口中的内容复制出来。\n\n用termux时遇到了server refused our key的错误，折腾再三，将`/usr/etc/ssh/sshd_config`内容加上这几句。似乎0.73版本后没有问题。\n\n```\nPasswordAuthentication no\nPubkeyAuthentication yes\nAuthorizedKeysFile ~/.ssh/authorized_keys\n```\n\n通过看putty的log，了解公钥认证的流程。网络连接和加密算法协商之后，putty会从私钥中生成公钥并发给服务器，如果配置了该公钥，服务器会返回接受该公钥。然后putty再发送公钥的签名，签名也被接受后，就进入Access Granted状态。打开一个session，得知agent-forwarding port-forwarding pty user-rc x11-forwarding这些属性，设置pty的速度，双向都是38400kbps，至此会话建立成功。\n\n结合以上的流程，可能失败的原因是缺少最后一句配置，指定公钥文件保存的位置。对sshd来说，收到putty提供的公钥，如果不知道去哪里找，显示会refused。但是对多用户系统是否也能这么写？怀疑应该是可以的，因为即使是公钥登陆，也必须指定用户名（公私钥对和用户名没有关系）。有了用户名，sshd就能从~映射到对应的用户目录。\n\n!! keygen的使用\n\n* ssh-keygen -y -f 私钥  # 从私钥计算公钥，可用-yf\n* ssh-keygen -l -f 公钥  # 从公钥计算指纹，可用-lf\n\n!! 隧道\n\n平时用ssh感觉永远是连上远程主机并打开shell，其实只有加密连接远程主机这步不可缺少，在远程主机上打开shell是个默认行为，如果选择不打开shell，这时连接已经建立，就可以利用这条加密连接做些其它事，这就是隧道（又叫端口转发，因为是基于ssh的端口，工作在TCP层）。\n\nssh连接建立后，双端配合启动隧道功能。隧道在客户端打开，所以是ssh在监听，而sshd负责消息转发。以L本地转发为例，客户侧的程序ClientProgram和ssh间是明文通信，ssh和sshd之间当然是密文，到了服务端的sshd侧，再按明文发给预设的端口，就完成了隧道的使命。\n\n因为ssh原本的任务就是加密并在server端启动shell进程，隧道无非是把启动shell改成向另一个指定端口转发消息，和整个流程是契合的。\n\n!! 认证代理\n\n使用公私钥登陆时，如果所有主机用同一个私钥还好，但现实往往不同主机配不同私钥，ssh只认`id_rsa`一个名字（算法不同名字不同），这就导致要手动指定私钥。为解决这个问题，就有了ssh-agent和ssh-add这套方案，可以一次性手动把所有私钥通过ssh-add加到agent，如果私钥有passphrase，只要在add时输入一次，只要agent不挂，以后不用再输入，这样看起来私钥带上passphrase也并不麻烦。但有点让我介意的是，即使退出终端agent并不会结束，下一个人或者其他人登陆这台主机，可以可享agent规则登陆所有你登陆的主机，只是无法知道passpharse。虽说并没有更多的权限，但总感到有些不妥。\n","modified":"20160204121530000","tags":"security"},
{"created":"20190926121530000","title":"SSL和SSH比较","text":"\n两者都是常见的安全术语，安全包含四层含义\n\n* 数据加密，即抓包不可读，看上去是乱码，这个最好理解，也最直观\n* 数据完整性，这是第二个层次，即数据虽然被加密了，但万一被人篡改了怎么办？又或者数据没有收发完整怎么办？数据完整性解决的就是这类问题\n* 身份验证，这是第三个层次，刚接触安全的话也许不会注意。虽然数据加密了，也有完整性校验了，但怎么知道发消息给你的人，就是你期望的人？直白的说类似证明**你妈是你妈**，比喻可能不太合适，但目的是一样的。\n* 不可抵赖性，A做过的承诺，只要做了数字签名，就无法反悔。\n\n二者都能很好地完成前两层，但只能SSL可以实现身份验证。由于ssh自身没有认证，所以ssh和Kerberos的结合就是顺理成章的事了。Kerberos用于解决一套大系统内的身份识别、数据加密。因此在使用场景上存在很大差异。\n\n!! 协议背景\n\n从名字就可以看出使用了不同的协议。解决的是两点间的加密防窥、互信。SSL和SSH都是基于公钥认证，SSL的出发点是让客户端确保服务端是可信的，而SSH反过来，让服务端确保客户端可信。尽管理论上SSL也扩展了互相认证的机制，但实际中我还没有见过SSL这方面的应用。\n\nSSL是会话层协议，其上可以承载各种其它协议，典型的比如HTTPS，我在公司做过一个私有协议全链路加密也是over SSL的。SSL的版本有V2、V3(V1版本因为存在重大安全缺陷，并没有公开过)。后续则更名为TLS，从V1.0->V1.1->V1.2->V1.3。因为SSLv3的漏洞被证明不再具备安全性，至少也是从TLS起使用比较好。SSLv2版本的协议和v3之后的格式上有很大不同，因此OpenSSL代码里特地有一种称为v23的方法，就是使用v3可以回落到v2。至于v3到TLS则沿用同样的总体结构(采用TLV格式)，版本号也一脉相承地从0x0300到0x0304。\n\nSSH是个特定应用的协议，就我所知仅远程终端操作，隧道和文件传输功能。仅有v1和v2两个版本，而且v1已经几乎绝迹。我想不明白为什么SSL的版本一直在演进而SSH却不动了。\n\n!! 交互流程\n\nSSL采用客户端主动发起模式，交互采用Client-Hello、Server-Hello、Change-Cipher等过程。\n\nSSH在TCP连接建立后，Server端和Client端互发一段明文字符串消息SSH-2.0-xxx，xxx代表软件名字，不规定发送顺序。接着Client Key Exchange Init的流程。SSH在交互开始，服务端会把自己的公钥（注意：不是证书）给客户端，客户端工具会提示用户，第一次客户只能选择相信，如果想长期使用，就写入`known_host`文件，所以客户端不具备认证服务端的能力，只能识别变化。使用的工具和版本不同，协商算法不同，指纹也会不同，比较新的版本会协商出ssh-ed25519，老版本是ssh-rsa，dsa或ecdsa。算法生成的公私钥长度从大到小顺序RSA > DSA > ECDSA > ED25519（严格的说，RSA私钥比DSA长但公钥短，另两个全方位得短）。不管哪种都表示成MD5或SHA256值，很难记住。ssh-keyscan专门用于探测公钥，也是ssh2e协议但message code略有不同。\n\nssh协议在进入加密传输阶段后(ssh-keyscan得到公钥就结束，不会进入这个环节)，每个包结尾都会带上mac验证数据，带宽无法百分百的用于传输，但为了校验完整性，这点损失只能接受。\n\n!! 身份验证\n\nSSL为了证明服务器是真实可信，需要给出服务器一些信息才行，便是经常听到的数字证书。直观的可以这么理解，你去拜访某个大佬，但又不知道是不是被人乔装，于是你向面前这位大佬采集了指纹，接着把指纹发到公安局，询问是否是本人，公安局如果给出肯定的答复，就可以放心地聊下去了。\n\n证书包含公钥和一些持有者的信息（比如域名、公司名等），与之对应的必然有一个私钥文件。两者构成了SSL服务端的必备文件。如果用OpenSSL工具生成的话，后缀名是.pem。pem可以通过普通的文本编辑器打开，是RFC1421定义的一种格式，首行和尾行是标示文件类型，中间部分是经过Base64之后的数据，因为这个特性，可以通过cat命令把多个证书文件串在一起也是可以使用的。解码后的二进制数据是符合规范，通过OpenSSL的对应命令字可以看内容。比如\n\n* openssl x509 -in 公钥名.pem -noout -text\n\n可以看到数字证书的公钥、签发者等信息，把x509换成rsa，再打开私钥文件则可以看到RSA的公私钥和计算因子。\n\nssh不具备证书功能，因此ssh-keygen只能生成公私钥对。openssl和ssh-keygen生成的私钥格式一样，但公钥格式差别很大，好在ssh-keygen可以把openssl的格式转换成ssh的，详细看ssh-keygen的-m选项。\n\n!! TLS密钥的来源\n\n文件内容是对称加密，其密钥采用会话加密机制，不会重用。这个密钥的生成机制有3步\n\n# premaster key。客户端生成随机数，用服务端的RSA公钥加密后传回服务端（先不考虑DH方式）。这里还有个要点，premaster的前两位是TLS的协商版本，一旦服务端解密后发现这个版本比client hello的版本高，说明会话被劫持，可以拒绝协商，防止降级攻击。\n# master key。联合premaster key和客户端、服务端互换的随机数，一共3个随机数，生成固定长度的密钥。（猜测是用hash机制）\n# session key。以master key为种子，通过密钥衍生算法，生成最终的加密密钥。","modified":"20190926121530000","tags":"security"},
{"created":"20160601121530000","title":"SSL杂记","text":"\nSSL和OpenSSL的关系，就好比C++和Visual C++的关系。OpenSSL是业界公认的烂代码，但也许是出来比较早，在江湖上已立稳了脚跟，因此尽管有很多人不爽，但毕竟现有项目大量的依赖，就我所知的一些fork项目都是采用头文件兼容，而重新实现的方式，也许若干年后OpenSSL会变成一个接口标准，那也是后话了。\n\nOpenSSL库在Linux下就一个文件，而在Windows下是分为libeay32和ssleay32两个文件，其中libeay是和加密算法相关的，包括AES、RSA、MD5等，而ssleay则是SSL握手、网络收发数据相关，因而需要依赖于libeay。取这么怪的名字是因为最初的作者是Eric A. Young而得名。\n\n用vc6编译openssl，自带perl脚本生成makefile，但还是有很多遗漏，有两点\n\n# ms目录下有个文件要加no-asm，否则自带的汇编文件在vc6的masm无法编译，类似编nginx也遇到过md5和sha1有使用汇编的选项，大概hash类算法规律，用汇编效率提升明显。\n# 编译要加’__i386__'选项，否则编crypt库会有链接错误，原因不明国内网站没有答案，是在英文站上看来的，不确定是否ssl部分也需要。\n\n!! 实现SSL连接(PHP为例)\n\n在我的安卓手机上运行PHP，由于域名解析机制不知什么原因，无法正常工作，只能先在PC上解析出IP，用PHP的socket机制完成连接。如果是HTTP连接使用\"tcp://ip\"的方式，再手工构造HTTP的GET请求，网页的内容就拿到了，如果是HTTPS则麻烦一点。\n\n首先PHP支持\"ssl://ip\"或者\"tls://ip\"，虽然看起来是不同的协议，但至少我安装的PHP环境发起的Client Hello请求都是TLS1.0(请求包头是16 03 01)，但是握手结束PHP会报类似这样的错误 `Peer certificate CN=`example.server' did not match expected CN=`ip'`\n\n原因是TLS连接时服务端会发送它的数字证书，证书的CN(CommonName)记载的内容和请求的IP地址不符合。\n\nfsockopen是PHP4时代的接口，设计时并没有考虑传入SSL连接的选项，到了PHP5，提供了整套Stream Classes，包括了socket、context、filter、bucket等完整的网络连接设施。这些中可以用`stream_socket_client`函数，配合最后一个参数`stream_context`。使用`stream_context_create`构造一个不做检验的TLS请求(内网很多证书都是自签名，必须要跳过)，构造语法array('ssl' => array('verify_peer_name'=>FALSE, 'verify_peer'=>FALSE)); 同时关闭验证证书和CN。这里的verify_peer_name是配合peer_name选项，允许用户对站点设置指定名称。\n\n题外话，不同的语言都提供类似的操作，比如Go提供了InsecureSkipVerity:true关闭校验。默认情况会提示x509: certificate signed by unknown authority。\n\nSSL_connect并不关心证书校验，成功返回后可以对SSL结构体进一步分析，有60多种X509_V_ERR_的定义，对DEPTH_ZERO_SELF_SIGN_CERT会网开一面，否则不予承认这个连接。\n\n注意必须是二维的array结构，而且这里只能是ssl，如果传入'tls'无法构造合法的context。一切准备妥当就可以完成SSL握手了，接下来在这个连接上发送HTTP的GET请求，对读和写数据来说就是透明的。\n\n`stream_context`由option和parameter两部分组成，option除了前面提到的ssl，还有socket/http/ftp。parameter目前我只看到一种notification，用于设置回调，在`STREAM_NOTIFY_*`事件发生时触发回调。context不仅能用于stream，也能用于fopen和`file_get_contents`。\n\n再来分析TLS握手流程，从数据上看客户端发送的数据要远小于服务端回复的数据，大约是\u003C1K和5K这个量级。原因是服务器会带回完整的证书和cipher list，而客户端只做验证并选择一个cipher方式，因此数据量才会有这么大的差距，其中光是Server Hello中的Certificate环节的内容就长达2960字节。握手结束服务器会生成session ticket，长度192字节，有效期18小时。","modified":"20160601121530000","tags":"security"},
{"created":"20160214121530000","title":"stackless和stackfull概念在VM上的一些理解","text":"\n以前知道有个stackless的python实现，但不明白是什么意思，看一篇分析Lua虚拟机的文章也提到了这个概念，就做个记录。\n\nstackless python的意义在于不需要C语言的call stack作为python的堆栈，因此CPython又被称为stackfull的实现。由于依赖了C语言的堆栈，必然对实现有了限制，典型的就是多线程之间需要Global Interpreater Lock，导致实际的单线程。又比如yield的一层限制。再比如GC就很难用tracing方式，而只能用引用计数方式。Lexical closure也没有实现，而是保存变量的引用，因此Python有个Vyper的OCaml实现，解决的好像就是这个问题。\n\n反观Lua的虚拟机实现，基本上是stackless方式的实现，摘一段奇异技术点博客的分析：基于虚拟机的语言的call stack有两种可能的设计，一是称为stackfull方案，借用Host主机的stack，Byte－Code的函数调用比如Call指令对应native代码的函数调用，即X86的call指令，这种情况下，虚拟机stack随Byte－Code函数调用层次的增加而增长。二是stackless方案，由虚拟机维护额外的call stack数据结构，Byte－Code的函数调用和其他指令一样，在虚拟机的同一个循环中完成，虚拟机的stack不体现Byte－code函数的调用层次。\n\nLua虚拟机的stack，存储在lua_State结构的StkID stack字段中，是个数组，包括函数指针（Lua和C都可以），函数的参数和返回值，Lua函数的局部变量。但在stack字段缺少C代码stack的东西，如C语言的call stack，函数的返回地址，帧指针栈指针EBP、ESP信息。那么这些信息保存在哪里呢？ 其实Lua虚拟机是双stack结构，保存在CallInfo＊ ci这个字段里。CallInfo结构保存了函数位置，这个函数可以是Lua或C。当Lua作为caller时，返回地址保存在CallInfo的u.l.savedpc里，如果C函数作为caller，返回地址在VM stack。C函数发生yield时，VM的stack被破坏，该coroutine下次resume的地址由u.c.k决定。\n\n所以对yield设计来说，相当于在整体stackless的Lua虚拟机设计中导入一个额外的stackfull，也因此Lua51要求C语言的yield必须在return时调用，只有这样，才能很好地衔接stackless和stackfull两种结构。就好像GC，在Lua整体采用的是root－tracing，或名mark and sweep方式，但为了方便C语言操作，也提供了`luaL_ref`／`luaL_unref`的引用计数方式让C语言影响虚拟机的工作状态。","modified":"20160214121530000","tags":"lang"},
{"created":"20211226121530000","title":"SU的执行过程与用户登陆机制","text":"\n起因是在ssh中执行\"su xx;whoami\"被卡住无法返回，于是看了源码后解开疑问。\n\nsu切换用户的核心逻辑如下\n\n```\nfork();\nif (pid==0) {\n  setuid();\n  exec(command);\n}else {\n  wait();\n}\n```\n\n解读一下就是su会创建子进程，父进程会等待子进程结束才会返回，而子进程默认执行的命令是登陆shell然后开始等待用户输入，对于ssh远程执行命令的我们来说显然不是想要的，办法就是\"su xx -c 'command'\"，利用-c选项指定子进程要执行的命令，执行完结束回到主进程，就不会阻塞远程执行了。\n\n在分析的过程中，又引申出一些新的点\n\n如果一个用户在passwd配置的是nologin，执行su会报错，原因同上，默认不带参数触发了调用shell，但用户又是nologin，于是报错。这种用户只是用于配合特定软件执行功能。\n\n计算密码用到的crypt函数在unistd.h和crypt.h都有声明，但是只include unistd.h编译会告警，执行更是会core dump。原来是unistd.h被条件宏保护起来，于是编译器找不到声明，默认返回int，这就和定义不符，进而导致执行时core dump。","modified":"20211226121530000","tags":"os"},
{"created":"20200125121530000","title":"tags的说明和比较","text":"\n通用编辑软件用于代码有两个点，看时方便跳转和写时方便补全，跳转靠的就是tags。\n\ntags有两种主流实现ctags和etags。ctags诞生于BSD系统，是vim能原生识别的格式，而etags是emacs的附属品。两者生成的文件格式不同，但ctags能生成etags的格式，似乎ctags使用更广，emacs上有插件能识别ctags格式。\n\n不同语言的要素不同，ctags有相应的选项来识别，从而更好地跳转。默认什么都不加也能工作，显然加上会更精准。识别要素有3种类别\n\n# kinds: 用--list-kinds=xx 显示默认会识别哪些元素，如果要调用，用--xx-kinds=+-yy 选项\n# fields: 比如 i 表示如果有继承，要标明父类； a 表示如果是类的成员，要标明其public/private属性； S 表示如果是函数，要标明函数的signature；\n# extra: 默认只包括函数的名字，不包括类名，用了--extra=+q会有类名\n\n早期的tags只包含definition，universal ctags已具备简单的reference功能，外围配套还不是非常成熟。\n\n!! 文件格式\n\nctags是纯文本文件，每行是一条记录，原始的vi格式很简单，`{tagname}\u003CTab>{tagfile}\u003CTab>{tagaddress}`，定义标签名，所在文件，所在行的完整内容(ex模式)。当编辑器触发跳转定义时，从tags文件找到匹配的行，并解析出对应的文件名，再根据最后的模式精确定位到行，核心功能很好理解。vim对行格式做了增强，在原来行的末尾增加`;\"\u003CTab>{tagfield}...`，其中`;\"`会被vi识别成注释，保持兼容性。后续内容是type\u003Ctab>key:value，type是单字母形式，kv对可以有多个。\n\netags由多个section组成，每个section对应一个源文件。段间和段内含有少量不可打印字符，绝大多数仍是文本。段与段间由两行`\u003C\\x0c>`分隔，然后是文件名和tag的字节数，接下来也是每行一个tag定义，`{tag_definition_text}\u003C\\x7f>{tagname}\u003C\\x01>{line_number},{byte_offset}`，和ctags相比，由于直接保存行号和偏移，在尺寸上etags要小很多，但是如果对一个在编辑中的工程来说，增加内容导致行号变化，会使etags失效，而ctags方式的按文本匹配会更健壮。","modified":"20200125121530000","tags":"tool"},
{"created":"20180423121530000","title":"TCP的状态与nc的理解","text":"\nTCP的状态多达11个，4个连接7个关闭。之所以会这么复杂，是因为TCP作为双向全双工协议，读写端是完全独立的，建立连接的过程不区分，所以相对简洁一些，一旦连接建立后，分化出读写两个管道，要关闭这两个独立的管道，会经历不同的状态，显然复杂度会翻倍。调用close()只能主动关闭写管道，读端会被动一些。\n\n| 写关闭状态 | 说明 | 读关闭状态 | 说明 |\n| --- | --- | --- | --- |\n| FIN_WAIT1 | 发送FIN给对端，关闭写道道 | CLOSE_WAIT | 收到FIN，关闭读通道 |\n| FIN_WAIT2 | 收到对方的ACK，但还没收到对方的FIN | LAST_ACK | 读端Only，收到FIN后自动触发close进入该状态，并等待ACK，网络中断时才会出现 |\n| TIME_WAIT | 收到对方的FIN | | |\n\n还有两个状态是读写端都会有\n\n* CLOSING  本该收到对端ACK却收到FIN，发ACK给对方，就会进入最终的CLOSED\n* CLOSED  收到FIN后再过2个MSL才可以彻底关闭\n\n说完TCP的双工性，来看看nc，从它的简述`Concatenate and redirect sockets`能看出，nc也是利用了socket的双工性再连接了shell的stdin/stdout，实现了像反弹shell这样的魔法。","modified":"20180423121530000","tags":"net"},
{"created":"20190613121530000","title":"TeX学习笔记","text":"\n到现在TeX还有价值的至少有3块\n\n# box-and-glue model\n# hyphenation algorithm\n# line-breaking algorithm\n\n要分清几个概念\n\n* 引擎: 执行程序，用得最多的是 pdftex(越南人写的)，最近比较新的有 xetex, luatex，这些都符合TeX标准。\n* 格式: 后缀 .fmt，是一组经常用的宏包，往往编译后把内存的dump出来，下次直接加载减少启动时间\n* 宏包: 文本格式的宏指令集，没到通用的程度，但各种类型的文档多少会用到\n* 编辑器: 比如WinEdt之类包装引擎的输入工具\n\ntexlive包含的文件至少8000个以上，为了快速寻找文件，引入kpathsearch库，依赖 texmf.cnf 文件。\n\nTeX本身很基础，所有的功能都依赖宏包。文件分为三类：run files, doc files, src files。其中 run files 是编译时使用的文件（包括宏包的 .sty, .cls 等，字体的 .tfm, .pfb 等）；doc files 是说明文档；src files 是源代码（如宏包的 .dtx-生成文档, .ins-真正的代码 等，字体的 .mf 文件等）。文档和源代码部分在安装 TeX Live 的时候是可以选择不安装以节省空间的。","modified":"20190613121530000","tags":"tool"},
{"created":"20190105121530000","title":"TinyScheme的运行过程","text":"\n其前身是MiniScheme，代码量不到2500行，大量使用全局变量，风格算不上好，但对于trace来说很方便。\n\ncar和cdr是lisp系最典型的特征，通过宏包装后，在C层面大量使用。为了减少分配碎片，一次性先分配连续的内存，其中每个元素典型的tag value风格。每次分配或释放都会将cdr指向正确的位置。\n\n```\nstruct cell{\n  tag;\n  union : {\n    struct pair {\n      cell* left;\n      cell* right;\n    };\n  }\n}\n```\n\n虚拟机运行中，共用到4个寄存器。args, envir, code, dump。其中dump值得一说，可以将它等效地认为是C语言的栈。顺便说句cadr的读法是从右往左，先cdr再car，取第2个元素，习惯表示记住就行。\n\n运行前先将args设置为pair，car是待运行的文件名，其它3个寄存器为NULL。\n\n第一条指令是LOAD，接下来是T0LVL，此时会把envir绑定到global env，这个阶段只是准备，所以命名为0。然后会依次向dump保存VALUEPRINT和T1LVL，由于cons队列属性，后保存的先被取出执行，而T1LVL实质就是eval，到这里就已经构成了LOAD(就是READ)，EVAL，PRINT的完整过程，加上外层的无限循环，整个REPL就完备了。\n\n因为初始化的时候，往往把常用的放在前面，但保存的数据结构也是cons,导致搜索的耗时会变长，似乎逆序是更好的选择。\n\n有3个在执行中很常用的宏，`s_goto`，`s_save`，`s_return`。goto直接更改op并进入下一次循环，save和return要配合dump寄存器保存所有的状态。`s_save`将op, args, envir, code,倒序挂在dump前面，`s_return`会将当前求得的值保存在value(也叫`ret_value`)，然后从dump中以save的逆序取出4个元素，赋值给op, args, envir, code。此后dump就回到上一次状态，类似x86的push esp;push ebp;和pop指令，最终的目的都是要保证栈平衡。return比save多一步赋值value也好理解，因为已经把这次的求值结果保存在value了，接下来就是取下一个op，这时可能会用到value。在`OP_DEF1`的结尾就是return，之后从dump中取出op，但是如果注释掉了`OP_VALUEPRINT`语句，堆栈就不平衡，导致下一次eval时op是乱码，引发程序崩溃。\n\n典型如(define a 3)这句，先READ，发现是左括号，进入RDSEXPR，读到ATOM后，先save一个RDLIST，再goto到RDSEXPR，所以看起来会有两次连续的RDSEXPR。每次RDLIST都会从上一步的RDSEXPR得到value，依次是define, a, 3。读完之后，这3个元素就构成一个完整的list，进入EVAL开始求值。\n\n由于只有闭包，函数定义和对象的类型是一样的。car是code，cdr是env。普通的函数env指向global，对象的cddr是global，cdar是其upvalue。code的car是参数列表，cdr是行为，通常是lambda。在闭包合成的过程中，被绑定的参数被挂接到global前面，从而在求值时就可以先找到。\n\n看个示例\n```\n(define (bi a)\n   (lambda () (+ a 3)))\n(define c (bi 1))\n```\n\n函数定义bi是这样\n\n![def](/img/scm-def.png)\n\n生成的闭包c是这样\n\n![closure](/img/scm-clo.png)\n\nglobal由于始终按向car上挂接，非常不平衡，是个优化点。","modified":"20190105121530000","tags":"lang"},
{"created":"20190901121530000","title":"traceroute原理和ICMP","text":"\n项目中遇到ping返回time to live exceeded，即TTL超出，展开讲讲。\n\nping是基于ICMP协议，它是附在IP协议的数据段的一种应用协议，可以类比为HTTP之于TCP，由于是二层协议所以没有端口。IP协议共20字节，专门留了1个字节表示TTL，源端在发出时会预设一个值，比如64或128，每过一跳就减1，归零时如果还没到dst就会报ICMP错（不管请求的是TCP或UPD甚至就是ICMP协议）。目的是防止IP在路由的过程中遇到环，通过这种方式阻断循环路由。\n\nIP层的典型协议编码\n\n* ICMP: 1\n* TCP:  6\n* UDP:  17\n\nICMP有8字节头，如果是request再多32(windows)或48(android)字节的无意义数据。\n\n利用IP的TTL特性，可以检测到dst的所有节点。原理就是依次从源端向dst发出TTL只有1、2、3...的ICMP包，TTL为1的包在第一个转发节点会回复ICMP错，TTL为2的包在第二个转发节点回复ICMP错，直到最后一个成功到达的包，通过这种方式就能得到dst的完整链路。\n\n额外说下，正常要发送ICMP要用`SOCK_RAW`，但apple的系统要用`socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);`。\n\n!! 实战连接github\n\n在Alpine的虚拟机中，git clone失败，问题分析后记录如下。\n\n最开始怀疑是路由错误，但包可以下载说明不是这个问题。又尝试ping 163仍然失败，看来是DNS问题，虚拟机的路由 /etc/resolv.conf 改为家中路由的地址，可以ping通163，但github仍失败。\n\n浏览器可以上github，说明没被墙，用独立的域名解析网站分析，对应多个IP，逐个尝试发现部分可以部分会超时。说明浏览器会尝试多次，而命令行只试第一个。\n\n在/etc/hosts手动加入条目解决。","modified":"20190901121530000","tags":"net"},
{"created":"20140307121530000","title":"UDP广播多播和IPv6记要","text":"\n!! 广播与多播\n\nUDP的socket才有的特性，其中广播是socket级的特性，需要setsockopt时指定SO_BROADCAST选项，而多播是IP级的，比如加入一个多播组，用的是`IP_ADD_MEMBERSHIP`和`IP_DROP_MEMBERSHIP`。\n\n为什么一个是IP级，另一个是socket级，大概是因为广播包一定会通过IP层，直到UDP层才会做处理，因此用SO前缀；而多播地址是D类网段，加入多播组时，网卡会知道，会在网卡级收到消息时就过滤，连驱动层都不能到，更别说UDP层了，所以用了IP为前缀的选项。\n\n广播时socket如果要接收，要先将自己绑定到INADDR_ANY和广播的端口，一旦感知到消息再通过recvfrom从`INADDR_BROADCAST`的相同端口接受数据。发送则不需要绑定，直接sendto到`INADDR_BROADCAST`的约定端口就可以了。广播的接收与发送因为地址只有一个`IPADDR_BROADCAST`，所以只能靠端口区分，接收端也必须作一次bind。\n\n多播是与地址相关，只要bind地址就可以了，和端口关系不大，之所以现在的代码都要绑定地址和端口，是因为历史上Solaris对多播要求必须做端口的绑定，所以后来的代码出于跨平台的考虑，都加入了端口绑定。\n\n加入多播组有三个选择，IP_ADD_MEMBERSHIP，`IPV6_JOIN_GROUP`和`MCAST_JOIN_GROUP`。前两个是与IP协议版本相关，不能混用，而MCAST是协议无关，使用的地址结构体也要大得多，至于功能是一样的。\n\n!! IPv6\n\n源和目的地址从32位扩大到128位，分为高低两个64位，高位表示网络类型(单播/组播/任播)、子网标识，低64位则表示网卡地址，可以由MAC地址计算。加上其它的控制标志，IPv6的报头从20字节扩大到40字节。\n\nMAC地址48位同样分为上下两个24位，高24位是厂商标识，低24位则是网卡标识。从最高位开始数的第7、8位有特殊的含义，第7位如果是0表示IEEE分配，如果是1则表示本地分配。没见过是1的，第8位是0表示单播MAC，1表示组播MAC。当发送广播包时，会在发送前把MAC地址的第8位改成1，静态情况下通过ifconfig无法看出来，只有运行期抓包才能发现。由于第7和8都是0，所以正常12数字的MAC地址的第2个数字一定0bXX00即4的倍数。\n\nIPv6的socket默认可以接收IPv4的连接请求，除非显示打开`IPV6_V6ONLY`选项。所以如果用netstat看到只监听v6端口，不妨先尝试v4的连接。","modified":"20140307121530000","tags":"net"},
{"created":"20180813121530000","title":"UDP和相关操作","text":"\nTCP属于有连接协议，所以一定需要有bind操作。服务端显式bind，客户端在connect时会内OS隐式bind。一直不确定UDP要不要bind，正好有同事问起组播和单播如果监听同一个端口，如何区分。查看代码才知道UDP的bind在这种场景就有意义了。\n\n先说广播，把0xFFFFFFFF通过bind和UDP的socket绑定，最好再用setsockopt(SOL_SOCKET, SO_BROADCAST)配置。\n\n如果是组播的D类地址段，范围是[0xE0000000, 0xF0000000)，在这个区间内，绑定后用setsockopt(IPPROTO_IP, IP_ADD_MEMBERSHIP)方式加到组播组。\n\n单播的socket和网卡的IP地址用bind关联。\n\n如果是一张网卡要同时收UDP的单播和组播，对这两个socket都做一次setsockopt(SOL_SOCKET, SO_BINDTODEVICE)。把地址和eth0这样的网卡名关联上。\n\n顺便再谈谈选项分类。可以看到有SOL_XXX和IPPROTO_XXX这两大分类。上面没有列出的，还有SOL_IP、IPPROTO_TCP等。SOL的层级比IP和TCP都高，广播数据直到UDP才会被处理，和在IP层处理的组播不同，因此选项前缀也不一样。\n\n广播的地址有4种，工作中我只用到了全为1的受限广播，只有主机号全为1的广播地址没有接触过。","modified":"20180813121530000","tags":"net"},
{"created":"20190223121530000","title":"Unicode的若干概念","text":"\n可以把Unicode想成一本字典，规定了每个文字的映射(严格的说有些带声调的文字是组合出来的)。ASCII的删除键DEL编码是0x7F，在打孔机时代把字母全部重置，如果没见过纸带怕是理解不了的。\n\n欧洲文字ISO8859定义了16个分部，但是要混打德文和俄文就不行了，于是2022规范引入了ESC转义规则，这套规则后来也被用在JIS和GB上。\n\n截止1999年前，CJK统一汉字的范围是4E00-9FA5，用了基本面的20901个符号。后来又补充了若干编码，大多在基本面，少量在0x20000面，都是很少见的字。不严谨地说，用4E00-9FA5是足够用的。\n\n首先每个字符是不是等宽，于是就有了宽字节和多字节的区分。宽字节的好处是查找统计反转方便，而多字节由于是变长，保存拉丁字母会省空间。因此宽内存多用于内存中的计算，而多字节用于存储或传输。Windows的API就是宽字节版。\n\nBMP之前的宽字节方案，就称为UCS2，多字节编码是UTF8。随着UCS2不得换为更大集合，出现了UCS4方案，Windows为了保持和UCS2的兼容性，于是有了UTF16编码。它选取了UCS2一段不用的编码段来标识。而这个段的范围是1024x1024。这个范围等于17x65536，也就是现在字符集范围的来历。\n\n!! 正则匹配\n\npcre库为适应Unicode，加入了`\\p`选项，支持pUnicode类名和p{Unicode}文字名两种模式。比如想匹配广义的数字，用`/\\pN+/`，想匹配中文，用`\\p{Han}`不用指定编码区间，全部交给底层文字引擎就可以了。\n\n!! 代理项对sorrogate pair\n\n最初的1.0版本定义65536的集合大小，称为BMP。但是2006年中国要求所有软件支持GB18030，这个范围就不够了。这时就从BMP中把D800~DFFF这段区间保留下来不单独表示任何字符，专门用于转义扩展。这个区间又叫S区，共2048个字符。\n\n转义时，D800到DBFF表示高10bit，DC00到DFFF表示低10bit，于是又能多表示16x65536个字符，再加上BMP。整个Unicode范围17个位面就是这么来的。","modified":"20190223121530000","tags":"protocol"},
{"created":"20160522121530000","title":"Url Rewrite和PHP路由的初步认识","text":"\n使用PHP开发网站，最基本的做法是将Url路径指向某个php页面，然后通过GET或POST方法向这个页面传递参数来实现。如果是GET方式，Url通常是这样(POST因为Url上看不出什么，不在本篇讨论之列)：\n\n* web.site/index.php?key1=value1&key2=value2\n\n这种风格比较基本，但存在一些问题：\n\n# 如果Url固定后不允许更改(在大型系统内很正常)，则后期重构会受到限制\n# 代码实现时会不自觉地受制于这种模式，很难做到逻辑分离\n# 风格不够Restful，内容没有资源化\n\n因此我看到业界更提倡的方式，是转化成这样：\n\n* web.site/key1/value1/key2/value2\n\n显然这种Url是无法直接定位到PHP脚本的，必须要借助Url Rewrite。Apache和Nginx都支持Url Rewrite，除了可以通过配置文件进行设置，\nApache还可以在每个目录下通过.htaccess文件进行自定义，也更灵活。\n别小看了.htaccess自定义，如果你使用的是虚拟主机，根本没有可能去修改Web服务器的主配置，这时想做Url Rewrite，修改.htaccess几乎是惟一的方式。在.htaccess中配置这样一条规则 `RewriteRule !\\.(js|ico|gif|jpg|png|css)$ index.php`\n\n意思是把所有不是js、css等结尾的Url请求，统统重新定位到index.php文件。\n经过这一步，请求就进到PHP的处理领域了。这个index.php并不是通常意义上包含内容的首页，而是一个动态分发器。\n先把Url进行分解，这里你可以自定义分割符，最传统的是'/'，当然也可以用一些古怪的符号，不过我不建议这么做，毕竟会造成理解上的困难。\n如果有些虚拟服务商不允许改写web server的配置，也可以手动地使用index.php/key/value/param的Url风格。\n\n!! 超小型框架CEPHP的实现\n\n把Url分解成数组后，CEPHP的做法比较死板，取数组的[0]为class名，[1]为method名，后面的就做为参数传递给method了。做了这样的转换，后续就可以对数组如何创建对象做些重定向。\n\n通过Url得到class名，接下来的关键是如何实例化这个class。直接new一定会提示找不到类定义，就必须依赖语言的动态特性。这里岔开提一句，从表达力上来说比较公认的是Lisp > Ruby == Python > PHP。PHP在灵活性上能和Ruby比肩的也只有OO方面，而函数级别的魔性还是远不如Ruby的。\n\nPHP5支持`__autoload`函数，随后的SPL又定义了6个`spl_autoload`开头的函数，其中`spl_autoload_register`且于替代`__autoload`。它能接受一个string表示的函数名，在new的时候使用register的函数去寻找类的定义。除此之外用define给`CLASS_DIR`赋值，再配合`spl_autoload_extensions`也能正常地工作。\n\n说完了类，再说method。PHP的类支持包括`__construct`/`__call`在内的多种魔术方法。比如实现了`__call`方法，如果调用的方法不存在，就会fallback到`__call`的实现，然后根据第一个入参即方法名，可以决定要如何处理这个请求。这个特性在Ruby称为`method_missing()`方法。\n想像一下通过这个特性，像getByName、getById、getByAge这三种Url就可以只实现一个getBy方法，然后把Name、Id、Age作为参数传递到getBy方法中，非常简洁。\n\n!! YXcms的路由实现\n\n基于CanPHP的二次开发系统，路径使用index.php?r=default/column/index&col=demoshow风格，估计是为解决在虚拟主机上无法直接配置的缘故，方便一些小企业。index.php入口首先reqiure了protected/core.php并执行run函数。按顺序最关键的两个函数urlRoute和autoload。\n\nurlRoute将`$_REQUEST['r']`拆分成app/controller/action三级并用define函数保存，如果没有则分别赋予默认值default/index/index。app似乎是区分Mobile或PC。接着注入的autoload，定义一个array，其中包含9条类名到文件路径的映射。用foreach逐一匹配，一旦匹配就加载这个文件。为什么要设置这么多路径？一方面不会把所有的类放在同一个目录下，另一方面由于是二次开发系统，要保留原有框架的autoload机制，用多路径逐条匹配就成了很好的选择。最后用controller拼接上\"Controller\"作为类名，通过`class_exists`判断是否存在，存在则构造对象并调用action方法。默认的首页路径映射到indexController.php，它又层层继承向上5次才能找到根类，每次类声明时的extends语句，同样会触发autoload。\n\n默认的controller动作是display，需要用于模板引擎的知识，暂时放一放，从构造函数跟踪进去发现又new了baseModel类，最终使用了CanPHP的cpModel类。","modified":"20160522121530000","tags":"web"},
{"created":"20140523121530000","title":"UTF8编码规范小记","text":"\n看了Lua5.3的work2代码，从简单但个人觉得最常用的UTF8库看起，通过代码很快就明白UTF8的规则。\n\n以前看中文UTF8编码，总是奇怪为什么一定是0xEx打头的三个字节，比如“中国”这两个字的编码分别是：E4 B8 AD和E5 9B BD。如今明白UTF8的解析规则，这一切就很好理解了。说句题外话，Unicode的当前最大值范围是0x10FFFFFF(17个位面)，共有21字节，short类型表示不下。\n\n首先UTF8是照顾ASCII编码的，毕竟人家是老前辈了，所以第一个字节在0x80以下，UTF8的解析规则就直接结束。如果是大于等于0x80，则最高位1后的1的个数表示后面还跟着几个字节，这些跟在首字节后的字节数据，术语称为continuation byte。因此欧洲编码占用两个字节，则首字节一定是0xCx(110x xxxx)，而CJK的编码占用三个字节，首字节必然是0xEx(即1110 xxxx)。如果不符合此规则，则为非法。\n\n首字节的规则看完了，接下来说continuation byte的约束，代码是这样写的：\n```\nif ((cc & 0xC0) != 0x80)  /* not a continuation byte? */\n        return NULL;\n```\n也就是说，continuation byte的值范围一定是在0x8*~0xB*之间(必须是10** ****)。由于continuation byte的范围被限定了，能表达的有效位数只有6位，每个字节的低6bit被按序组装成完整的值，就可以得到对应的Unicode值了。\n\n附更全的考古\n\nRob Pike 在 2003 发的邮件，讨论的是 UTF-8 编码诞生之初的故事。Rob 和 Ken 是 UTF-8 的共同发明人。读罢不仅深化了对 UTF-8 编码的理解，更为大师们的智慧所折服。现在整理成文分享给大家。\n\n故事是从 Plan 9 操作系统开始的。为了让 Plan 9 支持 Unicode (ISO 10646)，Rob 和 Ken 选用了 UCS 编码（标准制定的 16 位编码方案，后来扩展成了 UTF-16）。虽然使用了 UCS 编码，但对 USC 编码并不满意，原文是 but we hated it。当整个工作几近完成的时候（大约在 1992 年的九月份），X/Open 组织有人给他们打电话，让 Rob 和 Ken 投票支持所谓的 FSS/UTF 编码方案。Rob 和 Ken 提出要根据自己的经验设计一个更好的编码方案。X/Open 的人接受了这个提议，但要求尽快提交方案。吃晚饭的时候，Ken 在餐桌上就完成了编码规则的设计。回到实验室，他们给 X/Open 发邮件说明了新编码的设计大纲。X/Open 的人则回复说 Rob 和 Ken 的方案比他们自己方案更好，并且询问什么时候能实现这一编码。当天是周三，Rob 以为 X/Open 会在下周一开始投票，所以就保证说下周一给出完整实现。\n\nRob 和 Ken 当晚就开始编码，Ken 负责实现 UTF-8 编解码逻辑，Rob 负责改造现有的 c 库和图形库。到了第二天，编码工作就已完成，俩个人开始使用新编码对 Plan 9 上的文本文件进行转码。到周五，Plan 9 系统完全基于新编码运行了。Rob 和 Ken 称这种新的编码为 UTF-8。然后，UTF-8 改变了历史。\n\n根据 Google 2012 年的统计，当年 web 领域 UTF-8 编码的占比就已经超过了 60%。\n\n可是，Rob 和 Ken 为什么没有采用 X/Open 的编码方案呢？Rob 指出 X/Open 的编码方案和当时的好多编码一样，没有自同步这一特性，所以他们提出了 UTF-8 方案。我们会在下文解释这个自同步特性。\n\n为了把事情说清楚，Rob 联系 Russ Cox 查询当年的来往邮件。然后 Russ 真的找到了相关邮件，甚至还给出了 1992 年的邮件发送记录！邮件记录了 UTF-8 最早的设计方案。\n\nFSS/UTF 编码全称是 File System Safe Universal Character Set Transformation Format。为什么要考虑这个文件系统安全呢？因为在 unicode 出现之前，计算机普遍使用 ASCII 编码。UNIX 的文件系统使用 /，也就是 0x2f，作为路径分隔标志。另一方面，c 语言使用 0x00 表示字符串的结尾。而 ISO/IEC 10646 (Unicode) 制定 UCS-2 编码使用双字节编码，最多支持表示 65535 个字符（code point）。UCS-2 编码一定会出现某个字符编码包含 0x2f 或 0x00 情况。例如，「⼀」的 UCS-2 编码是 0x2f00，同时包含了 0x2f 和 0x00。UNIX 系统和 c 语言基本没法处理使用 UCS-2 编码的数据。如果非要使用 UCS-2 编码，那就只有一个办法——将老数据使用 UCS-2 转码。这显然不现实。\n\n所以 Rob 和 Ken 给新编码制定了几条指导原则：\n\n兼容历史文件系统，文件名不能包含 0x2f 和 0x00\n兼容现有程序，非 ASCII 字符编码不能部分包含 ASCII 编码\n与 UCS 编码转换要简单\n首字节需要指明后续字节长度\n编码格式不要浪费空间\n自同步\n前两条讲得是一个事情。ASCII 编码范围是 0x00-0x7f，新编码方案中非 ASCII 字符的编码序列不能包含 0x00-0x7f 范围的内容，不然现有的系统和程序会把这部分内容当成 ASCII 处理而导致混乱。\n\n第六条说的是错误恢复。简单来说，程序从文件的任意部分开始读取，可能只读到一个字符的部分编码字节，从而无法实别这一字符。但没关系，编码方案需要支持程序快速跳过有问题的字节，然后正常解码。\n\n这六条原则一言一蔽之，多快好省。\n\n最终的编码方案使用变长字节编码，不同范围的字符使用不同长度的字节编码，最多使用 6 个字节，可表示范围为 [0,0x7fffffff]。\n\n其中，ASCII 字符 [0x00-0x7f] 的编码方式与现有 ASCII 编码保持一致，已有的 ASCII 编码无需做任何改动。其他字符使用多字节编码。\n\n为了实现第一条和第二条原则，多字节编码的每个字节的最高位永远是 1，而 ASCII 字符编码的最高位是 0，所以从根本上杜绝了编码冲突。\n\n为了实现第四条原则，多字节编码以 11{1,5}0 开头。1 和 0 之间 1 的数量表示后续字节的长度（这里借用了正则的表示方式）。\n\n为了实现第五条原则，编码规定，如果一个字符的编码可以有多种表示方式，则选用最短的表示。\n\n为了实现第六条原则，编码序列的后续字节都是以 10 开头的。如果程序读到了受损的文件，只能有三种情况：1、当前字节最高位是 0，则是合法 ASCII 字符；2、当前最高两位是 11，则是合法的多字节编码；3、当前字节最高两位是 10，则是其他字符编码的一部分，跳过，直到读到最高位为 0 或最高两位为 11 为止。\n\n举个例子，汉字「吕」的 Unicde 编码是 U+5415，对应二进制为 0b0101010000010101，需要 15 bit，所以使用三字节编码，对应二进制拆成（从低位到高位）三部分，分别是 0b0101, 010000, 0b010101，再拼上编码前缀得到 0b11100101, 0b10010000, 0b10010101，对应十六进制为 0xe5, 0x90, 0x95。所以汉字「吕」的 UTF-8 编码是 0xe59095。\n\n完整的编码规则如下表：\n\nBits  Hex Min  Hex Max  Byte Sequence in Binary\n1    7  00000000 0000007f 0vvvvvvv\n2   11  00000080 000007FF 110vvvvv 10vvvvvv\n3   16  00000800 0000FFFF 1110vvvv 10vvvvvv 10vvvvvv\n4   21  00010000 001FFFFF 11110vvv 10vvvvvv 10vvvvvv 10vvvvvv\n5   26  00200000 03FFFFFF 111110vv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv\n6   31  04000000 7FFFFFFF 1111110v 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv\n最终 ISO 标准化的 FSS/UTF 编码方案可以从这里获取。\n\nIETF 也制定了 RFC3629 对 UTF-8 做了进一步标准化。RFC3629 制定的版本将 UTF-8 的表示范围限制在了 [0-10FFFF]，所以只需要 4 个字节就够了。标准原文\n\nRestricted the range of characters to 0000-10FFFF (the UTF-16 accessible range)\n如果大家对这个问题感兴趣，可以参考 Stijn de Witt 的这篇文章。此处就不展开讨论了。","modified":"20140523121530000","tags":"protocol"},
{"created":"20190209121530000","title":"vim的概念和配置","text":"\n!! 编译遇到的问题\n\n在cent6上遇到Python无法编译出动态库，只有.a库，这时编译vim的选项 ./configure --with-features=huge  --enable-python3interp=yes --enable-luainterp --enable-multibyte --enable-sniff --enable-fontset\n\n如果能编译出Python的so库，可以--enable-python3interp=dynamic，这种情况下vim的版本会显示python3/dyn，vim也会去找so库，对提高加载速度有一定帮助。虽然编译出来，但运行中还是报错undefine symbol `PyByteArray_Type`，网上找到解决方法export LDFLAGS=\"-rdynamic\"方式解决的。\n\n!! 模式\n\nvim最大的特色就是模式，也是和emacs比较时不能直接对比的地方。基础模式有7种，只不过像Select/Ex模式很少会用，最常用的有normal、insert、command。插入模式没什么特别，normal模式堪称移动的最佳实践，而command模式（或者说ex模式）则是真正进阶vim高手的必经之路，一切高级的批量处理，或是函数与脚本都是这个模式的扩展，至于快捷键，只不过是把ex模式的动作做了映射。在配置键绑定或命令时，要区分不同的模式。部分模式还有子模式，insert模式有Ctrl-X的自动补全子模式。\n\nnormal模式下有一种特殊的operator，包括原生的cdy和自定义命令，后面必须跟motion（更高级的叫法是文本对象，同样可以定制），使我们可以对文本进行任意操作。\n\nvim启动会依赖$VIM、$VIMRUNTIME、$HOME变量，其中$VIMRUNTIME默认是$VIM/vim{version}，而$VIM在unix是share/目录，在windows则是安装vim的目录。然后按某个顺序从这些变量指定的目录寻找.vimrc，这个文件可以不直接写内容，而是加载.vimrc.before和.vimrc.bundles脚本将不同用途脚本归类。\n\n!! 目录作用\n\nVIM的行为，受配置参数的调整。或者统称为plugin(Vim script file)。整个plugin体系的入口，就是.vimrc相当于C语言的main函数，或者脚本的主文件，.vim目录下的各个子目录，可以认为在一定条件下，通过require方式导入的。遇到比较多的目录有\n\n* plugin 相当于全局的加载，只要有文件就会加载\n* ftplugin 和文件类型相关的加载方式，需要filetype命令来打开\n* syntax 和语法相关的加载，需要syntax命令来打开\n* indent 缩进相关，也可以放在ftplugin，单独放只是为了更清晰\n\n这样看下来，这些目录的分类并不是vim强制要求，更像是社区的一种自发行为。对Vim来说就像个脚本解析器，以.vimrc为入口不断地导入关联的其它脚本，并运行在全局空间或Local Buffer上，进而达到高效编辑的效果。所以要相深入理解就必须明白Vim的脚本语法和内置规则。\n\n!! 概念和区别\n\nVIM的概念很多，要能清楚这些概念的使用场景和区分。\n\n值类型的概念\n\n* 变量: 有10种类型，用let/unlet定义和删除变量，*弱类型、强作用域、无块作用域*。有多个命名空间控制变量的作用域，通过前缀来区分。比如脚本的静态变量用s:name，VIM自定义的变量用v:name，局部缓冲用b:name，窗口用w:name，全局用g:name，函数参数用a:name引用等等。而函数的变长参数更可以用a:1，a:2的方式表示第一个和第二个参数。如果在函数scope外用l:varible会报错。由于源出ex，和shell类似，变量没有块作用域，意味着在条件判断中创建的变量，出了判断块依赖可以使用。\n* 选项: 有3种类型，VIM内置的一类特殊内部变量，刚学习的用户从修改选项开始。8.1版本的帮助手册显示有403个选项，不过有些选项如果编译时没有打开开关，是不能访问的，比如编译时用的python是3.6版本，而你电脑上是3.8版，就可以修改pythondll选项来适配。用set修改，用set filetype?/set syntax?查看，set syntax&恢复默认。也能用let &syntax=c方式来修改。\n\n动作类型的概念\n\n* 函数: 用function定义的一段功能，执行需要用call或eval方式调用，主要是作为插件的组成部分，如果要映射到按键，要用:call \u003Cfuncname>。\n* 命令: 用command定义并可以在Ex模式下直接触发，通用是插件开放给用户的接口形式，可以用map映射到按键，最终还是调用函数。\n\n其它\n\n* 事件: 还不了解\n* 组: 还不了解\n\n如果在终端显示乱码，可以尝试将lang目录改名甚至删除，将只显示英文不会有显示乱码的问题。\n\n!! 帮助系统\n\n有时某个查询的关键字会在多个分类下出现，比如@@既是一种操作，也是一个变量，直接:h @@只会出现操作的含义，这时就要:h variables再从这页单独查找。类似的options和内建函数也是类似做法。\n\n!! 缓存和窗口\n\n两者相近却大不相同，buf是真正具备文字内容的对象，而window只是展示buf的容器。所以两者的属性也不一样，比如localdir是挂在窗口，而非缓存，两者也不绑定，用:ls看到的是缓存列表，其中有隐藏的缓存，需要的时候开个窗口并用b\u003Cbuf-number>来关联这个缓存；也有些虽然只是一个缓存，却在多个窗口同时打开时。\n\n缓存有多种类型，默认是文件，不保存甚至不能正常退出，很多时候我们打开一个临时缓存只是作为展示，所以需要设置属性成nofile，除此之外还有很多别的有趣的类型。\n\n窗口同样有多种类型，不同类型的窗口可以同时存在，不同类型窗口在打开新内容时，会替换成新的buf。\n\n* 常规编辑窗口\n* 帮助窗口 :h命令显示内容的窗口\n* quickfix窗口 :copen打开的用于显示错误的窗口","modified":"20190209121530000","tags":"tool"},
{"created":"20210421121530000","title":"vim的扩展与插件","text":"\n!! 理念的区别\n\n扩展的最终目的，是把操作映射为脚本化的描述，说到这点不得不和EMACS做个对比。\n\nEMACS统一用函数表达，函数和变量在EMACS中体现得非常彻底，而vi由于其操作第一性，并不是每个操作都有对应的函数（比如说hjkl代表的移动，没有直接对应函数来表示这个行为，只能cursor间接实现）。VimL脚本实质是ex命令的集合，因为vi有多模式，操作要注意是在什么模式下进行（可以是normal或execute方式的动态化操作）。但是很多原来只是给人看的操作，通过`redir => var`方式，也能被变量捕获，进而获得一定程度的脚本化能力，这也是vim自身在演化过程做出的调整。\n\n因此VimL脚本的思路和EMACS不同，操作是交互式的，并不是所有操作都适应脚本化。比如移动窗口到下一个位置，对人有意义，但对精确的脚本作业就没有实质价值。VIM把所有的按键都赋予很高效的操作方式，脚本层面看起来就不一致甚至丑陋，而EMACS则在函数层面更一致，也导致经常要连续按多个按键才能触发一个动作。\n\n!! 脚本与扩展\n\n前面提到vi逐渐演化成今天的样子，所以脚本中有多种方式来触发动作，典型有3种\n\n# execute 动态执行ex模式的命令\n# call 执行指定函数\n# normal 输入操作指令\n\n扩展主要会用到以下3种方式\n\n# 快捷键，最终触发函数或命令（含自定义和内建命令）\n# 命令，触发内建命令或函数\n# 操作宏，似乎更像Ad-Hoc操作\n\n函数是一系列操作的批量作用，两者结合达成最终目的。\n\n快捷键最终都是映射到命令，所以格式一定要用`:call xx\u003CCR>`。即用冒号触发命令模式，再用回车结束。\n\n自定义命令即不需要冒号也不需要回车，前者是已经在命令模式，又因在命令模式一定会按回车，所以不用写回车。\n\n!! 函数参数\n\n必须明确写出参数个数，否则运行时报错而不是静默地处理为NULL，可变参数a:000的类型是list，即使不传值也会构造一个空list，先用a:0取得长度，再取数。静态函数由于最终被展开为`\u003CSNR_xx>`，不知道具体名字，所以特意引入\u003CSID>相对表示。\n\n!! 模拟的包机制\n\n官方只做了autoload加载，包机制是爱好者开发的，是沿着autoload的进一步封装。调用package#import函数，获得某个指定模块的字典对象，接下来就可以在这个字典对象上执行函数调用，看起来和常见的编程语言风格更接近。\n\n!! 插件原理\n\n由于支持写扩展命令，某人把他写好的扩展命令，用vim和用户交互的接口，包括命令、函数、\u003Cplug>键映射、事件代码的方式开放给别人用，便是个插件。\n\n插件是一个具有特定结构的目录。其中最重要的一级子目录是plugin目录，如果整个目录在vim的rtp列表中，则这个目录的plugin子目录内的每个vim文件（不管多深）都会在启动时被加载，但不确保加载顺序。这种加载方式只适合互相之间没有关联的场景，且也不能做到懒加载。逐渐地衍生出了autoload目录，autoload内的vim文件，只有在其它文件出现call xyz#abc()函数调用时，才会去加载autoload/xyz.vim文件，进而调用abc函数。有了autoload机制后，现在的插件几乎都变成了plugin子目录下仅有1个vim文件，其它文件都移到autoload目录按需调用。\n\n有些插件希望自己的加载顺序靠后一些，因此目录下如果有after/plugin文件夹，则这个文件夹内的所有vim文件至少会在plugin后面加载。\n\nplug是个单体文件，放在**runtimepath简称rtp**的autoload目录，必须命名为plug.vim，*必须小写*否则会找不到（原因从前述机制可以明白）。用`echo &rtp`查看选项值，如果不包含插件目录，配置`rtp+=your-dir`。这个插件用法是先调用plug#begin()，然后用Plug命令加载各种插件目录，最后执行plug#end()。原理是#begin()时会初始化g:plugs字典，在Plug时把各种路径写入这个字典，到#end()时，会遍历g:plugs，并source每个目录的plugin/ftdetect/after等关键目录下的所有vim文件，从而实现插件加载。\n\n!! 问题排查\n\n配置了若干插件，但是调整了一些文件后发现又失效了。现象是插件管理的Plug系命令有效，但Rainbow命令出不来，就要从插件的加载会依赖rtp路径，用echo &rtp发现我的配置路径并不在列表中，但Plug又是可用的，加载Plug之后rtp路径被修改了。由于最后加载的spf13.vim是抄的，搜索rtp没结果，再搜索runtimepath，果然用=把结果全部重置了，但并不影响已经载入的Plug命令。问题找到去掉赋值语句就行了。\n\n排查问题首先还是要对机制熟悉，再从现象反推各个环节。","modified":"20210421121530000","tags":"tool"},
{"created":"20201225121530000","title":"vim的自动补全","text":"\n自动补全有15种模式（:help ins-completion）。其中有两种的补全列表内容与另外两种相同，只是排序不同\n\n# 文字编辑用的 3 种:\n\n* K 模式    （Vim 默认: CTRL-X CTRL-K） -- 字典补全，查找字典文件中的匹配单词，组成补全列表\n* H 模式    （Vim 默认: CTRL-X CTRL-T） -- 分类补全，查找分类文件（thesaurus 文件）中的匹配单词，组成补全列表\n* S 模式    （Vim 默认: CTRL-X s）        -- 拼写建议\n\n# 自定义模式，通常要写函数的2种:\n\n* O 模式    （Vim 默认: CTRL-X CTRL-O） -- 全能补全，由一个自定义函数生成补全列表，又名omni-complete，和filetype绑定，在autoload路径下找{filetype}complete.vim文件并找到其中的补充函数，自带有10多种常见语言的补全实例。\n* U 模式    （Vim 默认: CTRL-X CTRL-U） -- 自定义补全，也是由自定义函数生成补全列表\n\n# 所有人都喜欢的4种:\n\n* n 模式    （Vim 默认: CTRL-N）        -- 关键字补全，查找 'complete' 选项指定文件中的匹配单词，组成补全列表\n* N 模式    （Vim 默认: CTRL-X CTRL-N） -- 关键字补全，查找当前 buffer 里的匹配单词，组成补全列表\n* 另外两种: p 模式与 P 模式，分别与 n 模式和 N 模式相同，只是补全列表中候选词的排序相反。\n\n# 程序员用的3种:\n\n* T 模式    （Vim 默认: CTRL-X CTRL-]） -- tag 补全，查找 tag 中的匹配单词，组成补全列表\n* I 模式    （Vim 默认: CTRL-X CTRL-I） -- 头文件补全，查找当前 buffer 和 include file 中的匹配单词，组成补全列表\n* D 模式    （Vim 默认: CTRL-X CTRL-D） -- 定义补全，查找当前 buffer 与 include file 中匹配的名称定义，组成补全列表\n\n# 特殊语境下专用的3种:\n\n* V 模式    （Vim 默认: CTRL-X CTRL-V） -- Vim 补全，查找 Vim 的命令名, 函数名等等，组成补全列表\n* F 模式    （Vim 默认: CTRL-X CTRL-F） -- 文件名补全，查找匹配的路径或文件名，组成补全列表\n* L 模式    （Vim 默认: CTRL-X CTRL-L） -- 整行补全，查找 'complete' 选项指定文件中匹配的整行内容，组成补全列表\n\n!! 插件解析\n\n以easycomplete使用为例，不同的语言定义不同的completor、constructor、gotodefinition、command指令。\n\n!! 问题\n\n遇到奇怪的问题，在vim环境下发现PATH变量和修改的路径一样，但是executable()只认原生的路径，最终仍要把程序移到标准目录才行。","modified":"20201225121530000","tags":"tool"},
{"created":"20170324121530000","title":"VPN概念解释","text":"\nVPN的本意是把来自不同子网的设备放在同一个子网内，构建虚拟网络。既然要并网，肯定要做身份认证，而PPP点对点协议天生就带认证属性，这也是家庭网络都是PPPoE方式接入。\n\n实现VPN的协议很多，举我所知的几种\n\n# PPTP  微软出的规范，RFC2637。必须基于IP或TCP协议(至少要3层网络)，加密密钥最高支持到128bit，强度比较弱，甚至在iOS10的时代直接被苹果给抛弃了，但是因为是微软自家的东西，又出了SSTP后继，好像没什么人在用\n# L2TP  思科提出，RFC2661，广泛使用\n# IPSec 用XAuth认证用户，model config分配IP。由于XAuth有版权且没有标准化，兼容性不如L2TP。运行在用户态的IKE daemon和处理实际IP报文并运行在内核态的IPSec协议栈，不同的OS实现不同。\n# IKEv2 iOS10去掉PPTP后，新支持的类型。特性是IKEv2的MOBIKE(见RFC4555)扩展，VPN建立后切换网络(如从4G到3G)不会掉线。另外认证也支持EAP，比IPSec只支持XAuth好像更高级\n# OpenVPN/ShadowSocks/V2Ray 这些更多的是穿越工具，分类上有些并不属于VPN，也没有RFC标准，一般都只是某个开源软件的实现，因此Android/iOS系统都需要额外安装对应的客户端软件，系统本身不自带\n\n!! L2TP\n\nLayer 2 Tunnel Protocol的缩写，Layer 2这里指的是PPP协议，通俗地说，就是为了运输二层协议PPP而存在的。L2TP因为有PPP，负责AAA，也就是认证、授权、计费（Authentication, Authorization, Accounting）。除了IP网，还可以跑在ATM, MPLS, 帧中继等网络。由于L2TP 传输安全性太差，于是人们在 L2TP 外层再套一个 IPSec 来保证传输过程的安全性，传输HTTP的话就是这样一个层级\n\n```\nIP/UDP(4500)/ESP/UDP(1701)/L2TP/PPP/IP/TCP/HTTP\n```\n\nIPSec使用ESP加密，除上面介绍的传输模式外，还有另一种方式IP/ESP/UDP(1701)/L2TP/PPP，也叫隧道模式。这种方式IP层的负载是ESP，往往过不了NAT，并不适用于发起VPN者的网络环境。而前面提到的方式虽然会有两层UDP，但容易过NAT，这也是单纯技术上最佳的选择并不会被市场接受。\n\nL2TP似乎只有6个字节，每两字节一段，分为3段。第1段是协议和标志位，第2段是Tunnel ID，第3段是Session ID。后面这两个ID看起来是绑定的，但方向不同值不一样，命名为Session ID有点不对题。其上的PPP只有4个字节，1字节Address，1字节Control，2字节的承载协议类型（此例中指明是IP）。比TCP三卷本的说明少了最开始的0x7E。\n\n!! IPSec和IKE\n\nIPSec方式工作在IP层，其涵盖的ESP和AH协议主要是规定IP包的格式，因此在连接对端时，只要服务器域名不需要端口。\n\n中间人攻击是针对加密会话的初始化阶段进行的，IPSec 的初始化阶段显然要考虑这个问题，所以提出了XAuth规范，但该规范不如IKE的EAP，说到这里就要引出IKE协议了。IKE 协议在1988年11月发布v1版，2005年升级到v2版。是在奥克利协议（Oakley protocol）与ISAKMP协议的基础之上发展出来的，它和IPSec是独立的两套协议，但人们发现二者组合非常互补，所以现在往往一起提。由于IKE使用X.509安全认证，问题就转化成了面对中间人攻击，我们要如何去验证 IKE peer 的身份呢？也就是说，我们要如何确定对方就是我们要联络的人呢？IKE 协议里Message type 5 和 type 6 就是负责这个事情的。具体来讲有三种方法：\n\n# 预共享密钥：Pre Shared Key，简称PSK。用大白话就是双方商定一个密钥作为彼此认证的手段\n# 公钥加密：需要配置用户证书/CA证书/服务器证书\n# 数字签名\n\nXAuth似乎只支持预共享密钥和公钥加密，对应了XAuth和PSK/RSA选项，EAP不再依赖PSK。\n\n!!! StrongSwan\n\n基于IPSec最早的项目名叫FreeS/WAN，所以现在都沿用了swan这个名字，是Secure Wide-Area Networking首字母的缩写。这个项目停止维护后，衍生出OpenSwan、LibreSwan、StrongSwan。StrongSwan的主程序名就叫ipsec。\n\n!! OpenVPN\n\n通过四层的TCP/UDP建立连接，然后客户端会从服务端得到私有网络的配置信息，进而客户端会在其主机上创建TUN网卡，该网卡的地址和服务器在同一个网段，从而构成私有网络。\n\nTUN/TAP网卡是linux2.4版本出现的最早的虚拟网络，TUN网卡工作在三层，主要和应用程序直接打交道，为了模拟一张完整的网卡，再配套一张工作在二层的TAP网卡，整个网络栈就齐备了。\n\n使用iproute2的ip命令来创建TUN网卡，需要root权限。此外TUN还用于做IP隧道，IP4和IP6组合起来共有4种类型。","modified":"20170324121530000","tags":"security"},
{"created":"20181101121530000","title":"Web单页和跳转","text":"\n思考开放平台的网页呈现方式，基于已经有若干md文件，怎么去呈现。基本的想法是目录中放html文件，以静态方式来获取，完全不需要一行代码，但是开发似乎已经不知道还有上古技术了。单页配合后台按路径读数据也足够简单，定下大致思路。期间想到文档间需要跳转，如果按md内相对路径的写法，编译成chm没有任何障碍，但到了单页应用就会面临被跳转到其它页面的问题。\n\n经前端开发提醒，href除了绝对路径和相对路径外，还支持哈希方式，就是以#为记号的页面内跳转。简单测了下，规则大致是这样\n\n# 如果发现是`scheme://`开头，且scheme可以识别，就直接向外发起链接，页面也转移走了。\n# 如果首字母是`#`，进行页面内定位，仍留在当前页。\n# 除以上情况外，就以这个页面为根，在服务器的目录进行间接寻址。比如当前页面请求的路径是`/www`，如果name是ha，就向/www/ha发请求同时页面会跳转。\n\n可以看出，只有#路径的点击可以驻留，可以说是SPA的最佳搭档，同时会回调onhashchange函数，只要能进入JS，拿到#后面的数据，重新请求数据就是自然而然的事情，接下来就是编码的工作了。\n\n再看图片。如果用img标签，src是不会触发JS的(可以跨域的属性，当然不能随便加载JS)。这就要求必须能定位到这个SPA页面的根地址，再以跟地址进行相对路径的编写，理论上也是可以找到图片的。还没验证，先记录一下。\n\n最坏情况下，还能把图片先base64编码再嵌入页面，像这样`\u003Cimg src=\"data:image/png;base64,agEna13==\">`。","modified":"20181101121530000","tags":"web"},
{"created":"20231027033338666","text":"\u003Cdiv class=\"tc-table-of-contents\">\n\u003C\u003Ctoc-selective-expandable 'web' sort[title]>>\n\u003C/div>","tags":"目录","title":"Web开发","modified":"20231027033356768"},
{"created":"20160131121530000","title":"Widnows的编译库的理解","text":"\n!! 生成动态库\n\nwindows下生成动态库，会输出3个文件。通过dumpbin把三者的段内容分别打印并比较一下。\n\nexp类型也是COFF OBJECT，即和编译生成的.obj是一样的。\n\n打印/symbols，只有exp有大量的输出，而dll和lib没有输出。因为/symbols表示COFF 符号表，只有exp和obj能输出。exp的symbols分两类，Static和External，意义很直接。\n\n打印/imports，只有dll有大量输出，大多是依赖系统库，如MVVCRT等，而lib和exp无输出。只对exe和dll有意义。\n\n打印/exports，dll和lib都有大量输出，而exp没有输出。dll和lib的输出差异在于，dll输出的符号和函数中一致(似乎是Name)，而lib的符号则多了一个下划线前缀(似乎是Symbol Name)。\n\n另外编译后的资源文件.res也是COFF OBJECT类型，也是按段来组织的。\n\n另外lib和exp都无法反编译，即/disasm无输出，应该是内部只有符号表，无text段的关系。而dll是有大量的反汇编代码。说明编译时导入的lib也就是起到了符号寻路的作用，没有真正有意义的代码段。\n\ndll的反汇编代码，尤其跳转类je/jne指令后面都是绝对地址，说明不是地址无关代码，需要运行时做基址重定位，即ReBase修正。\n\n!! 使用动态库\n\n使用dll库时需要一个同名的.lib，称为导入库。而windows下的静态库的后缀也是.lib。这是经常让人迷惑的地方。由于Linux没有对应导入库的形态，编译时直接指定.dll已可以。\n\n但是MinGW移植的GCC做得更友好一点，编译时直接指定dll文件名，就可以生成可执行文件，其实是不需要导入库这东西。相比起来VC作为原生编译器，限制反而更多一点。MinGW作为Port，当然也能支持导入库。一般情况下VC生成的导入库可以直接被GCC读取(用cdecl导出的)，如果是stdcall导出的符号，因为VC会加上“`_`”前缀，所以把“`_`”去掉就可以给GCC用了。还有一种方式是用pexports从dll中导出.def文件，再用dlltool也能生成导入库。从这个角度看，MinGW直接支持编译时指定dll，也是理所当然的。\n\n另外MinGW下有一个工具叫reimp，整个代码都不大，简单地看了代码，导入库的格式如下，头部的MagicNumber是!\u003Carch>\\n共8个字符，再之后是结构体\n\n```\nstruct ar_hdr {\n  char ar_name[16];\n  char ar_date[12];\n  char ar_uid[6];\n  char ar_gid[6];\n  char ar_mode[8];\n  char ar_size[10];\n  char ar_fmag[2];\n};\n```\n\n而且这个结构体会重复多次出现，此结构出现两次后，会出现一段字符串表，所有需要导入的符号都在这里。但是数量上会多一点。比如dll有128个符号，字符串表会有128x2+3=259个符号。x2是因为每个符号都是有一个对应的`__imp_`对应符号，另外+3是在首部有`__IMPORT_DESCRIPTOR_`和`__NULL_IMPORT_DESCRIPTOR`开头的字符串，末尾处有一个0x7F开头的字符串(对应ASCII的del键，不是个可打印字符)。这3个去掉之后，剩下的导出符号就可以对上了。\n\n最后用这个方法做了个试验，找到一个tcmalloc.dll，然后通过pexports生成.def文件，再用dlltool生成导入库，用gcc编译成功通过且能运行。直接用dll也运行正常。\n","modified":"20160131121530000","tags":"os"},
{"created":"20170531121530000","title":"Word的标题样式和多级列表关系","text":"\n对一篇有结构层次的文档而言，章节标题的编号是很重要的，它能很直观地给出这部分内容在整个文章中的位置和前后关系。虽然通过给标题刷上样式，也能出现编号，但这种编号只能是简单的一个数字，想要达到类似1.1，1.2.1这样具备层次的效果，只靠标题样式无法实现。需要利用Word中被称为`多级列表`功能，它不同于简单的编号，也无法在样式的菜单中实现。\n\n定义一个想要的多级列表，需要通过独立的多级列表菜单进入。在备选的列表库中，提供了几种多级列表样式。如果要自定义的话，有几个很重要的点要注意\n\n# 将定义后的多级列表链接到样式，这点非常重要。我猜测是样式只记录了自身编号，所以样式的编号菜单不论再怎么折腾，只能实现一级数字的效果，无法实现多级序号并列。要显示多级序号，必然要参照更高一级别的编号，如果实现在样式中，按程序员的行话，就会造成标题间的强耦合，而微软又是一个非常强调工程师文化的地方，并不考虑使用者是否好用，所以没有把多级列表的设定放进样式菜单。\n# 怎么让多级列表能识别上一级标题，不要出现明明第二章了，却还是1.4这种荒诞的样式呢？在设定新的多级列表中，又有两个选项，此级别的编号样式和包含的级别编号两项，包含的级别编号就能自动继承上一级标题。但要注意这两个编号的顺序不要反，否则会出现本级标题在前，大标题在后的怪异效果，即明明是第二章第一节，应该显示2.1却显示成了1.2。搞不懂为什么要有这种灵活性，按我想法，直接固定上级标题在前，本级标题在后，岂不是更方便使用。难道在多语言环境中，会出现本级标题在前高级标题在后的需要吗？","modified":"20170531121530000","tags":"tool"},
{"created":"20170728121530000","title":"wren语言记录","text":"\n一门很小且很快的语言，EOS的作者BM对wren语言非常推崇，并整合到EOS中。\n\n下载源码后先到src目录下看看wren的代码结构。目录结构很简洁，核心代码都在vm目录，一万行出头，光有vm还不够，另外的module目录实现了基本的io/os/timer功能，代码才800多行，代码少的原因是依赖libuv。还有optional目录，不需要uv，支持了随机数和元的功能。以上3个是库，还有个单独的cli生成可执行文件。\n\n在windows下无法通过make自动编译成功，原因是Makefile的调用Python脚本，使用了Linux下的#!语法，在windows需要调用前显示地加上python字样。首先将vm下的代码生成libwren.so，这步比较顺利。但编译cli版本会失败，原因是需要下载uv，但用的机制是git和python的gyp机制，gyp的源码地址无法访问，好在cli程序的.o目标文件能编译出来，只要手动修改支持uv的头文件和库，就可以用了。\n\n前面提到编译wren需要python，原因是这样的。一个编译器如果纯用C写，工作量是很大的，如果在实现了语言分析的基础(或最小子集)后，直接用新的语言来定义扩展功能显然更方便，wren用的方法就是用wren语言写扩展，然后用python把这个扩展用文字替换方式变成C风格的字符串，通过C语言的include机制在虚拟机加载字符串，最后调用`wrenInterpret`接口加载到vm。所以换个角度想，作者直接用python把wren转换好再上传，就不需要客户端安装python了。但这种写完虚拟机，并用新语言进行扩展的作法值得学习。\n\n通过wren.h来一窥与C语言的交互，毕竟作为wren目的是提供一种快的可嵌入的纯粹的脚本引擎，vm部分没有集成任何外围库。在C语言宿主程序要用wren源码，只有上面提到过的`wrenInterpret`接口，它支持传入字符串，但不支持传入文件名或文件指针，原因是它没有IO库。载入脚本后最自然的想法就是传参并调用函数，传参用`wrenSetSlot***`函数族，Slot类似Lua中栈的索引，比较好理解。但是函数调用就很不一样了，共有3个步骤\n\n# `WrenHandle* wrenMakeCallHandle(WrenVM* vm, const char* signature)` 构造一个函数签名对象\n# `wrenGetVariable(WrenVM* vm, const char* module, const char* name, int slot)` 加载包含method的变量，另外准备好参数\n# `WrenInterpretResult wrenCall(WrenVM* vm, WrenHandle* method)` 执行第一步构造得到的函数签名\n\nwren是class-based的语言，且为了支持大规模开发，支持module，因此作为最小执行粒度的函数，要经过module->class->method这样一条路才能找到。module一般对应文件，class包含两个特殊的函数定义allocate/finalize，构造是必须的，析构可选。allocate需要从wren中调用，它的原型是`typedef void (*WrenForeignMethodFn)(WrenVM* vm);`，没有返回值是因为wren的函数必须且只能返回一个值(默认返回null)，所以就省略了。finalize的原型是`typedef void (*WrenFinalizerFn)(void* data);`，没有vm参数是原因是它in the middle of GC。为了减少查找method的开销，甚至把函数签名放到C的空间，而不是vm上。另外函数签名也是wren特有的，目的都是为了提高执行速度。\n\nwrenInterpreter的执行流程是先加载`main`模块(指cli下运行，如果是host内执行可以是别的模块)。wren的编译把parser和compiler分成了两个类别，先把module和source保存在parser，再传入compiler输出一个ObjFn，再将这个Fn包装成Closure，最后把Closure包装成Fiber，到这一步才真正开始执行。","modified":"20170728121530000","tags":"lang"},
{"created":"20161124121530000","title":"X509证书与GPG验证","text":"\n!! 证书定义\n\n加密体系中证书是非常重要的一环，最有名的标准就是X.509。它使用ASN1格式描述，这个标准有3个版本，主要用的是V1和V3版本。证书大小通常在1K字节左右。\n\nX509证书有几种格式，openssl默认使用PEM格式(Privacy Enhanced Mail)，而12306则使用了DER格式(Distinguished Encoding Rules)。DER是ASN.1这种二进制编码标准的一个实现方案(还有一种叫BER)，C函数中的`d2i_X509`和`i2d_X509`，d就代表DER，i则指internal，即C的struct格式。用openssl看的话，要加上-inform der才能正确地打开。\n\n证书的开始是版本号(1或3)，然后是证书序列号(Serial Number)。序列号是整数形式，比如：ab:a5:7c:fb:27:3c:50:91。是个64位数字。虽然名字叫序列号，但不能只靠这个做惟一区分，因为X509标准只要求序列号在同一个发行者或者颁发者(Issuer)下惟一即可（通常是每签发一个证书就加一）。\n接下来是签名，签名算法一般是非对称+散列，比如sha1WithRSAEncryption。再是发行者，Issuer有很多个字段，其中必须有的是C国家，ST省，O组织，OU组织单元和CN通用名称(CommonName必须是域名，比如`*.waer.com`)。比如发行者就是德国某州的Apache测试组织。组织后面是证书有效期，包含不早于和不晚于两个时间点。然后是主体或授与者(Subject)信息，同样有C国家、ST省份、O组织等类似的部分，身份介绍后是授与者的公钥，比如1024bit的RSA公钥，这部分显示时似乎总是以00:开头，然后是RSA的exponent，0x1001。\n\n最后是整份证书的签名，否则无法证明公钥及其所有者的信息一致。这里再次用了sha1WithRSAEncryption方式，计算方式我猜测是这样：\n先用sha1计算，然后用私钥生成签名，拿到证书的人，用公钥解密后的值，和证书的sha1值比对，只有对上了，说明这份证书才是正确的，防止被人伪造。\n\n上面列的字段都是X509的V1版本，V3在签名前面还会多出许多内容，从结构和原理上差不多就是这些。V3多出了扩展(颁发机构，CRL，使用者密钥标识)，关键扩展(密钥用法)，属性(指纹和指纹算法)。\n\n一份数字证书，最核心的内容就是这几件事：\n\n# 谁给你签发的(Issuer)\n# 证书有效期\n# 你的身份是谁(Subject)\n# 你的公钥，用于通信时交换密钥\n# 使用签发者公钥对以上信息hash做的签名，防伪造\n\nX509覆盖的范围比较多，从头文件看，除用于认证的X509，还有CRL(证书吊销)、REQ(证书申请)、NAME(证书持有者信息名字)、ATTRIBUTE、EXTENSION五种扩展功能。\n\n!! 证书签发流程与自签证书\n\nPKI体系的证书存在链式依赖，下游证书由上游证书签发，最顶级的根证书没有签发者，只能是自己给自己签发，但因为各种浏览器都集成了这些签发者的公钥，所以仍被认为有效，反之如果签发证书使用的顶级公钥没有被集成进浏览器，就会提示用户有风险。12306的根证书就是没有被广泛集成进浏览器的自签发证书。使用证书给别人签发证书，就是上游签发。\n\n从上一节数字证书包含的内容来看，包含两个不同的公钥。当我们在学习做自签发证书的时候，为简单起见，这两个公钥会用同一个。下面来看步骤：\n\n# 第一步生成私钥，RSA用`openssl genrsa`命令，ECDSA用`openssl ecparam -name secp521r1 -genkey -param_enc explicit`。带上`param_enc`的私钥会把参数都嵌入，体积大一点，否则只有曲线名称，但遇到版本不匹配时，可能无法构造曲线。另外如果担心私钥泄密，还可以在生成私钥的时候用AES-CBC或其它算法对私钥进行保护。得到的私钥文件已经包含了公钥信息。虽然有了私钥，可是没有任何表明身份的信息啊。\n# 第二步生成证书申请，使用`openssl req`，这步要输入上一步生成的私钥。如果没有私钥，你的申请信息就可以被随意篡改，这显然不是证书的本意。申请文件一般用.csr作为后缀。\n# 最后一步签发证书，用`openssl x509 -req -signkey`命令，signkey是自签名的关键，生成的就是根证书了。还有另一种生成自签名证书方式，把申请和签发证书两步合二为一，命令`openssl req -new -x509 -days 365 -key keyca.pem -out pubca.pem`。\n\n有了自签发的根证书，服务器证书类似，第一步先生成私钥，第二步也是生成申请，其中带上服务器的信息，第三步将申请和服务器的公钥交给根机构，由根机构用根私钥对服务器申请加密，输出的文件就是服务器证书了，这时用的命令是`openssl x509 -req -CA -CAkey`。和自签名的差异是参数从signkey换成了CA和CAkey。从这个流程看，证书显然包含了信息和公钥。\n\n还有另一种签发方式`openssl ca -keyfile keyca.pem -cert pubca.pem -in svr.csr -out pubsvr.pem -days 99`，这种方式有几个限制\n\n# 必须在当前目录下创建demoCA目录，这个目录内还要有newcerts目录，空的index.txt文件、内容为01的serial文件。\n# 根证书（自签名证书）和申请者的Province和Unit必须一致，否则无法签发。\n\n最后看一张图了解客户端对证书的认证过程\n\n![x509-verify](/img/x509-verify.png)\n\n!! 使用GPG来验证文件\n\n常见的方式有MD5验证，但是问题在于你怎么确信看到的MD5就是真实的呢？使用更高级别的GnuPG吧，它是符合OpenPGP标准的加密软件，可以加解密，还能签名或验证。最早由德国人开发了PGP软件并大受欢迎，但由于是个商业软件，就出现了OpenPGP标准，而gpg则是最广泛使用的实现，全名GNU Privacy Guard，名字如此相似，不知是故意还是巧合。\n\n先从最常用的验证说起吧。签名文件一般是.asc或.sig结尾，命令 `gpg2 --verify check.asc filename`\n\n签名文件放在前面，在这个流程里还是依赖一个中心化的公钥服务器，比如Openresty的声明如下：\n\n    releases are signed by the public PGP key A0E98066 of Yichun Zhang\n\n可以在pgp.mit.edu网站查到，A0E98066是RSA key ID，可以检索。不知道这算不算PKI。","modified":"20161124121530000","tags":"security"},
{"created":"20180405121530000","title":"YXcms和CanPHP的结合","text":"\n以前写过一篇URL路由，提到YXcms的解析思路，分析整体代码的思路。\n\nCanPHP的结构很清晰，分core/lib/ext三个目录，lib是官方功能扩展，ext是第三方扩展。core的顶级只有1017行代码，算上cache和db目录的各种不同实现共2千行。lib包括鉴权、图片等常用功能共5292行。ext有邮件和IP地址共1015行。\n\ncore目录有如下文件，cpApp加载入口，cpModel/cpCache数据库相关，cpTemplate/cpHtmlCache页面展示，cpConfig/cpError辅助功能。对于框架来说一定要提供M和V，而C天然是应用层要做的事，CanPHP做到了。\n\nYXcms会在它的体系中包含这些文件，cpModel被model使用，cpCache在cpModel内部包含，不需要显式使用。cpTemplate被controller和commonController使用，cpHtmlCache被baseController使用。cpConfig和cpError直接在YXcms的入口文件core使用。cpApp的入口功能被core重写，所以没有被使用。从中可以看出，CanPHP最核心的功能一个不落地被YXcms引用了。\n\nYXcms具有完整的MVC，C的代表controller，构造时会创建model，其view函数会创建cpTemplate进而渲染视图。V是一堆含有待替换值的HTML页面。","modified":"20180405121530000","tags":"web"}
]</script><div id="storeArea" style="display:none;"></div>
<!--~~ Raw markup for the bottom of the body section ~~-->

<!--~~ Load external JavaScripts ~~-->
<script src="tiddlywikicore-5.3.1.js" onerror="alert('Error: Cannot load tiddlywikicore-5.3.1.js');"></script>
</body>
</html>
