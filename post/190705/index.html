<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Go语言学习笔记 | 蛙二的思考</title><meta property="og:title" content="Go语言学习笔记 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-07-05T12:00:00+08:00"><meta property="article:modified_time" content="2019-07-05T12:00:00+08:00"><meta name=Keywords content><meta name=description content="Go语言学习笔记"><meta name=author content><meta property="og:url" content="/post/190705/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Go语言学习笔记</h1></header><date class="post-meta meta-date">2019年7月5日</date><div class=post-content><h2 id=gomod>go.mod</h2><p>从1.13开始module成为默认行为，不再要求在GOPATH目录编译，而是鼓励在当前或父目录添加go.mod文件使这个目录成为go的模块，同时也不再限制必须有src目录。配置<code>go env -w GOPROXY=https://goproxy.cn,direct</code>后，下载依赖包也变得非常方便。</p><p>在代码还没推送到远端服务器前，本地目录的导入是个很需要的功能，官方的文档并没有重视。首先module的名字要用带点号的域名形式（比如.me），不用担心域名是否存在，只要遵循这个规范就好。接着在go.mod中添加require xxx v0.0.0和replace xxx v0.0.0 => ./xxx，关键是用replace将包指向本地目录，go就不会去网上找这个包了。</p><h2 id=代码目录结构不再适用>代码目录结构（不再适用）</h2><p>Go的1.11版本以前，规定了代码必须放在GOPATH环境变量指定的目录，背后的原因可能是Google所有的代码在同一个repo下，微缩后就变成了GOPATH。固定 bin/pkg/src 三个目录，在src下建立目录比如xyz，进入这个目录下编写代码，最后用go build就会自动编译。强行指定文件名固然可以，但并不推荐。引入Module机制后，可以不限制在GOPATH路径。GOROOT则指定了Go的工具、库和源码的存放路径。</p><h2 id=包和模块>包和模块</h2><p>一个目录就是一个包package，通过这个目录下的每个源文件开头申明相同的package xx表示属于一个包。取名为main的包比较特殊，通常会定义main函数作为总的入口。同一个包内的函数和类型可以互相引用，不需要申明为大写。多个包构成一个模块，通过在顶级目录添加go.mod声明是一个module。</p><p>包可以被编译成.a库。解压后虽然也是.o，但和C语言不同，是混合了字符和二进制的特定形式。不过Go提倡按源文件编译，即使提供了.a库机制，似乎用处不大。</p><h2 id=编译>编译</h2><p>仔细看build过程，先生成一个中间过程的importcfg.link文件，内容是用packagefile指定了若干运行相关的参数，比如cpu、字节运算方式、math/sys库，并用go的link工具加载这些参数生成可执行文件a.out，然后改名成包相同的名字。</p><p>import时指定的是目录名称，导入同时会解析目录下的包名称，所以真正调用的时候以包名称引用（目录名和包名称不强制一样，但目录内的package包必须统一）。另外包名只有一级，不支持点号，所以不管import的目录名有多长，但真正起作用的，就是最后一个目录内实际的包名，而且当包名重复时，编译也会报错。所以在命名时，可以在package名中加入下划线适当增加长度，但也不需要太过冗长。导入包重命名机制一定程度上解决命名空间只有一层的简陋。</p><p>go build -tags &ldquo;abc xyz"会启动条件编译，只有代码首行指定了<code>//+build abc</code>的文件会被编译。似乎充斥着这种打补丁似的语法，大约是实际的需求和理想化简约之间的冲突吧。</p><p>run指令可以带多个文件列表，顺序可以任意，甚至用*.go，否则main函数调用的其它文件没有被引入会报错，不需要像C语言把被依赖的文件放在最前面。main包平铺拆成多个文件也是最简单的项目拆分方式，如果想形成多目录，就要用replace指令，对新手来说难度会大很多。</p><h2 id=测试与调试>测试与调试</h2><p>单元测试要函数名以<code>Test[A-Z]</code>方式开头，如果是小写字母则不会运行。在GOPATH下直接运行go test package，虽然能运行用例，但正常的例子不会输出到stdout，而进到package的目录直接运行go test，会输出stdout。Example开头的函数，要增加<code>//output:</code>才会输出。</p><p>用GDB调试，build命令可以加两个参数</p><ol><li>使用go build -ldflags &ldquo;-s -w"减少生成文件的体积。-s: 去掉符号信息，-w: 去掉DWARF调试信息。</li><li>传递-gcflags &ldquo;-N -l&rdquo; 参数，这样可以忽略Go内部做的一些优化，聚合变量和函数等优化，这样对于GDB调试来说非常困难，所以在编译的时候加入这两个参数避免这些优化。另外-m会在编译期打印逃逸分析结果。</li></ol><h2 id=语言特性>语言特性</h2><p>JSON库要求struct的成员必须是大写字母开头，否则无法导出，可见性渗透到很多地方。</p><p>string和[]byte在二进制层面是一样的数据，但类型不同，原因是string被设计为不可变，保证多线程安全，而[]byte就是一块内存区域。当函数需要的参数和实际类型不匹配时，二者间要做类型转换，不可避免地会引入内存复制开销，如果想避免开销，就一定要自己保证内存安全。</p><p>go可以认为是启动了新线程（较创建原生线程开销较小），goroutine是不可控的线程操作，原生带了channel用于通信，对channel的读写是阻塞的（否则执行序不可控的多个go程就无法协作了）。而coroutine其实是严格串行执行，基于共享内存通信无妨，并不需要channel，用yield和resume显示控制。</p><p>每个包可以定义init函数，会先于main执行，多个包的init顺序不可控。</p><p>严格地说go的函数参数传递只有一种：<strong>值传递</strong>。因此对复杂struct变量，用指针方式减少复制的开销。但有一种说法，在特定的场合值会比指针开销少，原因是逃逸分析。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>