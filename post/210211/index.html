<!doctype html><html lang=zh-ch>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>线程模型与调度 | 蛙二的思考</title>
<meta property="og:title" content="线程模型与调度 - 蛙二的思考">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-02-11T12:00:00+08:00">
<meta property="article:modified_time" content="2021-02-11T12:00:00+08:00">
<meta name=Keywords content>
<meta name=description content="线程模型与调度">
<meta name=author content>
<meta property="og:url" content="/post/210211/">
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=stylesheet href=/css/normalize.css>
<link rel=stylesheet href=/css/style.css>
<script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
</head>
<body>
<header id=header class=clearfix>
<div class=container>
<div class=col-group>
<div class=site-name>
<a id=logo href>
蛙二的思考
</a>
</div>
<div>
<nav id=nav-menu class=clearfix>
<a class=current href>首页</a>
</nav>
</div>
</div>
</div>
</header>
<div id=body>
<div class=container>
<div class=col-group>
<div class=col-8 id=main>
<div class=res-cons>
<article class=post>
<header>
<h1 class=post-title>线程模型与调度</h1>
</header>
<date class="post-meta meta-date">
2021年2月11日
</date>
<div class=post-content>
<p>共有3种线程模型，以x:y命名，即x个用户线程对应y个内核调度实体(Kernel Scheduling Entity，这个是内核分配CPU的对象单位)。</p>
<ol>
<li>多对一(M:1)的用户级线程模型。似乎没有实现，缺点在于：多线程并发执行，如果一个线程执行阻塞的IO操作，内核接管这个操作，用户态的其他线程都会被阻塞，因为这些线程都对应同一个内核调度实体。这时内核不知道用户态有多线程，无法把它们调度到其他处理器，也无法通过优先级来调度。这种模型只在单核处理器上有一定意义。</li>
<li>一对一(1:1)的内核级线程模型。典型的是POSIX的pthread，每个用户线程都对应各自的内核调度实体。由内核来调度的结果就是：线程的每次操作会在用户态和内核态切换，影响速度。另外如果出现大量线程，会在内核分配同等数量的线程调度实体，影响系统性能。</li>
<li>多对多(M:N)的两级线程模型。典型的是golang的协程调度，结合了1：1和M：1的优点，每个线程可以拥有多个调度实体，也可以多个线程对应一个调度实体。但这种模型的线程调度，必须由内核态和用户态一起来实现，典型如go语言在1.2版本后内嵌支持了（1.1时代是1：1模型）。因为当多个对象操作一个资源时，肯定要有同步机制，用户态和内核态的分工合作导致实现该模型非常复杂。Linux的第二代模型NGPT用了多对多模型，但性能上仍输给了使用一对一模型的第三代NPTL。（其实NPTL曾经也想使用M:N，但因为太复杂，且要对内核进行大范围改动，最终还是用了一对一）。</li>
</ol>
<h2 id=golang调度>golang调度</h2>
<p>Go的调度器内部有三个重要的结构：M，P，G</p>
<ul>
<li>M是对内核级线程的封装，数量对应真实的CPU数，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息</li>
<li>P全称是Processor，它处理的是协程与队列，用于执行goroutine的。每个Processor对象都拥有一个LRQ（Local Run Queue），未分配的Goroutine对象保存在GRQ（Global Run Queue ）中，等待分配给某一个P的LRQ中，每个LRQ里面包含若干个用户创建的Goroutine对象。</li>
<li>G代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。</li>
</ul>
<p>Golang采用M:N线程模型，对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。</p>
<p>这张图是正在运行中的状态，有2个物理线程M，每一个M被一个处理器P管理，每一个P也都有一个正在运行的goroutine（蓝色），灰色的那些goroutine并没有运行，而是处于等待被调度的ready就绪态。P维护着这个队列（称之为runqueue）。</p>
<p>
<img class=mx-auto alt=go-runtime-state src=img/gorun1.jpg>
</p>
<p>P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出一个goroutine执行。</p>
<p>当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p>
<p>
<img class=mx-auto alt=go-runtime-block src=img/gorun2.jpg>
</p>
<p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p>
<p>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很闲，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里拿任务的话，会拿run queue的一半，这就确保了每个OS线程都能充分的使用，如下图：</p>
<p>
<img class=mx-auto alt=go-runtime-schedule src=img/gorun3.jpg>
</p>
<h2 id=mpg相关qa>MPG相关QA</h2>
<ol>
<li>
<p>M和P的数量如何确定？何时会创建M和P？</p>
<p>a) P的数量由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定（默认是1）。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。</p>
<p>b) M的数量受go语言本身的限制，go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
runtime/debug中的SetMaxThreads函数，设置M的最大数量。一个M阻塞了，会创建新的M。</p>
<p>c) M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p>
<p>d) P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p>
<p>e) M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
</li>
<li>
<p>M选择哪一个P关联？什么时候会切换P与M的关联关系？</p>
<p>M会关联到创建了这个M的那个P。当M因系统调用而阻塞时（M上运行的G进入了系统调用的时候），M与P会分开，如果此时P的就绪队列中还有任务，P就会去关联一个空闲的M，或者创建一个M进行关联。（也就是说go不是像libtask一样处理IO阻塞的？不确定。）</p>
</li>
<li>
<p>就绪的G如何选择进入哪个P的就绪队列？</p>
<p>默认情况下：P的数量是1（M不一定是1），所以如果我们不改变GOMAXPROCS，无论我们在程序中用go语句创建多少个goroutine，它们都只会被塞入同一个P的就绪队列中。</p>
<p>有多个P的情况下：如果修改了GOMAXPROCS或者调用了runtime.GOMAXPROCS，运行时系统会把所有的G均匀的分布在各个P的就绪队列中。</p>
</li>
<li>
<p>如何保证每个P的就绪队列中都会有G</p>
<p>如果一个P的就绪队列所有任务都执行完了，那么P会尝试从其他P的就绪队列中取出一部分到自己的就绪队列中，保证每个P都有任务可以执行。</p>
</li>
</ol>
<h2 id=erlang的调度>Erlang的调度</h2>
<p>BEAM的调度模式在2006从单线程切换到多线程（最早在1998年由一个硕士着手研究），有点类似go的MG模型，没有P。相比go的原生调度，由于BEAM是虚拟机形态，调度灵活程度更高。</p>
<p>在BEAM中，除了process之外，还有3种调度单位：端口（ports）、链入式驱动（linkd-in drivers）和系统级活动（system level activities）。这三种特殊的任务形式主要用来进行IO操作和执行其他语言的代码等功能。</p>
<h2 id=go和erlang的比较>Go和Erlang的比较</h2>
<p>go是协作式调度，除非进入内核阻塞态，协程一直运行，这和它native的实现有一定关系。而erlang是轮转调度，分了4个优先级，基于VM机制可以抢占。</p>
</div>
<div class="post-meta meta-tags">
没有标签
</div>
</article>
</div>
<footer id=footer>
<div>
&copy; 2021 <a href>蛙二的思考 By </a>
</div>
<br>
<div>
<div class=github-badge>
<a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
</div>
<div class=github-badge>
<a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a>
</div>
<div class=github-badge>
<a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
</div>
</div>
</footer>
<script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:!0}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script>
</div>
<div id=secondary>
<section class=widget>
<form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1>
<input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button>
</form>
</section>
<section class=widget>
<h3 class=widget-title>最近文章</h3>
<ul class=widget-list>
<li>
<a href=/post/210901/ title=对昼伏夜出和朝九晚五两个技战法的分析>对昼伏夜出和朝九晚五两个技战法的分析</a>
</li>
<li>
<a href=/post/210729/ title=git的远程访问辨析>git的远程访问辨析</a>
</li>
<li>
<a href=/post/210721/ title=PySpark分析>PySpark分析</a>
</li>
<li>
<a href=/post/210614/ title=erlang和其上的扩展语言>erlang和其上的扩展语言</a>
</li>
<li>
<a href=/post/210613/ title=lisp编程与结构化思想>lisp编程与结构化思想</a>
</li>
<li>
<a href=/post/210611/ title=理解shell的换行和打印>理解shell的换行和打印</a>
</li>
<li>
<a href=/post/210421/ title=vim的自定义扩展>vim的自定义扩展</a>
</li>
<li>
<a href=/post/210404/ title=数据库的执行优化>数据库的执行优化</a>
</li>
<li>
<a href=/post/210322/ title=对公有云上数仓的调研>对公有云上数仓的调研</a>
</li>
<li>
<a href=/post/210216/ title=hadoop体系理解>hadoop体系理解</a>
</li>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/categories/>分类</a></h3>
<ul class=widget-list>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/tags/>标签</a></h3>
<div class=tagcloud>
</div>
</section>
<section class=widget>
<h3 class=widget-title>其它</h3>
<ul class=widget-list>
<li><a href=index.xml>文章 RSS</a></li>
</ul>
</section>
</div>
</div>
</div>
</div>
</body>
</html>