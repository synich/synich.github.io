<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>setjmp的机制及lua中的异常 | 蛙二的思考</title><meta property="og:title" content="setjmp的机制及lua中的异常 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2014-10-02T12:00:00+08:00"><meta property="article:modified_time" content="2014-10-02T12:00:00+08:00"><meta name=Keywords content><meta name=description content="setjmp的机制及lua中的异常"><meta name=author content><meta property="og:url" content="/post/141002/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>setjmp的机制及lua中的异常</h1></header><date class="post-meta meta-date">2014年10月2日</date><div class=post-content><p>setjmp/longjmp是C标准的函数，常用的做法是用来实现异常/跳转。原型如下：</p><ul><li>int setjmp(jmp_buf env);</li><li>int longjmp(jmp_buf env, int err);</li></ul><p>这组函数依赖于<code>jmp_buf</code>的变量类型，从接口声明看，
<code>jmp_buf</code>是值类型的，但每次调用setjmp都会把当前的各个寄存器值包括PC保存起来，
供以后longjmp来恢复，所以这个<code>jmp_buf</code>一定是指针语义的。
看了GCC 3.4.5的定义，将宏简化之后就是 typedef int <code>jmp_buf</code>[16];
也就是说<code>jmp_buf</code>类型其实是个数组，而数组在传参时又是作为指针来处理，
所以setjmp能改变<code>jmp_buf</code>所对应的值，之后的longjmp才能恢复回来。
实测在32位的XP系统上，只用了0~6共7个值，其余都是置0。</p><p>如果没有setjmp就直接longjmp，因为PC值和各种寄存器值一定是乱的，
必然导致系统崩溃。调试模式下是ntdll下抛异常。
而每一次的setjmp都将当前状态写入到jmp_buf中并返回0，
因此多次调用setjmp以后，longjmp会回到最后一次setjmp的地方。</p><p>再说说setjmp在lua中的应用。</p><p>lua在内部执行操作时，大都是调用luaD_pcall，
这内部调用到了luaD_rawrunprotected，在内部会进入LUAI_TRY这个宏。
如果用C++编译，这个宏就被展开成try{}块；如果是C，
这个宏就被展开成if (setjmp() == 0) {action}这样的形式。
jmp_buf的值会随着L带到action中，一旦发生无法补救的错误，
就会通过luaD_throw函数，在判断了存在jmp_buf后，
再调用LUAI_THROW宏，实质就是longjmp的形式直接返回。
由于先判断了L中是否有jum_buf，也就不会有异常的死机问题。</p><p>Lua的语法层面并不支持try/catch/throw这种显式的异常处理方式，
但是做一些不符合规定的操作，比如数字加nil，
字符串和nil拼接等等动作，Lua会执行出错，
如果不是在pcall内执行，导致程序提前终止，
这其实就是一种变相的固定类型的异常，
只是自定义异常类这块功能没有开放罢了。</p><p>只有系统自带的操作，在执行非法时抛出个可捕获的异常，
用pcall/xpcall来模拟try/catch，而用类似<code>1+nil</code>的方式模拟throw。
要想程序能够跑完，就要时刻注意用pcall的方式把函数执行做个封装，
而如果想提前终止，也可以用故意写非法语句来达到类似的效果。
但是写的非法语句毕竟不能携带自定义信息，只能靠代码行号来反推，
效果上就差强人意了。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>