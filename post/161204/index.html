<!doctype html><html lang=zh-ch>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>CGI规范的理解 | 蛙二的思考</title>
<meta property="og:title" content="CGI规范的理解 - 蛙二的思考">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-12-04T12:00:00+08:00">
<meta property="article:modified_time" content="2016-12-04T12:00:00+08:00">
<meta name=Keywords content>
<meta name=description content="CGI规范的理解">
<meta name=author content>
<meta property="og:url" content="/post/161204/">
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=stylesheet href=/css/normalize.css>
<link rel=stylesheet href=/css/style.css>
<script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
</head>
<body>
<header id=header class=clearfix>
<div class=container>
<div class=col-group>
<div class=site-name>
<a id=logo href>
蛙二的思考
</a>
</div>
<div>
<nav id=nav-menu class=clearfix>
<a class=current href>首页</a>
</nav>
</div>
</div>
</div>
</header>
<div id=body>
<div class=container>
<div class=col-group>
<div class=col-8 id=main>
<div class=res-cons>
<article class=post>
<header>
<h1 class=post-title>CGI规范的理解</h1>
</header>
<date class="post-meta meta-date">
2016年12月4日
</date>
<div class=post-content>
<p>最早的Web交互协议规范，由于足够简单甚至连busybox都能支持，只要做到以下两点就可以</p>
<ol>
<li>在网站根目录下创建cgi-bin目录（必须是这个名字，否则作为普通的目录，只会读取文本不会执行）</li>
<li>在cgi-bin目录下创建文件，子目录也可以，并具有执行权限，但文件名不要和系统自带命令同名，我就遇到过命名为env后，程序一直执行不会退出</li>
</ol>
<p>然后在浏览器端，只要访问/cgi-bin/xxx，就可以触发执行CGI程序。RFC规范定义了以下环境变量给脚本读取使用：</p>
<ul>
<li>REQUEST_METHOD: GET/POST等HTTP方法，busybox只实现了GET/POST，其它方法会报错501 Not Implemented</li>
<li>REQUEST_URI: 请求的完整路径</li>
<li>QUERY_STRING: 把URI的?之后部分提取出来，保存到这个变量</li>
<li><code>SCRIPT_NAME</code>: 被执行脚本的相对路径，Web根目录为/</li>
<li><code>PATH_INFO</code>: 额外的路径信息，由客户端给出的。换句话说，脚本可以由他们的虚拟路径名来访问，在这个路径的末尾附带额外的信息。这个额外信息被作为<code>PATH_INFO</code>发送。这个信息如果在传递给CGI脚本之前来自URL就可以由服务器来解码。如果请求http://example.com/test/test.php/a/b?k=v，则PATH_INFO的值为/a/b。</li>
<li><code>PATH_TRANSLATED</code>: 服务器提供的PATH_INFO的转换版本，它需要路径并且为它做虚拟到物理的映射。busybox不支持。</li>
<li>SERVER_PROTOCOL/GATEWAY_INTERFACE/SERVER_SOFTWARE: 值类似HTTP/1.0、CGI/1.1，告知服务器运行版本</li>
<li>stdout: 这并不是环境变量，对于POST请求的内容来说，URI之外的数据，需要脚本从stdout来读取，所以也提一下</li>
</ul>
<p>从Nginx的配置语句也可以看出点端倪，fastcgi部分一共支持两个预置变量</p>
<ul>
<li>$<code>fastcgi_script_name</code></li>
<li>$<code>fastcgi_path_info</code></li>
</ul>
<p>从命名看出和CGI规范也是符合的，那么这两个变量怎么赋值呢？</p>
<p>答案就是通过<code>fastcgi_split_path_info</code>这个命令字。这个命令的参数是捕获两个变量的正则表达式，捕获对象是$uri，前一个赋值给<code>script_name</code>，
后一个赋值给<code>path_info</code>。<code>PATH_TRANSLATED</code>这个变量好像没什么用，没有在nginx内赋值程序也能正常执行。</p>
<p>看一段PHP代码时，发现URL映射很不寻常，用了/index.php/article/?s=a这种格式。印象里.php这个SCRIPT_NAME在末尾，最多就是再跟个<code>QUERY_STRING</code>。查了CGI规范，允许这种写法，且后面的/article/还有标准名字，叫<code>PATH_INFO</code>。</p>
<p>PHP对<code>PATH_TRANSLATED</code>的支持有点问题，以前是和<code>SCRIPT_FILENAME</code>一样，但这不符合CGI规范，现在默认已修正，但还有个cgi.fix_pathinfo=1选项能倒退回以前的行为。归根结底CGI就是先定位到一个文件，在这个文件基础上附带参数。参数分两段，<code>/</code>之后(含/)的<code>PATH_INFO</code>和<code>？</code>之后的<code>QUERY_STRING</code>。在Apache或PHP -S选项下，只能写成/index.php/article，而nginx由于用了更灵活的正则匹配方式，写成/index.php-article也可以识别并正确引导。</p>
<p><code>parse_url</code>函数会拆解成5个部分，scheme, host, path, query, fragment。在这套定义中<code>script_name</code>是path的一部分，不是独立元素。</p>
<h2 id=fastcgi协议及php中的相关部分>FastCGI协议及PHP中的相关部分</h2>
<p>FastCGI作为解决CGI协议的后继者，已深得人心，在Nginx和PHP中都默认支持。比如php-cgi虽然名字是cgi，但是-b模式开启的其实是FastCGI模式。再配合上Nginx的<code>fastcgi_pass</code>指令，动态网页的环境就完成了。</p>
<p>CGI使用环境变量和stdin/stdout来传输数据，FastCGI是网络化的，因此有协议规范，协议为8字节对齐，头是个8字节的标志位：</p>
<pre tabindex=0><code>typedef struct _fcgi_header {
    unsigned char version;
    unsigned char type;
    unsigned char requestIdB1;
    unsigned char requestIdB0;
    unsigned char contentLengthB1;
    unsigned char contentLengthB0;
    unsigned char paddingLength;
    unsigned char reserved;
} fcgi_header;
</code></pre><p>这个格式缺少协议头标志(MagicFlag)，大概那个时代都是如此吧。版本好像只有1，type是消息类型共有10种：</p>
<pre tabindex=0><code>typedef enum _fcgi_request_type {
    FCGI_BEGIN_REQUEST      =  1, /* [in]                              */
    FCGI_ABORT_REQUEST      =  2, /* [in]  (not supported)             */
    FCGI_END_REQUEST        =  3, /* [out]                             */
    FCGI_PARAMS             =  4, /* [in]  environment variables       */
    FCGI_STDIN              =  5, /* [in]  post data                   */
    FCGI_STDOUT             =  6, /* [out] response                    */
    FCGI_STDERR             =  7, /* [out] errors                      */
    FCGI_DATA               =  8, /* [in]  filter data (not supported) */
    FCGI_GET_VALUES         =  9, /* [in]                              */
    FCGI_GET_VALUES_RESULT  = 10  /* [out]                             */
} fcgi_request_type;
</code></pre><p>比较常见的有<code>BEGIN_REQUEST</code>/<code>END_REQUEST</code>(网络化后标识请求应答状态用)，PARAMS(代替环境变量)，STDIN/STDOUT(名字和CGI一样，含义则作了泛化)。</p>
<p>BEGIN/END的payload部分是定长的，BEGIN定义</p>
<pre tabindex=0><code>typedef struct _fcgi_begin_request {
    unsigned char roleB1;
    unsigned char roleB0;
    unsigned char flags;
    unsigned char reserved[5];
} fcgi_begin_request;
</code></pre><p>role表示Web服务器期望应用扮演的角色。分为三个角色</p>
<pre tabindex=0><code>typedef enum _fcgi_role {
    FCGI_RESPONDER  = 1,
    FCGI_AUTHORIZER = 2,
    FCGI_FILTER = 3
} fcgi_role;
</code></pre><p>flags包含一个控制线路关闭的位：FCGI_KEEP_CONN：</p>
<ul>
<li>0，则应用在对本次请求响应后关闭线路。</li>
<li>非0，应用在对本次请求响应后不会关闭线路。一般都是非0，减少连接开销。</li>
</ul>
<p>END定义：</p>
<p>appStatus是应用级别的状态码。protocolStatus组件是协议级别的状态码；
protocolStatus的值可能是：</p>
<ul>
<li><code>FCGI_REQUEST_COMPLETE</code>：请求的正常结束。</li>
<li><code>FCGI_CANT_MPX_CONN</code>：拒绝新请求。这发生在Web服务器通过一条线路向应用发送并发的请求时，后者被设计为每条线路每次处理一个请求。</li>
<li><code>FCGI_OVERLOADED</code>：拒绝新请求。这发生在应用用完某些资源时，例如数据库连接。</li>
<li><code>FCGI_UNKNOWN_ROLE</code>：拒绝新请求。这发生在Web服务器指定了一个应用不能识别的角色时。</li>
</ul>
<p>另外PARAMS、STDIN/STDOUT由于受协议单次数量64K的限制，如果要分包，
则采用最后带一个长度为0的请求表示结束。有点类似HTTP的CHUNK传输方式。</p>
<p>详细说下chunked方式，回复的HTTP包头如果标识是chunked方式，包头结束后(即单独的一个空行<code>\r\n</code>)，接下来就是若干个chunk，格式遵循这个格式：该chunk的字节长度加上回车，然后是正文数据加上一个回车结束。</p>
<p>比如发送abcd四个字节，这个chunk是<code>34 0d 0a 61 62 63 64 0d 0a</code>，34和回车表示这个块有4字节，正文数据的长度匹配后再跟一个回车，当所有带内容的chunk都结束后，要再发送一个结束包<code>30 0d 0a 0d 0a</code>，30和回车表示块有0个字节，这个不存在的正文后再跟一个回车，内容结束。长度按16进制表示，比如一个附件是44307字节，抓包是<code>61 64 31 33 0d 0a</code>，表示ad13，转成十进制正好是44307。</p>
</div>
<div class="post-meta meta-tags">
没有标签
</div>
</article>
</div>
<footer id=footer>
<div>
&copy; 2021 <a href>蛙二的思考 By </a>
</div>
<br>
<div>
<div class=github-badge>
<a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
</div>
<div class=github-badge>
<a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a>
</div>
<div class=github-badge>
<a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
</div>
</div>
</footer>
<script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:!0}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script>
</div>
<div id=secondary>
<section class=widget>
<form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1>
<input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button>
</form>
</section>
<section class=widget>
<h3 class=widget-title>最近文章</h3>
<ul class=widget-list>
<li>
<a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a>
</li>
<li>
<a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a>
</li>
<li>
<a href=/post/211102/ title=几种语言的包加载和管理机制>几种语言的包加载和管理机制</a>
</li>
<li>
<a href=/post/211016/ title=以太和IP网之外的一些网络>以太和IP网之外的一些网络</a>
</li>
<li>
<a href=/post/210901/ title=对昼伏夜出和朝九晚五两个技战法的分析>对昼伏夜出和朝九晚五两个技战法的分析</a>
</li>
<li>
<a href=/post/210729/ title=git的远程访问辨析>git的远程访问辨析</a>
</li>
<li>
<a href=/post/210721/ title=PySpark分析>PySpark分析</a>
</li>
<li>
<a href=/post/210614/ title=erlang和其上的扩展语言>erlang和其上的扩展语言</a>
</li>
<li>
<a href=/post/210613/ title=lisp编程与结构化思想>lisp编程与结构化思想</a>
</li>
<li>
<a href=/post/210611/ title=理解shell的换行和打印>理解shell的换行和打印</a>
</li>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/categories/>分类</a></h3>
<ul class=widget-list>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/tags/>标签</a></h3>
<div class=tagcloud>
</div>
</section>
<section class=widget>
<h3 class=widget-title>其它</h3>
<ul class=widget-list>
<li><a href=index.xml>文章 RSS</a></li>
</ul>
</section>
</div>
</div>
</div>
</div>
</body>
</html>