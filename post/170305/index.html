<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>系统性能分析的理解 | 蛙二的思考</title><meta property="og:title" content="系统性能分析的理解 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2017-03-05T12:00:00+08:00"><meta property="article:modified_time" content="2017-03-05T12:00:00+08:00"><meta name=Keywords content><meta name=description content="系统性能分析的理解"><meta name=author content><meta property="og:url" content="/post/170305/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>系统性能分析的理解</h1></header><date class="post-meta meta-date">2017年3月5日</date><div class=post-content><p>曾经以为性能分析一定要用看起来很高深的工具，实际上重点还是在于对系统各个方面的理解。对《性能之巅》观测指标做个分类，分为软件和硬件，软件类包含操作系统、文件系统和进程，而硬件包含CPU、内存、磁盘和网络。</p><h2 id=进程状态>进程状态</h2><p>ps会显示多种状态</p><ul><li>S 可中断睡眠，可以被外部信号或内核唤醒，比如网络等待</li><li>D 不可中断睡眠，只能被内核唤醒，比如读写磁盘，虽然不占CPU但占着其它硬件，且必须一直拿着这个硬件，否则会导致硬件损坏</li><li>T或Z 停止或僵尸</li></ul><p>另有几种文档说BSD状态，但好像也会显示</p><ul><li>&lt;和N 高低优先级</li><li>s session leader</li><li>l 多线程</li><li>+ 前台进程组，不理解，似乎不重要</li></ul><h2 id=cpu>CPU</h2><p>最粗略的观察通过uptime和top，看变化趋势和整体分布，要注意的是load和usage是不是维度的度量，两者甚至可能出现很大的偏差。因为load统计可以大体等同于R和D状态的进程总数，表示运行中的进程数，但是D状态不会占用usage，所以如果出现有大量读磁盘的进程时，load会明显高于usage；理论上猜测（没有遇到过），当进程数较少，但某些进程使用多核计算，会出现usage高于load的情况。</p><p>CPU的计时分了很多状态: usr, sys, nic, idle, io(wa), irq(hi), sirq(si)</p><p>usr、sys和nic是某个进程的耗时，nic是低优先级(1~19)进程的用户态耗时，而io、irq计算整个系统的耗时，类似于公摊，不计入进程耗时。进程还要观察上下文切换，也会导致CPU过高。</p><h2 id=内存>内存</h2><p>内存首先分为物理内存和虚拟内存（swap分区）。</p><p>内存有cache和buffer。buffer对应block device，比如文件系统的MetaData，量并不大，知道就好不用太关注。</p><p>cache比较重要，它表示程序曾经往Disk写入的数据，除非系统判断内存不足，不会去清理cache，所以经常看起来很大，但不必担心。</p><p>ps有个-o选项，可以输出非常多的信息，说说内存。</p><ul><li><p>rss，resident set size，表示常驻物理内存的大小。这里有个要注意的，在计算so共享库的时候，会全部计算进去，实际上so的多存往往是多个进程共用，对系统的占用并没有表面上来得严重。累计了CODE段和DATA段的总大小。用pss做总和才是正确的值，p表示比例，共享的内存按比例均分。</p></li><li><p>sz，比rss大</p></li><li><p>vsz，虚拟内存，最大。等于swap和rss总和。</p></li></ul><p>另有pss(proportional set size)是将so内存按比例统计，对每个进程来说更准确。uss则完全不计入so内存。</p><p>pmap可以给出更细的检测报告，每个so库的每种段，堆和栈占用多少内存全部统计分明。</p><p>内存在系统中有4种状态</p><ol><li>未载入(不用关心)</li><li>已载入，但未映射</li><li>已载入，且已映射</li><li>已载入，但被换到虚拟内存</li></ol><p>通过工具看到最多的，3代表常驻内存RSS，2,3,4合起来又名VSS</p><p>监测可以针对系统级进程。监测的原理分为计数器和跟踪，另外profile也有，但使用面会窄些。</p><ul><li><p>计数器方式：由于内核本就维护各种统计数据，因此计数方式的采集可以认为是零开销。基于计数器方式有sysstat工具包，涵盖了一系列专项的工具，如pidstat/mpstat/iostat等。另外sar是system active report的简写，虽然没有stat但也是sysstat的一员。其它各自针对不同资源进行监测。还有一个procps-ng包，包括了vmstat/free/ps/top等经常会用到的工具，形成两大派别。netstat是早已有之，不在这两个派别内。</p></li><li><p>跟踪方式：又叫事件，系统级典型如perf/systemtap，进程级有strace/gdb，基于系统事件方式的采样。找到哪个环节出问题，针对性的采集数据。Perf是Linux内核自带的性能监测工具，自2.6.31版开始引入所以发行版都会带这个功能。它配合内核的<code>perf_events_open</code>接口(也是perf惟一的接口)使用。而systemtap更像是CentOS专门的工具，默认不带要另外安装。</p></li></ul><h2 id=计数器方式>计数器方式</h2><p>计数器方式可以很快地看出系统的负载，最复杂的命令是sar，用sar -A可以看到所有数据，底层有sadc(采集数据)和sadf(输出格式化数据)支持。再说几个工具的特性。</p><p>iostat可以监视IO(-d)和CPU(-c)，类似的top命令观测CPU时也有iowait指标，也体现了IO的度量，IO不仅受磁盘影响，也会影响CPU的使用率。</p><p>pidstat从名字可以看出，用于找出问题出在哪个进程，指标包括IO，内存缺页，栈的使用大小。</p><h2 id=跟踪方式>跟踪方式</h2><p>2.5版本内核支持了ftrace特性，并以tracefs文件系统方式展现给用户。如果打开了该特性，可以在/proc/mounts查找tracefs的挂载点，并切换到root（sudo不行！）进入该目录（一般是/sys/kernel/debug/tracing/）。既然是类文件系统，通过修改文件来打开跟踪和观察。这种方式操作不友好，trace-cmd包可以简化一些。ftrace的实现依赖于内核在gcc编译阶段留的桩，编译内核的参数缺省会用"-pg -mfentry -mrecord-mcount"，前两个参数给每个函数开头插入5个字节的callq指令，而最后一个参数则在vmlinuz的<code>mcount_loc</code>段记录了所有内核函数的地址。但是所有函数都留桩显然开销太大（下降13%），所以ftrace在内核启动时会callq指令替换成nop指令。当用户对特定函数开启了追踪，用callq替换nop，将追踪信息写入ring buffer输出给用户。</p><p>2.6版本出现了perf，因为ftrace只管抓trace数据并没有分析，perf在trace数据分析方面做出了很多成果。在trace数据采集方面，perf复用了ftrace的所有插桩点，并且加入了采样法(硬件PMU)。PMU是一种非常重要的数据采集方法，因为它大部分是硬件的，所以可以做到一些软件做不到的事情，获取到一些底层硬件的信息。</p><blockquote><p>PMU是什么：像L1 cache失效、分支预测失败等几种处理器特性对软件的性能有很大的影响，然而依赖时钟进行定期采样的 profiler 模式无法揭示程序对这些处理器硬件特性的使用情况。处理器厂商针对这种情况，在硬件中加入了 PMU 单元，即 performance monitor unit。PMU 允许软件针对某种硬件事件设置 counter，此后处理器便开始统计该事件的发生次数，当发生的次数超过 counter 内设置的值后，便产生中断。比如 cache miss 达到某个值后，PMU 便能产生相应的中断。捕获这些中断，便可以考察程序对这些硬件特性的利用效率了。</p></blockquote><p>BPF源于1992年的Berkeley Packet Filter论文，触发Linux社区在97年也跟进并实现了Linux Socket Filter机制，但长久以来只有tcpdump这个应用。BPF原理如下图。经网卡驱动层的报文在上报给协议栈的同时会多出一路来传送给BPF，再经后者过滤后最终拷贝给用户态的应用。除开tcpdump，当时的 RARP 协议也可以利用 BPF 工作(Linux 2.2 起，内核开始提供 rarp 功能，因此如今的 RARP 已经不再需要 BPF 了)</p><p><img class=mx-auto alt=bpf-germ src=/img/bpf-germ.jpg></p><p>其中的filter是类似汇编码的指令，为了防止注入，对BPF的指令做了很多数量和长度的限制。由于内核态开销大，3.x时代出现了JIT for BPF，2013年对BPF做了彻底重写，命名为eBPF，最终在3.17时代进化出全新的eBPF，并持续发展了seccomp、XDP、traffic control等机制。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>