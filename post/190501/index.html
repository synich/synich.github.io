<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux的软件包管理软件说明 | 蛙二的思考</title><meta property="og:title" content="Linux的软件包管理软件说明 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-05-01T12:00:00+08:00"><meta property="article:modified_time" content="2019-05-01T12:00:00+08:00"><meta name=Keywords content><meta name=description content="Linux的软件包管理软件说明"><meta name=author content><meta property="og:url" content="/post/190501/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux的软件包管理软件说明</h1></header><date class="post-meta meta-date">2019年5月1日</date><div class=post-content><p>不同发行版有独特的包管理软件，分为打包软件和包管理两块，相对来说打包软件定义包的格式，而包管理要解决的问题要复杂得多。</p><ol><li>添加软件时，要记录所有依赖的库和执行程序，且依赖项的引用计数要加1</li><li>删除库时，所有依赖这个库的执行程序都要连带删除</li><li>删除执行程序时，对其依赖的库的引用计数要减1，如果减到0了，要提醒用户，但并不删除，比如apt autoremove就是用于删除引用计数为0的库和执行程序</li><li>更新软件时，对依赖项有变动的，要更新引用计数，并按上面提到的策略给用户以提示</li><li>列举已安装软件时，apt做得很清晰。如果是被连带安装，会标注automatic，如果引用计数到0了，会提示auto-removable。对被连带安装的软件，如果手动安装一次，其auto标记会被清除，以后就不再提示auto-removable了。</li></ol><h2 id=centos>CentOS</h2><p>可以更新系统内核版本。</p><ul><li>yum clean all</li><li>yum update</li></ul><p>时间取决于和最新版本的差距，我从7.3到7.6约用了10分钟。为了让新安装的内核成为默认启动选项，你需要如下修改 GRUB 配置,打开并编辑 /etc/default/grub 并设置 GRUB_DEFAULT=0.意思是 GRUB 初始化页面的第一个内核将作为默认内核。不过这条我没用到。</p><p>升级后不同版本会遗留很多的垃圾，要清理。先找出冗余内核</p><p>rpm -qa | grep kernel</p><p>对不是当前在用的，复制名字并删除。</p><p>yum remove xxx yyy</p><p>yum不会升级内核版本，elrepo.org 专门负责有内核升级需求的人。命令如下</p><ul><li>rpm &ndash;import <a href=https://www.elrepo.org/RPM-GPG-KEY-elrepo.org>https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a></li><li>rpm -Uvh <a href=http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm>http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</a> //适当调整</li></ul><p>仓库启用后，你可以使用下面的命令列出可用的系统内核相关包:</p><ul><li>yum &ndash;disablerepo="*" &ndash;enablerepo=&ldquo;elrepo-kernel&rdquo; list available</li></ul><p>接下来，安装最新的主线稳定内核:</p><ul><li>yum &ndash;enablerepo=elrepo-kernel install kernel-ml</li></ul><p>外番：rpm的命令围绕-q, -i, -e展开，选项不能随意搭配，但顺序随意。有些只用于-q查询，有些只用于-i安装。奇怪的是-R只在man能看到，帮助没有显示。</p><h2 id=alpinelinux>AlpineLinux</h2><p>首先编辑/etc/apk/repository，到你想要的版本号，执行</p><ul><li>apk update ; 更新repo的index</li><li>apk upgrade ; 更新程序实体</li><li>sync;reboot ; 保证落盘重启生效</li></ul><h2 id=debian>Debian</h2><p>版本7(wheezy)以前是apt-get和apt-cache分离，版本8(jessie)增加了统一入口apt。apt-get负责下载软件和仓库索引，而apt-cache是查询，初始干净的版本是没有仓库索引的，这时用apt-cache搜索没有结果，是正常现象，apt-get update后就能正常使用了。</p><h2 id=arch>Arch</h2><p>pacman的命令风格格式全部以<code>-[DQRSU]</code>开头，接下来是选项，如果是单字选项可以直接跟在命令后面。比如-Qv命令显示同步源和所有已安装的包，比如我的版本有5个文件，大小从4K到5M不等，每个文件是gz压缩的纯文本。所有已安装的包也以独立目录的形式存在，每个包的描述、文件详情都能很方便得看到。</p><p>pacman的包没有.deb或.rpm这样特殊的后缀，而是很朴实地用了.tar.xz名（也可以配置为.tar.gz）。包的内容通常是建立在/usr目录下的各个文件，还有.BUILDINFO, .MTREE, .PKGINFO三个元数据文件。制作包也很朴实，写好PKGBUILD文件，再用makepkg就能打包。</p><h2 id=gentoo>Gentoo</h2><p>衍生自BSD系的portage，全部由python/bash构成。和其它二进制方式管理包不同，仓库同保存的各种软件的元信息，以目录形式保存描述，倾向于源码编译。</p><p>所有的命令都以e开头，核心命令是emerge，支持5种安装格式。意寓把某个软件合并到portage树，最常用的world是一个set的别名。另外还有ebuild，emaint等。</p><p>由于从源码编译，有几个很独特的概念</p><ul><li>USE: 类似编译开关，选择是否取消某些连带项，而arch就做不到，只能取决于维护者的个人喜好</li><li>mask: 对包做的标记，如果前提不满足，无法安装</li><li>EAPI: ebuild的格式版本，隔一段时间会更新，如果达不到上游的要求不能安装软件</li></ul><h2 id=pacman在其它发行版上的尝试>pacman在其它发行版上的尝试</h2><p>起因是装了Gentoo但是磁盘空间不够，第一步emerg-webrsync就失败了，无法下载软件的系统是没有意义，于是想既然Linux的内核一致，能否从别的发行版移植包管理器来用。</p><p>最流行的当然是apt，但这几天刚好在用ArchLinux的pacman，而且从不足2小时的了解来看，pacman非常简明，且源码只有3M，感觉比较容易，这是我第一次尝试编译包管理系统。pacman依赖并不多，在这个2015年左右的Gentoo上，只缺少libarchive的3.0版本，另外bash版本稍低，最终决定编译pacman的5.1.3。(5.2版本要求bash版本4.4以上)。遇到<code>clock_gettime</code>函数不存在，好在代码里用宏给了另一种实现，把相关3行代码换一下手动编译过。配置通过/etc/pacman.conf就够了，可以配置repo位置、arch、哪些包不更新、使用curl/wget下载等。</p><p>pacman的思路，所有的软件信息保存在本地的sync和local两个目录，sync是全部软件的索引，local是已安装的软件。-S操作sync，-Q操作local。所以搜索也区分全部搜索的-Ss和本地搜索的-Qs。一旦理解其设计思路，命令就能说通了。</p><p>安装和配置完成后，先尝试安装locate包(几乎没有依赖)，然后提示需要更新filesystem、glibc、tzdata等若干个包，但是下载后又提示glibc: exists in filesystem并拒绝安装。我猜原因是这些包不在pacman的记录中，且对应位置已经有文件，为防止潜在的冲突，就停止安装。加了&ndash;overwrite *选项后大部分错误都屏蔽了(这个选项正常情况下尽量避免)，只有filesystem提示一些目录无法覆盖。于是我尝试把另一个版本DB Path下local目录的filesystem内容复制过来，果然骗过了pacman更新了glibc等库并装上了locate。但是悲剧的是执行ls会提示glibc相关的错误，而且ssh也连接不上。</p><p>分析挂掉的原因，对每个发行版来说，最根本的rootfs一定包含基础工具(哪怕是busybox)和libc，而我只更新libc却瞒过filesystem，导致两者不能配套，最终使得整个系统挂掉。可以至少对pacman来说，由于它管理了rootfs，当安装到其它发行版时，会出现不配套问题。</p><p>Arch没有固定版本(但是filesystem的日期勉强可以算版本)，因此不可能有锚定的rootfs，基础库和工具一定是不停更新的，这也是和debian/cent系最大的区别。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>