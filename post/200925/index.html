<!doctype html><html lang=zh-ch>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>python点滴记录 | 蛙二的思考</title>
<meta property="og:title" content="python点滴记录 - 蛙二的思考">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-09-25T12:00:00+08:00">
<meta property="article:modified_time" content="2020-09-25T12:00:00+08:00">
<meta name=Keywords content>
<meta name=description content="python点滴记录">
<meta name=author content>
<meta property="og:url" content="/post/200925/">
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=stylesheet href=/css/normalize.css>
<link rel=stylesheet href=/css/style.css>
<script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
</head>
<body>
<header id=header class=clearfix>
<div class=container>
<div class=col-group>
<div class=site-name>
<a id=logo href>
蛙二的思考
</a>
</div>
<div>
<nav id=nav-menu class=clearfix>
<a class=current href>首页</a>
</nav>
</div>
</div>
</div>
</header>
<div id=body>
<div class=container>
<div class=col-group>
<div class=col-8 id=main>
<div class=res-cons>
<article class=post>
<header>
<h1 class=post-title>python点滴记录</h1>
</header>
<date class="post-meta meta-date">
2020年9月25日
</date>
<div class=post-content>
<h2 id=多线程>多线程</h2>
<p>拜臭名昭著的GIL所赐，多线程只在IO密集场景下有一战之力。即便只能用到一个核，锁还是必须的，但这个锁和OS的锁不同，是语言级别的锁，不会触发futex调研。有人解释说这种锁的获取和释放，会引起GIL的调度，暂时不能确定。另外py3新增了asyncio后，多线程的使用场景似乎更少了。</p>
<h2 id=多进程>多进程</h2>
<p>多进程库有两种构造进程的方式，Process（构造一个）和Pool（构造多个功能相同的进程）。从实际效果来看，每生成1个进程，实际会生成2个线程。以生产消费模型，结合队列来举例子。</p>
<p>先说队列Queue，生产者用put方法，消费者用get方法，但是这里有个隐秘且反直觉的地方，调用put会将队列的计数加1，但get并不会减1，需要在get之后再调用task_done才行，背后的原因是get允许异步获取，所以必须消费者确认得到消息后，才能将队列次数减1。队列的次数可以通过empty方法得到。真实代码中，生产者会用队列的join方法，join会阻塞直到队列为空才执行下去。</p>
<p>就产生了这样一种方式，消费者用with Pool结构，在这个结构内，用Process来创建生产者，生产者全部start()后，会挨个join()，直到每个生产者执行中，队列的join通过后，才会结束。<em>注意，这里有两个join，分别作用在队列和进程上，而进程的join又被队列的join所阻塞，最终等待消费者消费完所有消息，这就构成了完整的闭环</em>。当生成者结束后，with语句块的生命周期结束，调用Pool的<code>__exit__</code>方法，它又触发了Pool的terminate()，将所有消费进程强行停止，于是所有进程就都正常回收了。</p>
<p>一开始我看这段还很疑惑，为什么while Tue循环里只有队列的get，看不到判断和退出，其它是用了with块的方式强行中止了进程，自然就不用判断队列。</p>
<p>JoinableQueue objects should only be shared between processes through inheritance</p>
<p>Pool创建的进程，和Process没有继承关系。跟踪系统调用发现，都是用clone函数，无非用的标志位不同</p>
<ul>
<li>CLONE_VM: VM shared between processes，内存共享，大约等于线程</li>
<li>CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID: Store child thread ID in child memory.Erase child thread ID in child memory space when child exits.</li>
<li>CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID:</li>
</ul>
<h2 id=进程池>进程池</h2>
<p>使用进程池Pool启动多进程建议用<code>apply_async</code>，这个方法默认不会阻塞，想要等待必须连用Pool的close和join方法，网上文章几乎不提为什么。看了源码才知道，Pool有4种状态，INIT，RUN，CLOSE，TERMINATE。构造进程池对象时，内部会经由INIT状态切到RUN状态。CLOSE状态是为了配合join使用，如果不切换到CLOSE状态，join动作会报错。join内部调用到的方法有wait，只是觉得都用join还是有些混淆。</p>
<h2 id=多进程的队列>多进程的队列</h2>
<p>底层使用操作系统的pipe作为传输，但为了实现任意py对象的传输，在数据写队列前，会先用pickle序列化，读出的一方会先确认pipe内的消息长度，读出后再反序列化。复杂队列的实现，发送者每次发一条消息，会创建一个线程，由这个新的线程向pipe写数据。</p>
<h2 id=defaultdict>defaultdict</h2>
<p>出人意料的是这个容器是builtin的，实现在<code>_collection</code>包中，不是一个独立的磁盘文件，而是和C语言实现打包在一起，可能对字典的操作需要极高的性能，因此无法用py实现吧。</p>
<h2 id=namedtuple>namedtuple</h2>
<p>是一个函数返回一个用type方法动态构建的类</p>
<h2 id=pickle序列化>pickle序列化</h2>
<p>首字节固定0x80，然后跟1字节的版本号，截止3.8共有1-5的版本。</p>
<p>每遇到新的复杂结构（tuple/list/dict），都会写入一个新的标记符，<code>EMPTY_XX</code>，然后跟着具体的值。</p>
<p>结构内的字符串，以类型+长度+值的方式保存（典型的TLV格式）。</p>
<p>字典内容都结束后，以一个&rsquo;s'（SETITEM动作）把kv的pair对加入字典。</p>
<p>最后以'.&lsquo;结尾这个pickle。</p>
<p>当然过程中会用MEMOIZE技术复用已保存的字符串，达到节约空间的效果。整个pickle不仅仅记录了值，更记录了从一片空白到完成所有对象的整个操作步骤，在构建过程中逐步还原出对象。</p>
</div>
<div class="post-meta meta-tags">
没有标签
</div>
</article>
</div>
<footer id=footer>
<div>
&copy; 2021 <a href>蛙二的思考 By </a>
</div>
<br>
<div>
<div class=github-badge>
<a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
</div>
<div class=github-badge>
<a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a>
</div>
<div class=github-badge>
<a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
</div>
</div>
</footer>
<script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:!0}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script>
</div>
<div id=secondary>
<section class=widget>
<form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1>
<input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button>
</form>
</section>
<section class=widget>
<h3 class=widget-title>最近文章</h3>
<ul class=widget-list>
<li>
<a href=/post/210901/ title=对昼伏夜出和朝九晚五两个技战法的分析>对昼伏夜出和朝九晚五两个技战法的分析</a>
</li>
<li>
<a href=/post/210729/ title=git的远程访问辨析>git的远程访问辨析</a>
</li>
<li>
<a href=/post/210721/ title=PySpark分析>PySpark分析</a>
</li>
<li>
<a href=/post/210614/ title=erlang和其上的扩展语言>erlang和其上的扩展语言</a>
</li>
<li>
<a href=/post/210613/ title=lisp编程与结构化思想>lisp编程与结构化思想</a>
</li>
<li>
<a href=/post/210611/ title=理解shell的换行和打印>理解shell的换行和打印</a>
</li>
<li>
<a href=/post/210421/ title=vim的自定义扩展>vim的自定义扩展</a>
</li>
<li>
<a href=/post/210404/ title=数据库的执行优化>数据库的执行优化</a>
</li>
<li>
<a href=/post/210322/ title=对公有云上数仓的调研>对公有云上数仓的调研</a>
</li>
<li>
<a href=/post/210216/ title=hadoop体系理解>hadoop体系理解</a>
</li>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/categories/>分类</a></h3>
<ul class=widget-list>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/tags/>标签</a></h3>
<div class=tagcloud>
</div>
</section>
<section class=widget>
<h3 class=widget-title>其它</h3>
<ul class=widget-list>
<li><a href=index.xml>文章 RSS</a></li>
</ul>
</section>
</div>
</div>
</div>
</div>
</body>
</html>