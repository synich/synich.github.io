<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Python的包机制 | 蛙二的思考</title><meta property="og:title" content="Python的包机制 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-06-06T12:00:00+08:00"><meta property="article:modified_time" content="2020-06-06T12:00:00+08:00"><meta name=Keywords content><meta name=description content="Python的包机制"><meta name=author content><meta property="og:url" content="/post/200606/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python的包机制</h1></header><date class="post-meta meta-date">2020年6月6日</date><div class=post-content><h2 id=包的封装机制>包的封装机制</h2><p>python社区前后有easy_install的egg和pip的wheel两种包封装机制，另有anaconda给出的conda方案。python由于版本不兼容原因，最好配合venv/virtualenv指定版本，否则依赖库会冲突。wheel只是发行格式，安装完成就变回普通的文件夹和文件，而egg不仅是发行格式，也是运行时可以直接加载的格式。通常都建议wheel，毕竟有PEP背书，特殊场合比如不想被直接看到代码，打包到一个文件更简洁。</p><p>安装PyHive包，以tar包源码形式发布，执行setup.py之后在这台机器上可用，但去site-package目录下看到的却只有一个egg包，和pip方式安装得到的几个目录方式不同，直接复制这个egg包到其它目录后，会提示无法找到PyHive。直到用easy_install安装这个egg包，才明白要在site-package下的easy-install.pth文件里添加一行关于PyHive的版本说明，才能找到。大概原因是import机制会忽略带有连字符的包，而egg包一定有连字符，需要需要.pth文件做个牵引。</p><h2 id=setuppy使用>setup.py使用</h2><p>官方早期提供的distutil包可以制作无依赖的安装包，为支持更复杂的场景，产生了第三方的setuptools，包制作仍然基于distutil，扩展了依赖包管理。但是distutil的文件比较混乱，而且setuptools都会完整地内嵌一份，到了3.10版本官方正式确定废弃distutil，全面改用setuptools。easy_install现在也是setuptools的一个子模块。</p><p>setup.py有多种子命令，bdist编译egg包，如果本地装了wheel，可以用python setup.py bdist_wheel指令打成wheel包。egg包放到pypi的仓库中，无法用pip安装，会提示no match version之类错误，但包名是包含了版本的，原因不明。</p><p>存放代码的目录可以随意命名，制作包的setup函数有非常多参数，有一些概念要注意区分</p><ul><li>name=&lsquo;abc&rsquo; 包的名字，只是一个宣传用的名字，对程序运行没有特别的作用，也不要求和import的包名一致。安装之后，包描述目录的METADATA文件会显示这个name</li><li>packages=[] 包安装到site-package后的目录名，可以和包名不同，也可以有多个。一般一个包安装一个目录，但像pyhive就会装两个目录</li><li>package_dir={} 安装到site-package的目录名和源码目录的映射关系</li><li>ext_modules = [ Extension(&lsquo;x&rsquo;, sources=[&lsquo;x.c&rsquo;])] C语言写成的扩展模块</li></ul><p>上面packages两条，我觉得都是非常糟糕的设计，灵活到让初学者非常迷惑，比如import的包名，在pip freeze却很可能找不到对应的包名，甚至描述目录名都没有与之对应，直到找到了目录的MEATDATA文件才找到包名。但也可能是import用的名字会有很多人想要，于是允许不同的包名安装时用不同的名字（相当于pip注册时是不同的），但安装后用同一个目录名。如果真的产生冲突，那就由用户自己决定。</p><h2 id=自定义安装位置>自定义安装位置</h2><p>site.py可以额外添加两个加载包的路径，<code>USER_SITE</code>类似全局的位置，而<code>USER_BASE</code>则默认指向当前用户的.local目录。第三方可以仅给某些用户安装，因此<code>USER_BASE</code>的价值就体现出来了。但要启用这个机制还有个前提，getuid和geteuid，getgid和getegid的返回必须相同，否则会认为是sudo行为，不予加载。</p><h2 id=控制符号的导出>控制符号的导出</h2><p><code>__all__</code>变量只对import *语法有作用，如果手动地导出一个确实存在的变量，<code>__all__</code>是不会阻拦的。从字面含义也好理解，all对应的是*，当然不影响手动导出符号，不过也可见这套机制的简陋。同样py文件中的函数也是这个道理，所有以_开头的函数，用import *都是看不到的，但是如果知道名字，仍然可以手动调用，所谓防君子不防小人是也。</p><h2 id=windows环境的包特性>Windows环境的包特性</h2><p>Python标准包有近百个目录和文件，在分布运行时非常不便，尽管可以把第三方包做成zip，但标准包却不行。因此官方针对Windows提供了embeddable方式的二进制包，把标准包也做成了zip包，而python程序在编译时加了特殊配置，直接加载标准zip包。</p><p>包的加载路径，如果存在site-packages目录，它会被加入sys.path；而如果根本没有这个目录，sys.path就不会去搜索这个目录。有些包会额外产生一个命令行程序，典型的比如pip。pip在更新自己时需要替换pip.exe，但由于Windows的机制不允许替换自己，现象是pip目录会被改名为~ip，再次执行会报找不到pip。解决办法就是把~ip改回pip就可以了，因此Windows上似乎只能删了重装pip。</p><h2 id=venv机制>venv机制</h2><p>官方提供的venv包会把一个目录做成相对独立的环境，具体过程不复杂</p><ol><li>在该目录下建立bin/lib等目录</li><li>将venv目录的activate文件复制到bin</li><li>使用标准库ensurepip安装一套独立pip/setuptools到bin和lib</li></ol><p>venv初始化后，source bin/activate，会把当前目录放到PATH的开头。于是当前会话下的pip操作就会把要安装的新包放到这个独立目录（退出shell或执行deactive则仍旧用全局pip）。python复用全局命令，观察此时的sys.path，会发现site-package已经换成venv指定的目录了（其它标准目录不变）。</p><h2 id=import过程>import过程</h2><p>结合q这个包和一些试验，看整个import xxx过程发生了什么。</p><ol><li>先判断sys.modules[&lsquo;xxx&rsquo;]是否存在，有值直接结束，没值则查找文件。注意：<em>不是判断当前上下文是否有xxx变量</em>。</li><li>找到xxx.py并读取，在开始读取前，sys.modules[&lsquo;xxx&rsquo;]已经被初始化，并且具有了<code>__name__</code>、<code>__doc__</code>等内置变量</li><li>随着对xxx.py的解析，xxx模块定义的类、函数也会被添加到sys.modules[&lsquo;xxx&rsquo;]</li><li>结束对xxx.py解析，在当前上下文，新增xxx变量，并让xxx指向sys.modules[&lsquo;xxx&rsquo;]。如果在import xxx之前已经有xxx变量，会覆盖xxx。</li></ol><p>q这个包就在第3步结束前，覆写了sys.modules[&lsquo;q&rsquo;]变量，实现了import q后，q就能使用的魔术技法，同时也隐藏了q的实现类，非常巧妙。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>