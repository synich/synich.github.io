<!doctype html>
<html lang="zh-ch">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <title>【转】对PHP的分析 | 蛙二的思考</title>
    <meta property="og:title" content="【转】对PHP的分析 - 蛙二的思考">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2018-10-21T12:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2018-10-21T12:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="【转】对PHP的分析">
        
    <meta name="author" content="">
    <meta property="og:url" content="/post/181021/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="">
                        蛙二的思考
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">【转】对PHP的分析</h1>
        </header>
        <date class="post-meta meta-date">
            2018年10月21日
        </date>
        
        
        
        <div class="post-content">
            <p>我不考虑可以用封装库解决的问题，比如不考虑 JSON api，in_array 默认 == 等等
我不考虑各种 VM 实现的问题，比如 C 扩展常驻内存</p>
<p>我不考虑 PHP 文档的问题，不考虑 PHP 历史上的问题，比如 5.3 中不能 parse $cb()()
我不考虑 parser 的报错信息难读问题</p>
<p>文章内容目录：</p>
<ul>
<li>FP：set! 和 defun 是不一样的，但是 PHP 连 set! 都不如</li>
<li>MP: MP 不是 toString 或者 any -&gt; String， 而是 Expr -&gt; Expr 和 Expr -&gt; Q</li>
<li>OO: The big idea is messaging.</li>
</ul>
<p>eechen 说我们可以使用 $func来在 PHP 中实现 FP，但是这是不可行的。让我们考虑最简单的 fib</p>
<pre tabindex="0"><code>$fib = function ($x) use ($fib) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($fib, [$x-1]);
};
var_dump($fibs(10));
或者

$fib = function ($x) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($fib, [$x-1]);
};
var_dump($fibs(10));
</code></pre><p>二者皆会报错，第一个说找不到 $fib，第二个说 $fib 是没有定义的 NULL。</p>
<p>继而我们猜测这只是 PHP 解释器的一个小 bug，我们只需要把 closure 的位置在 AST 往下压一层之后 use 就能找到了，比如</p>
<pre tabindex="0"><code>function id($x) {return $x;)
$fib = id(function ($x) use ($fib) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($fib, [$x-1]);
});
var_dump($fibs(10));
</code></pre><p>依然是找不到 $fib。</p>
<p>可能这时候我们只是认为 use 之前需要声明，只是一个 php 解释器上实现的一个小 bug，比如</p>
<pre tabindex="0"><code>$fib = NULL;
$fib = function ($x) use ($fib) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($fib, [$x-1]);
};
var_dump($fibs(10));
</code></pre><p>结果是 $fib 在 closure 中对应的值 NULL，无法被访问。</p>
<p>这就是我们说 PHP 既不支持函数作为第一成员又没有 scope 的原因。scope 是作用域内 symbol 和 value 的绑定。PHP 并不存在一个正常的讲上层 scope 的某个 symbol 映射放到 closure 中的方法，PHP 的所谓的 use 只是即时地在 closure 中插入一个 $fib = NULL ，而并非是将对 $fib 的访问转移到上层 scope 的访问中。</p>
<p>简单来讲，<strong>PHP 所谓的 scope 不是 scope，而只是一个解释求值的 barrier，你不可能访问上层 scope 的 symbol。而 php 的 closure 也不是 closure，php 的 closure 只能绑定 value 而不能绑定 symbol。</strong></p>
<p>如果说要强行 $func 来实现自指递归或者互指递归也不是不可以，那么你需要这么写</p>
<pre tabindex="0"><code>$scope = [];
$scope['fib'] = function ($x) use ($scope) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($scope['fib'], [$x-1]);
};
$fib = $scope['fib'];

或者更加规范的，默认使用的 scope 入口和 defun

function createDefun($scope) {
   return function($fname, $definition) use ($scope) {
       $scope[$fname] = function () use ($scope, $fname, $definition) {
          $args = func_get_args();
          $scope[$fname] = call_user_func_array($definition, array_merge([$scope], $args));
       };
   };
};

$sp = [];
$defun = createDefun($sp);
$defun('fib', function($scope, $x) {
  if ($x == 0) {
    return 1;
  }
  return $x* call_user_func_array($scope['fib'], [$x-1]);
});
$fib = $sp['fib'];
</code></pre><p>我只是觉得，「一个语言支持 FP 范式」和「一个语言需要自行实现 scope 然后就可以通过手动注入 scope 然后就可以 FP 了」应该是完全不同的两个意思吧？</p>
<p>这也是我们说 「PHP 不是一门支持 FP 的语言」时和说「JS，Py 等等可以写 FP，但是毕竟不是一门 FP 语言」的不同。如果我们有其他语言的经验，（无论这语言是 Py2/Py3，JS，Perl5，还是利用 operation() 当作 function 的旧 CPP，甚至是他喵的 MatLab），我们可以看到他们访问上层 scope 中的 symbol 是自然而然的；而 PHP 我们要么自己实现一个 scope 和 defun，要么就是使用 array(<strong>NAMESPACE</strong> . &lsquo;' . $className, $funcName) 和 static 这种并非设计为 FP 的 ugly hack。所以我们可以安全地宣称，PHP 是不支持 FP 的。</p>
<p>PS：在本节末尾指出来一下， eechen 原文误以为「PHP 变量可以绑定类」，实际上 PHP 变量只能被赋值为类的实例而不能绑定类。这种不能绑定类特性的缺乏导致了没法实现 immutable-js BaseRecord = Record({&hellip;}) 之类的基于函数的类派生，也对实现利用 cache 来加速 immutable 变量的生成增添了很多不必要的 boilerplate code</p>
<p>MP: MP 不是 toString 或者 any -&gt; String， 而是 Expr -&gt; Expr 和 Expr -&gt; Q</p>
<p>一个语言是否具有 MP 的能力并不是其是否有一个叫做 XXXRefection 的方法，实际上 PHP 的 reflection 只是一系列拿到源码的 toString；这类方法在其他语言中也是常见，比如 ES3 时代就有了 Function.prototype.toString这样的方法</p>
<pre tabindex="0"><code>function hasContent() {/*
    Line 1
    Line 2
    Line 3
  */}
var content = hasContent.toString.split('\n').slice(1, -1).join('\n')
</code></pre><p>如果我说 ES3 时代就实现了 MP，我觉得我会被 JSer 打死。甚至 ES5 时代 styled-component 通过了 Tagged templates 实现了 JS 中解析运行 CSS，JSers 也没有吹什么 「JS 是一个支持了 MP」的语言（虽然我明年准备看看能不能借用 tagged template 可以访问 js obj 的特性来实现一些简单的可访问 JS 变量的 DSL，当然这只能说能有一点 MP 技巧；和真正利用 MP 做 code gen 离得很远）</p>
<p>MP 是利用已知代码进行 code generaation 的手段。比如 Julia 如果不想多次写 dimension 可以（免责声明：自转行后大概有一年没写 Julia 了，所以下面可能会有简单的语法错误或者漏写 global 或者 quote）</p>
<p>const c = @cmm( squeeze(sum(mean(a,3),2))) ## cmm stands for common math macros</p>
<p>扩展成如下代码以避免写两次 dimension</p>
<p>const c = squeeze(sum(mean(a,3),2)), (2,3))</p>
<p>同样我们可以轻松地在处理 NaN 的时候利用 macro 来做替换</p>
<p>const c = @cmm( periodic(mean(x,2, isNaN=false)))</p>
<p>替换成这样的形式，也就是我们在没有提供 isNaN 接口的时候，一定程度上可以类似用写 R 的方式处理数据</p>
<p>const c =  periodic(nonNaNMean(x,2))</p>
<p>甚至可以模拟一下 typeclass，下面是利用 MP 将 svd, eof, 等等方法从 Array{Float, 2} 扩展到 Array{Float64, n} 的一种 macro 示例</p>
<pre tabindex="0"><code>const (eofs, pcs) = fuck2D(
  quote
    global SST // SST is a 3D array of lat * lon * time
    describe(SST, 3) // 3 is the timal dimension;
    return svd(SST)
  end
)
这将扩展成现将 SST 转成 2D array， 然后将 分析后的 1D array 转回 2D 的方法

const (eofs, pcs) = do
   global SST
   SST_config_#1 = create_Dconfig({timal_dims: 3})
   (SST2D_#1, from_1D_to_sp, from_1D_to_timal) = decompose(SST, SST_config_#1);
   (eofs1D_#1,pc1D_#1) = svd(SST2D_#1)
   eofs_#1 = intercept_1D(eofs1D_#1, from_1D_to_sp)
   pcs_#1  = intercept_1D(pcs1D_#1, from_1D_to_timal)
   return (eofs_#1, pcs_#1)
end
</code></pre><p>这类宏生成代码节省了大量手动写 adapter 的时间，实现了类似 type class 的效果。另外一类常用的 MP 做法是将任何一个需要埋点的函数</p>
<pre tabindex="0"><code>function func(a,b,c) {
     return func(a', b', c')
}
这类代码转换成类似

function func_effect(f, a, b, c) {
      call_effect(f, a', b', c')
}
</code></pre><p>这样我们可以在 call_effect 中使用统一的 effect 处理和上下文传递等等。</p>
<p>首先PHPer 看不懂 MP 但是又说 PHP 支持 MP 难道是我的错么？
这里只是展现一下为什么 MP 的实践需要 AST；在这类需求中，文本替换然后 eval 显然是不安全而且不够灵活的。不在 AST 上 walk 一下还能怎么办呢，难道拿头锤 regex 做替换？</p>
<p>一个 PHPer 可能会争论说其实这类 MP 实践在 PHP 中是可以做到的；然后他可能会举出类似于 Roave/BetterReflection这样的库；显然，在看过这种库之后，即使不懂 MP 也能发现很明显的风险：</p>
<p>其 parser 库并非是 php 解释器自己的 parser，而是另一种 PHP 实现的 <a href="https://github.com/nikic/PHP-Parser">https://github.com/nikic/PHP-Parser</a> ；也就是任何 PHP-Parser 和 php 解释器 parser 的不一致都会影响到结果 （而且难以 debug）
PHP 并没有 eval(Expr) 的手段，对于变换后的 AST，需要使用 PHP-Parser 来 write string，然后执行转写的 string。这不仅仅依赖于 PHP-parser 的正确性，而且任何 php 的报错都会在 eval 这一行，eval（string） 永远是危险的呀</p>
<p>而且不可避免的，这样的 parser 实践还会导致所有含有副作用的语言中 MP 共同要面对的问题：副作用跟踪。考虑到我们在某个文件中元编程两次</p>
<p>eval(AST2String(expr1))</p>
<p>eval(AST2String(expr2))</p>
<p>如果在 expr1 中含有了</p>
<p>function foo {&hellip;}
bar_effect = &hellip;；
然后 expr2 含有了</p>
<p>function foo {&hellip;}
bar_effect = &hellip;;
然后 expr1 的部分结果就有被 expr2 覆盖的风险。</p>
<p>在 Julia 中，macroexpand 直接会分析上下文并且在变量后面加上 <code>_#number</code> 这样的后缀防止覆写变量；而且很多 lisp 系语言中，eval 本身是 lexical scope 下在一个新的 scope 进行的。</p>
<p>OOP：三原则或者四圣谛只是 90 年代类似 Java 语言对于 OOP 的一种实现手段而已</p>
<p>本来我以为我这里不需要解释一下 extends 的问题，可以直接讨论层次复杂度和静态检查的关系。我发现我还是必须引用一下 Alan Kay 的名言 <a href="http://wiki.c2.com/?AlanKayOnMessaging">The big idea is &ldquo;messaging&rdquo;</a></p>
<p>只要我们能够实现层次划分和父子 components 之间的 messaging 传递，那么 OOP 所需要的 divide and conquer 是自然而然的，而且会便利实现 testable module （类似于为了测试方便， database 仅仅被实现为获得值和更新值的一种特例，而非必要的 backend）。</p>
<p>而旧时代的 java 以及其所代码的三原则，实际上很容易出现两个很讨厌的事情，一者是子类对父类的副作用污染，另外一种是只要一个香蕉但是拿到了香蕉加猴子加森林。</p>
<p>当然 data class 和 sub typing 本身就是很讨厌的强行 binding 数据和方法的手段，但是如果不得不这么做了，实际上我们更常委托的方式而非 extends 的方式处理父类和子类的关系。当然，把大部分所需要的方法重新写一遍是很讨厌的 repeat yourself 行为。所以对于动态语言，我们常常依赖约定自动推导 b -&gt; f a -&gt; f b 或者 (a-&gt; b) -&gt; f a -&gt; f b 来压缩类的层次。Java 等等静态语言虽然不能使用这种方法，但是静态分析可以保证在使用工厂或者其他委托方法时候代码的正确性。</p>
<p>然后 PHP 学 Java 了，但是问题是 PHP 能够用静态分析保证委托足够复杂时的正确性，PHP 行么？没有静态分析学 java 就像猪学鸟跳出飞机一样。</p>
<p>尾声</p>
<p>如果你不会 FP，不懂 FP，也没写过 FP，那么就不要说别人「无脑黑 PHP 不支持 FP」
如果你不会 MP，不懂 MP，也没写过 MP，那么就不要说别人「无脑黑 PHP 不支持 MP」
如果你对 OO 的理解只停留在三原则上&hellip;.算了，对于这种 ill-defined 的东西你开心就好
如果你只会 PHP，或者只会用 PHP 的方式写很多副作用满天飞的语言&hellip; 就不要讲什么「好的程序只和程序员有关，和程序语言无关」；这类编程经验不能教人「什么是好的程序」</p>
<p>其实说句实话，作者还真不是了解 php，起码一些基础不行，简单的问题复杂化了，或者是 JavaScript 给你了一些固定的思维方式。明显就是作用域问题，至于为什么 use 继承不了，考虑考虑操作符优先级。</p>
<pre tabindex="0"><code>$fib = function ($x) { 
  global $fib;
 if ($x == 0) { return 1; }
 return $x * $fib($x-1);
};
</code></pre><p>var_dump($fib(10))</p>

        </div>

        


        


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="">蛙二的思考 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>







                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='//www.google.com/search' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="/post/210901/" title="对昼伏夜出和朝九晚五两个技战法的分析">对昼伏夜出和朝九晚五两个技战法的分析</a>
    </li>
    
    <li>
        <a href="/post/210729/" title="git的远程访问辨析">git的远程访问辨析</a>
    </li>
    
    <li>
        <a href="/post/210721/" title="PySpark分析">PySpark分析</a>
    </li>
    
    <li>
        <a href="/post/210614/" title="erlang和其上的扩展语言">erlang和其上的扩展语言</a>
    </li>
    
    <li>
        <a href="/post/210613/" title="lisp编程与结构化思想">lisp编程与结构化思想</a>
    </li>
    
    <li>
        <a href="/post/210611/" title="理解shell的换行和打印">理解shell的换行和打印</a>
    </li>
    
    <li>
        <a href="/post/210421/" title="vim的自定义扩展">vim的自定义扩展</a>
    </li>
    
    <li>
        <a href="/post/210404/" title="数据库的执行优化">数据库的执行优化</a>
    </li>
    
    <li>
        <a href="/post/210322/" title="对公有云上数仓的调研">对公有云上数仓的调研</a>
    </li>
    
    <li>
        <a href="/post/210216/" title="hadoop体系理解">hadoop体系理解</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>