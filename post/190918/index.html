<!doctype html><html lang=zh-ch>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>进程线程和协程的切换开销 | 蛙二的思考</title>
<meta property="og:title" content="进程线程和协程的切换开销 - 蛙二的思考">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-09-18T12:00:00+08:00">
<meta property="article:modified_time" content="2019-09-18T12:00:00+08:00">
<meta name=Keywords content>
<meta name=description content="进程线程和协程的切换开销">
<meta name=author content>
<meta property="og:url" content="/post/190918/">
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=stylesheet href=/css/normalize.css>
<link rel=stylesheet href=/css/style.css>
<script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
</head>
<body>
<header id=header class=clearfix>
<div class=container>
<div class=col-group>
<div class=site-name>
<a id=logo href>
蛙二的思考
</a>
</div>
<div>
<nav id=nav-menu class=clearfix>
<a class=current href>首页</a>
</nav>
</div>
</div>
</div>
</header>
<div id=body>
<div class=container>
<div class=col-group>
<div class=col-8 id=main>
<div class=res-cons>
<article class=post>
<header>
<h1 class=post-title>进程线程和协程的切换开销</h1>
</header>
<date class="post-meta meta-date">
2019年9月18日
</date>
<div class=post-content>
<p>测试Context Switch time(进程上下文切换时间) ，创建两个进程(实时进程)并在它们之间传送一个令牌，如此往返传送一定的次数。其中一个进程在读取令牌时就会引起阻塞。另一个进程发送令牌后等待其返回时也处于阻塞状态。发送令牌带来的开销与上下文切换带来的开销相比，可以忽略不计。 (利用管道传递令牌)</p>
<h2 id=测试程序1>测试程序(1)</h2>
<p>C代码</p>
<pre tabindex=0><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;sys/time.h&gt;  
#include &lt;time.h&gt;  
#include &lt;sched.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;unistd.h&gt;      //pipe()  
  
int main()  
{  
    int x, i, fd[2], p[2];  
    char send    = 's';  
    char receive;  
    pipe(fd);  
    pipe(p);  
    struct timeval tv;  
    struct sched_param param;  
    param.sched_priority = 0;  
  
    while ((x = fork()) == -1);  
    if (x==0) {  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        gettimeofday(&amp;tv, NULL);  
        printf(&quot;Before Context Switch Time %u us\n&quot;, tv.tv_usec);  
        for (i = 0; i &lt; 10000; i++) {  
            read(fd[0], &amp;receive, 1);  
            write(p[1], &amp;send, 1);  
        }  
        exit(0);  
    }  
    else {  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        for (i = 0; i &lt; 10000; i++) {  
            write(fd[1], &amp;send, 1);  
            read(p[0], &amp;receive, 1);  
        }  
        gettimeofday(&amp;tv, NULL);  
        printf(&quot;After Context SWitch Time %u us\n&quot;, tv.tv_usec);  
    }  
    return 0;  
}
</code></pre><p>测试结果(进程切换时间不超过5us)</p>
<p>Before Context Switch Time 617087 us
After Context SWitch Time 702420 us</p>
<p>702420us - 617087us = 85333 us
85333us / 20000 = 4.26665 us</p>
<p>进程切换时间为4.26665 us</p>
<p>注： cpu MHz : 2801.042</p>
<h2 id=测试程序2-使用rdtsc获取当前时间>测试程序(2) 使用rdtsc()获取当前时间</h2>
<p>C代码</p>
<pre tabindex=0><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;sched.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;unistd.h&gt;  
  
long long rdtsc()  
{  
    __asm(&quot;rdtsc&quot;);  
}  
  
int main()  
{  
    int x, i, fd[2], p[2];  
    char send    = 's';  
    char receive;  
    pipe(fd);  
    pipe(p);  
    struct sched_param param;  
    param.sched_priority = 0;  
  
    while ((x = fork()) == -1);  
    if (x==0) {  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        printf(&quot;Before Context Switch Time %lld\n&quot;, rdtsc());  
        for (i = 0; i &lt; 10000; i++) {  
            read(fd[0], &amp;receive, 1);  
            write(p[1], &amp;send, 1);  
        }  
        exit(0);  
    }  
    else {  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        for (i = 0; i &lt; 10000; i++) {  
            write(fd[1], &amp;send, 1);  
            read(p[0], &amp;receive, 1);  
        }  
        printf(&quot;After Context Switch Time %lld\n&quot;, rdtsc());  
    }  
    return 0;  
}  
</code></pre><h2 id=测试结果进程切换时间不超过5us>测试结果(进程切换时间不超过5us)</h2>
<p>Before Context Switch Time 16208184381648</p>
<p>After Context Switch Time 16208424333213</p>
<p>16208424333213 - 16208184381648 = 239951565(clock cycle)</p>
<p>239951565 * 0.357009998 ns = 85665107.74074687 ns</p>
<p>85665107.74074687 ns / 20000 = 4283.255387037 ns = 4.283255387037 us</p>
<p>注： cpu MHz : 2 801 042 000Hz</p>
<p>clock cycle = 1 000 000 000 ns / 2 801 042 000 = 0.357009998ns</p>
<h2 id=测试程序3-可直接获得进程上下文切换时间>测试程序(3) 可直接获得进程上下文切换时间</h2>
<p>C代码</p>
<pre tabindex=0><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;        //drand48()  
#include &lt;sched.h&gt;  
#include &lt;sys/types.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;sys/time.h&gt;      //gettimeofday()  
#include &lt;time.h&gt;  

typedef unsigned long long u64;  
double clockCycleTimeS,clockRateHZ;  
  
/* 获取当前时间，返回秒 */  
double second() {  
    struct timeval tv;  
    gettimeofday(&amp;tv,0);  
    return tv.tv_sec + 1e-6 * tv.tv_usec;  
}  
  
/* 获取当前时间，返回clock cycle */  
u64 rdtsc() {  
    u64 tsc;  
    __asm__ __volatile__(&quot;rdtsc&quot; : &quot;=A&quot; (tsc));  
    return tsc;  
}  
  
/* 睡眠us微秒 */  
void selectsleep(unsigned us) {  
    struct timeval tv;  
    tv.tv_sec = 0;  
    tv.tv_usec = us;  
    select(0, 0, 0, 0, &amp;tv);  
}  
  
/* 计算当前CPU的工作频率 */  
void calibrate() {  
    double sumx = 0;  
    double sumy = 0;  
    double sumxx = 0;  
    double sumxy = 0;  
    double slope;  
    const unsigned n = 30;  
    unsigned i;  
  
    for (i=0; i&lt;n; i++) {  
        double breal,real,ticks;  
        u64 bticks;  
  
        breal = second();  
        bticks = rdtsc();  
        selectsleep((unsigned)(10000 + drand48() * 200000));  
        ticks = rdtsc() - bticks;  
        real = second() - breal;  
  
        sumx += real;  
        sumxx += real * real;  
        sumxy += real * ticks;  
        sumy += ticks;  
    }  
    slope = ( (sumxy - (sumx*sumy) / n) /  
              (sumxx - (sumx*sumx) / n) );  
    clockRateHZ = slope;  
    clockCycleTimeS = 1.0 / slope;  
    printf(&quot;%3.3f MHz\n&quot;, clockRateHZ*1e-6);  
}  
  
int main()  
{  
    calibrate();  
  
    int x, i, p1[2], p2[2], time[2];  
    char send    = 's';  
    char receive;  
    u64 old_time;  
    pipe(p1);  
    pipe(p2);  
    pipe(time);  
    struct sched_param param;     
    param.sched_priority = 0;     
  
    while ((x = fork()) == -1);  
    if (x==0)  
    {  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        old_time = rdtsc();  
        write(time[1], &amp;old_time, sizeof(old_time));  
        for (i = 0; i &lt; 10000; i++) {  
            read(p1[0], &amp;receive, 1);  
            write(p2[1], &amp;send, 1);  
        }  
        exit(0);  
    }  
    else  
    {  
        u64 new_time;  
        sched_setscheduler(getpid(), SCHED_FIFO, &amp;param);  
        for (i = 0; i &lt; 10000; i++) {  
            write(p1[1], &amp;send, 1);  
            read(p2[0], &amp;receive, 1);  
        }  
        new_time = rdtsc();  
        read(time[0], &amp;old_time, sizeof(old_time));  
        printf(&quot;Latency time = %3.3f us\n&quot;,  
                1e6 * (new_time - old_time) * clockCycleTimeS / 20000);  
    }  
    return 0;  
}
</code></pre><p>测试结果(Linux-2.6.21 + RealTime Patch) Latency time = 8.129 us</p>
<p>2801.226 MHz</p>
<h2 id=协议的意义和测试>协议的意义和测试</h2>
<p>前面用实验的方式验证了Linux进程和线程的上下文切换开销，大约是3-15us之间（）。这个开销确实不算大，但是海量互联网服务端和一般的计算机程序相比，特点是：</p>
<ul>
<li>高并发：每秒钟需要处理成千上万的用户请求</li>
<li>周期短：每个用户处理耗时越短越好，经常是ms级别的</li>
<li>高网络IO：经常需要从其它机器上进行网络IO、如Redis、Mysql等等</li>
<li>低计算：一般CPU密集型的计算操作并不多</li>
</ul>
<p>即使3-15us的开销，如果上下文切换量特别大的话，也仍然会显得是有那么一些性能低下。例如之前的Web Server之Apache，就是这种模型下的软件产品。（其实当时Linux操作系统在设计的时候，目标是一个通用的操作系统，并不是专门针对服务端高并发来设计的）</p>
<p>为了避免频繁的上下文切换，还有一种异步非阻塞的开发模型。那就是用一个进程或线程去接收一大堆用户的请求，然后通过IO多路复用的方式来提高性能（进程或线程不阻塞，省去了上下文切换的开销）。Nginx和Node Js就是这种模型的典型代表产品。平心而论，从程序运行效率上来，这种模型最为机器友好，运行效率是最高的（比下面提到的协程开发模型要好）。所以Nginx已经取代了Apache成为了Web Server里的首选。但是这种编程模型的问题在于开发不友好，说白了就是过于机器化，离进程概念被抽象出来的初衷背道而驰。人类正常的线性思维被打乱，应用层开发们被逼得以非人类的思维去编写代码，代码调试也变得异常困难。</p>
<p>于是就有一些聪明的脑袋们继续在应用层又动起了主意，设计出了不需要进程/线程上下文切换的“线程”，协程。用协程去处理高并发的应用场景，既能够符合进程涉及的初衷，让开发者们用人类正常的线性的思维去处理自己的业务，也同样能够省去昂贵的进程/线程上下文切换的开销。因此可以说，协程就是Linux处理海量请求应用场景里的进程模型的一个很好的的补丁。</p>
<p>背景介绍完了，那么我想说的是，毕竟协程的封装虽然轻量，但是毕竟还是需要引入了一些额外的代价的。那么我们来看看这些额外的代价具体多小吧。</p>
<p>协程切换CPU开销测试，测试过程是不断在协程之间让出CPU。Go代码如下。</p>
<pre tabindex=0><code>func cal()  {
    for i :=0 ; i&lt;1000000 ;i++{
        runtime.Gosched()
    }
}

func main() {
    runtime.GOMAXPROCS(1)

    currentTime:=time.Now()
    fmt.Println(currentTime)

    go cal()  
    for i :=0 ; i&lt;1000000 ;i++{
        runtime.Gosched()
    }

    currentTime=time.Now()
    fmt.Println(currentTime)
}
</code></pre><p>总的来说线程切换的时间和协程的比值约是<strong>几十倍</strong>，线程切换在10us级别，协程在1us以下。</p>
</div>
<div class="post-meta meta-tags">
没有标签
</div>
</article>
</div>
<footer id=footer>
<div>
&copy; 2021 <a href>蛙二的思考 By </a>
</div>
<br>
<div>
<div class=github-badge>
<a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
</div>
<div class=github-badge>
<a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a>
</div>
<div class=github-badge>
<a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
</div>
</div>
</footer>
<script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:!0}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script>
</div>
<div id=secondary>
<section class=widget>
<form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1>
<input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button>
</form>
</section>
<section class=widget>
<h3 class=widget-title>最近文章</h3>
<ul class=widget-list>
<li>
<a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a>
</li>
<li>
<a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a>
</li>
<li>
<a href=/post/211102/ title=几种语言的包加载和管理机制>几种语言的包加载和管理机制</a>
</li>
<li>
<a href=/post/211016/ title=以太和IP网之外的一些网络>以太和IP网之外的一些网络</a>
</li>
<li>
<a href=/post/210901/ title=对昼伏夜出和朝九晚五两个技战法的分析>对昼伏夜出和朝九晚五两个技战法的分析</a>
</li>
<li>
<a href=/post/210729/ title=git的远程访问辨析>git的远程访问辨析</a>
</li>
<li>
<a href=/post/210721/ title=PySpark分析>PySpark分析</a>
</li>
<li>
<a href=/post/210614/ title=erlang和其上的扩展语言>erlang和其上的扩展语言</a>
</li>
<li>
<a href=/post/210613/ title=lisp编程与结构化思想>lisp编程与结构化思想</a>
</li>
<li>
<a href=/post/210611/ title=理解shell的换行和打印>理解shell的换行和打印</a>
</li>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/categories/>分类</a></h3>
<ul class=widget-list>
</ul>
</section>
<section class=widget>
<h3 class=widget-title><a href=/tags/>标签</a></h3>
<div class=tagcloud>
</div>
</section>
<section class=widget>
<h3 class=widget-title>其它</h3>
<ul class=widget-list>
<li><a href=index.xml>文章 RSS</a></li>
</ul>
</section>
</div>
</div>
</div>
</div>
</body>
</html>