<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>git概念理解 | 蛙二的思考</title><meta property="og:title" content="git概念理解 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-03-12T12:00:00+08:00"><meta property="article:modified_time" content="2019-03-12T12:00:00+08:00"><meta name=Keywords content><meta name=description content="git概念理解"><meta name=author content><meta property="og:url" content="/post/190312/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>git概念理解</h1></header><date class="post-meta meta-date">2019年3月12日</date><div class=post-content><p>和cvs/svn相比，操作粒度从文件变成了commit。而操作步骤上的变化则是多出了暂存区index的概念，每次提交都分为add(也可以用stage，同义词)和ci两个步骤。有观点提出，这是为了达到svn的多文件原子提交，但命令行不容易选文件，于是多出个中间环节，先小步多次挑选要提交的文件，用add将这些文件形成index暂存区，然后ci实现原子化。通过日志也能看到commit前后两次index的变化，每次也会用sha1编码来表示。</p><p>其实暂存区并不是必备的，创建时用git init &ndash;bare就能创建没有.git目录的仓库（原来放在.git目录下的文件在当前目录直接能看到，相当于整个目录自己就是.git目录）。这个仓库无法执行add操作，一般用来做中心仓库，多人向裸仓库推。如果不这样，冲突会很多，所以有bare特性。</p><p>存储方式也不同于cvs的差分保存，每次提交都会保存一份完整的记录在objects/目录下，不仅文件，每次commit时的目录结构、日志都会保存。通过git gc打包会把这些文件压缩成idx和pack文件，如果操作过程干净，所有的独立文件都会被压缩，当遇到stash恢复冲突等特殊场景，会有少量文件无法被打包。</p><p>有4种object类型：commit, tag, tree, blob。</p><h2 id=一切皆commit>一切皆commit</h2><p>所有的提交形成一个commit树，每个commit号标示出树上唯一确定的点。本地或远程Branch、Tag、HEAD都是这个commit树上某个点或某根枝条的别名。</p><ul><li>HEAD: 动态指向这棵树上当前开发最新节点。注意这个最新不一定是树的末端，而是当前开发在哪个状态，随着每次提交动作而移动</li><li>Tag: 静态指向commit树的某个节点，一旦确定就永远不再变化</li><li>Branch: 对应commit树上某一段（如果不开分支，就是整棵树）的别名，由于是枝的形状，所以不表示某个具体的提交点，但可以沿着枝来溯源</li></ul><h2 id=分支>分支</h2><p>仅仅init不会有分支，必须在提交后才会有第一个master。分支和暂存区之间会引入复杂的关系，如果暂存区有内容，换分支有可能被中止，提交或stash后才能继续换分支。说明只有分支是独立存在，暂存区只有一个，是多分支共享的。这也是stash存在的原因。</p><p>refs/heads/保存了所有分支。删除一个旧的分支，没问题。但如果删除的是比当前要新的分支，用-d是没用的，防止辛苦做的提交白白丢失。如果确实没用，-D还是能删的。</p><p>一个本地仓库可以对应多个远程分支，不同的远程仓库间用名字区分。比如用<code>git remote add origin git@github.com:synich/demo.git</code>添加一个远程origin分支。</p><p>master和origin都是默认名字，并没有要求必须用这个名字，一般大家都遵守这种习惯。</p><h2 id=仓库目录作用>仓库目录作用</h2><p>.git目录保存了所有的文件，说说几个最有用的目录</p><ul><li>HEAD: 存储当前检出的引用或者提交 ID 在远程服务器上用于展示默认分支</li><li>config: 存储库配置 存储库配置优先级高于用户配置，用户配置优先级高于系统配置</li><li>hooks: Git 钩子目录，包括服务端钩子和客户端钩子，当设置了 core.hooksPath 时，则会从设置的钩子目录查找钩子</li><li>info: 存储库信息，http dumb 协议依赖，但目前 dumb 协议已经无人问津</li><li>objects: 存储库对象存储目录</li><li>refs: 存储库引用存储目录</li><li>packed-refs: 存储库打包引用存储文件，默认不存在，运行 git pack-refs 或者 git gc 后出现</li></ul><p>这些目录中最重要的是 objects 和 refs ，只需要两个目录的数据，就可以重建存储库了。在 objects 目录下，Git 对象可能以松散对象也可能以打包对象的形式存储。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>