<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>PHP与Web服务器的集成方式 | 蛙二的思考</title><meta property="og:title" content="PHP与Web服务器的集成方式 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-06-11T12:00:00+08:00"><meta property="article:modified_time" content="2016-06-11T12:00:00+08:00"><meta name=Keywords content><meta name=description content="PHP与Web服务器的集成方式"><meta name=author content><meta property="og:url" content="/post/160611/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>PHP与Web服务器的集成方式</h1></header><date class="post-meta meta-date">2016年6月11日</date><div class=post-content><p>PHP是一种宿主语言，即它主要的应用方式是寄宿在其它程序内的。
最直观的理解就是作为动态网页的开发语言，监听HTTP请求并不在PHP
之内做，一般是由Web服务器(如Apache或Nginx)完成，当检测到是一个
动态网页的请求，比如Url的后缀是.php，则把请求转给PHP程序，由它来
处理后续的工作。</p><p>在Windows上个人觉得比较好的集成工具是<a href=http://www.phpstudy.net>PhpStudy</a>，
集成了Apache/Nginx/Lighttpd等多种服务器(最新的2016版把Lighttpd去掉了)，
而且支持多种PHP版本，就以PhpStudy安装后为例，说说两者的集成方式。</p><p>先说Apache，官方标准的方式有三种，经常用到的有两种(CGI基本用不到，完全
被FastCGI替代)。分别是</p><ul><li>作为Apache内建模块运行，官方文档称为handler方式</li><li>以FastCGI方式运行</li></ul><p>handler方式就是在httpd的worker进程直接执行php程序，这种方式的配置
会加载一个php-sapixx.conf文件(PhpStudy的写法，非官方)，xx是PHP的版本号，
比如55、70等。从conf文件可以看到，其通过LoadFile和LoadModule指令
加载了php5.dll和php5apache2_4.dll。数字随着使用的版本而变。
LoadModule直接和Apache交互，从dll名字也可以看出，包含了php和
apache两个程序，像PHP这么复杂的应用，不可能完全通过module代码完全实现，
module更像是个桥接器，真正的任务还是要通过PHP来完成，
因此和LoadModule配套，还要用LoadFile指令载入php5.dll，负责真正的PHP执行代码。
另外PHP5.2版本，还通过LoadFile载入了libmysql.dll。也许是PHP和MySQL没有打通吧。
如果module载入成功，通过</p><p><code>PHPIniDir "D:/phpstudy/php52/"</code></p><p>这句指令来设置php.ini的路径。(命令行的php方式可以使用-c选项，在宿主环境下就要配置了)。
岔开一句，载入lua扩展只要LoadModule就可以，不需要LoadFile来指定lua.dll的位置。
遍观所有配置，除了PHP的SAPI方式，也只有httpd-proxy-html.conf配置，
用了LoadFile来加载zlib.dll,iconv.dll,libxml2.dll。</p><p>FastCGI方式则不同，需要先加载FastCGI的运作器，注意模块名是fcgid，
而不是fastcgi，这是两个不同的项目，差别我引用网上的说法：</p><blockquote><p><code>mod_fastcgi</code>因为实现方式的限制，所以可能会创建了很多不必要的进程，
而实际上只需要更少的进程就能处理同样的请求。
<code>mod_fastcgi</code>的另外一个问题是每一个CGI的多个进程都共享同一个管道文件，
所有到同一个fastcgi的通讯都通过这个同名的管道文件进行，
这样当出现通讯错误的时候，根本不知道正在通讯的是哪一个fastcgi，
于是也没有办法将这个有问题的进程杀死。</p></blockquote><blockquote><p><code>mod_fcgid</code>尝试使用共享内存来解决这个问题。共享内存里面有当前每个fastcgi进程的信息
（包括进程号，进程使用的管道文件名等），当 每次尝试请求fastcgi工作的时候，
Apache将会首先在共享内存里面查询，只有在共享内存里面发现确实没有足够的fastcgi进程了，
才会创建 新的进程，这样可以保证当前创建的进程数量刚好能够处理客户的请求。
另外，由于每一个fastcgi进程使用不同名称的管道文件，
所以可以在通讯失败的时候知道到底哪个fastcgi进程有问题，而能够尽早的将其剔除。</p></blockquote><p>所以现在apache官方推荐使用的模块就是fcgid了。
有一个专门的fcgid.conf文件，fcgid的参数很多，
比较典型的，如FcgidMaxProcesses表示最多允许打开多少个进程。
由于参数由Apache来读取，创建进程，控制进程的数量也同样是Apache。
所以这种模式下可以看到的httpd进程中，有些并不是执行Web请求，而是执行PHP的宿主。
有了宿主，接下来就是找到PHP并执行，和php关联的是这句指令</p><p><code>FcgidWrapper "D:/phpstudy/php55n/php-cgi.exe" .php</code></p><p>把请求直接导向了php-cgi程序。php-cgi本身就依赖于php5.dll，
因此FastCGI方式下不需要通过LoadFile来载入php5.dll。指定php.ini仍然不能少，通过</p><p><code>FcgidInitialEnv PHPRC "D:/phpstudy/php55n"</code></p><p>这种方式，Apache会常驻进程，减少每次请求的创建进程开销。
fcgid的耦合度比Handler方式更小，体现在</p><ol><li>httpd进程的作用分离，Web请求和PHP执行在两个进程</li><li>载入PHP方式，从.dll换成了.exe，从而避免了代码的强耦合。换句话说，
Handler方式必须依赖php5apache2_4.dll，而CGI方式调用PHP的程序即可。</li></ol><p>Handler和FastCGI的方式，进程的所有者都是Apache，随着PHP自身的演化，5.3.3版本后的
PHP官方代码也支持FastCGI模式，就是PHP-FPM(FastCGI-Process-Manager)，
这个包还没有windows的移植版本。从命名就能看出，它是一个进程管理软件。
PHP-FPM是daemon程序，它启动一个进程池，和Web之间通过监听TCP端口或Unix域套接字来进行通信。
并会随着负载大小动态地增加或减少进程数量(可配置)。
因此Apache的2.4版本之后，又增加了一种模式<code>mod_proxy_fcgi</code>，
这种模式下Apache不需要知道PHP的文件或库位置，只管把请求发到指定的端口或域套接字就可以了。</p><p>与Apache相比，nginx官方实现不支持动态载入模块，所有的功能都需要在编译时指定，
也就没有对应Apache的handler方式一说。
nginx也没有和PHP做整合，在nginx里不会看到PHP路径配置，
仅支持类似Apache的mod_proxy_fcgi配置方式，由于Windows版本下没有PHP-FPM，
因此运行PHP并监听端口，通过phpstudy这个管理程序来实现。</p><p>从nginx的配置可以看出，在和PHP通信时，有大量的fastcgi_xx的指令。
其中的<code>fastcgi_param</code>指令，就对应CGI规范中的Request Meta-Variables。
比如<code>SRIPT_NAME</code>、<code>QUERY_STRING</code>。这些值需要在nginx.conf中设置，
nginx会把<code>fastcgi_param</code>设置的值传递到PHP。
从而在PHP中<code>_SERVER["SCRIPT_NAME"]</code>的方式可以取值。</p><p>比起CGI的RFC规范，PHP可用的Meta-Variables要多一些。比如RFC只定义了
<code>SCRIPT_NAME</code>和<code>QUERY_STRING</code>，
PHP多定义了<code>SCRIPT_FILENAME</code>和<code>REQUEST_URI</code>。<code>REQUEST_URI</code>是
<code>SCRIPT_NAME</code>和<code>QUERY_STRING</code>的字符串连接。<code>SCRIPT_NAME</code>和
<code>SCRIPT_FILENAME</code>的差别在于<code>SCRIPT_FILENAME</code>是绝对路径，
nginx中一定要通过指定<code>SCRIPT_FILENAME</code>才能真正调用到PHP脚本，
<code>SCRIPT_NAME</code>就是相对路径了。</p><p>现在RESTFul大行其道，以资源形态表示的URL上，是肯定不会看到
script.php的字样的，最直接的做法，就是在nginx配置这样一句：</p><p><code>fastcgi_param SCRIPT_FILENAME $document_root/script.php;</code></p><p>也就是说虽然在URL上看到的只是个资源，但是到了Web端仍然是对应到具体的PHP文件。
在这个script.php中可以再从<code>REQUEST_URI</code>分离出资源信息，
从<code>REQUEST_METHOD</code>得到操作信息，这样就可以完成资源到操作的转换。
因为CGI出现的背景就是执行独立程序，因此规范直接定义<code>SCRIPT_NAME</code>就不奇怪了。</p><p>像<code>REQUEST_URI</code>这种值，其实都是由Web服务器来设置的，如果不在RFC规范，
就完全看Web服务器的实现了，因此会有些框架做些兼容处理。</p><p>比较两种Web服务器的加载后进程列表，选择apache启动方式，进程管理器只能看到
数个httpd进程，而选择nginx的话，除了nginx还能看到数个php-cgi程序。
原因就是apache的FastCGI方式是以自身程序模块在运行，在httpd进程中执行php程序，
因此进程管理器看不到php的名字。而nginx更有代理的味道，把请求数据
向php-cgi监听的端口送去后，就和nginx无关了，因此php-cgi是以独立进程方式存在。
这方面还遇到过一个奇怪的问题，本地调试网页用httpd正常打开，用nginx却总是超时.nginx下php-cgi默认分配的是9000端口，于是用netstat -ano查了到底哪个进程占用了9000端口，果然这个端口被其它程序给占住了，但是phpstudy并不会报异常，也就表现在nginx超时，如果用openresty方式运行就不会有这个问题，因为openresty也是类似httpd方式，直接在nginx内执行业务逻辑。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>