<!doctype html><html lang=zh-ch><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>浏览器对文件的处理 | 蛙二的思考</title><meta property="og:title" content="浏览器对文件的处理 - 蛙二的思考"><meta property="og:type" content="article"><meta property="article:published_time" content="2018-04-21T12:00:00+08:00"><meta property="article:modified_time" content="2018-04-21T12:00:00+08:00"><meta name=Keywords content><meta name=description content="浏览器对文件的处理"><meta name=author content><meta property="og:url" content="/post/180421/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href>蛙二的思考</a></div><div><nav id=nav-menu class=clearfix><a class=current href>首页</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>浏览器对文件的处理</h1></header><date class="post-meta meta-date">2018年4月21日</date><div class=post-content><p>协议工作经常遇到Web开发问及如何处理二进制数据的问题，查了资料并记录。</p><p>最早的HTML浏览器实现，是李在1990年实做的，IETF在93年中发布了相关草案，在95年11月24日发布的HTML2.0规范RFC1866，这份规范的内容非常简洁，只有77页。它定义了HTML的MIME类型、基本元素，紧接着在次日，发布了名为《HTML中基于表单的文件上传》的1867。后来的RFC1942又扩充了table的表示法。</p><p>1866的HTML表单规范为INPUT元素的TYPE属性定义了八种可能的值，分别是：CHECKBOX, HIDDEN, IMAGE, PASSWORD, RADIO, RESET, SUBMIT, TEXT。另外，当表单采用POST方式的时候，表单默认的具有"application/x-www-form-urlencoded" 的ENCTYPE属性。1867则建议对HTML做出了两处修改：</p><ol><li>为INPUT元素的TYPE属性增加了一个FILE选项。</li><li>INPUT标记可以具有ACCEPT属性，该属性能够指定可被上传的文件类型或文件格式列表。</li></ol><p>另外，本建议还定义了一种新的MIME类型：multipart/form-data（因为urlencoded效率太低了），以及当处理一个带有
ENCTYPE=&ldquo;multipart/form-data&rdquo; 并且/或含有<code>&lt;INPUT type="file"></code>的标记的表单时所应该
采取的行为。</p><p>由于ENCTYPE不同，每个文件都必须配备一个单独的表单。不能和文本类的form共用一个表单。</p><p>随着HTML的发展，IETF也就是RFC的责任方决定将它交给W3C组织专门维护，也就没有RFC来记载HTML的描述了。</p><h2 id=上传>上传</h2><p>时间来到了HTML5标准，file元素配合FileReader对象，有了更多的变化。通过getElementById拿到这个file对象后，一个files的数组(虽然我没见过支持多文件选择，也许是为了以后扩展吧)，取<code>files[0]</code>就是文件对象，这个对象可以传到FileReader.readAsXXX。由于JS的异步属性，读取到的内容惯用法是在回调函数中返回，</p><pre tabindex=0><code>reader=new FileReader;
reader.readAsDataURL(files[0]);
reader.onload = function(){ this.result;// this指向reader，读取成功onload，不考虑成功失败，用onloadend也行}
</code></pre><p>奇怪的是即使用二进制读出图片数据，再用base64转换得到的长度始终有问题，只能用DataURL获取图片，原因未知。</p><h2 id=下载>下载</h2><p>静态方式的下载用href标签可以实现<code>&lt;a href=http://www.xx.com/xx.zip>点击下载&lt;/a></code>，但是问题不少，用PHP实现，核心代码</p><pre tabindex=0><code>  header(&#34;Content-Type: application/octet-stream&#34;);
  header(&#34;Content-Length: &#34;.$fsize);
  header(&#34;Content-Disposition: attachment; filename=xx.zip&#34; );
  @ob_clean();
  flush();
  readfile($f);
  exit;
</code></pre><p>把文件类型改成octet，然后用readfile函数把文件写入标准输出流，由于PHP的stdout已经绑定到HTTP连接，客户端就能得到完整的文件。通常Content-Length是规范要求必须有的，没有的话浏览器也会兼容，但下载过程中无法显示总长度和当前进度。标准中这个字段表示传输过程中的长度，嚼字眼的话说明不是文本的原始长度，比如开启了gzip压缩，传输长度和实体长度就不一样，如果PHP外面的nginx又套了gzip，由于nginx无法事先知道要代理的内容长度，干脆全部用chunk方式传输，此时Content-Length会被chunk遮蔽，也不会有问题。</p></div><div class="post-meta meta-tags">没有标签</div></article></div><footer id=footer><div>&copy; 2022 <a href>蛙二的思考 By</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">蛙二</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<a id=rocket href=#top></a>
<script type=text/javascript src="/js/totop.js?v=0.0.0" async></script></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=/post/220421/ title=数据引擎和算子对比>数据引擎和算子对比</a></li><li><a href=/post/220405/ title=Kubernetes初学笔记>Kubernetes初学笔记</a></li><li><a href=/post/220312/ title=分布式计算在Spark上的实现>分布式计算在Spark上的实现</a></li><li><a href=/post/220204/ title=分布式哈希技术摘录>分布式哈希技术摘录</a></li><li><a href=/post/220201/ title=压缩技术浅谈>压缩技术浅谈</a></li><li><a href=/post/220115/ title=Python的数据科学相关库介绍>Python的数据科学相关库介绍</a></li><li><a href=/post/211226/ title=SU的执行过程与用户登陆机制>SU的执行过程与用户登陆机制</a></li><li><a href=/post/211222/ title=SQL的JOIN种类与选择>SQL的JOIN种类与选择</a></li><li><a href=/post/211218/ title=内存使用的观察和理解>内存使用的观察和理解</a></li><li><a href=/post/211115/ title=搭建最小化的Linux系统>搭建最小化的Linux系统</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories/>分类</a></h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title><a href=/tags/>标签</a></h3><div class=tagcloud></div></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>